Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 39 - 80 [Require~Export~Overture~Basics...] 0.02 secs (0.011u,0.009s)
Chars 82 - 108 [Set~Universe~Polymorphism.] 0. secs (0.u,0.s)
Chars 109 - 132 [Set~Implicit~Arguments.] 0. secs (0.u,0.s)
Chars 133 - 161 [Generalizable~Variables~all.] 0. secs (0.u,0.s)
Chars 162 - 186 [Set~Asymmetric~Patterns.] 0. secs (0.u,0.s)
Chars 188 - 217 [Declare~Scope~morphism_scope.] 0. secs (0.u,0.s)
Chars 218 - 247 [Declare~Scope~category_scope.] 0. secs (0.u,0.s)
Chars 248 - 275 [Declare~Scope~object_scope.] 0. secs (0.u,0.s)
Chars 277 - 320 [Delimit~Scope~morphism_scope~w...] 0. secs (0.u,0.s)
Chars 321 - 364 [Delimit~Scope~category_scope~w...] 0. secs (0.u,0.s)
Chars 365 - 404 [Delimit~Scope~object_scope~wit...] 0. secs (0.u,0.s)
Chars 406 - 438 [#[local]Open~Scope~morphism_sc...] 0. secs (0.u,0.s)
Chars 1463 - 2946 [Record~PreCategory~:=~~Build_P...] 0.01 secs (0.007u,0.002s)
Chars 2948 - 2991 [Bind~Scope~category_scope~with...] 0. secs (0.u,0.s)
Chars 2992 - 3028 [Bind~Scope~object_scope~with~o...] 0. secs (0.u,0.s)
Chars 3029 - 3069 [Bind~Scope~morphism_scope~with...] 0. secs (0.u,0.s)
Chars 3138 - 3178 [Arguments~object~!C%category~/...] 0. secs (0.u,0.s)
Chars 3179 - 3225 [Arguments~morphism~!C%category...] 0. secs (0.u,0.s)
Chars 3226 - 3279 [Arguments~identity~{!C}%catego...] 0. secs (0.u,0.s)
Chars 3280 - 3356 [Arguments~compose~{!C}%categor...] 0. secs (0.u,0.s)
Chars 3358 - 3402 [#[local]Infix~"o"~:=~compose~:...] 0. secs (0.u,0.s)
Chars 3530 - 3588 [#[local]Notation~"x~-->~y"~:=~...] 0. secs (0.u,0.s)
Chars 3589 - 3641 [#[local]Notation~"1"~:=~(ident...] 0. secs (0.u,0.s)
Chars 3751 - 4139 [Definition~Build_PreCategory~o...] 0.003 secs (0.001u,0.001s)
Chars 4141 - 4181 [#[global]Existing~Instance~tru...] 0. secs (0.u,0.s)
Chars 4238 - 4275 [Create~HintDb~category~discrim...] 0. secs (0.u,0.s)
Chars 4328 - 4365 [Create~HintDb~morphism~discrim...] 0. secs (0.u,0.s)
Chars 4367 - 4453 [#[export]~Hint~Resolve~left_id...] 0. secs (0.u,0.s)
Chars 4454 - 4517 [#[export]Hint~Rewrite~left_ide...] 0. secs (0.u,0.s)
Chars 4518 - 4581 [#[export]Hint~Rewrite~left_ide...] 0. secs (0.u,0.s)
Chars 4633 - 4657 [Section~identity_unique.] 0. secs (0.u,0.s)
Chars 4660 - 4685 [Variable~(C~:~PreCategory).] 0. secs (0.u,0.s)
Chars 4731 - 4942 [Lemma~identity_unique~(id0~id1...] 0.001 secs (0.001u,0.s)
Chars 4945 - 4951 [Proof.] 0. secs (0.u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 0 - 22 [Require~Import~Basics.] 0.351 secs (0.278u,0.072s)
Chars 289 - 514 [Lemma~comm_square_comp~{A}~{B}...] 0.009 secs (0.003u,0.005s)
Chars 515 - 521 [Proof.] 0. secs (0.u,0.s)
Chars 4956 - 4962 [intro.] 40.053 secs (0.u,0.003s)
Chars 4967 - 5041 [(etransitivity;~[~symmetry;~ap...] 0.005 secs (0.003u,0.002s)
Chars 4956 - 4962 [intro.] 0. secs (0.u,0.s)
Chars 4967 - 5041 [(etransitivity;~[~symmetry;~ap...] 0.001 secs (0.001u,0.s)
Chars 5044 - 5048 [Qed.] 0.001 secs (0.001u,0.s)
Chars 5175 - 5320 [Definition~concat_left_identit...] 0.003 secs (0.u,0.002s)
Chars 5324 - 5462 [Definition~concat_right_identi...] 0.002 secs (0.002u,0.s)
Chars 5463 - 5483 [End~identity_unique.] 0.003 secs (0.003u,0.s)
Chars 5573 - 5609 [Module~Export~CategoryCoreNota...] 0. secs (0.u,0.s)
Chars 5612 - 5650 [Infix~"o"~:=~compose~:~morphis...] 0. secs (0.u,0.s)
Chars 5784 - 5843 [#[local]Notation~"x~-->~y"~:=~...] 0. secs (0.u,0.s)
Chars 5846 - 5904 [#[local]Notation~"x~-->~y"~:=~...] 0. secs (0.u,0.s)
Chars 5907 - 5953 [Notation~"1"~:=~(identity~_)~:...] 0. secs (0.u,0.s)
Chars 5954 - 5980 [End~CategoryCoreNotations.] 0. secs (0.u,0.s)
Chars 6121 - 6262 [Tactic~Notation~"try_associati...] 0. secs (0.u,0.s)
Chars 524 - 533 [(intros~x).] 40.087 secs (0.001u,0.011s)
Chars 536 - 561 [(path_via~(g'~(f'~(h~x)))).] 0.005 secs (0.003u,0.002s)
Chars 564 - 579 [(apply~ap,~comm).] 0.001 secs (0.u,0.s)
Chars 524 - 533 [(intros~x).] 0. secs (0.u,0.s)
Chars 536 - 561 [(path_via~(g'~(f'~(h~x)))).] 0. secs (0.u,0.s)
Chars 564 - 579 [(apply~ap,~comm).] 0. secs (0.u,0.s)
Chars 580 - 588 [Defined.] 0.001 secs (0.001u,0.s)
Chars 797 - 1022 [Lemma~comm_square_comp'~{A~B~C...] 0.008 secs (0.005u,0.003s)
Chars 1023 - 1029 [Proof.] 0. secs (0.u,0.s)
Chars 1032 - 1041 [(intros~x).] 4.678 secs (0.001u,0.013s)
Chars 1044 - 1067 [(path_via~(j~(g~(k~x)))).] 0.004 secs (0.004u,0.s)
Chars 1070 - 1082 [(apply~ap,~H).] 0.001 secs (0.001u,0.s)
Chars 1032 - 1041 [(intros~x).] 0. secs (0.u,0.s)
Chars 1044 - 1067 [(path_via~(j~(g~(k~x)))).] 0. secs (0.u,0.s)
Chars 1070 - 1082 [(apply~ap,~H).] 0. secs (0.u,0.s)
Chars 1083 - 1091 [Defined.] 0.001 secs (0.u,0.s)
Chars 1274 - 1454 [Lemma~comm_square_inverse~{A~B...] 0.007 secs (0.004u,0.003s)
Chars 1455 - 1461 [Proof.] 0. secs (0.u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 43 - 65 [Require~Import~Basics.] 0.34 secs (0.245u,0.094s)
Chars 66 - 87 [Require~Import~Types.] 1.437 secs (1.341u,0.094s)
Chars 88 - 111 [Require~Import~Cubical.] 1.831 secs (1.724u,0.104s)
Chars 112 - 133 [Require~Import~HProp.] 0.024 secs (0.023u,0.s)
Chars 134 - 154 [Require~Import~HSet.] 0.022 secs (0.022u,0.s)
Chars 155 - 183 [Require~Import~NullHomotopy.] 0.011 secs (0.01u,0.001s)
Chars 184 - 210 [Require~Import~Extensions.] 3.258 secs (3.116u,0.136s)
Chars 211 - 243 [Require~Import~Colimits.Pushout.] 0. secs (0.u,0.s)
Chars 244 - 271 [Require~Import~Truncations.] 2.44 secs (2.337u,0.098s)
Chars 273 - 301 [#[local]Open~Scope~path_scope.] 0. secs (0.u,0.s)
Chars 384 - 397 [Section~Join.] 0. secs (0.u,0.s)
Chars 401 - 494 [Definition~Join~(A~:~Type@{i})...] 0. secs (0.u,0.s)
Chars 498 - 580 [Definition~joinl~{A}~{B}~:~A~-...] 0.001 secs (0.001u,0.s)
Chars 584 - 666 [Definition~joinr~{A}~{B}~:~B~-...] 0.001 secs (0.001u,0.s)
Chars 670 - 757 [Definition~jglue~{A}~{B}~a~b~:...] 0.001 secs (0.001u,0.s)
Chars 761 - 974 [Definition~Join_ind~{A~B~:~Typ...] 0.001 secs (0.001u,0.s)
Chars 977 - 983 [Proof.] 0. secs (0.u,0.s)
Chars 1464 - 1474 [(intros~a').] 40.103 secs (0.001u,0.013s)
Chars 1477 - 1516 [(path_via~(wB^-1~(wB~(f~(wA^-1...] 0.009 secs (0.005u,0.003s)
Chars 1519 - 1520 [-] 0. secs (0.u,0.s)
Chars 1521 - 1544 [(apply~inverse,~eissect).] 0.001 secs (0.001u,0.s)
Chars 1547 - 1548 [-] 0. secs (0.u,0.s)
Chars 1549 - 1576 [(apply~ap,~(concat~(wf~_)^)).] 0.002 secs (0.002u,0.s)
Chars 1581 - 1599 [(apply~ap,~eisretr).] 0.001 secs (0.001u,0.s)
Chars 1464 - 1474 [(intros~a').] 0. secs (0.u,0.s)
Chars 1477 - 1516 [(path_via~(wB^-1~(wB~(f~(wA^-1...] 0. secs (0.u,0.s)
Chars 1521 - 1544 [(apply~inverse,~eissect).] 0. secs (0.u,0.s)
Chars 1549 - 1576 [(apply~ap,~(concat~(wf~_)^)).] 0. secs (0.u,0.s)
Chars 1581 - 1599 [(apply~ap,~eisretr).] 0. secs (0.u,0.s)
Chars 1600 - 1608 [Defined.] 0.001 secs (0.u,0.s)
Chars 1714 - 1973 [Lemma~comm_square_inverse_is_s...] 0.007 secs (0.004u,0.002s)
Chars 1974 - 1980 [Proof.] 0. secs (0.u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 0 - 37 [Require~Import~HoTT.Basics.Dec...] 0.321 secs (0.24u,0.08s)
Chars 38 - 186 [Require~Import~HoTT.Classes.in...] 9.753 secs (9.266u,0.464s)
Chars 187 - 230 [Require~Export~HoTT.Classes.or...] 0.847 secs (0.798u,0.023s)
Chars 232 - 270 [Generalizable~Variables~F~f~R~...] 0. secs (0.u,0.s)
Chars 272 - 289 [Section~contents.] 0. secs (0.u,0.s)
Chars 290 - 316 [Context~`{OrderedField~F}.] 0.002 secs (0.002u,0.s)
Chars 318 - 399 [Lemma~pos_recip_compat~(x~:~F)...] 0.004 secs (0.004u,0.s)
Chars 400 - 406 [Proof.] 0. secs (0.u,0.s)
Chars 988 - 1020 [srapply~(Pushout_ind~P~P_A~P_B).] 40.148 secs (0.003u,0.032s)
Chars 1025 - 1038 [(intros~[a~b]).] 0.003 secs (0.003u,0.s)
Chars 1043 - 1070 [(apply~dp_path_transport^-1).] 0.012 secs (0.009u,0.003s)
Chars 1075 - 1091 [exact~(P_g~a~b).] 0.002 secs (0.002u,0.s)
Chars 988 - 1020 [srapply~(Pushout_ind~P~P_A~P_B).] 0. secs (0.u,0.s)
Chars 1025 - 1038 [(intros~[a~b]).] 0.001 secs (0.001u,0.s)
Chars 1043 - 1070 [(apply~dp_path_transport^-1).] 0.001 secs (0.001u,0.s)
Chars 1075 - 1091 [exact~(P_g~a~b).] 0.001 secs (0.001u,0.s)
Chars 1094 - 1102 [Defined.] 0.002 secs (0.002u,0.s)
Chars 1106 - 1361 [Definition~Join_ind_beta_jglue...] 0.004 secs (0.003u,0.s)
Chars 1364 - 1370 [Proof.] 0. secs (0.u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 44 - 78 [Require~Import~Basics~Types~HP...] 1.824 secs (1.63u,0.191s)
Chars 79 - 131 [Require~Import~Modalities.Moda...] 7.652 secs (7.297u,0.344s)
Chars 1983 - 2035 [(unfold~comm_square_inverse,~c...] 40.111 secs (0.003u,0.016s)
Chars 2038 - 2080 [(repeat~apply~(concat~(concat_...] 0.007 secs (0.005u,0.002s)
Chars 2081 - 2096 [(apply~moveR_Vp).] 0.002 secs (0.002u,0.s)
Chars 2099 - 2172 [transitivity~(ap~(wB^-1~o~wB)~...] 0.01 secs (0.006u,0.003s)
Chars 2175 - 2220 [2:~(apply~(concat~(concat_Ap~(...] 0.004 secs (0.002u,0.002s)
Chars 2221 - 2243 [2:~(apply~ap,~ap_idmap).] 0.003 secs (0.001u,0.001s)
Chars 2246 - 2291 [(apply~(concat~(concat_p_pp~_~...] 0.006 secs (0.u,0.005s)
Chars 2294 - 2363 [(apply~(concat~(ap_pp~wB^-1~_~...] 0.01 secs (0.004u,0.005s)
Chars 2366 - 2415 [(apply~ap,~(concat~(concat_pp_...] 0.006 secs (0.003u,0.002s)
Chars 2418 - 2464 [(path_via~(ap~(f'~o~wA)~(eisse...] 0.024 secs (0.016u,0.008s)
Chars 2467 - 2468 [-] 0. secs (0.u,0.s)
Chars 2469 - 2484 [(apply~whiskerR).] 0.002 secs (0.001u,0.s)
Chars 2486 - 2524 [(apply~(concatR~(ap_compose~wA...] 0.004 secs (0.004u,0.s)
Chars 2529 - 2546 [(apply~ap,~eisadj).] 0.003 secs (0.003u,0.s)
Chars 2549 - 2550 [-] 0. secs (0.u,0.s)
Chars 2551 - 2583 [(apply~(concat~(concat_Ap~wf~_...] 0.003 secs (0.003u,0.s)
Chars 2588 - 2622 [(apply~whiskerL,~(ap_compose~f...] 0.003 secs (0.003u,0.s)
Chars 1983 - 2035 [(unfold~comm_square_inverse,~c...] 0.002 secs (0.002u,0.s)
Chars 2038 - 2080 [(repeat~apply~(concat~(concat_...] 0.001 secs (0.u,0.s)
Chars 2081 - 2096 [(apply~moveR_Vp).] 0.001 secs (0.001u,0.s)
Chars 2099 - 2172 [transitivity~(ap~(wB^-1~o~wB)~...] 0.001 secs (0.u,0.s)
Chars 2175 - 2220 [2:~(apply~(concat~(concat_Ap~(...] 0.001 secs (0.001u,0.s)
Chars 2221 - 2243 [2:~(apply~ap,~ap_idmap).] 0.001 secs (0.u,0.s)
Chars 2246 - 2291 [(apply~(concat~(concat_p_pp~_~...] 0.001 secs (0.u,0.s)
Chars 2294 - 2363 [(apply~(concat~(ap_pp~wB^-1~_~...] 0.001 secs (0.001u,0.s)
Chars 2366 - 2415 [(apply~ap,~(concat~(concat_pp_...] 0.001 secs (0.001u,0.s)
Chars 2418 - 2464 [(path_via~(ap~(f'~o~wA)~(eisse...] 0.001 secs (0.001u,0.s)
Chars 2469 - 2484 [(apply~whiskerR).] 0. secs (0.u,0.s)
Chars 2486 - 2524 [(apply~(concatR~(ap_compose~wA...] 0. secs (0.u,0.s)
Chars 2529 - 2546 [(apply~ap,~eisadj).] 0. secs (0.u,0.s)
Chars 2551 - 2583 [(apply~(concat~(concat_Ap~wf~_...] 0. secs (0.u,0.s)
Chars 2588 - 2622 [(apply~whiskerL,~(ap_compose~f...] 0.001 secs (0.001u,0.s)
Chars 2623 - 2631 [Defined.] 0.089 secs (0.057u,0.031s)
Chars 2713 - 2974 [Lemma~comm_square_inverse_is_r...] 0.005 secs (0.005u,0.s)
Chars 2975 - 2981 [Proof.] 0. secs (0.u,0.s)
Chars 132 - 177 [Require~Import~Spaces.BAut~Spa...] 4.3 secs (4.154u,0.139s)
Chars 178 - 208 [Require~Import~ExcludedMiddle.] 0.007 secs (0.007u,0.s)
Chars 210 - 239 [#[local]Open~Scope~trunc_scope.] 0. secs (0.u,0.s)
Chars 240 - 268 [#[local]Open~Scope~path_scope.] 0. secs (0.u,0.s)
Chars 607 - 625 [Section~SwapTypes.] 0. secs (0.u,0.s)
Chars 788 - 824 [Context~`{Funext}~`{ExcludedMi...] 0. secs (0.u,0.s)
Chars 827 - 890 [Context~(A~B~:~Type)~(ne~:~~~(...] 0. secs (0.u,0.s)
Chars 894 - 938 [Definition~equiv_swap_types~:~...] 0. secs (0.u,0.s)
Chars 941 - 947 [Proof.] 0. secs (0.u,0.s)
Chars 952 - 1104 [refine~~((equiv_decidable_sum~...] 1.718 secs (0.16u,0.071s)
Chars 1109 - 1329 [refine~~(equiv_functor_sum_l~(...] 0.219 secs (0.187u,0.028s)
Chars 1334 - 1430 [refine~(equiv_sum_assoc~_~_~_~...] 0.003 secs (0.003u,0.s)
Chars 1435 - 1461 [(apply~equiv_functor_sum_r).] 0.002 secs (0.002u,0.s)
Chars 1466 - 1577 [(assert~~~(q~:~BAut~B~<~>~{x~:...] 0.003 secs (0.002u,0.s)
Chars 1582 - 1583 [{] 0. secs (0.u,0.s)
Chars 1584 - 1620 [refine~(equiv_sigma_assoc~_~_~...] 0.002 secs (0.002u,0.s)
Chars 1627 - 1666 [(apply~equiv_functor_sigma_id;...] 0.002 secs (0.002u,0.s)
Chars 1673 - 1695 [(apply~equiv_iff_hprop).] 0.028 secs (0.021u,0.006s)
Chars 1702 - 1703 [-] 0. secs (0.u,0.s)
Chars 1704 - 1713 [(intros~p).] 0. secs (0.u,0.s)
Chars 1722 - 1746 [refine~(fun~q~=>~_;~p).] 0.004 secs (0.003u,0.s)
Chars 1755 - 1773 [strip_truncations.] 0.103 secs (0.101u,0.002s)
Chars 1782 - 1793 [(destruct~q).] 0.001 secs (0.001u,0.s)
Chars 1802 - 1832 [exact~(ne~(equiv_path~X~B~p)).] 0. secs (0.u,0.s)
Chars 1839 - 1840 [-] 0. secs (0.u,0.s)
Chars 1841 - 1851 [exact~pr2.] 0.001 secs (0.001u,0.s)
Chars 1852 - 1853 [}] 0. secs (0.u,0.s)
Chars 1858 - 1891 [refine~(_~oE~equiv_sum_symm~_~_).] 0.001 secs (0.001u,0.s)
Chars 1896 - 1921 [(apply~equiv_functor_sum').] 0.001 secs (0.001u,0.s)
Chars 1926 - 1927 [-] 0. secs (0.u,0.s)
Chars 1928 - 1949 [exact~(e^-1~oE~q^-1).] 0.002 secs (0.001u,0.s)
Chars 1954 - 1955 [-] 0. secs (0.u,0.s)
Chars 1956 - 1971 [exact~(q~oE~e).] 0.001 secs (0.001u,0.s)
Chars 952 - 1104 [refine~~((equiv_decidable_sum~...] 0. secs (0.u,0.s)
Chars 1109 - 1329 [refine~~(equiv_functor_sum_l~(...] 0. secs (0.u,0.s)
Chars 1334 - 1430 [refine~(equiv_sum_assoc~_~_~_~...] 0. secs (0.u,0.s)
Chars 1435 - 1461 [(apply~equiv_functor_sum_r).] 0. secs (0.u,0.s)
Chars 1466 - 1577 [(assert~~~(q~:~BAut~B~<~>~{x~:...] 0. secs (0.u,0.s)
Chars 1584 - 1620 [refine~(equiv_sigma_assoc~_~_~...] 0. secs (0.u,0.s)
Chars 1627 - 1666 [(apply~equiv_functor_sigma_id;...] 0. secs (0.u,0.s)
Chars 1673 - 1695 [(apply~equiv_iff_hprop).] 0. secs (0.u,0.s)
Chars 1704 - 1713 [(intros~p).] 0. secs (0.u,0.s)
Chars 1722 - 1746 [refine~(fun~q~=>~_;~p).] 0. secs (0.u,0.s)
Chars 1755 - 1773 [strip_truncations.] 0. secs (0.u,0.s)
Chars 1782 - 1793 [(destruct~q).] 0. secs (0.u,0.s)
Chars 1802 - 1832 [exact~(ne~(equiv_path~X~B~p)).] 0. secs (0.u,0.s)
Chars 1841 - 1851 [exact~pr2.] 0. secs (0.u,0.s)
Chars 1858 - 1891 [refine~(_~oE~equiv_sum_symm~_~_).] 0. secs (0.u,0.s)
Chars 1896 - 1921 [(apply~equiv_functor_sum').] 0. secs (0.u,0.s)
Chars 1928 - 1949 [exact~(e^-1~oE~q^-1).] 0. secs (0.u,0.s)
Chars 1956 - 1971 [exact~(q~oE~e).] 0. secs (0.u,0.s)
Chars 1974 - 1982 [Defined.] 0.01 secs (0.01u,0.s)
Chars 1986 - 2054 [Definition~equiv_swap_types_sw...] 0.001 secs (0.001u,0.s)
Chars 2057 - 2063 [Proof.] 0. secs (0.u,0.s)
Chars 1375 - 1403 [(apply~dp_apD_path_transport).] 17.275 secs (0.001u,0.034s)
Chars 1408 - 1439 [srapply~Pushout_ind_beta_pglue.] 0.01 secs (0.01u,0.s)
Chars 1375 - 1403 [(apply~dp_apD_path_transport).] 0.001 secs (0.001u,0.s)
Chars 1408 - 1439 [srapply~Pushout_ind_beta_pglue.] 0.001 secs (0.001u,0.s)
Chars 1442 - 1450 [Defined.] 0.044 secs (0.027u,0.016s)
Chars 1454 - 1573 [Definition~Join_rec~{A~B~P~:~T...] 0. secs (0.u,0.s)
Chars 1576 - 1582 [Proof.] 0. secs (0.u,0.s)
Chars 407 - 448 [(apply~(strictly_order_reflect...] 40.151 secs (0.016u,0.023s)
Chars 449 - 466 [(rewrite~mult_0_r).] 0.011 secs (0.009u,0.001s)
Chars 467 - 494 [(rewrite~(recip_inverse'~x)).] 0.005 secs (0.004u,0.001s)
Chars 495 - 508 [(apply~lt_0_1).] 0.011 secs (0.01u,0.s)
Chars 407 - 448 [(apply~(strictly_order_reflect...] 0.001 secs (0.001u,0.s)
Chars 449 - 466 [(rewrite~mult_0_r).] 0.001 secs (0.u,0.s)
Chars 467 - 494 [(rewrite~(recip_inverse'~x)).] 0.001 secs (0.u,0.s)
Chars 495 - 508 [(apply~lt_0_1).] 0. secs (0.u,0.s)
Chars 509 - 513 [Qed.] 0.002 secs (0.002u,0.s)
Chars 515 - 596 [Lemma~neg_recip_compat~(x~:~F)...] 0.004 secs (0.004u,0.s)
Chars 597 - 603 [Proof.] 0. secs (0.u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 0 - 28 [Require~Import~Basics~Types.] 1.803 secs (1.626u,0.172s)
Chars 606 - 650 [(set~(negxpos~:=~fst~(flip_neg...] 9.392 secs (-1.715u,-0.083s)
Chars 2984 - 3036 [(unfold~comm_square_inverse,~c...] 40.114 secs (0.004u,0.022s)
Chars 3039 - 3054 [(rewrite~!ap_pp).] 0.022 secs (0.021u,0.001s)
Chars 3057 - 3081 [(rewrite~<-~!concat_pp_p).] 0.021 secs (0.019u,0.001s)
Chars 3084 - 3104 [(rewrite~concat_pp_p).] 0.007 secs (0.006u,0.s)
Chars 3107 - 3195 [(set~(p~:=~ap~wB~(ap~wB^-1~(ap...] 0.017 secs (0.015u,0.002s)
Chars 3198 - 3229 [(path_via~((eisretr~wB~_)^~@~p)).] 0.02 secs (0.018u,0.002s)
Chars 3232 - 3233 [-] 0. secs (0.u,0.s)
Chars 3234 - 3249 [(apply~whiskerR).] 0.003 secs (0.003u,0.s)
Chars 3254 - 3269 [(apply~moveR_pM).] 0.003 secs (0.003u,0.s)
Chars 3274 - 3363 [(path_via~~~((eisretr~wB~(f'~(...] 0.037 secs (0.032u,0.004s)
Chars 3368 - 3369 [+] 0. secs (0.u,0.s)
Chars 3370 - 3394 [(rewrite~ap_V,~<-~eisadj).] 0.009 secs (0.009u,0.s)
Chars 3401 - 3504 [transitivity~(ap~idmap~(wf~(wA...] 0.01 secs (0.009u,0.001s)
Chars 3511 - 3512 [*] 0. secs (0.u,0.s)
Chars 3513 - 3547 [(apply~whiskerR,~inverse,~ap_i...] 0.004 secs (0.004u,0.s)
Chars 3554 - 3555 [*] 0. secs (0.u,0.s)
Chars 3556 - 3605 [(apply~(concat_Ap~(fun~b'~=>~(...] 0.005 secs (0.004u,0.s)
Chars 3610 - 3611 [+] 0. secs (0.u,0.s)
Chars 3612 - 3621 [(apply~ap).] 0.004 secs (0.002u,0.001s)
Chars 3628 - 3654 [(rewrite~ap_compose,~!ap_V).] 0.018 secs (0.013u,0.005s)
Chars 3661 - 3682 [(apply~inverse,~inv_V).] 0.004 secs (0.003u,0.s)
Chars 3685 - 3686 [-] 0. secs (0.u,0.s)
Chars 3687 - 3702 [(apply~moveR_Vp).] 0.002 secs (0.002u,0.s)
Chars 3707 - 3715 [subst~p.] 0.001 secs (0.u,0.001s)
Chars 3720 - 3742 [(rewrite~<-~ap_compose).] 0.005 secs (0.003u,0.001s)
Chars 3747 - 3805 [(path_via~(eisretr~wB~_~@~ap~i...] 0.026 secs (0.024u,0.001s)
Chars 3810 - 3811 [+] 0. secs (0.u,0.s)
Chars 3812 - 3845 [(apply~(concat_Ap~(eisretr~wB)...] 0.003 secs (0.003u,0.s)
Chars 3850 - 3851 [+] 0. secs (0.u,0.s)
Chars 3852 - 3871 [(apply~ap,~ap_idmap).] 0.002 secs (0.002u,0.s)
Chars 2984 - 3036 [(unfold~comm_square_inverse,~c...] 0.002 secs (0.002u,0.s)
Chars 3039 - 3054 [(rewrite~!ap_pp).] 0.001 secs (0.001u,0.s)
Chars 3057 - 3081 [(rewrite~<-~!concat_pp_p).] 0.001 secs (0.001u,0.s)
Chars 3084 - 3104 [(rewrite~concat_pp_p).] 0.001 secs (0.001u,0.s)
Chars 3107 - 3195 [(set~(p~:=~ap~wB~(ap~wB^-1~(ap...] 0.001 secs (0.001u,0.s)
Chars 3198 - 3229 [(path_via~((eisretr~wB~_)^~@~p)).] 0.002 secs (0.002u,0.s)
Chars 3234 - 3249 [(apply~whiskerR).] 0.002 secs (0.002u,0.s)
Chars 3254 - 3269 [(apply~moveR_pM).] 0.002 secs (0.001u,0.s)
Chars 3274 - 3363 [(path_via~~~((eisretr~wB~(f'~(...] 0.002 secs (0.001u,0.s)
Chars 3370 - 3394 [(rewrite~ap_V,~<-~eisadj).] 0.001 secs (0.u,0.s)
Chars 3401 - 3504 [transitivity~(ap~idmap~(wf~(wA...] 0.001 secs (0.001u,0.s)
Chars 3513 - 3547 [(apply~whiskerR,~inverse,~ap_i...] 0.001 secs (0.001u,0.s)
Chars 3556 - 3605 [(apply~(concat_Ap~(fun~b'~=>~(...] 0.001 secs (0.001u,0.s)
Chars 3612 - 3621 [(apply~ap).] 0.001 secs (0.001u,0.s)
Chars 3628 - 3654 [(rewrite~ap_compose,~!ap_V).] 0.001 secs (0.001u,0.s)
Chars 3661 - 3682 [(apply~inverse,~inv_V).] 0.001 secs (0.001u,0.s)
Chars 3687 - 3702 [(apply~moveR_Vp).] 0.001 secs (0.001u,0.s)
Chars 3707 - 3715 [subst~p.] 0.001 secs (0.001u,0.s)
Chars 3720 - 3742 [(rewrite~<-~ap_compose).] 0.001 secs (0.u,0.s)
Chars 3747 - 3805 [(path_via~(eisretr~wB~_~@~ap~i...] 0. secs (0.u,0.s)
Chars 3812 - 3845 [(apply~(concat_Ap~(eisretr~wB)...] 0. secs (0.u,0.s)
Chars 3852 - 3871 [(apply~ap,~ap_idmap).] 0. secs (0.u,0.s)
Chars 3872 - 3880 [Defined.] 0.056 secs (0.047u,0.008s)
Chars 29 - 59 [Require~Import~Algebra.Groups.] 14.715 secs (14.147u,0.532s)
Chars 60 - 92 [Require~Import~Algebra.AbGroups.] 0.439 secs (0.428u,0.009s)
Chars 93 - 128 [Require~Import~Algebra.Rings.C...] 0.422 secs (0.409u,0.011s)
Chars 129 - 166 [Require~Import~Spaces.Int~Spac...] 0.001 secs (0.001u,0.s)
Chars 167 - 190 [Require~Import~WildCat.] 0.01 secs (0.01u,0.s)
Chars 770 - 797 [Definition~cring_Z~:~CRing.] 0. secs (0.u,0.s)
Chars 798 - 804 [Proof.] 0. secs (0.u,0.s)
Chars 2068 - 2099 [(pose~proof~(e~(point~_)).2~as...] 40.175 secs (0.001u,0.04s)
Chars 2100 - 2110 [(cbn~in~ea).] 0. secs (0.u,0.s)
Chars 2115 - 2143 [(strip_truncations;~apply~tr).] 0.021 secs (0.018u,0.002s)
Chars 2148 - 2172 [(unfold~equiv_swap_types).] 0.002 secs (0.002u,0.s)
Chars 2177 - 2197 [(apply~moveR_equiv_V).] 0.039 secs (0.033u,0.006s)
Chars 2202 - 2282 [(rewrite~(equiv_decidable_sum_...] 0.062 secs (0.054u,0.007s)
Chars 2287 - 2388 [(assert~(ne'~:~~~merely~(B~=~A...] 0.089 secs (0.075u,0.014s)
Chars 2393 - 2470 [(rewrite~(equiv_decidable_sum_...] 0.053 secs (0.048u,0.005s)
Chars 2475 - 2479 [(cbn).] 0.02 secs (0.019u,0.001s)
Chars 2484 - 2516 [(apply~ap,~path_sigma_hprop;~c...] 0.029 secs (0.027u,0.001s)
Chars 2521 - 2530 [exact~ea.] 0.001 secs (0.001u,0.s)
Chars 2068 - 2099 [(pose~proof~(e~(point~_)).2~as...] 0. secs (0.u,0.s)
Chars 2100 - 2110 [(cbn~in~ea).] 0. secs (0.u,0.s)
Chars 2115 - 2143 [(strip_truncations;~apply~tr).] 0. secs (0.u,0.s)
Chars 2148 - 2172 [(unfold~equiv_swap_types).] 0. secs (0.u,0.s)
Chars 2177 - 2197 [(apply~moveR_equiv_V).] 0.008 secs (0.006u,0.001s)
Chars 2202 - 2282 [(rewrite~(equiv_decidable_sum_...] 0.007 secs (0.007u,0.s)
Chars 2287 - 2388 [(assert~(ne'~:~~~merely~(B~=~A...] 0.023 secs (0.018u,0.004s)
Chars 2393 - 2470 [(rewrite~(equiv_decidable_sum_...] 0.008 secs (0.008u,0.s)
Chars 2475 - 2479 [(cbn).] 0.007 secs (0.005u,0.001s)
Chars 2484 - 2516 [(apply~ap,~path_sigma_hprop;~c...] 0.005 secs (0.004u,0.001s)
Chars 2521 - 2530 [exact~ea.] 0. secs (0.u,0.s)
Chars 1587 - 1619 [srapply~(Pushout_rec~P~P_A~P_B).] 40.152 secs (0.002u,0.034s)
Chars 1624 - 1637 [(intros~[a~b]).] 0.001 secs (0.001u,0.s)
Chars 1642 - 1652 [(apply~P_g).] 0. secs (0.u,0.s)
Chars 1587 - 1619 [srapply~(Pushout_rec~P~P_A~P_B).] 0. secs (0.u,0.s)
Chars 1624 - 1637 [(intros~[a~b]).] 0. secs (0.u,0.s)
Chars 1642 - 1652 [(apply~P_g).] 0. secs (0.u,0.s)
Chars 1655 - 1663 [Defined.] 0. secs (0.u,0.s)
Chars 1667 - 1839 [Definition~Join_rec_beta_jglue...] 0.002 secs (0.002u,0.s)
Chars 1842 - 1848 [Proof.] 0. secs (0.u,0.s)
Chars 2533 - 2541 [Defined.] 0.087 secs (0.08u,0.006s)
Chars 2545 - 2618 [Definition~equiv_swap_types_no...] 0.001 secs (0.001u,0.s)
Chars 2621 - 2627 [Proof.] 0. secs (0.u,0.s)
Chars 1853 - 1884 [srapply~Pushout_rec_beta_pglue.] 0.143 secs (0.008u,0.034s)
Chars 1853 - 1884 [srapply~Pushout_rec_beta_pglue.] 0. secs (0.u,0.s)
Chars 1887 - 1895 [Defined.] 0.001 secs (0.u,0.001s)
Chars 1970 - 2031 [#[global]Instance~contr_join~~...] 0. secs (0.u,0.s)
Chars 2034 - 2040 [Proof.] 0.003 secs (0.u,0.s)
Chars 2632 - 2641 [(intros~p).] 13.198 secs (-1.864u,-0.155s)
Chars 606 - 650 [(set~(negxpos~:=~fst~(flip_neg...] 40.059 secs (0.009u,0.023s)
Chars 653 - 697 [(apply~(strictly_order_reflect...] 0.047 secs (0.035u,0.012s)
Chars 700 - 717 [(rewrite~mult_0_r).] 0.012 secs (0.011u,0.s)
Chars 720 - 751 [(rewrite~<-~negate_mult_distr_l).] 0.006 secs (0.004u,0.002s)
Chars 754 - 781 [(rewrite~(recip_inverse'~x)).] 0.005 secs (0.005u,0.s)
Chars 784 - 814 [(apply~flip_pos_negate,~lt_0_1).] 0.021 secs (0.016u,0.004s)
Chars 606 - 650 [(set~(negxpos~:=~fst~(flip_neg...] 0.001 secs (0.u,0.s)
Chars 653 - 697 [(apply~(strictly_order_reflect...] 0.001 secs (0.001u,0.s)
Chars 700 - 717 [(rewrite~mult_0_r).] 0.001 secs (0.001u,0.s)
Chars 720 - 751 [(rewrite~<-~negate_mult_distr_l).] 0.001 secs (0.001u,0.s)
Chars 754 - 781 [(rewrite~(recip_inverse'~x)).] 0.001 secs (0.001u,0.s)
Chars 784 - 814 [(apply~flip_pos_negate,~lt_0_1).] 0.001 secs (0.u,0.s)
Chars 815 - 819 [Qed.] 0.003 secs (0.003u,0.s)
Chars 821 - 1005 [Lemma~flip_lt_recip~x~y~(Py~:~...] 0.017 secs (0.015u,0.002s)
Chars 1006 - 1012 [Proof.] 0. secs (0.u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 0 - 57 [Require~Import~HoTT.Types.Univ...] 1.038 secs (0.866u,0.169s)
Chars 807 - 903 [(snrapply~(Build_CRing~abgroup...] 40.455 secs (0.259u,0.076s)
Chars 906 - 907 [+] 0. secs (0.u,0.s)
Chars 908 - 928 [exact~int_mul_assoc.] 0. secs (0.u,0.s)
Chars 931 - 932 [+] 0. secs (0.u,0.s)
Chars 933 - 951 [exact~int_mul_1_l.] 0. secs (0.u,0.s)
Chars 954 - 955 [+] 0. secs (0.u,0.s)
Chars 956 - 974 [exact~int_mul_1_r.] 0. secs (0.u,0.s)
Chars 977 - 978 [+] 0. secs (0.u,0.s)
Chars 979 - 998 [exact~int_mul_comm.] 0. secs (0.u,0.s)
Chars 1001 - 1002 [+] 0. secs (0.u,0.s)
Chars 1003 - 1029 [exact~int_mul_add_distr_l.] 0. secs (0.u,0.s)
Chars 807 - 903 [(snrapply~(Build_CRing~abgroup...] 0.001 secs (0.001u,0.s)
Chars 908 - 928 [exact~int_mul_assoc.] 0. secs (0.u,0.s)
Chars 933 - 951 [exact~int_mul_1_l.] 0. secs (0.u,0.s)
Chars 956 - 974 [exact~int_mul_1_r.] 0. secs (0.u,0.s)
Chars 979 - 998 [exact~int_mul_comm.] 0. secs (0.u,0.s)
Chars 1003 - 1029 [exact~int_mul_add_distr_l.] 0. secs (0.u,0.s)
Chars 1030 - 1038 [Defined.] 0.004 secs (0.004u,0.s)
Chars 1040 - 1066 [#[local]Open~Scope~mc_scope.] 0. secs (0.u,0.s)
Chars 1275 - 1502 [Definition~cring_catamorphism_...] 0.009 secs (0.008u,0.s)
Chars 1614 - 1717 [#[local]~Instance~isequiv_grou...] 0.001 secs (0.001u,0.s)
Chars 1718 - 1724 [Proof.] 0. secs (0.u,0.s)
Chars 2632 - 2641 [(intros~p).] 40.098 secs (0.u,0.04s)
Chars 2646 - 2683 [(pose~proof~equiv_swap_types_s...] 0.001 secs (0.001u,0.s)
Chars 2688 - 2706 [strip_truncations.] 0.033 secs (0.023u,0.008s)
Chars 2711 - 2720 [(apply~ne).] 0. secs (0.u,0.s)
Chars 2725 - 2742 [(apply~equiv_path).] 0. secs (0.u,0.s)
Chars 2747 - 2771 [(rewrite~p~in~q;~exact~q).] 0.001 secs (0.001u,0.s)
Chars 2632 - 2641 [(intros~p).] 0. secs (0.u,0.s)
Chars 2646 - 2683 [(pose~proof~equiv_swap_types_s...] 0. secs (0.u,0.s)
Chars 2688 - 2706 [strip_truncations.] 0. secs (0.u,0.s)
Chars 2711 - 2720 [(apply~ne).] 0. secs (0.u,0.s)
Chars 2725 - 2742 [(apply~equiv_path).] 0. secs (0.u,0.s)
Chars 2747 - 2771 [(rewrite~p~in~q;~exact~q).] 0. secs (0.u,0.s)
Chars 2774 - 2778 [Qed.] 0.002 secs (0.002u,0.s)
Chars 2045 - 2071 [exists~(pushl~(center~A)).] 40.169 secs (0.u,0.029s)
Chars 2076 - 2124 [(intros~y;~simple~refine~(Push...] 0.001 secs (0.u,0.s)
Chars 2129 - 2130 [-] 0. secs (0.u,0.s)
Chars 2131 - 2157 [(intros~a;~apply~ap,~contr).] 0.001 secs (0.001u,0.s)
Chars 2162 - 2163 [-] 0. secs (0.u,0.s)
Chars 2164 - 2203 [(intros~b;~exact~(pglue~(cente...] 0.002 secs (0.002u,0.s)
Chars 2208 - 2209 [-] 0. secs (0.u,0.s)
Chars 2210 - 2228 [(intros~[a~b];~cbn).] 0.006 secs (0.005u,0.s)
Chars 2235 - 2287 [refine~(_~@~apD~(fun~a'~=>~jgl...] 0.003 secs (0.002u,0.s)
Chars 2294 - 2347 [(rewrite~transport_paths_r,~tr...] 0.011 secs (0.011u,0.s)
Chars 2354 - 2387 [(rewrite~ap_V,~inv_V,~concat_p...] 0.013 secs (0.011u,0.001s)
Chars 2394 - 2422 [(rewrite~ap_const,~concat_p1).] 0.009 secs (0.005u,0.003s)
Chars 2780 - 2794 [End~SwapTypes.] 0.147 secs (0.132u,0.014s)
Chars 2429 - 2441 [reflexivity.] 0.002 secs (0.002u,0.s)
Chars 2861 - 3007 [Definition~equiv_swap_rigid~`{...] 0. secs (0.u,0.s)
Chars 3008 - 3014 [Proof.] 0. secs (0.u,0.s)
Chars 2045 - 2071 [exists~(pushl~(center~A)).] 0. secs (0.u,0.s)
Chars 2076 - 2124 [(intros~y;~simple~refine~(Push...] 0. secs (0.u,0.s)
Chars 2131 - 2157 [(intros~a;~apply~ap,~contr).] 0. secs (0.u,0.s)
Chars 2164 - 2203 [(intros~b;~exact~(pglue~(cente...] 0. secs (0.u,0.s)
Chars 2210 - 2228 [(intros~[a~b];~cbn).] 0.002 secs (0.002u,0.s)
Chars 2235 - 2287 [refine~(_~@~apD~(fun~a'~=>~jgl...] 0.001 secs (0.001u,0.s)
Chars 2294 - 2347 [(rewrite~transport_paths_r,~tr...] 0.002 secs (0.002u,0.s)
Chars 2354 - 2387 [(rewrite~ap_V,~inv_V,~concat_p...] 0.001 secs (0.001u,0.s)
Chars 2394 - 2422 [(rewrite~ap_const,~concat_p1).] 0.001 secs (0.001u,0.s)
Chars 2429 - 2441 [reflexivity.] 0.001 secs (0.001u,0.s)
Chars 2444 - 2452 [Defined.] 0.021 secs (0.018u,0.002s)
Chars 2483 - 2531 [Definition~join_sym~A~B~:~Join...] 0. secs (0.u,0.s)
Chars 2534 - 2540 [Proof.] 0. secs (0.u,0.s)
Chars 58 - 127 [Require~HoTT.Classes.theory.in...] 13.205 secs (12.71u,0.465s)
Chars 128 - 514 [Require~Import~HoTT.Classes.im...] 0.046 secs (0.042u,0.003s)
Chars 515 - 560 [Require~Export~HoTT.Classes.or...] 0.002 secs (0.002u,0.s)
Chars 562 - 587 [Import~NatPair.Instances.] 0. secs (0.u,0.s)
Chars 588 - 620 [Generalizable~Variables~N~Z~R~f.] 0. secs (0.u,0.s)
Chars 622 - 639 [Section~integers.] 0. secs (0.u,0.s)
Chars 640 - 672 [Context~`{Funext}~`{Univalence}.] 0. secs (0.u,0.s)
Chars 673 - 714 [Context~`{Integers~Z}~`{!Trivi...] 0.002 secs (0.002u,0.s)
Chars 823 - 968 [Lemma~induction~(P~:~Z~->~Type...] 0.003 secs (0.003u,0.s)
Chars 969 - 975 [Proof.] 0. secs (0.u,0.s)
Chars 3017 - 3052 [refine~(equiv_swap_types~A~B~n...] 14.95 secs (0.002u,0.039s)
Chars 3055 - 3079 [(apply~equiv_contr_contr).] 0.008 secs (0.008u,0.s)
Chars 3017 - 3052 [refine~(equiv_swap_types~A~B~n...] 0. secs (0.u,0.s)
Chars 3055 - 3079 [(apply~equiv_contr_contr).] 0. secs (0.u,0.s)
Chars 3080 - 3088 [Defined.] 0.001 secs (0.u,0.s)
Chars 3126 - 3261 [Definition~equiv_swap_empty_un...] 0.008 secs (0.007u,0.s)
Chars 3331 - 3499 [Definition~equiv_swap_rigid_sw...] 0.003 secs (0.003u,0.s)
Chars 3500 - 3506 [Proof.] 0. secs (0.u,0.s)
Chars 1015 - 1058 [(assert~(0~<~x)~by~(transitivi...] 40.143 secs (0.01u,0.022s)
Chars 1061 - 1102 [(apply~(strictly_order_reflect...] 0.022 secs (0.02u,0.001s)
Chars 1105 - 1133 [(rewrite~(recip_inverse'~x)).] 0.006 secs (0.005u,0.s)
Chars 1136 - 1154 [(rewrite~mult_comm).] 0.013 secs (0.012u,0.s)
Chars 1157 - 1198 [(apply~(strictly_order_reflect...] 0.022 secs (0.017u,0.004s)
Chars 1201 - 1230 [(rewrite~mult_assoc,~mult_1_r).] 0.026 secs (0.024u,0.001s)
Chars 1233 - 1282 [(rewrite~(recip_inverse'~y),~m...] 0.018 secs (0.014u,0.004s)
Chars 1015 - 1058 [(assert~(0~<~x)~by~(transitivi...] 0.001 secs (0.u,0.s)
Chars 1061 - 1102 [(apply~(strictly_order_reflect...] 0.001 secs (0.001u,0.s)
Chars 1105 - 1133 [(rewrite~(recip_inverse'~x)).] 0.001 secs (0.001u,0.s)
Chars 1136 - 1154 [(rewrite~mult_comm).] 0.001 secs (0.001u,0.s)
Chars 1157 - 1198 [(apply~(strictly_order_reflect...] 0. secs (0.u,0.s)
Chars 1201 - 1230 [(rewrite~mult_assoc,~mult_1_r).] 0.001 secs (0.001u,0.s)
Chars 1233 - 1282 [(rewrite~(recip_inverse'~y),~m...] 0.001 secs (0.001u,0.s)
Chars 1283 - 1287 [Qed.] 0.006 secs (0.006u,0.s)
Chars 1289 - 1474 [Lemma~flip_lt_recip_l~x~y~(Py~...] 0.016 secs (0.015u,0.001s)
Chars 1475 - 1481 [Proof.] 0. secs (0.u,0.s)
Chars 1727 - 1735 [intro~x.] 40.192 secs (0.u,0.03s)
Chars 1738 - 1765 [srapply~isequiv_adjointify.] 0.002 secs (0.001u,0.s)
Chars 1768 - 1790 [1:~exact~(sg_op~(-~x)).] 0.001 secs (0.001u,0.s)
Chars 1793 - 1806 [all:~intro~y.] 0.001 secs (0.001u,0.s)
Chars 1809 - 1865 [all:~refine~((associativity~_~...] 0.062 secs (0.052u,0.009s)
Chars 1868 - 1904 [all:~refine~(ap~(fun~x~=>~x~*~...] 0.003 secs (0.002u,0.s)
Chars 1907 - 1930 [1:~(apply~right_inverse).] 0.003 secs (0.003u,0.s)
Chars 1933 - 1952 [(apply~left_inverse).] 0.002 secs (0.001u,0.001s)
Chars 1727 - 1735 [intro~x.] 0. secs (0.u,0.s)
Chars 1738 - 1765 [srapply~isequiv_adjointify.] 0. secs (0.u,0.s)
Chars 1768 - 1790 [1:~exact~(sg_op~(-~x)).] 0. secs (0.u,0.s)
Chars 1793 - 1806 [all:~intro~y.] 0. secs (0.u,0.s)
Chars 1809 - 1865 [all:~refine~((associativity~_~...] 0. secs (0.u,0.s)
Chars 1868 - 1904 [all:~refine~(ap~(fun~x~=>~x~*~...] 0. secs (0.u,0.s)
Chars 1907 - 1930 [1:~(apply~right_inverse).] 0. secs (0.u,0.s)
Chars 1933 - 1952 [(apply~left_inverse).] 0. secs (0.u,0.s)
Chars 1953 - 1961 [Defined.] 0.002 secs (0.u,0.001s)
Chars 2009 - 2109 [#[local]~Instance~isequiv_grou...] 0.001 secs (0.001u,0.s)
Chars 2110 - 2116 [Proof.] 0. secs (0.u,0.s)
Chars 2545 - 2584 [(unfold~Join;~refine~(pushout_...] 40.153 secs (0.002u,0.031s)
Chars 2589 - 2675 [(refine~(equiv_pushout~(equiv_...] 0.005 secs (0.004u,0.s)
Chars 2545 - 2584 [(unfold~Join;~refine~(pushout_...] 0. secs (0.u,0.s)
Chars 2589 - 2675 [(refine~(equiv_pushout~(equiv_...] 0.001 secs (0.001u,0.s)
Chars 2678 - 2686 [Defined.] 0.002 secs (0.001u,0.s)
Chars 2690 - 2848 [Definition~join_natsq_v~{A~B~:...] 0.002 secs (0.002u,0.s)
Chars 2851 - 2857 [Proof.] 0. secs (0.u,0.s)
Chars 976 - 1000 [(intros~P0~Psuc1~Psuc2~n).] 40.339 secs (0.001u,0.039s)
Chars 1001 - 1049 [(destruct~(int_abs_sig~Z~nat~n...] 0.015 secs (0.013u,0.001s)
Chars 1050 - 1051 [-] 0. secs (0.u,0.s)
Chars 1052 - 1064 [(rewrite~<-~A).] 0.002 secs (0.002u,0.s)
Chars 1065 - 1073 [clear~A.] 0.001 secs (0.001u,0.s)
Chars 1074 - 1083 [revert~a.] 0.001 secs (0.001u,0.s)
Chars 1086 - 1111 [(apply~naturals.induction).] 0.01 secs (0.01u,0.s)
Chars 1114 - 1115 [+] 0. secs (0.u,0.s)
Chars 1116 - 1142 [(rewrite~rings.preserves_0).] 0.008 secs (0.007u,0.s)
Chars 1143 - 1151 [trivial.] 0.001 secs (0.001u,0.s)
Chars 1154 - 1155 [+] 0. secs (0.u,0.s)
Chars 1156 - 1167 [(intros~m~E).] 0.001 secs (0.001u,0.s)
Chars 1172 - 1220 [(rewrite~rings.preserves_plus,...] 0.017 secs (0.014u,0.003s)
Chars 1225 - 1237 [(apply~Psuc1).] 0.002 secs (0.002u,0.s)
Chars 1242 - 1243 [*] 0. secs (0.u,0.s)
Chars 1244 - 1269 [(apply~to_semiring_nonneg).] 0.027 secs (0.025u,0.001s)
Chars 1274 - 1275 [*] 0. secs (0.u,0.s)
Chars 1276 - 1284 [trivial.] 0.002 secs (0.001u,0.s)
Chars 1285 - 1286 [-] 0. secs (0.u,0.s)
Chars 1287 - 1331 [(rewrite~<-~(groups.negate_inv...] 0.046 secs (0.038u,0.007s)
Chars 1334 - 1342 [clear~A.] 0.001 secs (0.001u,0.s)
Chars 1343 - 1352 [revert~a.] 0.001 secs (0.001u,0.s)
Chars 1353 - 1378 [(apply~naturals.induction).] 0.02 secs (0.019u,0.s)
Chars 1381 - 1382 [+] 0. secs (0.u,0.s)
Chars 1383 - 1425 [(rewrite~rings.preserves_0,~ri...] 0.015 secs (0.014u,0.001s)
Chars 1426 - 1434 [trivial.] 0.001 secs (0.001u,0.s)
Chars 1437 - 1438 [+] 0. secs (0.u,0.s)
Chars 1439 - 1450 [(intros~m~E).] 0.001 secs (0.001u,0.s)
Chars 1455 - 1503 [(rewrite~rings.preserves_plus,...] 0.017 secs (0.015u,0.001s)
Chars 1508 - 1555 [(rewrite~rings.negate_plus_dis...] 0.042 secs (0.039u,0.002s)
Chars 1560 - 1572 [(apply~Psuc2).] 0.002 secs (0.002u,0.s)
Chars 1577 - 1578 [*] 0. secs (0.u,0.s)
Chars 1579 - 1616 [(apply~naturals.negate_to_ring...] 0.026 secs (0.021u,0.004s)
Chars 1621 - 1622 [*] 0. secs (0.u,0.s)
Chars 1623 - 1631 [trivial.] 0.002 secs (0.002u,0.s)
Chars 976 - 1000 [(intros~P0~Psuc1~Psuc2~n).] 0. secs (0.u,0.s)
Chars 1001 - 1049 [(destruct~(int_abs_sig~Z~nat~n...] 0. secs (0.u,0.s)
Chars 1052 - 1064 [(rewrite~<-~A).] 0.001 secs (0.001u,0.s)
Chars 1065 - 1073 [clear~A.] 0.001 secs (0.001u,0.s)
Chars 1074 - 1083 [revert~a.] 0.001 secs (0.001u,0.s)
Chars 1086 - 1111 [(apply~naturals.induction).] 0.001 secs (0.001u,0.s)
Chars 1116 - 1142 [(rewrite~rings.preserves_0).] 0.001 secs (0.001u,0.s)
Chars 1143 - 1151 [trivial.] 0. secs (0.u,0.s)
Chars 1156 - 1167 [(intros~m~E).] 0.001 secs (0.001u,0.s)
Chars 1172 - 1220 [(rewrite~rings.preserves_plus,...] 0.001 secs (0.001u,0.s)
Chars 1225 - 1237 [(apply~Psuc1).] 0.001 secs (0.u,0.s)
Chars 1244 - 1269 [(apply~to_semiring_nonneg).] 0.001 secs (0.u,0.s)
Chars 1276 - 1284 [trivial.] 0.001 secs (0.001u,0.s)
Chars 1287 - 1331 [(rewrite~<-~(groups.negate_inv...] 0.001 secs (0.001u,0.s)
Chars 1334 - 1342 [clear~A.] 0.001 secs (0.001u,0.s)
Chars 1343 - 1352 [revert~a.] 0.001 secs (0.001u,0.s)
Chars 1353 - 1378 [(apply~naturals.induction).] 0.001 secs (0.001u,0.s)
Chars 1383 - 1425 [(rewrite~rings.preserves_0,~ri...] 0.001 secs (0.001u,0.s)
Chars 1426 - 1434 [trivial.] 0. secs (0.u,0.s)
Chars 1439 - 1450 [(intros~m~E).] 0.001 secs (0.001u,0.s)
Chars 1455 - 1503 [(rewrite~rings.preserves_plus,...] 0.001 secs (0.001u,0.s)
Chars 1508 - 1555 [(rewrite~rings.negate_plus_dis...] 0.001 secs (0.001u,0.s)
Chars 1560 - 1572 [(apply~Psuc2).] 0.001 secs (0.001u,0.s)
Chars 1579 - 1616 [(apply~naturals.negate_to_ring...] 0.001 secs (0.001u,0.s)
Chars 1623 - 1631 [trivial.] 0.001 secs (0.001u,0.s)
Chars 1632 - 1636 [Qed.] 0.011 secs (0.01u,0.s)
Chars 1638 - 1756 [Lemma~induction_nonneg~(P~:~Z~...] 0.003 secs (0.003u,0.s)
Chars 1757 - 1763 [Proof.] 0. secs (0.u,0.s)
Chars 3509 - 3551 [(unfold~equiv_swap_rigid,~equi...] 40.143 secs (0.001u,0.04s)
Chars 3554 - 3574 [(apply~moveR_equiv_V).] 0.037 secs (0.034u,0.002s)
Chars 3577 - 3655 [(rewrite~(equiv_decidable_sum_...] 0.056 secs (0.047u,0.009s)
Chars 3658 - 3757 [(assert~(ne'~:~~~merely~(B~=~A...] 0.132 secs (0.098u,0.033s)
Chars 3760 - 3835 [(rewrite~(equiv_decidable_sum_...] 0.05 secs (0.044u,0.005s)
Chars 3838 - 3842 [(cbn).] 0.02 secs (0.019u,0.s)
Chars 3845 - 3877 [(apply~ap,~path_sigma_hprop;~c...] 0.023 secs (0.023u,0.s)
Chars 3880 - 3939 [exact~(path_contr~(center~(BAu...] 0.011 secs (0.01u,0.s)
Chars 3509 - 3551 [(unfold~equiv_swap_rigid,~equi...] 0. secs (0.u,0.s)
Chars 3554 - 3574 [(apply~moveR_equiv_V).] 0.008 secs (0.008u,0.s)
Chars 3577 - 3655 [(rewrite~(equiv_decidable_sum_...] 0.007 secs (0.007u,0.s)
Chars 3658 - 3757 [(assert~(ne'~:~~~merely~(B~=~A...] 0.007 secs (0.006u,0.s)
Chars 3760 - 3835 [(rewrite~(equiv_decidable_sum_...] 0.008 secs (0.007u,0.s)
Chars 3838 - 3842 [(cbn).] 0.008 secs (0.008u,0.s)
Chars 3845 - 3877 [(apply~ap,~path_sigma_hprop;~c...] 0.002 secs (0.001u,0.001s)
Chars 3880 - 3939 [exact~(path_contr~(center~(BAu...] 0. secs (0.u,0.s)
Chars 3940 - 3948 [Defined.] 0.132 secs (0.119u,0.012s)
Chars 4078 - 4349 [Definition~equiv_swap_prod_rig...] 0.001 secs (0.001u,0.s)
Chars 4350 - 4356 [Proof.] 0. secs (0.u,0.s)
Chars 1484 - 1523 [(set~(apy0~:=~positive_apart_z...] 40.153 secs (0.007u,0.023s)
Chars 1526 - 1564 [(set~(eq~:=~recip_involutive~(...] 0.01 secs (0.008u,0.001s)
Chars 1567 - 1590 [(set~(eq'~:=~ap~pr1~eq)).] 0.004 secs (0.004u,0.s)
Chars 1593 - 1604 [(cbn~in~eq').] 0.003 secs (0.003u,0.s)
Chars 1607 - 1622 [(rewrite~<-~eq').] 0.004 secs (0.003u,0.s)
Chars 1625 - 1647 [(unfold~recip_on_apart).] 0.003 secs (0.003u,0.s)
Chars 1741 - 1761 [(set~(ltyx2~:=~ltyx)).] 0.005 secs (0.005u,0.s)
Chars 1764 - 1777 [(unfold~ltyx2).] 0.003 secs (0.003u,0.s)
Chars 1780 - 1850 [(rewrite~(recip_irrelevant~y~(...] 0.01 secs (0.008u,0.001s)
Chars 1853 - 1935 [(set~~~(ltyx_recips~:=~~~~flip...] 0.006 secs (0.004u,0.001s)
Chars 1938 - 1957 [(cbn~in~ltyx_recips).] 0.005 secs (0.005u,0.s)
Chars 1960 - 2074 [(rewrite~~~(recip_irrelevant~x...] 0.027 secs (0.024u,0.002s)
Chars 2077 - 2081 [(cbn).] 0.004 secs (0.004u,0.s)
Chars 2084 - 2162 [(rewrite~(recip_irrelevant~(//...] 0.017 secs (0.016u,0.s)
Chars 2165 - 2176 [assumption.] 0.003 secs (0.002u,0.s)
Chars 1484 - 1523 [(set~(apy0~:=~positive_apart_z...] 0.002 secs (0.002u,0.s)
Chars 1526 - 1564 [(set~(eq~:=~recip_involutive~(...] 0.001 secs (0.001u,0.s)
Chars 1567 - 1590 [(set~(eq'~:=~ap~pr1~eq)).] 0.002 secs (0.001u,0.s)
Chars 1593 - 1604 [(cbn~in~eq').] 0.002 secs (0.002u,0.s)
Chars 1607 - 1622 [(rewrite~<-~eq').] 0.002 secs (0.002u,0.s)
Chars 1625 - 1647 [(unfold~recip_on_apart).] 0.002 secs (0.002u,0.s)
Chars 1741 - 1761 [(set~(ltyx2~:=~ltyx)).] 0.003 secs (0.003u,0.s)
Chars 1764 - 1777 [(unfold~ltyx2).] 0.003 secs (0.003u,0.s)
Chars 1780 - 1850 [(rewrite~(recip_irrelevant~y~(...] 0.002 secs (0.002u,0.s)
Chars 1853 - 1935 [(set~~~(ltyx_recips~:=~~~~flip...] 0.002 secs (0.002u,0.s)
Chars 1938 - 1957 [(cbn~in~ltyx_recips).] 0.004 secs (0.003u,0.s)
Chars 1960 - 2074 [(rewrite~~~(recip_irrelevant~x...] 0.003 secs (0.003u,0.s)
Chars 2077 - 2081 [(cbn).] 0.003 secs (0.002u,0.s)
Chars 2084 - 2162 [(rewrite~(recip_irrelevant~(//...] 0.003 secs (0.003u,0.s)
Chars 2165 - 2176 [assumption.] 0.003 secs (0.003u,0.s)
Chars 2177 - 2181 [Qed.] 0.015 secs (0.012u,0.002s)
Chars 2182 - 2323 [Lemma~flip_lt_recip_r~(x~y~:~F...] 0.009 secs (0.008u,0.001s)
Chars 2324 - 2330 [Proof.] 0. secs (0.u,0.s)
Chars 2119 - 2127 [intro~x.] 40.185 secs (0.u,0.03s)
Chars 2130 - 2157 [srapply~isequiv_adjointify.] 0.002 secs (0.001u,0.s)
Chars 2160 - 2194 [1:~exact~(fun~y~=>~sg_op~y~(-~...] 0.001 secs (0.001u,0.s)
Chars 2197 - 2210 [all:~intro~y.] 0.001 secs (0.001u,0.s)
Chars 2213 - 2273 [all:~refine~(((associativity~_...] 0.075 secs (0.069u,0.005s)
Chars 2276 - 2302 [all:~refine~(ap~(y~*.)~_).] 0.002 secs (0.002u,0.s)
Chars 2305 - 2327 [1:~(apply~left_inverse).] 0.003 secs (0.003u,0.s)
Chars 2330 - 2350 [(apply~right_inverse).] 0.002 secs (0.002u,0.s)
Chars 2119 - 2127 [intro~x.] 0. secs (0.u,0.s)
Chars 2130 - 2157 [srapply~isequiv_adjointify.] 0. secs (0.u,0.s)
Chars 2160 - 2194 [1:~exact~(fun~y~=>~sg_op~y~(-~...] 0. secs (0.u,0.s)
Chars 2197 - 2210 [all:~intro~y.] 0. secs (0.u,0.s)
Chars 2213 - 2273 [all:~refine~(((associativity~_...] 0. secs (0.u,0.s)
Chars 2276 - 2302 [all:~refine~(ap~(y~*.)~_).] 0. secs (0.u,0.s)
Chars 2305 - 2327 [1:~(apply~left_inverse).] 0. secs (0.u,0.s)
Chars 2330 - 2350 [(apply~right_inverse).] 0. secs (0.u,0.s)
Chars 2351 - 2359 [Defined.] 0.002 secs (0.002u,0.s)
Chars 2386 - 2574 [#[global]~Instance~issemigroup...] 0.004 secs (0.003u,0.s)
Chars 2575 - 2581 [Proof.] 0. secs (0.u,0.s)
Chars 4359 - 4402 [refine~(equiv_swap_types~(X~*~...] 24.657 secs (8.701u,-0.265s)
Chars 2862 - 2876 [(destruct~p,~q).] 40.164 secs (0.001u,0.036s)
Chars 2881 - 2897 [(apply~sq_refl_v).] 0.001 secs (0.001u,0.s)
Chars 2862 - 2876 [(destruct~p,~q).] 0. secs (0.u,0.s)
Chars 2881 - 2897 [(apply~sq_refl_v).] 0. secs (0.u,0.s)
Chars 2900 - 2908 [Defined.] 0.001 secs (0.001u,0.s)
Chars 2912 - 3070 [Definition~join_natsq_h~{A~B~:...] 0.002 secs (0.001u,0.s)
Chars 3073 - 3079 [Proof.] 0. secs (0.u,0.s)
Chars 1764 - 1777 [(intros~P0~PS).] 40.189 secs (0.001u,0.037s)
Chars 1778 - 1811 [(refine~(induction~_~_~_~_);~a...] 0.01 secs (0.007u,0.002s)
Chars 1812 - 1829 [(intros~n~E1~?~E2).] 0.001 secs (0.001u,0.s)
Chars 1830 - 1857 [(destruct~(rings.is_ne_0~1)).] 0.008 secs (0.007u,0.s)
Chars 1858 - 1885 [(apply~(antisymmetry~(≤))).] 0.041 secs (0.033u,0.007s)
Chars 1886 - 1887 [-] 0. secs (0.u,0.s)
Chars 1888 - 1925 [(apply~(order_reflecting~(n~-~...] 0.045 secs (0.032u,0.012s)
Chars 1928 - 1974 [(rewrite~<-~plus_assoc,~plus_n...] 0.045 secs (0.044u,0.s)
Chars 1977 - 2000 [(transitivity~0;~trivial).] 0.077 secs (0.065u,0.011s)
Chars 2001 - 2002 [-] 0. secs (0.u,0.s)
Chars 2003 - 2032 [(transitivity~(n~-~1);~trivial).] 0.112 secs (0.101u,0.01s)
Chars 2035 - 2066 [(apply~(order_reflecting~(1~+))).] 0.017 secs (0.015u,0.002s)
Chars 2069 - 2123 [(rewrite~plus_comm,~<-~plus_as...] 0.05 secs (0.046u,0.003s)
Chars 2126 - 2141 [transitivity~0.] 0.068 secs (0.063u,0.005s)
Chars 2144 - 2145 [+] 0. secs (0.u,0.s)
Chars 2146 - 2154 [trivial.] 0.001 secs (0.001u,0.s)
Chars 2157 - 2158 [+] 0. secs (0.u,0.s)
Chars 2159 - 2172 [(apply~le_0_2).] 0.009 secs (0.009u,0.s)
Chars 1764 - 1777 [(intros~P0~PS).] 0. secs (0.u,0.s)
Chars 1778 - 1811 [(refine~(induction~_~_~_~_);~a...] 0.008 secs (0.005u,0.002s)
Chars 1812 - 1829 [(intros~n~E1~?~E2).] 0.001 secs (0.001u,0.s)
Chars 1830 - 1857 [(destruct~(rings.is_ne_0~1)).] 0.001 secs (0.u,0.s)
Chars 1858 - 1885 [(apply~(antisymmetry~(≤))).] 0. secs (0.u,0.s)
Chars 1888 - 1925 [(apply~(order_reflecting~(n~-~...] 0. secs (0.u,0.s)
Chars 1928 - 1974 [(rewrite~<-~plus_assoc,~plus_n...] 0.001 secs (0.001u,0.s)
Chars 1977 - 2000 [(transitivity~0;~trivial).] 0.002 secs (0.002u,0.s)
Chars 2003 - 2032 [(transitivity~(n~-~1);~trivial).] 0.002 secs (0.002u,0.s)
Chars 2035 - 2066 [(apply~(order_reflecting~(1~+))).] 0. secs (0.u,0.s)
Chars 2069 - 2123 [(rewrite~plus_comm,~<-~plus_as...] 0. secs (0.u,0.s)
Chars 2126 - 2141 [transitivity~0.] 0. secs (0.u,0.s)
Chars 2146 - 2154 [trivial.] 0. secs (0.u,0.s)
Chars 2159 - 2172 [(apply~le_0_2).] 0. secs (0.u,0.s)
Chars 2173 - 2177 [Qed.] 0.005 secs (0.005u,0.s)
Chars 2179 - 2210 [#[global]Instance:~(Biinductio...] 0. secs (0.u,0.s)
Chars 2211 - 2217 [Proof.] 0. secs (0.u,0.s)
Chars 4359 - 4402 [refine~(equiv_swap_types~(X~*~...] 40.089 secs (0.002u,0.04s)
Chars 4405 - 4427 [transitivity~(BAut~X).] 0.003 secs (0.003u,0.s)
Chars 4430 - 4431 [-] 0. secs (0.u,0.s)
Chars 4432 - 4478 [(symmetry;~exact~(baut_prod_ri...] 0.004 secs (0.003u,0.s)
Chars 4481 - 4482 [-] 0. secs (0.u,0.s)
Chars 4483 - 4519 [exact~(baut_prod_rigid_equiv~X...] 0.003 secs (0.003u,0.s)
Chars 4359 - 4402 [refine~(equiv_swap_types~(X~*~...] 0. secs (0.u,0.s)
Chars 4405 - 4427 [transitivity~(BAut~X).] 0. secs (0.u,0.s)
Chars 4432 - 4478 [(symmetry;~exact~(baut_prod_ri...] 0. secs (0.u,0.s)
Chars 4483 - 4519 [exact~(baut_prod_rigid_equiv~X...] 0. secs (0.u,0.s)
Chars 4520 - 4528 [Defined.] 0.003 secs (0.002u,0.s)
Chars 4645 - 4776 [Definition~lem_from_aut_type_u...] 0. secs (0.u,0.s)
Chars 4777 - 4783 [Proof.] 0. secs (0.u,0.s)
Chars 2333 - 2372 [(set~(apx0~:=~positive_apart_z...] 40.16 secs (0.006u,0.023s)
Chars 2375 - 2414 [(set~(apy0~:=~positive_apart_z...] 0.003 secs (0.003u,0.s)
Chars 2417 - 2458 [(change~x~with~((x;~apx0)~:~Ap...] 0.002 secs (0.002u,0.s)
Chars 2461 - 2500 [(rewrite~<-~(recip_involutive~...] 0.007 secs (0.007u,0.s)
Chars 2503 - 2530 [(unfold~recip_on_apart;~cbn).] 0.024 secs (0.017u,0.006s)
Chars 2533 - 2572 [(pose~proof~(pos_recip_compat~...] 0.002 secs (0.002u,0.s)
Chars 2575 - 2644 [(rewrite~(recip_irrelevant~y~(...] 0.008 secs (0.007u,0.001s)
Chars 2647 - 2696 [(change~y~with~((y;~apy0)~:~Ap...] 0.003 secs (0.003u,0.s)
Chars 2699 - 2746 [(rewrite~<-~(recip_involutive~...] 0.008 secs (0.008u,0.s)
Chars 2749 - 2792 [(unfold~recip_on_apart~in~ltyx...] 0.005 secs (0.005u,0.s)
Chars 2795 - 2906 [(rewrite~~~(recip_irrelevant~(...] 0.016 secs (0.016u,0.s)
Chars 2909 - 2982 [(pose~proof~(flip_lt_recip_l~(...] 0.004 secs (0.003u,0.s)
Chars 2985 - 2997 [(cbn~in~ltxy).] 0.004 secs (0.003u,0.s)
Chars 3000 - 3165 [(rewrite~~~(recip_irrelevant~(...] 0.025 secs (0.019u,0.005s)
Chars 3168 - 3179 [assumption.] 0.002 secs (0.002u,0.s)
Chars 2333 - 2372 [(set~(apx0~:=~positive_apart_z...] 0.001 secs (0.001u,0.s)
Chars 2375 - 2414 [(set~(apy0~:=~positive_apart_z...] 0.001 secs (0.001u,0.s)
Chars 2417 - 2458 [(change~x~with~((x;~apx0)~:~Ap...] 0.001 secs (0.001u,0.s)
Chars 2461 - 2500 [(rewrite~<-~(recip_involutive~...] 0.001 secs (0.001u,0.s)
Chars 2503 - 2530 [(unfold~recip_on_apart;~cbn).] 0.004 secs (0.004u,0.s)
Chars 2533 - 2572 [(pose~proof~(pos_recip_compat~...] 0.001 secs (0.001u,0.s)
Chars 2575 - 2644 [(rewrite~(recip_irrelevant~y~(...] 0.001 secs (0.001u,0.s)
Chars 2647 - 2696 [(change~y~with~((y;~apy0)~:~Ap...] 0.001 secs (0.u,0.s)
Chars 2699 - 2746 [(rewrite~<-~(recip_involutive~...] 0.001 secs (0.001u,0.s)
Chars 2749 - 2792 [(unfold~recip_on_apart~in~ltyx...] 0.004 secs (0.004u,0.s)
Chars 2795 - 2906 [(rewrite~~~(recip_irrelevant~(...] 0.001 secs (0.001u,0.s)
Chars 2909 - 2982 [(pose~proof~(flip_lt_recip_l~(...] 0.001 secs (0.001u,0.s)
Chars 2985 - 2997 [(cbn~in~ltxy).] 0.003 secs (0.003u,0.s)
Chars 3000 - 3165 [(rewrite~~~(recip_irrelevant~(...] 0.002 secs (0.001u,0.s)
Chars 3168 - 3179 [assumption.] 0.002 secs (0.002u,0.s)
Chars 3180 - 3184 [Qed.] 0.014 secs (0.01u,0.003s)
Chars 3186 - 3314 [Lemma~field_split2~(x~:~F)~:~~...] 0.04 secs (0.033u,0.006s)
Chars 3315 - 3321 [Proof.] 0. secs (0.u,0.s)
Chars 2685 - 2689 [(hnf).] 40.156 secs (0.u,0.03s)
Chars 2690 - 2713 [(intros~[x|~|~x]~[y|~|~y]).] 0.006 secs (0.006u,0.s)
Chars 2762 - 2800 [2,~5,~8:~(cbn;~by~rewrite~righ...] 0.032 secs (0.029u,0.002s)
Chars 2803 - 2838 [3,~4:~(symmetry;~apply~left_id...] 0.021 secs (0.018u,0.002s)
Chars 2916 - 2917 [{] 0. secs (0.u,0.s)
Chars 2918 - 3056 [(change~~~~(cring_catamorphism...] 0.008 secs (0.007u,0.s)
Chars 3061 - 3105 [(induction~y~as~[|~y~IHy]~usin...] 0.002 secs (0.002u,0.s)
Chars 3110 - 3111 [{] 0. secs (0.u,0.s)
Chars 3112 - 3118 [(simpl).] 0. secs (0.u,0.s)
Chars 3125 - 3145 [(rewrite~pos_add_1_r).] 0.002 secs (0.002u,0.s)
Chars 3152 - 3188 [(rewrite~pos_peano_rec_beta_po...] 0.002 secs (0.001u,0.001s)
Chars 3195 - 3215 [(apply~commutativity).] 0.01 secs (0.009u,0.s)
Chars 3216 - 3217 [}] 0. secs (0.u,0.s)
Chars 3222 - 3228 [(simpl).] 0.001 secs (0.001u,0.s)
Chars 3233 - 3256 [(rewrite~pos_add_succ_r).] 0.002 secs (0.002u,0.s)
Chars 3261 - 3299 [(rewrite~2!pos_peano_rec_beta_...] 0.004 secs (0.003u,0.s)
Chars 3304 - 3333 [(rewrite~simple_associativity).] 0.036 secs (0.032u,0.004s)
Chars 3338 - 3369 [(rewrite~(commutativity~_~(-~1...] 0.02 secs (0.017u,0.002s)
Chars 3374 - 3406 [(rewrite~<-~simple_associativi...] 0.036 secs (0.032u,0.004s)
Chars 3411 - 3416 [f_ap.] 0.003 secs (0.001u,0.001s)
Chars 3417 - 3418 [}] 0. secs (0.u,0.s)
Chars 3444 - 3445 [{] 0. secs (0.u,0.s)
Chars 3446 - 3450 [(cbn).] 0.001 secs (0.001u,0.s)
Chars 3455 - 3464 [revert~x.] 0. secs (0.u,0.s)
Chars 3469 - 3522 [(induction~y~as~[|~y~IHy]~usin...] 0.018 secs (0.015u,0.002s)
Chars 3527 - 3528 [{] 0. secs (0.u,0.s)
Chars 3529 - 3533 [(cbn).] 0.001 secs (0.001u,0.s)
Chars 3540 - 3580 [(induction~x~as~[|~x]~using~po...] 0.002 secs (0.002u,0.s)
Chars 3587 - 3624 [1:~(symmetry;~cbn;~apply~left_...] 0.009 secs (0.009u,0.s)
Chars 3631 - 3667 [(rewrite~pos_peano_rec_beta_po...] 0.002 secs (0.002u,0.s)
Chars 3674 - 3701 [(rewrite~int_pos_sub_succ_r).] 0.002 secs (0.002u,0.s)
Chars 3708 - 3745 [(cbn;~rewrite~<-~simple_associ...] 0.034 secs (0.034u,0.s)
Chars 3752 - 3771 [(apply~rng_moveL_Mr).] 0.002 secs (0.002u,0.s)
Chars 3778 - 3802 [(cbn;~rewrite~involutive).] 0.009 secs (0.006u,0.002s)
Chars 3809 - 3829 [(apply~commutativity).] 0.014 secs (0.013u,0.s)
Chars 3830 - 3831 [}] 0. secs (0.u,0.s)
Chars 3836 - 3880 [(induction~x~as~[|~x~IHx]~usin...] 0.002 secs (0.002u,0.s)
Chars 3885 - 3886 [{] 0. secs (0.u,0.s)
Chars 3887 - 3914 [(rewrite~int_pos_sub_succ_l).] 0.002 secs (0.002u,0.s)
Chars 3921 - 3945 [(cbn;~apply~rng_moveL_Mr).] 0.004 secs (0.003u,0.s)
Chars 3952 - 3976 [(cbn;~rewrite~involutive).] 0.009 secs (0.007u,0.001s)
Chars 3983 - 4022 [by~rewrite~pos_peano_rec_beta_...] 0.003 secs (0.002u,0.s)
Chars 4023 - 4024 [}] 0. secs (0.u,0.s)
Chars 4029 - 4059 [(rewrite~int_pos_sub_succ_succ).] 0.003 secs (0.003u,0.s)
Chars 4064 - 4076 [(rewrite~IHy).] 0.003 secs (0.001u,0.001s)
Chars 4081 - 4119 [(rewrite~2!pos_peano_rec_beta_...] 0.005 secs (0.005u,0.s)
Chars 4124 - 4153 [(rewrite~(commutativity~(-~1))).] 0.023 secs (0.018u,0.004s)
Chars 4158 - 4187 [(rewrite~simple_associativity).] 0.043 secs (0.04u,0.003s)
Chars 4192 - 4232 [(rewrite~<-~(simple_associativ...] 0.027 secs (0.025u,0.001s)
Chars 4237 - 4258 [(rewrite~left_inverse).] 0.016 secs (0.013u,0.003s)
Chars 4263 - 4268 [f_ap.] 0.021 secs (0.02u,0.s)
Chars 4273 - 4282 [symmetry.] 0.004 secs (0.004u,0.s)
Chars 4287 - 4308 [(apply~right_identity).] 0.014 secs (0.013u,0.s)
Chars 4309 - 4310 [}] 0. secs (0.u,0.s)
Chars 4313 - 4314 [-] 0. secs (0.u,0.s)
Chars 4315 - 4319 [(cbn).] 0.001 secs (0.001u,0.s)
Chars 4324 - 4333 [revert~x.] 0. secs (0.u,0.s)
Chars 4338 - 4391 [(induction~y~as~[|~y~IHy]~usin...] 0.003 secs (0.002u,0.s)
Chars 4396 - 4397 [{] 0. secs (0.u,0.s)
Chars 4398 - 4438 [(induction~x~as~[|~x]~using~po...] 0.002 secs (0.002u,0.s)
Chars 4445 - 4483 [1:~(symmetry;~cbn;~apply~right...] 0.009 secs (0.007u,0.001s)
Chars 4490 - 4526 [(rewrite~pos_peano_rec_beta_po...] 0.002 secs (0.002u,0.s)
Chars 4533 - 4559 [(rewrite~(commutativity~1)).] 0.014 secs (0.014u,0.s)
Chars 4566 - 4598 [(rewrite~<-~simple_associativi...] 0.028 secs (0.028u,0.s)
Chars 4605 - 4632 [(rewrite~int_pos_sub_succ_l).] 0.002 secs (0.002u,0.s)
Chars 4639 - 4685 [(cbn;~by~rewrite~right_inverse...] 0.021 secs (0.021u,0.s)
Chars 4686 - 4687 [}] 0. secs (0.u,0.s)
Chars 4692 - 4736 [(induction~x~as~[|~x~IHx]~usin...] 0.002 secs (0.002u,0.s)
Chars 4741 - 4742 [{] 0. secs (0.u,0.s)
Chars 4743 - 4770 [(rewrite~int_pos_sub_succ_r).] 0.002 secs (0.002u,0.s)
Chars 4777 - 4813 [(rewrite~pos_peano_rec_beta_po...] 0.002 secs (0.002u,0.s)
Chars 4820 - 4849 [(rewrite~simple_associativity).] 0.028 secs (0.028u,0.s)
Chars 4856 - 4860 [(cbn).] 0.001 secs (0.001u,0.s)
Chars 4867 - 4893 [(rewrite~(right_inverse~1)).] 0.009 secs (0.009u,0.s)
Chars 4900 - 4909 [symmetry.] 0.003 secs (0.003u,0.s)
Chars 4916 - 4936 [(apply~left_identity).] 0.009 secs (0.009u,0.s)
Chars 4937 - 4938 [}] 0. secs (0.u,0.s)
Chars 4943 - 4973 [(rewrite~int_pos_sub_succ_succ).] 0.002 secs (0.002u,0.s)
Chars 4978 - 4990 [(rewrite~IHy).] 0.002 secs (0.002u,0.s)
Chars 4995 - 5033 [(rewrite~2!pos_peano_rec_beta_...] 0.004 secs (0.004u,0.s)
Chars 5038 - 5064 [(rewrite~(commutativity~1)).] 0.032 secs (0.031u,0.s)
Chars 5069 - 5098 [(rewrite~simple_associativity).] 0.035 secs (0.035u,0.s)
Chars 5103 - 5146 [(rewrite~<-~(simple_associativ...] 0.022 secs (0.022u,0.s)
Chars 5151 - 5177 [(rewrite~(right_inverse~1)).] 0.012 secs (0.012u,0.s)
Chars 5182 - 5197 [(f_ap;~symmetry).] 0.011 secs (0.011u,0.s)
Chars 5202 - 5223 [(apply~right_identity).] 0.012 secs (0.012u,0.s)
Chars 5226 - 5227 [-] 0. secs (0.u,0.s)
Chars 5228 - 5232 [(cbn).] 0. secs (0.u,0.s)
Chars 5237 - 5281 [(induction~y~as~[|~y~IHy]~usin...] 0.001 secs (0.001u,0.s)
Chars 5286 - 5287 [{] 0. secs (0.u,0.s)
Chars 5288 - 5292 [(cbn).] 0.001 secs (0.001u,0.s)
Chars 5299 - 5319 [(rewrite~pos_add_1_r).] 0.001 secs (0.001u,0.s)
Chars 5326 - 5362 [(rewrite~pos_peano_rec_beta_po...] 0.001 secs (0.001u,0.s)
Chars 5369 - 5389 [(apply~commutativity).] 0.009 secs (0.008u,0.s)
Chars 5390 - 5391 [}] 0. secs (0.u,0.s)
Chars 5396 - 5419 [(rewrite~pos_add_succ_r).] 0.002 secs (0.002u,0.s)
Chars 5424 - 5462 [(rewrite~2!pos_peano_rec_beta_...] 0.003 secs (0.003u,0.s)
Chars 5467 - 5496 [(rewrite~simple_associativity).] 0.028 secs (0.028u,0.s)
Chars 5501 - 5513 [(rewrite~IHy).] 0.002 secs (0.002u,0.s)
Chars 5518 - 5547 [(rewrite~simple_associativity).] 0.035 secs (0.034u,0.s)
Chars 5552 - 5578 [(rewrite~(commutativity~1)).] 0.014 secs (0.014u,0.s)
Chars 5583 - 5595 [reflexivity.] 0.001 secs (0.001u,0.s)
Chars 2685 - 2689 [(hnf).] 0. secs (0.u,0.s)
Chars 2690 - 2713 [(intros~[x|~|~x]~[y|~|~y]).] 0. secs (0.u,0.s)
Chars 2762 - 2800 [2,~5,~8:~(cbn;~by~rewrite~righ...] 0.001 secs (0.001u,0.s)
Chars 2803 - 2838 [3,~4:~(symmetry;~apply~left_id...] 0.001 secs (0.001u,0.s)
Chars 2918 - 3056 [(change~~~~(cring_catamorphism...] 0. secs (0.u,0.s)
Chars 3061 - 3105 [(induction~y~as~[|~y~IHy]~usin...] 0. secs (0.u,0.s)
Chars 3112 - 3118 [(simpl).] 0. secs (0.u,0.s)
Chars 3125 - 3145 [(rewrite~pos_add_1_r).] 0. secs (0.u,0.s)
Chars 3152 - 3188 [(rewrite~pos_peano_rec_beta_po...] 0. secs (0.u,0.s)
Chars 3195 - 3215 [(apply~commutativity).] 0. secs (0.u,0.s)
Chars 3222 - 3228 [(simpl).] 0. secs (0.u,0.s)
Chars 3233 - 3256 [(rewrite~pos_add_succ_r).] 0. secs (0.u,0.s)
Chars 3261 - 3299 [(rewrite~2!pos_peano_rec_beta_...] 0. secs (0.u,0.s)
Chars 3304 - 3333 [(rewrite~simple_associativity).] 0. secs (0.u,0.s)
Chars 3338 - 3369 [(rewrite~(commutativity~_~(-~1...] 0. secs (0.u,0.s)
Chars 3374 - 3406 [(rewrite~<-~simple_associativi...] 0. secs (0.u,0.s)
Chars 3411 - 3416 [f_ap.] 0. secs (0.u,0.s)
Chars 3446 - 3450 [(cbn).] 0. secs (0.u,0.s)
Chars 3455 - 3464 [revert~x.] 0. secs (0.u,0.s)
Chars 3469 - 3522 [(induction~y~as~[|~y~IHy]~usin...] 0.001 secs (0.001u,0.s)
Chars 3529 - 3533 [(cbn).] 0. secs (0.u,0.s)
Chars 3540 - 3580 [(induction~x~as~[|~x]~using~po...] 0. secs (0.u,0.s)
Chars 3587 - 3624 [1:~(symmetry;~cbn;~apply~left_...] 0.001 secs (0.001u,0.s)
Chars 3631 - 3667 [(rewrite~pos_peano_rec_beta_po...] 0. secs (0.u,0.s)
Chars 3674 - 3701 [(rewrite~int_pos_sub_succ_r).] 0. secs (0.u,0.s)
Chars 3708 - 3745 [(cbn;~rewrite~<-~simple_associ...] 0.001 secs (0.001u,0.s)
Chars 3752 - 3771 [(apply~rng_moveL_Mr).] 0. secs (0.u,0.s)
Chars 3778 - 3802 [(cbn;~rewrite~involutive).] 0.001 secs (0.001u,0.s)
Chars 3809 - 3829 [(apply~commutativity).] 0. secs (0.u,0.s)
Chars 3836 - 3880 [(induction~x~as~[|~x~IHx]~usin...] 0. secs (0.u,0.s)
Chars 3887 - 3914 [(rewrite~int_pos_sub_succ_l).] 0. secs (0.u,0.s)
Chars 3921 - 3945 [(cbn;~apply~rng_moveL_Mr).] 0.001 secs (0.001u,0.s)
Chars 3952 - 3976 [(cbn;~rewrite~involutive).] 0.001 secs (0.001u,0.s)
Chars 3983 - 4022 [by~rewrite~pos_peano_rec_beta_...] 0. secs (0.u,0.s)
Chars 4029 - 4059 [(rewrite~int_pos_sub_succ_succ).] 0.001 secs (0.001u,0.s)
Chars 4064 - 4076 [(rewrite~IHy).] 0.001 secs (0.001u,0.s)
Chars 4081 - 4119 [(rewrite~2!pos_peano_rec_beta_...] 0.001 secs (0.001u,0.s)
Chars 4124 - 4153 [(rewrite~(commutativity~(-~1))).] 0.001 secs (0.001u,0.s)
Chars 4158 - 4187 [(rewrite~simple_associativity).] 0.001 secs (0.001u,0.s)
Chars 4192 - 4232 [(rewrite~<-~(simple_associativ...] 0.001 secs (0.001u,0.s)
Chars 4237 - 4258 [(rewrite~left_inverse).] 0.001 secs (0.001u,0.s)
Chars 4263 - 4268 [f_ap.] 0.001 secs (0.001u,0.s)
Chars 4273 - 4282 [symmetry.] 0.001 secs (0.001u,0.s)
Chars 4287 - 4308 [(apply~right_identity).] 0.001 secs (0.001u,0.s)
Chars 4315 - 4319 [(cbn).] 0. secs (0.u,0.s)
Chars 4324 - 4333 [revert~x.] 0. secs (0.u,0.s)
Chars 4338 - 4391 [(induction~y~as~[|~y~IHy]~usin...] 0.001 secs (0.001u,0.s)
Chars 4398 - 4438 [(induction~x~as~[|~x]~using~po...] 0. secs (0.u,0.s)
Chars 4445 - 4483 [1:~(symmetry;~cbn;~apply~right...] 0.001 secs (0.001u,0.s)
Chars 4490 - 4526 [(rewrite~pos_peano_rec_beta_po...] 0. secs (0.u,0.s)
Chars 4533 - 4559 [(rewrite~(commutativity~1)).] 0. secs (0.u,0.s)
Chars 4566 - 4598 [(rewrite~<-~simple_associativi...] 0. secs (0.u,0.s)
Chars 4605 - 4632 [(rewrite~int_pos_sub_succ_l).] 0. secs (0.u,0.s)
Chars 4639 - 4685 [(cbn;~by~rewrite~right_inverse...] 0.001 secs (0.001u,0.s)
Chars 4692 - 4736 [(induction~x~as~[|~x~IHx]~usin...] 0. secs (0.u,0.s)
Chars 4743 - 4770 [(rewrite~int_pos_sub_succ_r).] 0. secs (0.u,0.s)
Chars 4777 - 4813 [(rewrite~pos_peano_rec_beta_po...] 0. secs (0.u,0.s)
Chars 4820 - 4849 [(rewrite~simple_associativity).] 0. secs (0.u,0.s)
Chars 4856 - 4860 [(cbn).] 0. secs (0.u,0.s)
Chars 4867 - 4893 [(rewrite~(right_inverse~1)).] 0. secs (0.u,0.s)
Chars 4900 - 4909 [symmetry.] 0. secs (0.u,0.s)
Chars 4916 - 4936 [(apply~left_identity).] 0. secs (0.u,0.s)
Chars 4943 - 4973 [(rewrite~int_pos_sub_succ_succ).] 0.001 secs (0.001u,0.s)
Chars 4978 - 4990 [(rewrite~IHy).] 0.001 secs (0.001u,0.s)
Chars 4995 - 5033 [(rewrite~2!pos_peano_rec_beta_...] 0.001 secs (0.001u,0.s)
Chars 5038 - 5064 [(rewrite~(commutativity~1)).] 0.001 secs (0.001u,0.s)
Chars 5069 - 5098 [(rewrite~simple_associativity).] 0.001 secs (0.001u,0.s)
Chars 5103 - 5146 [(rewrite~<-~(simple_associativ...] 0.001 secs (0.001u,0.s)
Chars 5151 - 5177 [(rewrite~(right_inverse~1)).] 0.001 secs (0.001u,0.s)
Chars 5182 - 5197 [(f_ap;~symmetry).] 0.002 secs (0.002u,0.s)
Chars 5202 - 5223 [(apply~right_identity).] 0.001 secs (0.001u,0.s)
Chars 5228 - 5232 [(cbn).] 0. secs (0.u,0.s)
Chars 5237 - 5281 [(induction~y~as~[|~y~IHy]~usin...] 0. secs (0.u,0.s)
Chars 5288 - 5292 [(cbn).] 0. secs (0.u,0.s)
Chars 5299 - 5319 [(rewrite~pos_add_1_r).] 0. secs (0.u,0.s)
Chars 5326 - 5362 [(rewrite~pos_peano_rec_beta_po...] 0. secs (0.u,0.s)
Chars 5369 - 5389 [(apply~commutativity).] 0. secs (0.u,0.s)
Chars 5396 - 5419 [(rewrite~pos_add_succ_r).] 0. secs (0.u,0.s)
Chars 5424 - 5462 [(rewrite~2!pos_peano_rec_beta_...] 0. secs (0.u,0.s)
Chars 5467 - 5496 [(rewrite~simple_associativity).] 0. secs (0.u,0.s)
Chars 5501 - 5513 [(rewrite~IHy).] 0. secs (0.u,0.s)
Chars 5518 - 5547 [(rewrite~simple_associativity).] 0. secs (0.u,0.s)
Chars 5552 - 5578 [(rewrite~(commutativity~1)).] 0. secs (0.u,0.s)
Chars 5583 - 5595 [reflexivity.] 0. secs (0.u,0.s)
Chars 3084 - 3098 [(destruct~p,~q).] 40.158 secs (0.004u,0.031s)
Chars 3103 - 3119 [(apply~sq_refl_h).] 0.001 secs (0.001u,0.s)
Chars 3084 - 3098 [(destruct~p,~q).] 0. secs (0.u,0.s)
Chars 3103 - 3119 [(apply~sq_refl_h).] 0. secs (0.u,0.s)
Chars 3122 - 3130 [Defined.] 0.001 secs (0.001u,0.s)
Chars 3134 - 3221 [Definition~functor_join~{A}~{B...] 0. secs (0.u,0.s)
Chars 3224 - 3230 [Proof.] 0. secs (0.u,0.s)
Chars 5596 - 5600 [Qed.] 0.082 secs (0.082u,0.s)
Chars 5602 - 5710 [Lemma~cring_catamorphism_fun_n...] 0.003 secs (0.003u,0.s)
Chars 5711 - 5717 [Proof.] 0. secs (0.u,0.s)
Chars 2218 - 2235 [(intros~P~P0~Psuc).] 40.179 secs (0.u,0.041s)
Chars 2236 - 2261 [(apply~induction;~trivial).] 0.005 secs (0.004u,0.s)
Chars 2262 - 2263 [-] 0. secs (0.u,0.s)
Chars 2264 - 2285 [(intros~?~?;~apply~Psuc).] 0.002 secs (0.001u,0.s)
Chars 2286 - 2287 [-] 0. secs (0.u,0.s)
Chars 2288 - 2306 [(intros;~apply~Psuc).] 0.002 secs (0.002u,0.s)
Chars 2309 - 2363 [(rewrite~plus_comm,~<-~plus_as...] 0.047 secs (0.041u,0.005s)
Chars 2366 - 2374 [trivial.] 0.001 secs (0.001u,0.s)
Chars 2218 - 2235 [(intros~P~P0~Psuc).] 0. secs (0.u,0.s)
Chars 2236 - 2261 [(apply~induction;~trivial).] 0.002 secs (0.002u,0.s)
Chars 2264 - 2285 [(intros~?~?;~apply~Psuc).] 0.001 secs (0.001u,0.s)
Chars 2288 - 2306 [(intros;~apply~Psuc).] 0.001 secs (0.001u,0.s)
Chars 2309 - 2363 [(rewrite~plus_comm,~<-~plus_as...] 0. secs (0.u,0.s)
Chars 2366 - 2374 [trivial.] 0. secs (0.u,0.s)
Chars 2375 - 2379 [Qed.] 0.002 secs (0.002u,0.s)
Chars 2381 - 2455 [#[global]Instance~slow_int_le_...] 0. secs (0.u,0.s)
Chars 2456 - 2462 [Proof.] 0. secs (0.u,0.s)
Chars 4786 - 4832 [(apply~DNE_to_LEM,~DNE_from_al...] 40.148 secs (0.u,0.04s)
Chars 4835 - 4855 [(exists~(f~P);~split).] 0.002 secs (0.002u,0.s)
Chars 4858 - 4859 [-] 0. secs (0.u,0.s)
Chars 4860 - 4869 [(intros~p).] 0. secs (0.u,0.s)
Chars 4874 - 4936 [(assert~(Contr~P)~by~(apply~co...] 0.001 secs (0.001u,0.s)
Chars 4941 - 5023 [(assert~(q~:~Unit~=~P)~by~appl...] 0.003 secs (0.003u,0.s)
Chars 5028 - 5039 [(destruct~q).] 0.002 secs (0.u,0.s)
Chars 5044 - 5055 [(rewrite~eu).] 0.001 secs (0.001u,0.s)
Chars 5060 - 5065 [auto.] 0. secs (0.u,0.s)
Chars 5068 - 5069 [-] 0. secs (0.u,0.s)
Chars 5070 - 5081 [(intros~nfp).] 0. secs (0.u,0.s)
Chars 5086 - 5173 [(assert~(q~:~f~P~=~Empty)~by~~...] 0.002 secs (0.002u,0.s)
Chars 5178 - 5197 [(rewrite~<-~eu~in~q).] 0.001 secs (0.001u,0.s)
Chars 5202 - 5225 [(apply~(ap~f)^-1~in~q).] 0.036 secs (0.03u,0.005s)
Chars 5230 - 5250 [(rewrite~q;~exact~tt).] 0.001 secs (0.001u,0.s)
Chars 4786 - 4832 [(apply~DNE_to_LEM,~DNE_from_al...] 0. secs (0.u,0.s)
Chars 4835 - 4855 [(exists~(f~P);~split).] 0. secs (0.u,0.s)
Chars 4860 - 4869 [(intros~p).] 0. secs (0.u,0.s)
Chars 4874 - 4936 [(assert~(Contr~P)~by~(apply~co...] 0. secs (0.u,0.s)
Chars 4941 - 5023 [(assert~(q~:~Unit~=~P)~by~appl...] 0. secs (0.u,0.s)
Chars 5028 - 5039 [(destruct~q).] 0. secs (0.u,0.s)
Chars 5044 - 5055 [(rewrite~eu).] 0. secs (0.u,0.s)
Chars 5060 - 5065 [auto.] 0. secs (0.u,0.s)
Chars 5070 - 5081 [(intros~nfp).] 0. secs (0.u,0.s)
Chars 5086 - 5173 [(assert~(q~:~f~P~=~Empty)~by~~...] 0. secs (0.u,0.s)
Chars 5178 - 5197 [(rewrite~<-~eu~in~q).] 0. secs (0.u,0.s)
Chars 5202 - 5225 [(apply~(ap~f)^-1~in~q).] 0. secs (0.u,0.s)
Chars 5230 - 5250 [(rewrite~q;~exact~tt).] 0. secs (0.u,0.s)
Chars 5251 - 5259 [Defined.] 0.002 secs (0.002u,0.s)
Chars 5261 - 5378 [Lemma~equiv_hprop_idprod~`{Uni...] 0.001 secs (0.001u,0.s)
Chars 5379 - 5385 [Proof.] 0. secs (0.u,0.s)
Chars 3324 - 3353 [(rewrite~<-~plus_mult_distr_l).] 40.188 secs (0.011u,0.024s)
Chars 3356 - 3420 [(rewrite~<-~(mult_1_l~(recip'~...] 0.018 secs (0.017u,0.s)
Chars 3423 - 3452 [(rewrite~<-~plus_mult_distr_r).] 0.015 secs (0.011u,0.004s)
Chars 3455 - 3513 [(rewrite~(recip_inverse'~2~(po...] 0.017 secs (0.016u,0.001s)
Chars 3516 - 3533 [(rewrite~mult_1_r).] 0.009 secs (0.008u,0.s)
Chars 3536 - 3548 [reflexivity.] 0. secs (0.u,0.s)
Chars 3324 - 3353 [(rewrite~<-~plus_mult_distr_l).] 0.001 secs (0.001u,0.s)
Chars 3356 - 3420 [(rewrite~<-~(mult_1_l~(recip'~...] 0.001 secs (0.001u,0.s)
Chars 3423 - 3452 [(rewrite~<-~plus_mult_distr_r).] 0.001 secs (0.001u,0.s)
Chars 3455 - 3513 [(rewrite~(recip_inverse'~2~(po...] 0.001 secs (0.001u,0.s)
Chars 3516 - 3533 [(rewrite~mult_1_r).] 0. secs (0.u,0.s)
Chars 3536 - 3548 [reflexivity.] 0. secs (0.u,0.s)
Chars 3549 - 3553 [Qed.] 0.008 secs (0.007u,0.s)
Chars 3554 - 3567 [End~contents.] 0.117 secs (0.107u,0.009s)
Chars 5388 - 5394 [split.] 13.309 secs (-2.408u,-0.604s)
Chars 5720 - 5757 [snrapply~(groups.preserves_neg...] 40.162 secs (0.007u,0.028s)
Chars 5760 - 5783 [1-6:~typeclasses~eauto.] 0.033 secs (0.026u,0.006s)
Chars 5786 - 5820 [snrapply~Build_IsMonoidPreserv...] 0.003 secs (0.003u,0.s)
Chars 5823 - 5834 [1:~exact~_.] 0.003 secs (0.002u,0.s)
Chars 5837 - 5843 [split.] 0. secs (0.u,0.s)
Chars 5720 - 5757 [snrapply~(groups.preserves_neg...] 0. secs (0.u,0.s)
Chars 5760 - 5783 [1-6:~typeclasses~eauto.] 0. secs (0.u,0.s)
Chars 5786 - 5820 [snrapply~Build_IsMonoidPreserv...] 0. secs (0.u,0.s)
Chars 5823 - 5834 [1:~exact~_.] 0. secs (0.u,0.s)
Chars 5837 - 5843 [split.] 0. secs (0.u,0.s)
Chars 5844 - 5852 [Defined.] 0.002 secs (0.001u,0.s)
Chars 5854 - 6023 [Lemma~cring_catamorphism_fun_p...] 0.006 secs (0.005u,0.s)
Chars 6024 - 6030 [Proof.] 0. secs (0.u,0.s)
Chars 3235 - 3252 [srapply~Join_rec.] 40.261 secs (0.001u,0.035s)
Chars 3257 - 3287 [1:~(intro~a;~apply~joinl,~f,~a).] 0.001 secs (0.001u,0.s)
Chars 3292 - 3322 [1:~(intro~b;~apply~joinr,~g,~b).] 0.001 secs (0.001u,0.s)
Chars 3327 - 3338 [(intros~a~b).] 0. secs (0.u,0.s)
Chars 3343 - 3355 [(apply~jglue).] 0.005 secs (0.005u,0.s)
Chars 3235 - 3252 [srapply~Join_rec.] 0. secs (0.u,0.s)
Chars 3257 - 3287 [1:~(intro~a;~apply~joinl,~f,~a).] 0. secs (0.u,0.s)
Chars 3292 - 3322 [1:~(intro~b;~apply~joinr,~g,~b).] 0. secs (0.u,0.s)
Chars 3327 - 3338 [(intros~a~b).] 0. secs (0.u,0.s)
Chars 3343 - 3355 [(apply~jglue).] 0. secs (0.u,0.s)
Chars 3358 - 3366 [Defined.] 0. secs (0.u,0.s)
Chars 3370 - 3546 [Definition~functor_join_compos...] 0.004 secs (0.003u,0.s)
Chars 3549 - 3555 [Proof.] 0. secs (0.u,0.s)
Chars 2463 - 2474 [(intros~x~y).] 40.2 secs (0.u,0.039s)
Chars 2596 - 2623 [(pose~(E0~:=~naturals_ring)).] 0.013 secs (0.011u,0.s)
Chars 2624 - 2732 [(destruct~~~(dec~~~~~~(integer...] 0.382 secs (0.354u,0.028s)
Chars 2733 - 2734 [-] 0. secs (0.u,0.s)
Chars 2735 - 2740 [left.] 0.002 secs (0.u,0.001s)
Chars 2741 - 2773 [(apply~(order_reflecting~_)~in...] 0.116 secs (0.101u,0.014s)
Chars 2774 - 2782 [trivial.] 0.001 secs (0.001u,0.s)
Chars 2783 - 2784 [-] 0. secs (0.u,0.s)
Chars 2785 - 2791 [right.] 0.002 secs (0.002u,0.s)
Chars 2792 - 2841 [(intro;~apply~E;~apply~(order_...] 0.099 secs (0.094u,0.003s)
Chars 2463 - 2474 [(intros~x~y).] 0. secs (0.u,0.s)
Chars 2596 - 2623 [(pose~(E0~:=~naturals_ring)).] 0. secs (0.u,0.s)
Chars 2624 - 2732 [(destruct~~~(dec~~~~~~(integer...] 0. secs (0.u,0.s)
Chars 2735 - 2740 [left.] 0.001 secs (0.001u,0.s)
Chars 2741 - 2773 [(apply~(order_reflecting~_)~in...] 0.001 secs (0.001u,0.s)
Chars 2774 - 2782 [trivial.] 0. secs (0.u,0.s)
Chars 2785 - 2791 [right.] 0.001 secs (0.001u,0.s)
Chars 2792 - 2841 [(intro;~apply~E;~apply~(order_...] 0.007 secs (0.007u,0.s)
Chars 2842 - 2846 [Qed.] 0.033 secs (0.033u,0.s)
Chars 2847 - 2860 [End~integers.] 0.084 secs (0.082u,0.002s)
Chars 3560 - 3577 [srapply~Join_ind.] 12.493 secs (2.527u,-0.298s)
Chars 5388 - 5394 [split.] 40.086 secs (0.u,0.038s)
Chars 5397 - 5398 [-] 0. secs (0.u,0.s)
Chars 5399 - 5438 [(intros~p;~apply~path_universe...] 0.002 secs (0.002u,0.s)
Chars 5443 - 5490 [(apply~isequiv_adjointify~with...] 0.002 secs (0.002u,0.s)
Chars 5495 - 5496 [+] 0. secs (0.u,0.s)
Chars 5497 - 5519 [(intros~x;~reflexivity).] 0.001 secs (0.001u,0.s)
Chars 5524 - 5525 [+] 0. secs (0.u,0.s)
Chars 5526 - 5540 [(intros~[p'~x]).] 0.001 secs (0.001u,0.s)
Chars 5547 - 5601 [(apply~path_prod;~[~apply~path...] 0.003 secs (0.003u,0.s)
Chars 5604 - 5605 [-] 0. secs (0.u,0.s)
Chars 5606 - 5615 [(intros~q).] 0. secs (0.u,0.s)
Chars 5620 - 5638 [strip_truncations.] 0.101 secs (0.081u,0.018s)
Chars 5643 - 5665 [(apply~equiv_path~in~q).] 0. secs (0.u,0.s)
Chars 5670 - 5691 [exact~(fst~(q^-1~a)).] 0.002 secs (0.002u,0.s)
Chars 5388 - 5394 [split.] 0. secs (0.u,0.s)
Chars 5399 - 5438 [(intros~p;~apply~path_universe...] 0. secs (0.u,0.s)
Chars 5443 - 5490 [(apply~isequiv_adjointify~with...] 0. secs (0.u,0.s)
Chars 5497 - 5519 [(intros~x;~reflexivity).] 0. secs (0.u,0.s)
Chars 5526 - 5540 [(intros~[p'~x]).] 0. secs (0.u,0.s)
Chars 5547 - 5601 [(apply~path_prod;~[~apply~path...] 0.001 secs (0.001u,0.s)
Chars 5606 - 5615 [(intros~q).] 0. secs (0.u,0.s)
Chars 5620 - 5638 [strip_truncations.] 0. secs (0.u,0.s)
Chars 5643 - 5665 [(apply~equiv_path~in~q).] 0. secs (0.u,0.s)
Chars 5670 - 5691 [exact~(fst~(q^-1~a)).] 0. secs (0.u,0.s)
Chars 5692 - 5700 [Defined.] 0.001 secs (0.001u,0.s)
Chars 5702 - 5872 [Definition~lem_from_aut_type_i...] 0. secs (0.u,0.s)
Chars 5873 - 5879 [Proof.] 0. secs (0.u,0.s)
Chars 3560 - 3577 [srapply~Join_ind.] 40.07 secs (0.003u,0.034s)
Chars 3582 - 3599 [1,~2:~reflexivity.] 0.003 secs (0.001u,0.001s)
Chars 3604 - 3615 [(intros~a~b).] 0.001 secs (0.001u,0.s)
Chars 3620 - 3626 [(simpl).] 0.004 secs (0.004u,0.s)
Chars 3631 - 3646 [(apply~sq_dp^-1).] 0.009 secs (0.004u,0.004s)
Chars 3651 - 3663 [(apply~sq_1G).] 0.004 secs (0.004u,0.s)
Chars 3668 - 3677 [symmetry.] 0.004 secs (0.004u,0.s)
Chars 3682 - 3701 [(rewrite~ap_compose).] 0.005 secs (0.004u,0.s)
Chars 6033 - 6042 [revert~y.] 40.174 secs (0.u,0.028s)
Chars 6045 - 6098 [(induction~x~as~[|~x~IHx]~usin...] 0.002 secs (0.002u,0.s)
Chars 6101 - 6102 [{] 0. secs (0.u,0.s)
Chars 6103 - 6112 [symmetry.] 0.002 secs (0.002u,0.s)
Chars 6117 - 6137 [(apply~left_identity).] 0.007 secs (0.005u,0.001s)
Chars 6138 - 6139 [}] 0. secs (0.u,0.s)
Chars 3706 - 3736 [(rewrite~3!Join_rec_beta_jglue).] 0.071 secs (0.061u,0.009s)
Chars 3741 - 3753 [reflexivity.] 0.001 secs (0.001u,0.s)
Chars 3560 - 3577 [srapply~Join_ind.] 0. secs (0.u,0.s)
Chars 3582 - 3599 [1,~2:~reflexivity.] 0.001 secs (0.001u,0.s)
Chars 6142 - 6288 [(change~~~~(cring_catamorphism...] 0.009 secs (0.007u,0.001s)
Chars 3604 - 3615 [(intros~a~b).] 0. secs (0.u,0.s)
Chars 3620 - 3626 [(simpl).] 0.001 secs (0.001u,0.s)
Chars 3631 - 3646 [(apply~sq_dp^-1).] 0. secs (0.u,0.s)
Chars 6291 - 6314 [(rewrite~pos_mul_succ_l).] 0.002 secs (0.002u,0.s)
Chars 3651 - 3663 [(apply~sq_1G).] 0.001 secs (0.001u,0.s)
Chars 3668 - 3677 [symmetry.] 0. secs (0.u,0.s)
Chars 3682 - 3701 [(rewrite~ap_compose).] 0. secs (0.u,0.s)
Chars 3706 - 3736 [(rewrite~3!Join_rec_beta_jglue).] 0. secs (0.u,0.s)
Chars 3741 - 3753 [reflexivity.] 0. secs (0.u,0.s)
Chars 6317 - 6412 [refine~~(issemigrouppreserving...] 0.005 secs (0.005u,0.s)
Chars 6415 - 6427 [(rewrite~IHx).] 0.004 secs (0.003u,0.001s)
Chars 3756 - 3764 [Defined.] 0.018 secs (0.014u,0.004s)
Chars 3768 - 3867 [Definition~functor_join_idmap~...] 0.001 secs (0.001u,0.s)
Chars 3870 - 3876 [Proof.] 0. secs (0.u,0.s)
Chars 6430 - 6519 [transitivity~~((1~+~cring_cata...] 0.011 secs (0.01u,0.001s)
Chars 6522 - 6571 [2:~(simpl;~by~rewrite~pos_pean...] 0.006 secs (0.005u,0.001s)
Chars 6574 - 6593 [(rewrite~rng_dist_r).] 0.004 secs (0.003u,0.s)
Chars 6596 - 6619 [(rewrite~rng_mult_one_l).] 0.003 secs (0.002u,0.s)
Chars 6622 - 6642 [(apply~commutativity).] 0.018 secs (0.013u,0.004s)
Chars 6033 - 6042 [revert~y.] 0. secs (0.u,0.s)
Chars 6045 - 6098 [(induction~x~as~[|~x~IHx]~usin...] 0.001 secs (0.u,0.s)
Chars 6103 - 6112 [symmetry.] 0. secs (0.u,0.s)
Chars 6117 - 6137 [(apply~left_identity).] 0. secs (0.u,0.s)
Chars 6142 - 6288 [(change~~~~(cring_catamorphism...] 0. secs (0.u,0.s)
Chars 6291 - 6314 [(rewrite~pos_mul_succ_l).] 0. secs (0.u,0.s)
Chars 6317 - 6412 [refine~~(issemigrouppreserving...] 0. secs (0.u,0.s)
Chars 6415 - 6427 [(rewrite~IHx).] 0. secs (0.u,0.s)
Chars 6430 - 6519 [transitivity~~((1~+~cring_cata...] 0. secs (0.u,0.s)
Chars 6522 - 6571 [2:~(simpl;~by~rewrite~pos_pean...] 0.001 secs (0.001u,0.s)
Chars 6574 - 6593 [(rewrite~rng_dist_r).] 0. secs (0.u,0.s)
Chars 6596 - 6619 [(rewrite~rng_mult_one_l).] 0. secs (0.u,0.s)
Chars 6622 - 6642 [(apply~commutativity).] 0. secs (0.u,0.s)
Chars 6643 - 6647 [Qed.] 0.018 secs (0.012u,0.005s)
Chars 6691 - 6879 [#[global]~Instance~issemigroup...] 0.006 secs (0.003u,0.002s)
Chars 6880 - 6886 [Proof.] 0. secs (0.u,0.s)
Chars 5882 - 5928 [(apply~DNE_to_LEM,~DNE_from_al...] 40.188 secs (0.001u,0.04s)
Chars 5931 - 5957 [(exists~(f~(P~*~A));~split).] 0.003 secs (0.002u,0.s)
Chars 5960 - 5961 [-] 0. secs (0.u,0.s)
Chars 5962 - 5971 [(intros~p).] 0. secs (0.u,0.s)
Chars 5976 - 6023 [(pose~proof~(fst~(equiv_hprop_...] 0.002 secs (0.002u,0.s)
Chars 6028 - 6046 [(apply~(ap~f)~in~q).] 0.001 secs (0.001u,0.s)
Chars 6051 - 6067 [(rewrite~eu~in~q).] 0.001 secs (0.u,0.s)
Chars 6072 - 6088 [(rewrite~q;~auto).] 0.002 secs (0.002u,0.s)
Chars 6091 - 6092 [-] 0. secs (0.u,0.s)
Chars 6093 - 6102 [(intros~q).] 0. secs (0.u,0.s)
Chars 6107 - 6133 [(apply~equiv_to_empty~in~q).] 0. secs (0.u,0.s)
Chars 6138 - 6173 [(apply~path_universe_uncurried...] 0.001 secs (0.001u,0.s)
Chars 6178 - 6197 [(rewrite~<-~eu~in~q).] 0.001 secs (0.001u,0.s)
Chars 6202 - 6225 [(apply~(ap~f)^-1~in~q).] 0.03 secs (0.027u,0.003s)
Chars 6230 - 6271 [exact~(snd~(equiv_hprop_idprod...] 0.002 secs (0.001u,0.s)
Chars 5882 - 5928 [(apply~DNE_to_LEM,~DNE_from_al...] 0. secs (0.u,0.s)
Chars 5931 - 5957 [(exists~(f~(P~*~A));~split).] 0. secs (0.u,0.s)
Chars 5962 - 5971 [(intros~p).] 0. secs (0.u,0.s)
Chars 5976 - 6023 [(pose~proof~(fst~(equiv_hprop_...] 0. secs (0.u,0.s)
Chars 6028 - 6046 [(apply~(ap~f)~in~q).] 0. secs (0.u,0.s)
Chars 6051 - 6067 [(rewrite~eu~in~q).] 0. secs (0.u,0.s)
Chars 6072 - 6088 [(rewrite~q;~auto).] 0. secs (0.u,0.s)
Chars 6093 - 6102 [(intros~q).] 0. secs (0.u,0.s)
Chars 6107 - 6133 [(apply~equiv_to_empty~in~q).] 0. secs (0.u,0.s)
Chars 6138 - 6173 [(apply~path_universe_uncurried...] 0. secs (0.u,0.s)
Chars 6178 - 6197 [(rewrite~<-~eu~in~q).] 0. secs (0.u,0.s)
Chars 6202 - 6225 [(apply~(ap~f)^-1~in~q).] 0. secs (0.u,0.s)
Chars 6230 - 6271 [exact~(snd~(equiv_hprop_idprod...] 0. secs (0.u,0.s)
Chars 6272 - 6280 [Defined.] 0.001 secs (0.u,0.001s)
Chars 6500 - 6617 [Definition~zero_beers~`{Unival...] 0.001 secs (0.u,0.s)
Chars 6618 - 6624 [Proof.] 0. secs (0.u,0.s)
Chars 3881 - 3898 [srapply~Join_ind.] 40.163 secs (0.002u,0.033s)
Chars 3903 - 3920 [1,~2:~reflexivity.] 0.001 secs (0.001u,0.s)
Chars 3925 - 3936 [(intros~a~b).] 0. secs (0.u,0.s)
Chars 3941 - 3966 [(cbn;~apply~dp_paths_FlFr).] 0.003 secs (0.003u,0.s)
Chars 3971 - 3999 [(rewrite~Join_rec_beta_jglue).] 0.009 secs (0.008u,0.s)
Chars 4004 - 4032 [(rewrite~ap_idmap,~concat_p1).] 0.006 secs (0.006u,0.s)
Chars 4037 - 4053 [(apply~concat_Vp).] 0.002 secs (0.002u,0.s)
Chars 3881 - 3898 [srapply~Join_ind.] 0. secs (0.u,0.s)
Chars 3903 - 3920 [1,~2:~reflexivity.] 0. secs (0.u,0.s)
Chars 3925 - 3936 [(intros~a~b).] 0. secs (0.u,0.s)
Chars 3941 - 3966 [(cbn;~apply~dp_paths_FlFr).] 0. secs (0.u,0.s)
Chars 3971 - 3999 [(rewrite~Join_rec_beta_jglue).] 0. secs (0.u,0.s)
Chars 4004 - 4032 [(rewrite~ap_idmap,~concat_p1).] 0. secs (0.u,0.s)
Chars 4037 - 4053 [(apply~concat_Vp).] 0. secs (0.u,0.s)
Chars 4056 - 4064 [Defined.] 0.008 secs (0.007u,0.s)
Chars 4068 - 4206 [#[global]~Instance~isequiv_fun...] 0.001 secs (0.u,0.s)
Chars 4209 - 4215 [Proof.] 0. secs (0.u,0.s)
Chars 6889 - 6893 [(hnf).] 40.159 secs (0.u,0.029s)
Chars 6894 - 6917 [(intros~[x|~|~x]~[y|~|~y]).] 0.007 secs (0.005u,0.001s)
Chars 6920 - 6959 [2,~5,~8:~(symmetry;~apply~rng_...] 0.011 secs (0.009u,0.s)
Chars 6962 - 7031 [3,~4:~(cbn;~symmetry;~rewrite~...] 0.028 secs (0.026u,0.001s)
Chars 7034 - 7035 [{] 0. secs (0.u,0.s)
Chars 7036 - 7200 [(change~~~~(cring_catamorphism...] 0.014 secs (0.013u,0.s)
Chars 7205 - 7311 [by~~rewrite~2!cring_catamorphi...] 0.067 secs (0.054u,0.012s)
Chars 7312 - 7313 [}] 0. secs (0.u,0.s)
Chars 7316 - 7317 [{] 0. secs (0.u,0.s)
Chars 7318 - 7482 [(change~~~~(cring_catamorphism...] 0.017 secs (0.015u,0.002s)
Chars 7487 - 7582 [by~~rewrite~2!cring_catamorphi...] 0.029 secs (0.024u,0.005s)
Chars 7583 - 7584 [}] 0. secs (0.u,0.s)
Chars 7587 - 7588 [{] 0. secs (0.u,0.s)
Chars 7589 - 7753 [(change~~~~(cring_catamorphism...] 0.018 secs (0.015u,0.002s)
Chars 7758 - 7853 [by~~rewrite~2!cring_catamorphi...] 0.029 secs (0.027u,0.001s)
Chars 7854 - 7855 [}] 0. secs (0.u,0.s)
Chars 7858 - 7896 [(apply~cring_catamorphism_fun_...] 0.006 secs (0.005u,0.s)
Chars 6889 - 6893 [(hnf).] 0. secs (0.u,0.s)
Chars 6894 - 6917 [(intros~[x|~|~x]~[y|~|~y]).] 0. secs (0.u,0.s)
Chars 6920 - 6959 [2,~5,~8:~(symmetry;~apply~rng_...] 0.001 secs (0.001u,0.s)
Chars 6962 - 7031 [3,~4:~(cbn;~symmetry;~rewrite~...] 0.003 secs (0.003u,0.s)
Chars 7036 - 7200 [(change~~~~(cring_catamorphism...] 0. secs (0.u,0.s)
Chars 7205 - 7311 [by~~rewrite~2!cring_catamorphi...] 0. secs (0.u,0.s)
Chars 7318 - 7482 [(change~~~~(cring_catamorphism...] 0. secs (0.u,0.s)
Chars 7487 - 7582 [by~~rewrite~2!cring_catamorphi...] 0. secs (0.u,0.s)
Chars 7589 - 7753 [(change~~~~(cring_catamorphism...] 0. secs (0.u,0.s)
Chars 7758 - 7853 [by~~rewrite~2!cring_catamorphi...] 0. secs (0.u,0.s)
Chars 7858 - 7896 [(apply~cring_catamorphism_fun_...] 0. secs (0.u,0.s)
Chars 7897 - 7901 [Qed.] 0.032 secs (0.026u,0.005s)
Chars 7938 - 7990 [Definition~rng_homo_int~(R~:~C...] 0.002 secs (0.001u,0.001s)
Chars 7991 - 7997 [Proof.] 0. secs (0.u,0.s)
Chars 6627 - 6655 [(pose~(f~:=~equiv_inverse~g)).] 40.272 secs (0.u,0.037s)
Chars 6658 - 6670 [(intros~nlem).] 0. secs (0.u,0.s)
Chars 6673 - 6682 [(apply~ge).] 0. secs (0.u,0.s)
Chars 6685 - 6742 [(apply~path_universe_uncurried...] 0.001 secs (0.u,0.s)
Chars 6745 - 6756 [(apply~nlem).] 0. secs (0.u,0.s)
Chars 6759 - 6821 [(apply~(lem_from_aut_type_inha...] 0.002 secs (0.002u,0.s)
Chars 6824 - 6848 [(unfold~f;~apply~eissect).] 0.001 secs (0.001u,0.s)
Chars 6627 - 6655 [(pose~(f~:=~equiv_inverse~g)).] 0. secs (0.u,0.s)
Chars 6658 - 6670 [(intros~nlem).] 0. secs (0.u,0.s)
Chars 6673 - 6682 [(apply~ge).] 0. secs (0.u,0.s)
Chars 6685 - 6742 [(apply~path_universe_uncurried...] 0. secs (0.u,0.s)
Chars 6745 - 6756 [(apply~nlem).] 0. secs (0.u,0.s)
Chars 6759 - 6821 [(apply~(lem_from_aut_type_inha...] 0. secs (0.u,0.s)
Chars 6824 - 6848 [(unfold~f;~apply~eissect).] 0. secs (0.u,0.s)
Chars 6849 - 6857 [Defined.] 0.001 secs (0.u,0.s)
Chars 6859 - 7003 [Definition~lem_beers~`{Univale...] 0.001 secs (0.001u,0.s)
Chars 7004 - 7010 [Proof.] 0. secs (0.u,0.s)
Chars 4220 - 4247 [srapply~isequiv_adjointify.] 40.161 secs (0.u,0.033s)
Chars 4252 - 4286 [1:~(apply~(functor_join~f^-1~g...] 0.001 secs (0.001u,0.s)
Chars 4291 - 4313 [1,~2:~srapply~Join_ind.] 0.011 secs (0.006u,0.001s)
Chars 4318 - 4355 [1,~2:~(intro;~simpl;~apply~ap,...] 0.007 secs (0.007u,0.s)
Chars 4360 - 4397 [2,~3:~(intro;~simpl;~apply~ap,...] 0.006 secs (0.005u,0.s)
Chars 4402 - 4423 [1,~2:~(intros~c~d;~cbn).] 0.007 secs (0.006u,0.001s)
Chars 4428 - 4448 [1,~2:~(apply~sq_dp^-1).] 0.015 secs (0.013u,0.001s)
Chars 4454 - 4500 [1:~(rewrite~(ap_compose~_~(fun...] 0.007 secs (0.006u,0.s)
Chars 4506 - 4550 [2:~(rewrite~(ap_compose~(funct...] 0.007 secs (0.007u,0.s)
Chars 4555 - 4600 [1,~2:~(rewrite~2!Join_rec_beta...] 0.084 secs (0.065u,0.017s)
Chars 4605 - 4629 [1,~2:~(apply~join_natsq_v).] 0.011 secs (0.009u,0.001s)
Chars 4220 - 4247 [srapply~isequiv_adjointify.] 0. secs (0.u,0.s)
Chars 4252 - 4286 [1:~(apply~(functor_join~f^-1~g...] 0. secs (0.u,0.s)
Chars 4291 - 4313 [1,~2:~srapply~Join_ind.] 0.001 secs (0.001u,0.s)
Chars 4318 - 4355 [1,~2:~(intro;~simpl;~apply~ap,...] 0.002 secs (0.002u,0.s)
Chars 4360 - 4397 [2,~3:~(intro;~simpl;~apply~ap,...] 0.003 secs (0.002u,0.001s)
Chars 4402 - 4423 [1,~2:~(intros~c~d;~cbn).] 0.005 secs (0.003u,0.001s)
Chars 4428 - 4448 [1,~2:~(apply~sq_dp^-1).] 0.001 secs (0.u,0.s)
Chars 4454 - 4500 [1:~(rewrite~(ap_compose~_~(fun...] 0.001 secs (0.001u,0.s)
Chars 4506 - 4550 [2:~(rewrite~(ap_compose~(funct...] 0.001 secs (0.001u,0.s)
Chars 4555 - 4600 [1,~2:~(rewrite~2!Join_rec_beta...] 0.002 secs (0.002u,0.s)
Chars 4605 - 4629 [1,~2:~(apply~join_natsq_v).] 0.001 secs (0.001u,0.s)
Chars 4632 - 4640 [Defined.] 0.025 secs (0.02u,0.004s)
Chars 4644 - 4780 [Definition~equiv_functor_join~...] 0.03 secs (0.026u,0.003s)
Chars 4824 - 4914 [#[global]~Instance~ishprop_joi...] 0. secs (0.u,0.s)
Chars 4917 - 4923 [Proof.] 0. secs (0.u,0.s)
Chars 8000 - 8033 [snrapply~Build_CRingHomomorphism.] 40.248 secs (0.001u,0.03s)
Chars 8036 - 8072 [1:~exact~(cring_catamorphism_f...] 0.003 secs (0.002u,0.s)
Chars 8075 - 8097 [(repeat~split;~exact~_).] 0.014 secs (0.011u,0.002s)
Chars 8000 - 8033 [snrapply~Build_CRingHomomorphism.] 0. secs (0.u,0.s)
Chars 8036 - 8072 [1:~exact~(cring_catamorphism_f...] 0. secs (0.u,0.s)
Chars 8075 - 8097 [(repeat~split;~exact~_).] 0. secs (0.u,0.s)
Chars 8098 - 8106 [Defined.] 0.004 secs (0.003u,0.s)
Chars 8161 - 8215 [#[global]Instance~isinitial_cr...] 0.004 secs (0.002u,0.002s)
Chars 8216 - 8222 [Proof.] 0. secs (0.u,0.s)
Chars 4928 - 4956 [(apply~hprop_inhabited_contr).] 12.194 secs (1.817u,-0.478s)
Chars 7013 - 7025 [(intros~nlem).] 38.7 secs (21.805u,-0.356s)
Chars 7013 - 7025 [(intros~nlem).] 40.091 secs (0.u,0.039s)
Chars 7028 - 7064 [(pose~(nlem'~:=~equiv_to_empty...] 0. secs (0.u,0.s)
Chars 7067 - 7106 [(apply~path_universe_uncurried...] 0.001 secs (0.001u,0.s)
Chars 7109 - 7129 [(rewrite~nlem'~in~ge).] 0. secs (0.u,0.s)
Chars 7132 - 7159 [(apply~(zero_beers~g)~in~ge).] 0.001 secs (0.u,0.s)
Chars 7162 - 7178 [exact~(ge~nlem).] 0. secs (0.u,0.s)
Chars 7013 - 7025 [(intros~nlem).] 0. secs (0.u,0.s)
Chars 7028 - 7064 [(pose~(nlem'~:=~equiv_to_empty...] 0. secs (0.u,0.s)
Chars 7067 - 7106 [(apply~path_universe_uncurried...] 0. secs (0.u,0.s)
Chars 7109 - 7129 [(rewrite~nlem'~in~ge).] 0. secs (0.u,0.s)
Chars 7132 - 7159 [(apply~(zero_beers~g)~in~ge).] 0. secs (0.u,0.s)
Chars 7162 - 7178 [exact~(ge~nlem).] 0. secs (0.u,0.s)
Chars 7179 - 7187 [Defined.] 0.001 secs (0.001u,0.s)
Chars 4928 - 4956 [(apply~hprop_inhabited_contr).] 40.065 secs (0.u,0.033s)
Chars 4961 - 4973 [(unfold~Join).] 0. secs (0.u,0.s)
Chars 4978 - 5033 [refine~(Pushout_rec~_~_~_~(fun...] 0.045 secs (0.039u,0.005s)
Chars 5038 - 5039 [-] 0. secs (0.u,0.s)
Chars 5040 - 5067 [(intros~a;~apply~contr_join).] 0.001 secs (0.001u,0.s)
Chars 5076 - 5110 [exact~(contr_inhabited_hprop~A...] 0.001 secs (0.001u,0.s)
Chars 5115 - 5116 [-] 0. secs (0.u,0.s)
Chars 5117 - 5184 [(intros~b;~refine~(istrunc_equ...] 0.022 secs (0.017u,0.004s)
Chars 5191 - 5208 [(apply~contr_join).] 0. secs (0.u,0.s)
Chars 5215 - 5249 [exact~(contr_inhabited_hprop~B...] 0. secs (0.u,0.s)
Chars 4928 - 4956 [(apply~hprop_inhabited_contr).] 0. secs (0.u,0.s)
Chars 4961 - 4973 [(unfold~Join).] 0. secs (0.u,0.s)
Chars 4978 - 5033 [refine~(Pushout_rec~_~_~_~(fun...] 0. secs (0.u,0.s)
Chars 5040 - 5067 [(intros~a;~apply~contr_join).] 0. secs (0.u,0.s)
Chars 5076 - 5110 [exact~(contr_inhabited_hprop~A...] 0. secs (0.u,0.s)
Chars 5117 - 5184 [(intros~b;~refine~(istrunc_equ...] 0. secs (0.u,0.s)
Chars 5191 - 5208 [(apply~contr_join).] 0. secs (0.u,0.s)
Chars 5215 - 5249 [exact~(contr_inhabited_hprop~B...] 0. secs (0.u,0.s)
Chars 5252 - 5260 [Defined.] 0.001 secs (0.001u,0.s)
Chars 5310 - 5404 [Definition~equiv_join_hor~`{Fu...] 0. secs (0.u,0.s)
Chars 5407 - 5413 [Proof.] 0. secs (0.u,0.s)
Chars 8225 - 8242 [(unfold~IsInitial).] 40.198 secs (0.u,0.03s)
Chars 8245 - 8253 [intro~R.] 0. secs (0.u,0.s)
Chars 8256 - 8280 [exists~(rng_homo_int~R).] 0.003 secs (0.003u,0.s)
Chars 8283 - 8294 [(intros~g~x).] 0. secs (0.u,0.s)
Chars 8297 - 8319 [(destruct~x~as~[n|~|~p]).] 0.002 secs (0.002u,0.s)
Chars 8322 - 8323 [+] 0. secs (0.u,0.s)
Chars 8324 - 8356 [(induction~n~using~pos_peano_i...] 0.001 secs (0.u,0.s)
Chars 8361 - 8362 [{] 0. secs (0.u,0.s)
Chars 8363 - 8367 [(cbn).] 0.001 secs (0.001u,0.s)
Chars 8368 - 8404 [(symmetry;~rapply~rng_homo_min...] 0.004 secs (0.003u,0.s)
Chars 8405 - 8406 [}] 0. secs (0.u,0.s)
Chars 8411 - 8417 [(simpl).] 0.001 secs (0.001u,0.s)
Chars 8422 - 8458 [(rewrite~pos_peano_rec_beta_po...] 0.002 secs (0.001u,0.s)
Chars 8463 - 8488 [(rewrite~int_neg_pos_succ).] 0.002 secs (0.002u,0.s)
Chars 8493 - 8509 [(unfold~int_pred).] 0.001 secs (0.u,0.s)
Chars 8514 - 8535 [(rewrite~int_add_comm).] 0.002 secs (0.002u,0.s)
Chars 8540 - 8562 [(rewrite~rng_homo_plus).] 0.003 secs (0.003u,0.s)
Chars 8567 - 8594 [(rewrite~rng_homo_minus_one).] 0.003 secs (0.003u,0.s)
Chars 8599 - 8608 [(apply~ap).] 0.053 secs (0.047u,0.005s)
Chars 8613 - 8623 [exact~IHn.] 0.001 secs (0.u,0.s)
Chars 8626 - 8627 [+] 0. secs (0.u,0.s)
Chars 8628 - 8655 [by~rewrite~2!rng_homo_zero.] 0.003 secs (0.003u,0.s)
Chars 8658 - 8659 [+] 0. secs (0.u,0.s)
Chars 8660 - 8692 [(induction~p~using~pos_peano_i...] 0.001 secs (0.u,0.s)
Chars 8697 - 8698 [{] 0. secs (0.u,0.s)
Chars 8699 - 8703 [(cbn).] 0.001 secs (0.u,0.001s)
Chars 8704 - 8734 [(symmetry;~rapply~rng_homo_one).] 0.004 secs (0.004u,0.s)
Chars 8735 - 8736 [}] 0. secs (0.u,0.s)
Chars 8741 - 8747 [(simpl).] 0.001 secs (0.001u,0.s)
Chars 8752 - 8788 [(rewrite~pos_peano_rec_beta_po...] 0.002 secs (0.002u,0.s)
Chars 8793 - 8818 [(rewrite~int_pos_pos_succ).] 0.002 secs (0.001u,0.s)
Chars 8823 - 8839 [(unfold~int_succ).] 0.001 secs (0.001u,0.s)
Chars 8844 - 8865 [(rewrite~int_add_comm).] 0.002 secs (0.002u,0.s)
Chars 8870 - 8892 [(rewrite~rng_homo_plus).] 0.003 secs (0.002u,0.s)
Chars 8897 - 8918 [(rewrite~rng_homo_one).] 0.003 secs (0.002u,0.s)
Chars 8923 - 8932 [(apply~ap).] 0.001 secs (0.001u,0.s)
Chars 8937 - 8947 [exact~IHp.] 0.001 secs (0.001u,0.s)
Chars 8225 - 8242 [(unfold~IsInitial).] 0. secs (0.u,0.s)
Chars 8245 - 8253 [intro~R.] 0. secs (0.u,0.s)
Chars 8256 - 8280 [exists~(rng_homo_int~R).] 0. secs (0.u,0.s)
Chars 8283 - 8294 [(intros~g~x).] 0. secs (0.u,0.s)
Chars 8297 - 8319 [(destruct~x~as~[n|~|~p]).] 0. secs (0.u,0.s)
Chars 8324 - 8356 [(induction~n~using~pos_peano_i...] 0. secs (0.u,0.s)
Chars 8363 - 8367 [(cbn).] 0. secs (0.u,0.s)
Chars 8368 - 8404 [(symmetry;~rapply~rng_homo_min...] 0. secs (0.u,0.s)
Chars 8411 - 8417 [(simpl).] 0. secs (0.u,0.s)
Chars 8422 - 8458 [(rewrite~pos_peano_rec_beta_po...] 0. secs (0.u,0.s)
Chars 8463 - 8488 [(rewrite~int_neg_pos_succ).] 0. secs (0.u,0.s)
Chars 8493 - 8509 [(unfold~int_pred).] 0. secs (0.u,0.s)
Chars 8514 - 8535 [(rewrite~int_add_comm).] 0. secs (0.u,0.s)
Chars 8540 - 8562 [(rewrite~rng_homo_plus).] 0. secs (0.u,0.s)
Chars 8567 - 8594 [(rewrite~rng_homo_minus_one).] 0. secs (0.u,0.s)
Chars 8599 - 8608 [(apply~ap).] 0. secs (0.u,0.s)
Chars 8613 - 8623 [exact~IHn.] 0. secs (0.u,0.s)
Chars 8628 - 8655 [by~rewrite~2!rng_homo_zero.] 0. secs (0.u,0.s)
Chars 8660 - 8692 [(induction~p~using~pos_peano_i...] 0. secs (0.u,0.s)
Chars 8699 - 8703 [(cbn).] 0. secs (0.u,0.s)
Chars 8704 - 8734 [(symmetry;~rapply~rng_homo_one).] 0. secs (0.u,0.s)
Chars 8741 - 8747 [(simpl).] 0. secs (0.u,0.s)
Chars 8752 - 8788 [(rewrite~pos_peano_rec_beta_po...] 0. secs (0.u,0.s)
Chars 8793 - 8818 [(rewrite~int_pos_pos_succ).] 0. secs (0.u,0.s)
Chars 8823 - 8839 [(unfold~int_succ).] 0. secs (0.u,0.s)
Chars 8844 - 8865 [(rewrite~int_add_comm).] 0. secs (0.u,0.s)
Chars 8870 - 8892 [(rewrite~rng_homo_plus).] 0. secs (0.u,0.s)
Chars 8897 - 8918 [(rewrite~rng_homo_one).] 0. secs (0.u,0.s)
Chars 8923 - 8932 [(apply~ap).] 0. secs (0.u,0.s)
Chars 8937 - 8947 [exact~IHp.] 0. secs (0.u,0.s)
Chars 8948 - 8956 [Defined.] 0.026 secs (0.021u,0.004s)
Chars 5418 - 5440 [(apply~equiv_iff_hprop).] 22.056 secs (11.021u,-0.333s)
Chars 5418 - 5440 [(apply~equiv_iff_hprop).] 40.087 secs (0.016u,0.033s)
Chars 5445 - 5446 [-] 0. secs (0.u,0.s)
Chars 5447 - 5542 [refine~~(Pushout_rec~_~(fun~a~...] 0.004 secs (0.003u,0.s)
Chars 5547 - 5548 [-] 0. secs (0.u,0.s)
Chars 5549 - 5571 [(apply~Trunc_rec,~push).] 0.046 secs (0.04u,0.005s)
Chars 5418 - 5440 [(apply~equiv_iff_hprop).] 0. secs (0.u,0.s)
Chars 5447 - 5542 [refine~~(Pushout_rec~_~(fun~a~...] 0. secs (0.u,0.s)
Chars 5549 - 5571 [(apply~Trunc_rec,~push).] 0. secs (0.u,0.s)
Chars 5574 - 5582 [Defined.] 0.001 secs (0.001u,0.s)
Chars 5618 - 5784 [#[global]~Instance~isconnected...] 0.001 secs (0.u,0.s)
Chars 5787 - 5793 [Proof.] 0. secs (0.u,0.s)
     = 89
     : nat
'expQnat_R' is now a registered translation.
Chars 5798 - 5840 [(apply~isconnected_from_elim;~...] 40.134 secs (0.001u,0.034s)
Chars 5845 - 5866 [(pose~@istrunc_inO_tr).] 0. secs (0.u,0.s)
Chars 5871 - 5972 [(pose~proof~~~(istrunc_extensi...] 0.016 secs (0.01u,0.s)
Chars 5977 - 6004 [(unfold~ExtensionAlong~in~*).] 0.001 secs (0.u,0.s)
Chars 6009 - 6123 [transparent~assert~(~f~:~~(A~-...] 0.003 secs (0.003u,0.s)
Chars 6128 - 6129 [{] 0. secs (0.u,0.s)
Chars 6130 - 6180 [(intros~a;~exists~(fun~_~=>~k~...] 0.005 secs (0.004u,0.s)
Chars 6187 - 6212 [exact~(ap~k~(jglue~a~b)).] 0.002 secs (0.002u,0.s)
Chars 6213 - 6214 [}] 0. secs (0.u,0.s)
Chars 6219 - 6324 [(pose~proof~~~(isconnected_eli...] 0.018 secs (0.016u,0.002s)
Chars 6329 - 6379 [(unfold~NullHomotopy~in~*;~des...] 0.007 secs (0.005u,0.001s)
Chars 6384 - 6398 [exists~(c~tt).] 0.002 secs (0.002u,0.s)
Chars 6403 - 6433 [srefine~(Pushout_ind~_~_~_~_).] 0.003 secs (0.003u,0.s)
Chars 6438 - 6439 [-] 0. secs (0.u,0.s)
Chars 6440 - 6454 [(intros~a;~cbn).] 0.005 secs (0.005u,0.s)
Chars 6455 - 6480 [exact~(ap10~(h~a)~..1~tt).] 0.003 secs (0.003u,0.s)
Chars 6485 - 6486 [-] 0. secs (0.u,0.s)
Chars 6487 - 6501 [(intros~b;~cbn).] 0.005 secs (0.004u,0.s)
Chars 6502 - 6517 [exact~(g~b)^.] 0.002 secs (0.002u,0.s)
Chars 6522 - 6523 [-] 0. secs (0.u,0.s)
Chars 6524 - 6537 [(intros~[a~b]).] 0.007 secs (0.007u,0.s)
Chars 6544 - 6599 [(rewrite~transport_paths_FlFr,...] 0.026 secs (0.019u,0.006s)
Chars 6606 - 6749 [(subst~f;~set~(ha~:=~h~a);~cle...] 0.057 secs (0.048u,0.008s)
Chars 6756 - 6789 [(rewrite~<-~(inv_V~(ap10~ha1~t...] 0.007 secs (0.006u,0.001s)
Chars 6796 - 6814 [(rewrite~<-~inv_pp).] 0.007 secs (0.005u,0.001s)
Chars 6821 - 6836 [(apply~inverse2).] 0.003 secs (0.003u,0.s)
Chars 6843 - 6879 [(refine~(_~@~apD10~ha2~b);~cle...] 0.007 secs (0.007u,0.s)
Chars 6886 - 6942 [(rewrite~transport_forall_cons...] 0.015 secs (0.013u,0.001s)
Chars 6949 - 6977 [(rewrite~ap_const,~concat_p1).] 0.03 secs (0.022u,0.008s)
Chars 6984 - 6996 [reflexivity.] 0.004 secs (0.002u,0.001s)
Chars 5798 - 5840 [(apply~isconnected_from_elim;~...] 0. secs (0.u,0.s)
Chars 5845 - 5866 [(pose~@istrunc_inO_tr).] 0. secs (0.u,0.s)
Chars 5871 - 5972 [(pose~proof~~~(istrunc_extensi...] 0. secs (0.u,0.s)
Chars 5977 - 6004 [(unfold~ExtensionAlong~in~*).] 0. secs (0.u,0.s)
Chars 6009 - 6123 [transparent~assert~(~f~:~~(A~-...] 0. secs (0.u,0.s)
Chars 6130 - 6180 [(intros~a;~exists~(fun~_~=>~k~...] 0.003 secs (0.003u,0.s)
Chars 6187 - 6212 [exact~(ap~k~(jglue~a~b)).] 0.001 secs (0.001u,0.s)
Chars 6219 - 6324 [(pose~proof~~~(isconnected_eli...] 0.001 secs (0.u,0.001s)
Chars 6329 - 6379 [(unfold~NullHomotopy~in~*;~des...] 0.003 secs (0.003u,0.s)
Chars 6384 - 6398 [exists~(c~tt).] 0.002 secs (0.002u,0.s)
Chars 6403 - 6433 [srefine~(Pushout_ind~_~_~_~_).] 0.002 secs (0.001u,0.s)
Chars 6440 - 6454 [(intros~a;~cbn).] 0.004 secs (0.003u,0.s)
Chars 6455 - 6480 [exact~(ap10~(h~a)~..1~tt).] 0.001 secs (0.001u,0.s)
Chars 6487 - 6501 [(intros~b;~cbn).] 0.004 secs (0.003u,0.001s)
Chars 6502 - 6517 [exact~(g~b)^.] 0.001 secs (0.001u,0.s)
Chars 6524 - 6537 [(intros~[a~b]).] 0.003 secs (0.003u,0.s)
Chars 6544 - 6599 [(rewrite~transport_paths_FlFr,...] 0.007 secs (0.007u,0.s)
Chars 6606 - 6749 [(subst~f;~set~(ha~:=~h~a);~cle...] 0.038 secs (0.033u,0.004s)
Chars 6756 - 6789 [(rewrite~<-~(inv_V~(ap10~ha1~t...] 0.002 secs (0.002u,0.s)
Chars 6796 - 6814 [(rewrite~<-~inv_pp).] 0.002 secs (0.001u,0.s)
Chars 6821 - 6836 [(apply~inverse2).] 0.004 secs (0.002u,0.s)
Chars 6843 - 6879 [(refine~(_~@~apD10~ha2~b);~cle...] 0.005 secs (0.005u,0.s)
Chars 6886 - 6942 [(rewrite~transport_forall_cons...] 0.002 secs (0.001u,0.s)
Chars 6949 - 6977 [(rewrite~ap_const,~concat_p1).] 0.003 secs (0.003u,0.s)
Chars 6984 - 6996 [reflexivity.] 0.002 secs (0.002u,0.s)
Chars 6999 - 7007 [Defined.] 0.064 secs (0.049u,0.012s)
Chars 7009 - 7018 [End~Join.] 0.21 secs (0.194u,0.015s)
Chars 7051 - 7067 [Section~Diamond.] 0. secs (0.u,0.s)
Chars 7071 - 7092 [Context~{A~B~:~Type}.] 0. secs (0.u,0.s)
Chars 7096 - 7209 [Definition~Diamond~(a~a'~:~A)~...] 0.001 secs (0.001u,0.s)
Chars 7213 - 7293 [Definition~diamond_h~{a~a'~:~A...] 0. secs (0.u,0.s)
Chars 7296 - 7302 [Proof.] 0. secs (0.u,0.s)
[DEBUG] All good, a was instantiated with b's type (tFalse)
[DEBUG] hola
[DEBUG] hola
Universes written to file "universes-mtac2.txt".
[DEBUG] [ $(egrep "Coq.*Mtac2" universes-mtac2.txt | wc -l  | tr -d ' ') = "0" ]
0
     = Z0
     : Z
[DEBUG] Running test
produces_a_value
     : M nat
the_value_tactic = 1
     : nat
empty_string = ""
     : string
world_string = "world"
     : string
other_string = "other"
     : string
the_sequence_6 = 
6 :: 3 :: 10 :: 5 :: 16 :: 8 :: 4 :: 2 :: 1 :: nil
     : list nat
inlist
     : forall (A : Type) (x : A) (x0 : list A), M (In x x0)
y_in_zyx = 
fun x y z : nat => eval (inlist y (z :: y :: x :: nil))
     : forall x y z : nat, In y (z :: y :: x :: nil)

Arguments y_in_zyx (x y z)%nat_scope
inlist' = 
fun (A : Type) (x : A) =>
mfix1 f s : list A : M In x s :=
    (mmatch s in list A as s' return M (In x s')
     [m: ([?l r : list A] l ++ r =>
                          [H : s =m= l ++ r] mtry'
                                               ('il <- f l; 
                                                ret
                                                 ((fun 
                                                 (A0 : Type) 
                                                 (x0 : A0)
                                                 (_ : 
                                                 forall x1 : list A0,
                                                 M (In x0 x1))
                                                 (s0 l0 r0 : list A0)
                                                 (_ : s0 =m= l0 ++ r0)
                                                 (il0 : In x0 l0) =>
                                                 inlist'_obligation_1 x0 l0
                                                 r0 il0) A x f s l r H il) )
                                               (fun e : Exception =>
                                                mmatch'' NotCaught e
                                                 (raise e)
                                                 (with 
                                                 _ => 
                                                 'ir <- f r; 
                                                 ret
                                                 ((fun 
                                                 (A0 : Type) 
                                                 (x0 : A0)
                                                 (_ : 
                                                 forall x1 : list A0,
                                                 M (In x0 x1))
                                                 (s0 l0 r0 : list A0)
                                                 (_ : s0 =m= l0 ++ r0)
                                                 (_ : Exception)
                                                 (ir0 : In x0 r0) =>
                                                 inlist'_obligation_2 x0 l0
                                                 r0 ir0) A x f s l r H e ir) 
                                                 end)))%branch
       | ([?s' : list A] x :: s' => [_ : s =m= x :: s'] ret (in_eq x s'))%branch
       | ([?(y : A)
          (s' : list A)] y :: s' => [_ : s =m= y :: s'] 
                         'r <- f s'; ret (in_cons y x s' r) )%branch
       | (_ => raise NotFound)%branch])
     : forall (A : Type) (x : A) (x0 : list A), M (In x x0)

Arguments inlist' [A]%type_scope x x%list_scope
inlist'_obligation_1 = 
fun (A : Type) (x : A) (l r : list A) (il : In x l) =>
in_or_app l r x (or_introl il)
     : forall (A : Type) (x : A) (l r : list A), In x l -> In x (l ++ r)

Arguments inlist'_obligation_1 [A]%type_scope x (l r)%list_scope il
inlist'_obligation_2 = 
fun (A : Type) (x : A) (l r : list A) (ir : In x r) =>
in_or_app l r x (or_intror ir)
     : forall (A : Type) (x : A) (l r : list A), In x r -> In x (l ++ r)

Arguments inlist'_obligation_2 [A]%type_scope x (l r)%list_scope ir
ex_inlist = 
fun x y z : nat =>
in_cons y x
  ((fix app (l m : list nat) {struct l} : list nat :=
      match l with
      | nil => m
      | a :: l1 => a :: app l1 m
      end) (z :: nil) (x :: z :: nil))
  (in_cons z x
     ((fix app (l m : list nat) {struct l} : list nat :=
         match l with
         | nil => m
         | a :: l1 => a :: app l1 m
         end) nil (x :: z :: nil)) (in_eq x (z :: nil)))
     : forall x y z : nat, In x ((y :: z :: nil) ++ x :: z :: nil)

Arguments ex_inlist (x y z)%nat_scope
ex_inlist' = 
fun x y z : nat =>
(fun (A : Type) (x0 : A) (_ : forall x1 : list A, M (In x0 x1))
   (s l r : list A) (_ : s =m= l ++ r) (_ : Exception) 
   (ir : In x0 r) => inlist'_obligation_2 x0 l r ir) nat x
  (mfix1 f s : list nat : M In x s :=
       (mmatch s in list nat as s' return M (In x s')
        [m: ([?l r : list nat] l ++ r =>
                               [H : s =m= l ++ r] 
                               mtry'
                                 ('il <- f l; 
                                  ret
                                    ((fun (A : Type) 
                                        (x0 : A)
                                        (_ : forall x1 : list A, M (In x0 x1))
                                        (s0 l0 r0 : list A)
                                        (_ : s0 =m= l0 ++ r0)
                                        (il0 : In x0 l0) =>
                                      inlist'_obligation_1 x0 l0 r0 il0) nat
                                       x f s l r H il) )
                                 (fun e : Exception =>
                                  mmatch'' NotCaught e 
                                    (raise e)
                                    (with _ => 'ir <- f r; 
                                          ret
                                            ((fun 
                                                (A : Type) 
                                                (x0 : A)
                                                (_ : 
                                                 forall x1 : list A,
                                                 M (In x0 x1))
                                                (s0 l0 r0 : list A)
                                                (_ : s0 =m= l0 ++ r0)
                                                (_ : Exception)
                                                (ir0 : In x0 r0) =>
                                              inlist'_obligation_2 x0 l0 r0
                                                ir0) nat x f s l r H e ir) 
                                     end)))%branch
          | ([?s' : list nat] x :: s' => [_ : s =m= x :: s'] ret (in_eq x s'))%branch
          | ([?(y0 : nat)
             (s' : list nat)] y0 :: s' => [_ : s =m= y0 :: s'] 
                              'r <- f s'; ret (in_cons y0 x s' r) )%branch
          | (_ => raise NotFound)%branch]))
  ((y :: z :: nil) ++ x :: z :: nil) (y :: z :: nil) 
  (x :: z :: nil)
  (reduce (RedWhd [rl:RedBeta; RedDelta; RedMatch])
     match
       meq_refl in (_ =m= y0)
       return (y0 =m= (y :: z :: nil) ++ x :: z :: nil)
     with
     | meq_refl => meq_refl
     end) NotFound (in_eq x (z :: nil))
     : forall x y z : nat, In x ((y :: z :: nil) ++ x :: z :: nil)

Arguments ex_inlist' (x y z)%nat_scope
ex_inlist'' = 
fun x y z : nat =>
in_or_app (y :: z :: nil) (x :: z :: nil) x (or_intror (in_eq x (z :: nil)))
     : forall x y z : nat, In x ((y :: z :: nil) ++ x :: z :: nil)

Arguments ex_inlist'' (x y z)%nat_scope
ex1 = conj I (or_intror I)
     : True /\ (False \/ True)
nu@{u u0 u1} : forall {A B : Type}, name -> moption A -> (A -> M B) -> M B

nu is universe polymorphic
Arguments nu {A B}%type_scope _ _ _%function_scope
nu is opaque
Expands to: Constant Mtac2.intf.M.M.nu
ex_with_implication = 
fun (p q : Prop) (x : p) (x0 : q) => conj x x0
     : forall p q : Prop, p -> q -> p /\ q

Arguments ex_with_implication [p q]%type_scope _ _
Chars 7307 - 7318 [(destruct~p).] 40.161 secs (0.u,0.034s)
Chars 7323 - 7337 [(apply~sq_path).] 0.001 secs (0.001u,0.s)
Chars 7342 - 7379 [exact~(concat_pV~_~@~(concat_p...] 0.002 secs (0.002u,0.s)
Chars 7307 - 7318 [(destruct~p).] 0. secs (0.u,0.s)
Chars 7323 - 7337 [(apply~sq_path).] 0. secs (0.u,0.s)
Chars 7342 - 7379 [exact~(concat_pV~_~@~(concat_p...] 0. secs (0.u,0.s)
Chars 7382 - 7390 [Defined.] 0.002 secs (0.u,0.001s)
Chars 7394 - 7474 [Definition~diamond_v~(a~a'~:~A...] 0. secs (0.u,0.s)
Chars 7477 - 7483 [Proof.] 0. secs (0.u,0.s)
Chars 7488 - 7499 [(destruct~p).] 1.419 secs (0.001u,0.032s)
Chars 7504 - 7521 [by~apply~sq_path.] 0.003 secs (0.001u,0.s)
Chars 7488 - 7499 [(destruct~p).] 0. secs (0.u,0.s)
Chars 7504 - 7521 [by~apply~sq_path.] 0. secs (0.u,0.s)
Chars 7524 - 7532 [Defined.] 0.001 secs (0.001u,0.s)
Chars 7536 - 7611 [Lemma~diamond_symm~(a~:~A)~(b~...] 0. secs (0.u,0.s)
Chars 7614 - 7620 [Proof.] 0. secs (0.u,0.s)
Chars 7625 - 7653 [(unfold~diamond_v,~diamond_h).] 40.126 secs (0.u,0.031s)
Chars 7658 - 7688 [(symmetry;~apply~ap,~concat_pV).] 0.008 secs (0.006u,0.002s)
Chars 7625 - 7653 [(unfold~diamond_v,~diamond_h).] 0. secs (0.u,0.s)
Chars 7658 - 7688 [(symmetry;~apply~ap,~concat_pV).] 0.002 secs (0.002u,0.s)
Chars 7691 - 7699 [Defined.] 0.008 secs (0.008u,0.s)
Chars 7701 - 7713 [End~Diamond.] 0.01 secs (0.006u,0.002s)
Chars 7715 - 7857 [Definition~diamond_twist~{A~:~...] 0.001 secs (0.001u,0.s)
Chars 7858 - 7864 [Proof.] 0. secs (0.u,0.s)
Chars 7867 - 7878 [(destruct~p).] 40.191 secs (0.001u,0.033s)
Chars 7881 - 7900 [(apply~diamond_symm).] 0.003 secs (0.002u,0.001s)
Chars 7867 - 7878 [(destruct~p).] 0. secs (0.u,0.s)
Chars 7881 - 7900 [(apply~diamond_symm).] 0. secs (0.u,0.s)
Chars 7901 - 7909 [Defined.] 0.001 secs (0.u,0.s)
     = "YAPIGOLT"
     : string
     = Lt
     : comparison
     = ("swap",
       (["c1"; "c2"], [], bedrock_func_body:(
         $"v1" = load($"c1");
         $"v2" = load($"c2");
         store($"c1", $"v2");
         store($"c2", $"v1"))))
     : bedrock_func
AP_plus_closed
     : forall alpha beta gamma : Ord,
       In AP alpha -> beta < alpha -> gamma < alpha -> beta + gamma < alpha
Finished transaction in 40.607 secs (0.12u,0.124s) (successful)
     = (ω * 2)%pT1
     : ppT1
     = (ω * 5 + 5)%pT1
     : ppT1
     = (ω * 2 + 56)%pT1
     : ppT1
     = zero
     : T1
     = zero
     : T1
     = 1
     : ppT1
T2.T2
     : Set
Inductive T2 : Set :=
    zero : T2.T2 | gcons : T2.T2 -> T2.T2 -> nat -> T2.T2 -> T2.T2.

Arguments gcons _ _ _%nat_scope _
'C[[::]]
     : nat
'C[[:: 8]]
     : nat
Finished transaction in 0. secs (0.u,0.s) (successful)
     = Remaining 1
     : answer
     = Remaining 3
     : answer
     = Ok
     : answer
     = Ok
     : answer
     = Ok
     : answer
     = Ok
     : answer
     = Ok
     : answer
     = Ok
     : answer
     = Ok
     : answer
     = Ok
     : answer
     = Remaining (ω + 1)%pT1
     : answer
     = Remaining ω
     : answer
     = Ok
     : answer
     = Remaining ω
     : answer
     = Ok
     : answer
     = Ok
     : answer
     = Ok
     : answer
     = Ok
     : answer
     = Ok
     : answer
     = Ok
     : answer
     = Ok
     : answer
     = Remaining (ω ^ 2 * 2 + ω * 220 + 798)%pT1
     : answer
     = Remaining (ω ^ 2 * 2 + ω * 220)%pT1
     : answer
     = Remaining (ω ^ 2 * 2 + ω * 219 + 1799)%pT1
     : answer
     = Remaining (ω ^ 2 * 2 + ω * 218 + 2198)%pT1
     : answer
     = Remaining (ω ^ ω * 2 + ω ^ 3 * 4 + ω ^ 2 * 4 + ω * 1148 + 4222)%pT1
     : answer
     = (ω + 1)%pT1
     : ppT1
     = 2
     : ppT1
     = Ok
     : answer
     = 0
     : ppT1
     = Ok
     : answer
     = 0
     : ppT1
     = Ok
     : answer
     = Too_far
     : answer
     = Ok
     : answer
     = Remaining 32
     : answer
     = (ω * 15)%pT1
     : ppT1
     = (ω * 14)%pT1
     : ppT1
     = (ω * 13)%pT1
     : ppT1
     = (ω * 12)%pT1
     : ppT1
     = (ω * 11)%pT1
     : ppT1
     = (ω * 10)%pT1
     : ppT1
     = (ω * 9)%pT1
     : ppT1
     = (ω * 8)%pT1
     : ppT1
     = 1
     : nat
     = 2
     : nat
Finished transaction in 8.271 secs (8.182u,0.034s) (successful)
fun a : hT2 => [eta compare a]
     : hT2 -> hT2 -> comparison
T2lt : T2 -> T2 -> bool

T2lt is not universe polymorphic
Arguments T2lt a b
T2lt is transparent
Expands to: Constant gaia.schutte.ssete9.Gamma0.T2lt
Finished transaction in 101.493 secs (59.696u,1.046s) (successful)
Finished transaction in 0. secs (0.u,0.s) (successful)
Finished transaction in 4.451 secs (4.401u,0.034s) (successful)
Finished failing transaction in 3.396 secs (-63.946u,-1.679s) (failure)
Finished transaction in 45.577 secs (5.023u,0.193s) (successful)
Finished transaction in 0. secs (0.u,0.s) (successful)
Finished transaction in 0.456 secs (0.453u,0.002s) (successful)
Finished transaction in 46.519 secs (6.219u,0.14s) (successful)
Finished transaction in 0. secs (0.u,0.s) (successful)
     = [11; 10; 9; 8; 7; 6; 5; 4; 3; 2; 1; 0]
     : list Z
Finished transaction in 0.002 secs (0.002u,0.s) (successful)
     = [{| Naive.unsigned := 11; Naive._unsigned_in_range := eq_refl |};
       {| Naive.unsigned := 10; Naive._unsigned_in_range := eq_refl |};
       {| Naive.unsigned := 9; Naive._unsigned_in_range := eq_refl |};
       {| Naive.unsigned := 8; Naive._unsigned_in_range := eq_refl |};
       {| Naive.unsigned := 7; Naive._unsigned_in_range := eq_refl |};
       {| Naive.unsigned := 6; Naive._unsigned_in_range := eq_refl |};
       {| Naive.unsigned := 5; Naive._unsigned_in_range := eq_refl |};
       {| Naive.unsigned := 4; Naive._unsigned_in_range := eq_refl |};
       {| Naive.unsigned := 3; Naive._unsigned_in_range := eq_refl |};
       {| Naive.unsigned := 2; Naive._unsigned_in_range := eq_refl |};
       {| Naive.unsigned := 1; Naive._unsigned_in_range := eq_refl |};
       {| Naive.unsigned := 0; Naive._unsigned_in_range := eq_refl |}]
     : list word
Finished transaction in 0.006 secs (0.006u,0.s) (successful)
     = ("sizedlist_memcpy",
       (["len"; "a1"; "a2"], [], bedrock_func_body:(
         $"_gs_from0" = $0;
         $"_gs_to0" = $"len";
         while $"_gs_from0" < $"_gs_to0" {
           {$"v" = load($"a1" + $8 * $"_gs_from0");
            store($"a2" + $8 * $"_gs_from0", $"v");
            $(cmd.unset "v")};
           $"_gs_from0" = $"_gs_from0" + $1
         })))
     : bedrock_func
     = ("unsizedlist_memcpy",
       (["len"; "a1"; "a2"], [], bedrock_func_body:(
         $"_gs_from0" = $0;
         $"_gs_to0" = $"len";
         while $"_gs_from0" < $"_gs_to0" {
           {$"v" = load($"a1" + $8 * $"_gs_from0");
            store($"a2" + $8 * $"_gs_from0", $"v");
            $(cmd.unset "v")};
           $"_gs_from0" = $"_gs_from0" + $1
         })))
     : bedrock_func
     = ("vect_memcpy_s",
       (["len"; "a1"; "a2"], [], bedrock_func_body:(
         $"_gs_from0" = $0;
         $"_gs_to0" = $"len";
         while $"_gs_from0" .< $"_gs_to0" {
           {$"v" = load($"a1" + $8 * $"_gs_from0");
            store($"a2" + $8 * $"_gs_from0", $"v");
            $(cmd.unset "v")};
           $"_gs_from0" = $"_gs_from0" + $1
         })))
     : bedrock_func
sp_merge_sort : sort_fun_t
     : sort_fun_t
stable_merge_sort : sort_fun_t
     : sort_fun_t
Impossibility_std
     : forall (mu : T1) (m : Hydra -> T1) (Var : Hvariant T1_wf standard m),
       BoundedVariant Var mu -> False
Finished transaction in 6.895 secs (6.825u,0.057s) (successful)
clear  H  :  (False -> length l2 < length l1)
clear  H  :  (False -> length l2 < length l2)
clear  H  :  (False -> length l2 < length l1)
clear  H  :  (False -> length l1 < length l1)
clear  H  :  (False -> length l1 < length l2)
clear  H  :  (False -> length l1 < length l1)
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building ident_interp...
Building base_eq_dec...
Building base_beq_and_reflect...
Building base_beq...
Building reflect_base_beq...
Building baseHasNatAndCorrect...
Building baseHasNat...
Building baseHasNatCorrect...
Building base_interp_beq...
Building reflect_base_interp_beq...
Building try_make_base_transport_cps...
Building try_make_base_transport_cps_correct...
Building all_idents...
Building all_ident_and_interp...
Building buildEagerIdentAndInterpCorrect...
Building buildEagerIdent...
Building buildInterpEagerIdentCorrect...
Building toRestrictedIdentAndCorrect...
Building toRestrictedIdent...
Building toFromRestrictedIdent...
Building buildIdentAndInterpCorrect...
Building buildIdent...
Building buildInterpIdentCorrect...
Building ident_is_var_like...
Building eqv_Reflexive_Proper...
Building ident_interp_Proper...
Building invertIdent...
Building buildInvertIdentCorrect...
Building base_default...
Building package...
Building all_base...
Building all_idents...
Building ident_index...
Building eta_ident_cps_gen...
Building eta_ident_cps_gen_expand_literal...
Building eta_ident_cps...
Building simple_idents...
Building all_raw_idents...
Building raw_ident_index...
Building raw_ident_index_idempotent...
Building eta_raw_ident_cps_gen...
Building raw_ident_to_ident...
Building raw_ident_infos_of...
Building split_raw_ident_gen...
OrdersEx.Nat_as_OT.add_0_r: forall n : nat, n + 0 = n
OrdersEx.Nat_as_DT.add_0_r: forall n : nat, n + 0 = n
Nat.add_0_r: forall n : nat, n + 0 = n
NPeano.Nat.add_0_r: forall n : nat, n + 0 = n
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building invert_bind_args...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building ident_interp...
Building invert_bind_args_unknown...
Building all_pattern_idents...
Building base_eq_dec...
Building base_beq_and_reflect...
Building base_beq...
Building reflect_base_beq...
Building baseHasNatAndCorrect...
Building eta_pattern_ident_cps_gen...
Building baseHasNat...
Building baseHasNatCorrect...
Building base_interp_beq...
Building reflect_base_interp_beq...
Building try_make_base_transport_cps...
Building try_make_base_transport_cps_correct...
Building eta_pattern_ident_cps_gen_expand_literal...
Building all_idents...
Building all_ident_and_interp...
Building buildEagerIdentAndInterpCorrect...
Building split_types...
Building add_types_from_raw_sig...
Building buildEagerIdent...
Building buildInterpEagerIdentCorrect...
Building toRestrictedIdentAndCorrect...
Building toRestrictedIdent...
Building toFromRestrictedIdent...
Building buildIdentAndInterpCorrect...
Building buildIdent...
Building buildInterpIdentCorrect...
Building to_type_split_types_subst_default_eq...
Building ident_is_var_like...
Building eqv_Reflexive_Proper...
Building projT1_add_types_from_raw_sig_eq...
Building ident_interp_Proper...
Building invertIdent...
Building buildInvertIdentCorrect...
Building base_default...
Building package...
Building all_base...
Building all_idents...
Building ident_index...
Building eta_ident_cps_gen...
Building arg_types_unfolded...
Building type_of_list_arg_types_beq_unfolded...
Building eta_ident_cps_gen_expand_literal...
Building to_typed_unfolded...
Building eta_ident_cps...
Building simple_idents...
Building of_typed_ident_unfolded...
Building all_raw_idents...
Building raw_ident_index...
Building arg_types_of_typed_ident_unfolded...
Building raw_ident_index_idempotent...
Building eta_raw_ident_cps_gen...
Building raw_ident_to_ident...
Building raw_ident_infos_of...
Building split_raw_ident_gen...
Building unify...
Building unify_unknown...
Building final ident package...
Proving is_simple_correct0...
Building invert_bind_args...
Tactic call ran for 0.589 secs (0.58u,0.007s) (success)
Proving invert_bind_args_raw_to_typed...
Building invert_bind_args_unknown...
Building all_pattern_idents...
Building eta_pattern_ident_cps_gen...
Tactic call ran for 0.394 secs (0.391u,0.001s) (success)
Proving fold_invert_bind_args...
Building eta_pattern_ident_cps_gen_expand_literal...
Tactic call ran for 0.045 secs (0.045u,0.s) (success)
Proving split_ident_to_ident...
Tactic call ran for 0.023 secs (0.023u,0.s) (success)
Proving eq_indep_types_of_eq_types...
Building split_types...
Building add_types_from_raw_sig...
Building to_type_split_types_subst_default_eq...
Tactic call ran for 1.296 secs (1.281u,0.011s) (success)
Proving fold_eta_ident_cps...
Tactic call ran for 0.02 secs (0.019u,0.s) (success)
Proving fold_unify...
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving to_typed_of_typed_ident...
Building projT1_add_types_from_raw_sig_eq...
Building arg_types_unfolded...
Building type_of_list_arg_types_beq_unfolded...
Building to_typed_unfolded...
Building of_typed_ident_unfolded...
Building arg_types_of_typed_ident_unfolded...
Tactic call ran for 2.257 secs (2.243u,0.005s) (success)
Proving eq_invert_bind_args_unknown...
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving eq_unify_unknown...
Tactic call ran for 0. secs (0.u,0.s) (success)
Building unify...
Building unify_unknown...
Building final ident package...
Proving is_simple_correct0...
Tactic call ran for 0.582 secs (0.572u,0.008s) (success)
Proving invert_bind_args_raw_to_typed...
Tactic call ran for 0.426 secs (0.411u,0.015s) (success)
Proving fold_invert_bind_args...
Tactic call ran for 0.033 secs (0.033u,0.s) (success)
Proving split_ident_to_ident...
Tactic call ran for 0.025 secs (0.025u,0.s) (success)
Proving eq_indep_types_of_eq_types...
Reifying...
Compiling decision tree...
Splitting rewrite rules...
Tactic call ran for 1.36 secs (1.331u,0.026s) (success)
Proving fold_eta_ident_cps...
Tactic call ran for 0.001 secs (0.001u,0.s) (success)
Proving fold_unify...
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving to_typed_of_typed_ident...
Assembling rewrite_head...
Reducing rewrite_head...
Tactic call ran for 0.08 secs (0.08u,0.s) (success)
Tactic call ran for 0.026 secs (0.026u,0.s) (success)
Tactic call ran for 0.07 secs (0.07u,0.s) (success)
Assembling rewrite_head_no_dtree...
Reducing rewrite_head_no_dtree...
Proving Rewriter_Wf...
Tactic call ran for 0.029 secs (0.029u,0.s) (success)
Tactic call ran for 0.462 secs (0.456u,0.006s) (success)
Proving Rewriter_Interp...
Tactic call ran for 0.431 secs (0.428u,0.s) (success)
Tactic call ran for 2.71 secs (2.692u,0.013s) (success)
Proving eq_invert_bind_args_unknown...
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving eq_unify_unknown...
Tactic call ran for 0. secs (0.u,0.s) (success)
Tactic call ran for 0.205 secs (0.204u,0.s) (success)
Assembling verified rewriter...
Refining with verified rewriter...
Finished transaction in 23.133 secs (22.688u,0.362s) (successful)
Finished transaction in 1.52 secs (1.5u,0.018s) (successful)
Reifying...
Compiling decision tree...
Splitting rewrite rules...
Assembling rewrite_head...
Reducing rewrite_head...
Tactic call ran for 0.044 secs (0.043u,0.001s) (success)
Tactic call ran for 0.007 secs (0.007u,0.s) (success)
Tactic call ran for 0.048 secs (0.048u,0.s) (success)
Assembling rewrite_head_no_dtree...
Reducing rewrite_head_no_dtree...
Finished transaction in 1.482 secs (1.463u,0.018s) (successful)
Proving Rewriter_Wf...
Tactic call ran for 0.017 secs (0.017u,0.s) (success)
Tactic call ran for 0.147 secs (0.146u,0.001s) (success)
Proving Rewriter_Interp...
Tactic call ran for 0.258 secs (0.257u,0.s) (success)
Tactic call ran for 0.003 secs (0.002u,0.s) (success)
Assembling verified rewriter...
Refining with verified rewriter...
"Ty has been translated as Tyᵗ"
Tyᵗ : El Tyᵗ
     : El Tyᵗ
"sigT has been translated as sigTᵗ"
specialized goal using (eq_refl a )
"existT has been translated as existTᵗ"
Finished transaction in 0.543 secs (0.482u,0.059s) (successful)
(fold_left Ha Hf Hn = fold_left f [] p)
"sigT_ind has been translated as sigT_indᵗ"
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building ident_interp...
Building base_eq_dec...
Building base_beq_and_reflect...
Building base_beq...
Building reflect_base_beq...
Building baseHasNatAndCorrect...
Building baseHasNat...
Building baseHasNatCorrect...
Building base_interp_beq...
Building reflect_base_interp_beq...
Building try_make_base_transport_cps...
Building try_make_base_transport_cps_correct...
Building all_idents...
Building all_ident_and_interp...
Building buildEagerIdentAndInterpCorrect...
Building buildEagerIdent...
Building buildInterpEagerIdentCorrect...
Building toRestrictedIdentAndCorrect...
Building toRestrictedIdent...
Building toFromRestrictedIdent...
Building buildIdentAndInterpCorrect...
Building buildIdent...
Building buildInterpIdentCorrect...
Building ident_is_var_like...
Building eqv_Reflexive_Proper...
Building ident_interp_Proper...
Building invertIdent...
Building buildInvertIdentCorrect...
Building base_default...
Building package...
Building all_base...
Building all_idents...
Building ident_index...
Building eta_ident_cps_gen...
Building eta_ident_cps_gen_expand_literal...
Building eta_ident_cps...
Building simple_idents...
Building all_raw_idents...
Building raw_ident_index...
Building raw_ident_index_idempotent...
Building eta_raw_ident_cps_gen...
Building raw_ident_to_ident...
Building raw_ident_infos_of...
Building split_raw_ident_gen...
Building invert_bind_args...
Building invert_bind_args_unknown...
Building all_pattern_idents...
Building eta_pattern_ident_cps_gen...
Building eta_pattern_ident_cps_gen_expand_literal...
Building split_types...
Building add_types_from_raw_sig...
Building to_type_split_types_subst_default_eq...
Building projT1_add_types_from_raw_sig_eq...
Building arg_types_unfolded...
Building type_of_list_arg_types_beq_unfolded...
Building to_typed_unfolded...
Building of_typed_ident_unfolded...
Building arg_types_of_typed_ident_unfolded...
Building unify...
Building unify_unknown...
Building final ident package...
Proving is_simple_correct0...
Tactic call ran for 0.728 secs (0.718u,0.007s) (success)
Proving invert_bind_args_raw_to_typed...
Tactic call ran for 0.464 secs (0.452u,0.008s) (success)
Proving fold_invert_bind_args...
Tactic call ran for 0.054 secs (0.054u,0.s) (success)
Proving split_ident_to_ident...
Tactic call ran for 0.026 secs (0.026u,0.s) (success)
Proving eq_indep_types_of_eq_types...
Tactic call ran for 1.495 secs (1.472u,0.013s) (success)
Proving fold_eta_ident_cps...
Tactic call ran for 0.001 secs (0.001u,0.s) (success)
Proving fold_unify...
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving to_typed_of_typed_ident...
Tactic call ran for 3.026 secs (2.991u,0.014s) (success)
Proving eq_invert_bind_args_unknown...
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving eq_unify_unknown...
Tactic call ran for 0. secs (0.u,0.s) (success)
Reifying...
"paths has been translated as pathsᵗ"
Compiling decision tree...
Splitting rewrite rules...
Assembling rewrite_head...
Reducing rewrite_head...
Tactic call ran for 0.423 secs (0.415u,0.007s) (success)
Tactic call ran for 1.942 secs (1.913u,0.027s) (success)
Tactic call ran for 0.287 secs (0.273u,0.012s) (success)
Assembling rewrite_head_no_dtree...
Reducing rewrite_head_no_dtree...
Proving Rewriter_Wf...
Tactic call ran for 0.418 secs (0.41u,0.007s) (success)
Tactic call ran for 3.323 secs (3.185u,0.121s) (success)
Proving Rewriter_Interp...
Tactic call ran for 3.329 secs (3.293u,0.017s) (success)
Tactic call ran for 2.532 secs (2.49u,0.033s) (success)
Assembling verified rewriter...
Refining with verified rewriter...
"idpath has been translated as idpathᵗ"
"paths_ind has been translated as paths_indᵗ"
"Funext has been translated as Funextᵗ"
specialized H2 using (eq_refl a )
"FALSE has been translated as FALSEᵗ"
"UIP has been translated as UIPᵗ"
"False has been translated as Falseᵗ"
"equiv has been translated as equivᵗ"
simplified dependent [if true]
e : (x <? n1)  = true
if (x <? n1)
then (fun E0 : (x <? n1) = true => AA (ltN_of_nat x n1 E0))
else
(fun E0 : (x <? n1) = false =>
 BB (ltN_of_nat (x - n1) n2 (ltN_split_lemma1 (ltN_plus_lemma1 e) E0)))
rewrite if_dtt
if (n1 + x <? n1)
then (fun E0 : (n1 + x <? n1) = true => AA (ltN_of_nat (n1 + x) n1 E0))
else
(fun E0 : (n1 + x <? n1) = false =>
 BB (ltN_of_nat (n1 + x - n1) n2 (ltN_split_lemma1 (plus_ltN_lemma1 e) E0)))
rewrite if_dtt
if (x <? n1)
then
(fun E0 : (x <? n1) = true =>
 AA (exist (fun k : nat => (k <? n1) = true) x E0))
else
(fun E0 : (x <? n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true) (x - n1) (ltN_split_lemma1 e E0)))
rewrite if_dtt
if (proj1_sig x <? n)
then
(fun E0 : (proj1_sig x <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x) E0))
else
(fun E0 : (proj1_sig x <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x - n)
      (ltN_split_lemma1 (proj2_sig x) E0)))
rewrite if_dtt
if (proj1_sig x <? n)
then
(fun E0 : (proj1_sig x <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x) E0))
else
(fun E0 : (proj1_sig x <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x - n)
      (ltN_split_lemma1 (proj2_sig x) E0)))
rewrite if_dtt
if (proj1_sig x <? n)
then
(fun E0 : (proj1_sig x <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x) E0))
else
(fun E0 : (proj1_sig x <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x - n)
      (ltN_split_lemma1 (proj2_sig x) E0)))
rewrite if_dtt
if (proj1_sig x <? n)
then
(fun E0 : (proj1_sig x <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x) E0))
else
(fun E0 : (proj1_sig x <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x - n)
      (ltN_split_lemma1 (proj2_sig x) E0)))
rewrite if_dtt
if (proj1_sig x <? n)
then
(fun E0 : (proj1_sig x <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x) E0))
else
(fun E0 : (proj1_sig x <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x - n)
      (ltN_split_lemma1 (proj2_sig x) E0)))
Crunching:
(Σ
   (fun y0 : nat =>
    (if 0 =? 0
     then
      fun x y : nat =>
      match y with
      | 0%nat => match x with
                 | 0%nat => C1
                 | S _ => 0
                 end
      | 1%nat => match x with
                 | 0%nat | _ => 0
                 end
      | S (S _) => 0
      end ^*
     else
      fun x y : nat =>
      match y with
      | 0%nat => match x with
                 | 0%nat | _ => 0
                 end
      | 1%nat => match x with
                 | 0%nat => C1
                 | S _ => 0
                 end
      | S (S _) => 0
      end ^*) x y0 *
    (if 0 =? 0
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) y0 y) 2 = (if (x =? y) && (x <? 1) then C1 else 0))
rewrite if_dtt
if (proj1_sig x <? n)
then
(fun E0 : (proj1_sig x <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x) E0))
else
(fun E0 : (proj1_sig x <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x - n)
      (ltN_split_lemma1 (proj2_sig x) E0)))
Crunching: (list2D_to_matrix [[e]] = ⟨ 0 ∣ × ∣ 0 ⟩)
Crunching: (list2D_to_matrix [[C1]] = I 1)
Crunching: (list2D_to_matrix [[e]; [e0]] = / √ 2 .* ∣ 0 ⟩ .+ / √ 2 .* ∣ 1 ⟩)
Crunching:
(list2D_to_matrix [[e]; [e0]] =
 hadamard × list2D_to_matrix [[/ √ 2]; [/ √ 2]])
Crunching:
(list2D_to_matrix
   [[C1 / √ 2 * / √ 2 + C1 / √ 2 * / √ 2];
   [C1 / √ 2 * / √ 2 + - (C1 / √ 2) * / √ 2]] = ∣ 0 ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = / √ 2 .* ∣ 0 ⟩ .+ / √ 2 .* ∣ 1 ⟩)
Crunching:
(list2D_to_matrix [[e]; [e0]] =
 hadamard × list2D_to_matrix [[/ √ 2]; [/ √ 2]])
Crunching:
(list2D_to_matrix
   [[C1 / √ 2 * / √ 2 + C1 / √ 2 * / √ 2];
   [C1 / √ 2 * / √ 2 + - (C1 / √ 2) * / √ 2]] = ∣ 0 ⟩)
Crunching: (x - (x - z) - z = 0)
Crunching: (x - (x - z) - z = 0)
Crunching: (x - (x - z) - z = 0)
rewrite if_dtt
if (x0 <? n)
then
(fun E0 : (x0 <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) x0 E0))
else
(fun E0 : (x0 <? n) = false =>
 BB (exist (fun k : nat => (k <? 0) = true) (x0 - n) (ltN_split_lemma1 e E0)))
destruct  (Nat.add_0_r n)  in  x
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (exist (fun k : nat => (k <? S n1) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1)
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (exist (fun k : nat => (k <? S n1) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1)
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      (S n1) E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1) n2
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (exist (fun k : nat => (k <? S n1) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1)
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      (S n1) E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1) n2
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      (S n1) E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1) n2
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (exist (fun k : nat => (k <? S n1) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1)
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
Crunching:
((- - 0)%R +
 hadamard x 0%nat *
 (/ √ IZR (Z.succ (Z.succ 0)) .* ∣ 0 ⟩
  .+ - / √ IZR (Z.succ (Z.succ 0)) .* ∣ 1 ⟩) 0%nat y +
 hadamard x 1%nat *
 (/ √ IZR (Z.succ (Z.succ 0)) .* ∣ 0 ⟩
  .+ - / √ IZR (Z.succ (Z.succ 0)) .* ∣ 1 ⟩) 1%nat y = 
 ∣ 1 ⟩ x y)
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      (S n1) E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1) n2
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      (S n1) E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1) n2
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (exist (fun k : nat => (k <? S n1) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1)
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
Crunching:
((hadamard
  × (fun x y : nat =>
     / √ IZR (Z.succ (Z.succ 0)) * ∣ 0 ⟩ x y +
     - / √ IZR (Z.succ (Z.succ 0)) * ∣ 1 ⟩ x y)) 0%nat y = 
 ∣ 1 ⟩ 0%nat y)
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      (S n1) E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1) n2
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
Crunching:
((hadamard × (/ √ 2 .* ∣ 0 ⟩ .+ - / √ 2 .* ∣ 1 ⟩)) x y = ∣ 1 ⟩ x y)
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      (S n1) E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1) n2
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (exist (fun k : nat => (k <? S n1) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1)
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
Crunching:
(list2D_to_matrix [[e]; [e0]] = / √ 2 .* ∣ 0 ⟩ .+ - / √ 2 .* ∣ 1 ⟩)
Crunching:
(list2D_to_matrix [[e]; [e0]] =
 hadamard × list2D_to_matrix [[/ √ 2]; [- / √ 2]])
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      (S n1) E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1) n2
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
Crunching:
(list2D_to_matrix
   [[C1 / √ 2 * / √ 2 + C1 / √ 2 * - / √ 2];
   [C1 / √ 2 * / √ 2 + - (C1 / √ 2) * - / √ 2]] = 
 ∣ 1 ⟩)
rewrite if_dtt
if match n1 with
   | 0 => false
   | S m' => x <=? m'
   end
then
(fun E0 : match n1 with
          | 0 => false
          | S m' => x <=? m'
          end = true => AA (ltN_of_nat x n1 E0))
else
(fun E0 : match n1 with
          | 0 => false
          | S m' => x <=? m'
          end = false => BB (ltN_of_nat (x - n1) n2 (ltN_split_lemma1 e E0)))
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      (S n1) E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1) n2
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (exist (fun k : nat => (k <? S n1) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1)
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
rewrite if_dtt
if (S x <? S n1)
then
(fun E0 : (S x <? S n1) = true =>
 AA (exist (fun k : nat => (k <? S n1) = true) (S x) E0))
else
(fun E0 : (S x <? S n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true) (x - n1) (ltN_split_lemma1 e E0)))
simplified dependent [if true]
p : (S x <? S n1)  = true
if (S x <? S n1)
then
(fun E0 : (x <? n1) = true =>
 AA (exist (fun k : nat => (k <? n1) = true) x E0))
else
(fun E0 : (x <? n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true) (x - n1) (ltN_split_lemma1 e E0)))
simplified dependent [if false]
p : (S x <? S n1)  = true
if (S x <? S n1)
then
(fun E0 : (x <? n1) = true =>
 AA (exist (fun k : nat => (k <? n1) = true) x E0))
else
(fun E0 : (x <? n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true) (x - n1) (ltN_split_lemma1 e E0)))
Crunching:
(R ->
 R ->
 forall ψ : Vector delta1,
 probability_of_outcome H2 ψ =
 (norm (fun x z : nat => Σ (fun y : nat => ((H2 y x) ^* * ψ y z)%C) delta1)
  ^ 2)%R)
Crunching:
(R ->
 R ->
 forall ψ : Vector delta1,
 probability_of_outcome H2 ψ =
 (norm (fun x z : nat => Σ (fun y : nat => ((H2 y x) ^* * ψ y z)%C) delta1)
  ^ 2)%R)
Crunching:
(R ->
 forall ψ : Vector delta1,
 probability_of_outcome H2 ψ =
 (norm (fun x z : nat => Σ (fun y : nat => ((H2) † x y * ψ y z)%C) delta1)
  ^ 2)%R)
Crunching: (0 <= Cmod2 n)
Crunching:
(forall ψ : Vector delta1,
 probability_of_outcome H2 ψ =
 (norm (fun x z : nat => Σ (fun y : nat => ((H2) † x y * ψ y z)%C) delta1)
  ^ 2)%R)
Crunching:
(forall ψ : Vector delta1,
 probability_of_outcome H2 ψ =
 (norm (fun x z : nat => Σ (fun y : nat => ((H2) † x y * ψ y z)%C) delta1)
  ^ 2)%R)
Crunching: (0 <= Cmod2 n)
Crunching: (list2D_to_matrix [[e]; [e0]] = σx × ∣ 0 ⟩)
Crunching: (list2D_to_matrix [[0]; [C1]] = ∣ 1 ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = σx × ∣ 0 ⟩)
Crunching: (list2D_to_matrix [[0]; [C1]] = ∣ 1 ⟩)
Crunching:
(big_sum (fun i : nat => basis_vector H2 i × (basis_vector H2 i) †) N1 a b =
 0)
Crunching:
(I N1 = big_sum (fun i : nat => basis_vector H2 i × (basis_vector H2 i) †) N1)
Crunching:
(big_sum (fun i : nat => basis_vector H2 i × (basis_vector H2 i) †) N1 a b =
 0)
Crunching:
(I N1 = big_sum (fun i : nat => basis_vector H2 i × (basis_vector H2 i) †) N1)
Crunching: (list2D_to_matrix [[e]; [e0]] = σy × ∣ 0 ⟩)
Crunching: (list2D_to_matrix [[0]; [Ci]] = Ci .* ∣ 1 ⟩)
Crunching: (0 <= Cmod2 n)
Crunching: (0 < Cmod2 Hx)
Crunching: ((y < 2)%nat -> (h < 1)%nat -> (σz × ∣ 0 ⟩) y h = ∣ 0 ⟩ y h)
Crunching:
((forall (x : R) (n : nat), cos_approx x n = cos_approx (- x) n) ->
 (N1 <= 0)%nat ->
 (forall m : nat,
  (m < 0)%nat ->
  I N1 = big_sum (fun i : nat => basis_vector 0 i × (basis_vector 0 i) †) N1) ->
 I N1 = big_sum (fun i : nat => basis_vector 0 i × (basis_vector 0 i) †) N1)
Crunching:
(forall j : nat,
 (H1 < 2)%nat -> (j < 1)%nat -> (σz × ∣ 0 ⟩) H1 j = ∣ 0 ⟩ H1 j)
Crunching:
(I (S m) =
 I m
 .+ (fun i j : nat => if (i =? m) && (j =? 0) then C1 else 0)
    × (fun i j : nat => if (i =? m) && (j =? 0) then C1 else 0) †)
Crunching:
(forall j : nat, (m < 2)%nat -> (j < 1)%nat -> (σz × ∣ 0 ⟩) m j = ∣ 0 ⟩ m j)
Crunching: ((w2 < 2)%nat -> (H < 1)%nat -> (σz × ∣ 0 ⟩) w2 H = ∣ 0 ⟩ w2 H)
Crunching: ((y < 2)%nat -> (h < 1)%nat -> (σz × ∣ 0 ⟩) y h = ∣ 0 ⟩ y h)
Crunching: (forall c : C, Cmod2 c = (Cmod c ^ 2)%R)
Crunching: (forall c : C, Cmod2 c = (Cmod c ^ 2)%R)
Crunching: (forall c : C, Cmod2 c = (Cmod c ^ 2)%R)
Crunching: (forall c : C, Cmod2 c = (Cmod c ^ 2)%R)
Crunching: (prob_partial_meas ψ ϕ = (norm ((ψ ⊗ I (2 ^ d)) † × ϕ) ^ 2)%R)
Crunching: ((σz × ∣ 0 ⟩) H15 r = ∣ 0 ⟩ H15 r)
Crunching: (forall c : C, Cmod2 c = (Cmod c ^ 2)%R)
Crunching:
(prob_partial_meas n_lb ψ = (norm ((n_lb ⊗ I (2 ^ n)) † × ψ) ^ 2)%R)
Crunching:
(prob_partial_meas n_lb ψ = (norm ((n_lb ⊗ I (2 ^ n)) † × ψ) ^ 2 * 1)%R)
Crunching:
(prob_partial_meas n_lb ψ = (norm ((n_lb ⊗ I (2 ^ n)) † × ψ) ^ 2)%R)
Crunching: ((sin PI2)² <= 1²)
Crunching: (1² <= (sin PI2)²)
Crunching: ((sin PI2)² <= 1²)
Crunching: (1² <= (sin PI2)²)
Crunching: ((sin PI2)² <= 1²)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift θ × ∣ b ⟩)
Crunching:
(list2D_to_matrix
   [[(if (b =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 0%nat 0%nat];
   [Cexp θ *
    (if (b =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat]] = Cexp (b * θ) .* ∣ b ⟩)
Crunching:
(0 =
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat 1%nat)
Crunching:
(0 =
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat (S (S y)))
Crunching:
(0 =
 Cexp θ *
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat 1%nat)
Crunching:
(0 =
 Cexp θ *
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat (S (S y)))
Crunching:
((phase_shift n × ∣ i ⟩) 0%nat 0%nat = (Cexp (i * n) .* ∣ i ⟩) 0%nat 0%nat)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift n × ∣ i ⟩)
Crunching:
(list2D_to_matrix
   [[(if (i =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 0%nat 0%nat];
   [Cexp n *
    (if (i =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat]] = Cexp (i * n) .* ∣ i ⟩)
Crunching:
(0 =
 (if (i =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat 1%nat)
Crunching:
(0 =
 (if (i =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat (S (S y)))
Crunching:
(0 =
 Cexp n *
 (if (i =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat 1%nat)
Crunching:
(0 =
 Cexp n *
 (if (i =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat (S (S y)))
Crunching:
(list2D_to_matrix [[e]; [e0]] =
 (fun x y : nat =>
  match x with
  | 0%nat => match y with
             | 0%nat => C1
             | S _ => 0
             end
  | 1%nat => match y with
             | 1%nat => Cexp θ
             | _ => 0
             end
  | S (S _) => 0
  end) × ∣ b ⟩)
Crunching:
(list2D_to_matrix
   [[(if (b =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 0%nat 0%nat];
   [Cexp θ *
    (if (b =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat]] = (fun x y : nat => Cexp (b * θ) * ∣ b ⟩ x y))
Crunching:
(0 =
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat 1%nat)
Crunching:
(0 =
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat (S (S y)))
Crunching:
(0 =
 Cexp θ *
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat 1%nat)
Crunching:
(0 =
 Cexp θ *
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat (S (S y)))
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift θ × ∣ b ⟩)
Crunching:
(list2D_to_matrix
   [[(if (b =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 0%nat 0%nat];
   [Cexp θ *
    (if (b =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat]] = Cexp (b * θ) .* ∣ b ⟩)
Crunching:
(0 =
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat 1%nat)
Crunching:
(0 =
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat (S (S y)))
Crunching:
(0 =
 Cexp θ *
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat 1%nat)
Crunching:
(0 =
 Cexp θ *
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat (S (S y)))
Crunching:
((phase_shift n × ∣ i ⟩) 0%nat 0%nat = (Cexp (i * n) .* ∣ i ⟩) 0%nat 0%nat)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift n × ∣ i ⟩)
Crunching:
(list2D_to_matrix
   [[(if (i =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 0%nat 0%nat];
   [Cexp n *
    (if (i =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat]] = Cexp (i * n) .* ∣ i ⟩)
Crunching:
(0 =
 (if (i =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat 1%nat)
Crunching:
(0 =
 (if (i =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat (S (S y)))
Crunching:
(0 =
 Cexp n *
 (if (i =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat 1%nat)
Crunching:
(0 =
 Cexp n *
 (if (i =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat (S (S y)))
Tactic call ran for 0.008 secs (0.008u,0.s) (success)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching:
(list2D_to_matrix [[e]; [e0]] =
 (fun x y : nat =>
  match x with
  | 0%nat => match y with
             | 0%nat => C1
             | S _ => 0
             end
  | 1%nat => match y with
             | 1%nat => Cexp θ
             | _ => 0
             end
  | S (S _) => 0
  end) × ∣ b ⟩)
Crunching:
(list2D_to_matrix
   [[(if (b =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 0%nat 0%nat];
   [Cexp θ *
    (if (b =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat]] = (fun x y : nat => Cexp (b * θ) * ∣ b ⟩ x y))
Crunching:
(0 =
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat 1%nat)
Crunching:
(0 =
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat (S (S y)))
Crunching:
(0 =
 Cexp θ *
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat 1%nat)
Crunching:
(0 =
 Cexp θ *
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat (S (S y)))
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift θ × ∣ b ⟩)
Crunching:
(list2D_to_matrix
   [[(if (b =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 0%nat 0%nat];
   [Cexp θ *
    (if (b =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat]] = Cexp (b * θ) .* ∣ b ⟩)
Crunching:
(0 =
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat 1%nat)
Crunching:
(0 =
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat (S (S y)))
Crunching:
(0 =
 Cexp θ *
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat 1%nat)
Crunching:
(0 =
 Cexp θ *
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat (S (S y)))
Crunching:
(Pure_State_Vector EQ ->
 prob_partial_meas H2 (H3 ⊗ EQ) = (Cmod ⟨ H2, H3 ⟩ * (Cmod ⟨ H2, H3 ⟩ * 1))%R)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift θ × ∣ b ⟩)
Crunching:
(Cexp (b * θ) .* ∣ b ⟩ =
 list2D_to_matrix
   [[(if (b =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 0%nat 0%nat];
   [Cexp θ *
    (if (b =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat]])
Crunching:
(0 =
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat 1%nat)
Crunching:
(0 =
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat (S (S y)))
Crunching:
(0 =
 Cexp θ *
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat 1%nat)
Crunching:
(0 =
 Cexp θ *
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat (S (S y)))
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching:
((phase_shift n × ∣ i ⟩) 0%nat 0%nat = (Cexp (i * n) .* ∣ i ⟩) 0%nat 0%nat)
Crunching: ((phase_shift n × ∣ i ⟩) 0%nat = (Cexp (i * n) .* ∣ i ⟩) 0%nat)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift n × ∣ i ⟩)
Crunching:
(list2D_to_matrix
   [[(if (i =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 0%nat 0%nat];
   [Cexp n *
    (if (i =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat]] = Cexp (i * n) .* ∣ i ⟩)
Crunching:
(0 =
 (if (i =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat 1%nat)
Crunching:
(0 =
 (if (i =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat (S (S y)))
Crunching:
(0 =
 Cexp n *
 (if (i =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat 1%nat)
Crunching:
(0 =
 Cexp n *
 (if (i =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat (S (S y)))
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift Hq × ∣ b ⟩)
Crunching:
(list2D_to_matrix
   [[(if (b =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 0%nat 0%nat];
   [Cexp Hq *
    (if (b =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat]] = Cexp (b * Hq) .* ∣ b ⟩)
Crunching:
(0 =
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat 1%nat)
Crunching:
(0 =
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat (S (S y)))
Crunching:
(0 =
 Cexp Hq *
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat 1%nat)
Crunching:
(0 =
 Cexp Hq *
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat (S (S y)))
Crunching:
((phase_shift Hq × ∣ a ⟩) 0%nat 0%nat = (Cexp (a * Hq) .* ∣ a ⟩) 0%nat 0%nat)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching:
(list2D_to_matrix [[e]; [e0]] =
 (fun x y : nat =>
  match x with
  | 0%nat => match y with
             | 0%nat => C1
             | S _ => 0
             end
  | 1%nat => match y with
             | 1%nat => Cexp θ
             | _ => 0
             end
  | S (S _) => 0
  end) × ∣ b ⟩)
Crunching:
(list2D_to_matrix
   [[(if (b =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 0%nat 0%nat];
   [Cexp θ *
    (if (b =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat]] = (fun x y : nat => Cexp (b * θ) * ∣ b ⟩ x y))
Crunching:
(0 =
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat 1%nat)
Crunching:
(0 =
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat (S (S y)))
Crunching:
(0 =
 Cexp θ *
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat 1%nat)
Crunching:
(0 =
 Cexp θ *
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat (S (S y)))
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift θ × ∣ b ⟩)
Crunching:
(list2D_to_matrix
   [[(if (b =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 0%nat 0%nat];
   [Cexp θ *
    (if (b =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat]] = Cexp (b * θ) .* ∣ b ⟩)
Crunching:
(0 =
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat 1%nat)
Crunching:
(0 =
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat (S (S y)))
Crunching:
(0 =
 Cexp θ *
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat 1%nat)
Crunching:
(0 =
 Cexp θ *
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat (S (S y)))
Crunching:
(Pure_State_Vector EQ ->
 prob_partial_meas H2 (H3 ⊗ EQ) = (Cmod ⟨ H2, H3 ⟩ * (Cmod ⟨ H2, H3 ⟩ * 1))%R)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching:
(list2D_to_matrix [[e]; [e0]] =
 (fun x y : nat =>
  match x with
  | 0%nat => match y with
             | 0%nat => C1
             | S _ => 0
             end
  | 1%nat => match y with
             | 1%nat => Cexp θ
             | _ => 0
             end
  | S (S _) => 0
  end) × ∣ b ⟩)
Crunching:
((fun x y : nat => Cexp (b * θ) * ∣ b ⟩ x y) =
 list2D_to_matrix
   [[(if (b =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 0%nat 0%nat];
   [Cexp θ *
    (if (b =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat]])
Crunching:
(0 =
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat 1%nat)
Crunching:
(0 =
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat (S (S y)))
Crunching:
(0 =
 Cexp θ *
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat 1%nat)
Crunching:
(0 =
 Cexp θ *
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat (S (S y)))
Crunching: (sum_over_list (P :: l) = (P + sum_over_list l)%R)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift θ × ∣ b ⟩)
Crunching:
(Cexp (b * θ) .* ∣ b ⟩ =
 list2D_to_matrix
   [[(if (b =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 0%nat 0%nat];
   [Cexp θ *
    (if (b =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat]])
Crunching:
(0 =
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat 1%nat)
Crunching:
(0 =
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat (S (S y)))
Crunching:
(0 =
 Cexp θ *
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat 1%nat)
Crunching:
(0 =
 Cexp θ *
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat (S (S y)))
Crunching:
((phase_shift n × ∣ i ⟩) 0%nat 0%nat = (Cexp (i * n) .* ∣ i ⟩) 0%nat 0%nat)
Crunching: ((phase_shift n × ∣ i ⟩) 0%nat = (Cexp (i * n) .* ∣ i ⟩) 0%nat)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift n × ∣ i ⟩)
Crunching:
(list2D_to_matrix
   [[(if (i =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 0%nat 0%nat];
   [Cexp n *
    (if (i =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat]] = Cexp (i * n) .* ∣ i ⟩)
Crunching:
(0 =
 (if (i =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat 1%nat)
Crunching:
(0 =
 (if (i =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat (S (S y)))
Crunching:
(0 =
 Cexp n *
 (if (i =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat 1%nat)
Crunching:
(0 =
 Cexp n *
 (if (i =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat (S (S y)))
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift Hq × ∣ b ⟩)
Crunching:
(list2D_to_matrix
   [[(if (b =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 0%nat 0%nat];
   [Cexp Hq *
    (if (b =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat]] = Cexp (b * Hq) .* ∣ b ⟩)
Crunching:
(0 =
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat 1%nat)
Crunching:
(0 =
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat (S (S y)))
Crunching:
(0 =
 Cexp Hq *
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat 1%nat)
Crunching:
(0 =
 Cexp Hq *
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat (S (S y)))
Crunching:
((phase_shift Hq × ∣ a ⟩) 0%nat 0%nat = (Cexp (a * Hq) .* ∣ a ⟩) 0%nat 0%nat)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift θ × ∣ true ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift θ × ∣ false ⟩)
Crunching: (list2D_to_matrix [[0]; [Cexp θ]] = Cexp (true * θ) .* ∣ true ⟩)
Crunching: (list2D_to_matrix [[C1]; [0]] = Cexp (false * θ) .* ∣ false ⟩)
Crunching:
(forall b : bool, hadamard × ∣ b ⟩ = / √ 2 .* (∣0⟩ .+ (-1) ^ b .* ∣1⟩))
Crunching: (list2D_to_matrix [[e]; [e0]] = hadamard × ∣ H ⟩)
Crunching:
(list2D_to_matrix
   [[C1 / √ 2 *
     (if (H =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 0%nat 0%nat +
     C1 / √ 2 *
     (if (H =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 1%nat 0%nat];
   [C1 / √ 2 *
    (if (H =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 0%nat 0%nat +
    - (C1 / √ 2) *
    (if (H =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat]] = / √ 2 .* (∣0⟩ .+ (-1) ^ H .* ∣1⟩))
Crunching:
((hadamard × ∣ H ⟩) 0%nat 0%nat =
 (/ √ 2 .* (∣0⟩ .+ (-1) ^ H .* ∣1⟩)) 0%nat 0%nat)
Crunching:
((/ √ 2 .* (∣0⟩ .+ (-1) ^ H .* ∣1⟩)) 0%nat 0%nat =
 (hadamard × ∣ H ⟩) 0%nat 0%nat)
Crunching: (list2D_to_matrix [[e]; [e0]] = hadamard × ∣ a' ⟩)
Crunching:
(list2D_to_matrix
   [[C1 / √ 2 *
     (if (a' =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 0%nat 0%nat +
     C1 / √ 2 *
     (if (a' =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 1%nat 0%nat];
   [C1 / √ 2 *
    (if (a' =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 0%nat 0%nat +
    - (C1 / √ 2) *
    (if (a' =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat]] = / √ 2 .* (∣0⟩ .+ (-1) ^ a' .* ∣1⟩))
Crunching: (list2D_to_matrix [[e]; [e0]] = hadamard × ∣ a' ⟩)
Crunching:
(/ √ 2 .* (∣0⟩ .+ (-1) ^ a' .* ∣1⟩) =
 list2D_to_matrix
   [[C1 / √ 2 *
     (if (a' =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 0%nat 0%nat +
     C1 / √ 2 *
     (if (a' =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 1%nat 0%nat];
   [C1 / √ 2 *
    (if (a' =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 0%nat 0%nat +
    - (C1 / √ 2) *
    (if (a' =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat]])
Crunching:
(forall b : bool, hadamard × ∣ b ⟩ = / √ 2 .* (∣0⟩ .+ (-1) ^ b .* ∣1⟩))
Crunching: (list2D_to_matrix [[e]; [e0]] = hadamard × ∣ H ⟩)
Crunching:
(list2D_to_matrix
   [[C1 / √ 2 *
     (if (H =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 0%nat 0%nat +
     C1 / √ 2 *
     (if (H =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 1%nat 0%nat];
   [C1 / √ 2 *
    (if (H =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 0%nat 0%nat +
    - (C1 / √ 2) *
    (if (H =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat]] = / √ 2 .* (∣0⟩ .+ (-1) ^ H .* ∣1⟩))
Crunching:
((hadamard × ∣ H ⟩) 0%nat 0%nat =
 (/ √ 2 .* (∣0⟩ .+ (-1) ^ H .* ∣1⟩)) 0%nat 0%nat)
Crunching:
((hadamard × ∣ false ⟩) 0%nat 0%nat =
 (/ √ 2 .* (∣0⟩ .+ (-1) ^ false .* ∣1⟩)) 0%nat 0%nat)
Crunching: False
Crunching: (list2D_to_matrix [[e]; [e0]] = hadamard × ∣ b ⟩)
Crunching:
(list2D_to_matrix
   [[C1 / √ 2 *
     (if (b =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 0%nat 0%nat +
     C1 / √ 2 *
     (if (b =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 1%nat 0%nat];
   [C1 / √ 2 *
    (if (b =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 0%nat 0%nat +
    - (C1 / √ 2) *
    (if (b =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat]] = / √ 2 .* (∣0⟩ .+ (-1) ^ b .* ∣1⟩))
Crunching: (list2D_to_matrix [[e]; [e0]] = hadamard × ∣ a' ⟩)
Crunching:
(list2D_to_matrix
   [[C1 / √ 2 *
     (if (a' =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 0%nat 0%nat +
     C1 / √ 2 *
     (if (a' =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 1%nat 0%nat];
   [C1 / √ 2 *
    (if (a' =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 0%nat 0%nat +
    - (C1 / √ 2) *
    (if (a' =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat]] = / √ 2 .* (∣0⟩ .+ (-1) ^ a' .* ∣1⟩))
clear  H0  :  (False -> cB (map (rec a1)) a1 = Lt)
Crunching:
((hadamard × ∣ a' ⟩) 0%nat 0%nat =
 (/ √ 2 .* (∣0⟩ .+ (-1) ^ a' .* ∣1⟩)) 0%nat 0%nat)
Crunching: (list2D_to_matrix [[e]; [e0]] = hadamard × ∣ a' ⟩)
Crunching:
(/ √ 2 .* (∣0⟩ .+ (-1) ^ a' .* ∣1⟩) =
 list2D_to_matrix
   [[C1 / √ 2 *
     (if (a' =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 0%nat 0%nat +
     C1 / √ 2 *
     (if (a' =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 1%nat 0%nat];
   [C1 / √ 2 *
    (if (a' =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 0%nat 0%nat +
    - (C1 / √ 2) *
    (if (a' =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat]])
Crunching:
((/ √ 2 .* (∣0⟩ .+ (-1) ^ a' .* ∣1⟩)) 0%nat 0%nat =
 (hadamard × ∣ a' ⟩) 0%nat 0%nat)
Crunching: (list2D_to_matrix [[e]; [e0]] = hadamard × ∣ a' ⟩)
Crunching:
(big_sum (fun i : nat => nth i (a ++ b) 0) (length (a ++ b)) =
 (big_sum (fun i : nat => nth i a 0) (length a) +
  big_sum (fun i : nat => nth i b 0) (length b))%R)
Crunching:
(list2D_to_matrix
   [[C1 / √ 2 *
     (if (a' =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 0%nat 0%nat +
     C1 / √ 2 *
     (if (a' =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 1%nat 0%nat];
   [C1 / √ 2 *
    (if (a' =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 0%nat 0%nat +
    - (C1 / √ 2) *
    (if (a' =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat]] = / √ 2 .* (∣0⟩ .+ (-1) ^ a' .* ∣1⟩))
Crunching:
((hadamard × ∣ a' ⟩) 0%nat 0%nat =
 (/ √ 2 .* (∣0⟩ .+ (-1) ^ a' .* ∣1⟩)) 0%nat 0%nat)
Crunching: (list2D_to_matrix [[e]; [e0]] = hadamard × ∣ a' ⟩)
Crunching: (forall x y : nat, x < n -> y < n -> f x = f y -> x = y)
Crunching:
(/ √ 2 .* (∣0⟩ .+ (-1) ^ a' .* ∣1⟩) =
 list2D_to_matrix
   [[C1 / √ 2 *
     (if (a' =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 0%nat 0%nat +
     C1 / √ 2 *
     (if (a' =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 1%nat 0%nat];
   [C1 / √ 2 *
    (if (a' =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 0%nat 0%nat +
    - (C1 / √ 2) *
    (if (a' =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat]])
Crunching: (sum_over_list (b ++ c) = (sum_over_list b + sum_over_list c)%R)
Crunching: (list2D_to_matrix [[e]; [e0]] = hadamard × ∣ a' ⟩)
Crunching:
(list2D_to_matrix
   [[C1 / √ 2 *
     (if (a' =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 0%nat 0%nat +
     C1 / √ 2 *
     (if (a' =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 1%nat 0%nat];
   [C1 / √ 2 *
    (if (a' =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 0%nat 0%nat +
    - (C1 / √ 2) *
    (if (a' =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat]] = / √ 2 .* (∣0⟩ .+ (-1) ^ a' .* ∣1⟩))
Crunching: (list2D_to_matrix [[e]; [e0]] = hadamard × ∣ a' ⟩)
Crunching:
(/ √ 2 .* (∣0⟩ .+ (-1) ^ a' .* ∣1⟩) =
 list2D_to_matrix
   [[C1 / √ 2 *
     (if (a' =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 0%nat 0%nat +
     C1 / √ 2 *
     (if (a' =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 1%nat 0%nat];
   [C1 / √ 2 *
    (if (a' =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 0%nat 0%nat +
    - (C1 / √ 2) *
    (if (a' =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat]])
Crunching: (list2D_to_matrix [[e]; [e0]] = hadamard × ∣ a' ⟩)
Crunching:
(list2D_to_matrix
   [[C1 / √ 2 *
     (if (a' =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 0%nat 0%nat +
     C1 / √ 2 *
     (if (a' =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 1%nat 0%nat];
   [C1 / √ 2 *
    (if (a' =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 0%nat 0%nat +
    - (C1 / √ 2) *
    (if (a' =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat]] =
 / √ IZR (Z.succ (Z.succ 0)) .* (∣0⟩ .+ (-1) ^ a' .* ∣1⟩))
Crunching: (list2D_to_matrix [[e]; [e0]] = hadamard × ∣ a' ⟩)
Crunching:
(/ √ IZR (Z.succ (Z.succ 0)) .* (∣0⟩ .+ (-1) ^ a' .* ∣1⟩) =
 list2D_to_matrix
   [[C1 / √ 2 *
     (if (a' =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 0%nat 0%nat +
     C1 / √ 2 *
     (if (a' =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 1%nat 0%nat];
   [C1 / √ 2 *
    (if (a' =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 0%nat 0%nat +
    - (C1 / √ 2) *
    (if (a' =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat]])
Crunching: (list2D_to_matrix [[e]; [e0]] = hadamard × ∣ a' ⟩)
Crunching:
(list2D_to_matrix
   [[C1 / √ 2 *
     (if (a' =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 0%nat 0%nat +
     C1 / √ 2 *
     (if (a' =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 1%nat 0%nat];
   [C1 / √ 2 *
    (if (a' =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 0%nat 0%nat +
    - (C1 / √ 2) *
    (if (a' =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat]] =
 / √ IZR (Z.succ (Z.succ 0)) .* (∣0⟩ .+ (-1) ^ a' .* ∣1⟩))
Crunching: (list2D_to_matrix [[e]; [e0]] = hadamard × ∣ a' ⟩)
Crunching:
(forall f : nat -> nat,
 permutation Hq f -> forall x y : nat, x < Hq -> y < Hq -> f x = f y -> x = y)
Crunching:
(list2D_to_matrix
   [[C1 / √ 2 *
     (if (a' =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 0%nat 0%nat +
     C1 / √ 2 *
     (if (a' =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 1%nat 0%nat];
   [C1 / √ 2 *
    (if (a' =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 0%nat 0%nat +
    - (C1 / √ 2) *
    (if (a' =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat]] = / √ 2 .* (∣0⟩ .+ (-1) ^ a' .* ∣1⟩))
Crunching: (list2D_to_matrix [[e]; [e0]] = hadamard × ∣ H2 ⟩)
Crunching:
(list2D_to_matrix
   [[C1 / √ 2 *
     (if (H2 =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 0%nat 0%nat +
     C1 / √ 2 *
     (if (H2 =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 1%nat 0%nat];
   [C1 / √ 2 *
    (if (H2 =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 0%nat 0%nat +
    - (C1 / √ 2) *
    (if (H2 =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat]] =
 (fun x y : nat => / √ 2 * (∣ 0 ⟩ x y + (-1) ^ H2 * ∣ 1 ⟩ x y)))
Crunching:
(forall b : bool, hadamard × ∣ b ⟩ = / √ 2 .* (∣0⟩ .+ (-1) ^ b .* ∣1⟩))
Crunching: (list2D_to_matrix [[e]; [e0]] = hadamard × ∣ H ⟩)
Crunching:
(list2D_to_matrix
   [[C1 / √ 2 *
     (if (H =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 0%nat 0%nat +
     C1 / √ 2 *
     (if (H =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 1%nat 0%nat];
   [C1 / √ 2 *
    (if (H =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 0%nat 0%nat +
    - (C1 / √ 2) *
    (if (H =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat]] = / √ 2 .* (∣0⟩ .+ (-1) ^ H .* ∣1⟩))
Crunching:
((hadamard × ∣ H ⟩) 0%nat 0%nat =
 (/ √ 2 .* (∣0⟩ .+ (-1) ^ H .* ∣1⟩)) 0%nat 0%nat)
Crunching:
((hadamard × ∣ false ⟩) 0%nat 0%nat =
 (/ √ 2 .* (∣0⟩ .+ (-1) ^ false .* ∣1⟩)) 0%nat 0%nat)
Crunching:
((hadamard × ∣ H ⟩) 1%nat 0%nat =
 (/ √ 2 .* (∣0⟩ .+ (-1) ^ H .* ∣1⟩)) 1%nat 0%nat)
Crunching:
((hadamard × ∣ true ⟩) 1%nat 0%nat =
 (/ √ 2 .* (∣0⟩ .+ (-1) ^ true .* ∣1⟩)) 1%nat 0%nat)
Crunching:
((hadamard × ∣ false ⟩) 1%nat 0%nat =
 (/ √ 2 .* (∣0⟩ .+ (-1) ^ false .* ∣1⟩)) 1%nat 0%nat)
Crunching: (list2D_to_matrix [[e]; [e0]] = hadamard × ∣ true ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = hadamard × ∣ false ⟩)
Crunching:
(list2D_to_matrix [[C1 / √ 2]; [- (C1 / √ 2)]] =
 / √ 2 .* (∣ 0 ⟩ .+ (-1) ^ true .* ∣ 1 ⟩))
Crunching:
(list2D_to_matrix [[C1 / √ 2]; [C1 / √ 2]] =
 / √ 2 .* (∣ 0 ⟩ .+ (-1) ^ false .* ∣ 1 ⟩))
Crunching: (cnot × ∣ l, H5 ⟩ = ∣ l, (l + H5) mod 2 ⟩)
Crunching: (cnot × ∣ l, H5 ⟩ = ∣ l, (l + H5) mod S H5 ⟩)
Crunching: (cnot × ∣ l, H5 ⟩ = ∣ l, (l + H5) mod 2 ⟩)
Crunching: (cnot × ∣ l, H5 ⟩ = ∣ l, H5 - snd (Nat.divmod (l + H5) H5 0 H5) ⟩)
Crunching: (cnot × ∣ l, H5 ⟩ = ∣ l, (l + H5) mod S H5 ⟩)
Crunching:
(cnot
 × (fun x y : nat =>
    ∣ q ⟩ (x / 2)%nat (y / 1)%nat * ∣ q' ⟩ (x mod 2)%nat (y mod 1)%nat) =
 (fun x y : nat =>
  ∣ q ⟩ (x / 2)%nat (y / 1)%nat *
  ∣ (q + q') mod 2 ⟩ (x mod 2)%nat (y mod 1)%nat))
Crunching:
((n < 2)%nat -> (bv < 2)%nat -> cnot × ∣ n, bv ⟩ = ∣ n, (n + bv) mod 2 ⟩)
Crunching:
(forall (n : nat) (f g : nat -> nat),
 permutation n f -> permutation n g -> permutation n (f ∘ g)%prg)
Crunching: (cnot × ∣ l, H5 ⟩ = ∣ l, (l + H5) mod 2 ⟩)
'A_R' is now a registered translation.
Crunching: (cnot × ∣ l, H5 ⟩ = ∣ l, (l + H5) mod 2 ⟩)
Crunching: (cnot × ∣ l, H5 ⟩ = ∣ l, (l + H5) mod 2 ⟩)
Crunching: ((cnot × ∣ l, H5 ⟩) x y = ∣ l, (l + H5) mod S H5 ⟩ x y)
Crunching: (cnot × ∣ l, H5 ⟩ = ∣ l, H5 - snd (Nat.divmod (l + H5) H5 0 H5) ⟩)
Crunching: ((cnot × ∣ l, H5 ⟩) x y = ∣ l, (l + H5) mod S H5 ⟩ x y)
Crunching: (cnot × ∣ l, H5 ⟩ = ∣ l, H5 - snd (Nat.divmod (l + H5) H5 0 H5) ⟩)
Crunching: ((cnot × ∣ l, H5 ⟩) x y = ∣ l, (l + H5) mod S H5 ⟩ x y)
Crunching: (cnot × ∣ l, H5 ⟩ = ∣ l, H5 - snd (Nat.divmod (l + H5) H5 0 H5) ⟩)
Crunching: ((cnot × ∣ l, H5 ⟩) x y = ∣ l, (l + H5) mod S H5 ⟩ x y)
Crunching: (-1 <= / 3 <= 1)%R
Crunching: (cnot × ∣ l, H5 ⟩ = ∣ l, H5 - snd (Nat.divmod (l + H5) H5 0 H5) ⟩)
Crunching: (cnot × ∣ l, H5 ⟩ = ∣ l, H5 - snd (Nat.divmod (l + H5) H5 0 H5) ⟩)
Crunching: (cnot × ∣ l, H5 ⟩ = ∣ l, (l + H5) mod S H5 ⟩)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (permutation 0 (y ∘ Hn)%prg)
Crunching: ((∣ n ⟩) † = ⟨ n ∣)
Crunching: ((∣ n ⟩) † = ⟨ n ∣)
Crunching: ((∣ n ⟩) † = ⟨ n ∣)
Crunching: ((∣ n ⟩) † = ⟨ n ∣)
Crunching: (permutation E0 y -> permutation E0 (x ∘ y)%prg)
Crunching: Z
Crunching: ((∣ n ⟩) † = ⟨ n ∣)
Crunching: ((∣ 0 ⟩) ⊤ = ⟨ 0 ∣)
Crunching: ((∣ 1 ⟩) ⊤ = ⟨ 1 ∣)
Crunching: ((⟨ 0 ∣) ⊤ = ∣ 0 ⟩)
Crunching: ((⟨ 0 ∣) ⊤ = ∣ 0 ⟩)
Crunching: ((⟨ 1 ∣) ⊤ = ∣ 1 ⟩)
Crunching: ((⟨ 1 ∣) ⊤ = ∣ 1 ⟩)
Crunching: ((⟨ 1 ∣) † = ∣ 1 ⟩)
Crunching: ((⟨ 1 ∣) † = ∣ 1 ⟩)
Crunching: ((∣ 1 ⟩) † = ⟨ 1 ∣)
Crunching: ((⟨ 0 ∣) † = ∣ 0 ⟩)
Crunching: ((⟨ 0 ∣) † = ∣ 0 ⟩)
Crunching: ((∣ 0 ⟩) † = ⟨ 0 ∣)
Crunching: (permutation HE (fswap f x HE))
Crunching:
((1 < 0)%R ->
 forall (A : Type) (f : nat -> A) (i : nat) (b : A), update f i b i = b)
Crunching:
(forall r1 : R,
 ((if Rlt_le_dec r1 r then 0 else S (sample r0 (r1 - r))) <= S (length r0))%nat)
Crunching: (forall b : p1, update n 0 b 0 = b)
Crunching:
((1 < 0)%R ->
 forall (A : Type) (f : nat -> A) (i : nat) (b : A), update f i b i = b)
uniform_sigma_lifting (M:=[the monad of idfun]) ?op ?t Identity.naturality
     : imonad_transformer.lifting_monadT (M:=[the monad of idfun]) 
         ?op
         (t:=imonad_transformer.FMT.Exports.imonad_transformer_FMT__to__imonad_transformer_MonadT
               ?t)
         (slifting (M:=[the monad of idfun]) ?op ?t Identity.naturality)
where
?E : [ |- functor]
?op : [ |- ?E .-operation [the monad of idfun]]
?t : [ |- imonad_transformer.FMT.type]
'Z_R' is now a registered translation.
'A_R' is now a registered translation.
rewrite match_option_dtt
match (List.nth_error (list_of_array a) (proj1_sig x)) with
| None =>
(fun E : List.nth_error (list_of_array a) (proj1_sig x) = None =>
 match slist_nth_lemma1 (slist_of_array a) x E return A with
 end)
| Some m =>
(fun (a0 : A) (_ : List.nth_error (list_of_array a) (proj1_sig x) = Some a0)
 => a0)
rewrite match_option_dtt
match (List.nth_error (list_of_array a) (proj1_sig x)) with
| None =>
(fun E : List.nth_error (list_of_array a) (proj1_sig x) = None =>
 match slist_nth_lemma1 (slist_of_array a) x E return A with
 end)
| Some m =>
(fun (a0 : A) (_ : List.nth_error (list_of_array a) (proj1_sig x) = Some a0)
 => a0)
Crunching: (permutation HE (fswap f x HE))
Crunching: (b n = a -> permutation a (fswap b n a))
Crunching: (b n = a -> permutation a (fswap b n a))
specialized IHeP using (eq_refl e )
out of reach
Tactic call ran for 0.005 secs (0.004u,0.001s) (failure)
specialized IHeP2 using (eq_refl e0 )
specialized IHeP1 using (eq_refl e )
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching:
(exists N : nat,
   forall n : nat, (n >= N)%nat -> R_dist (PI_2_3_7_tg n) 0 < Hn)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (permutation (b c) (fswap b c (b c)))
Crunching: (permutation (b c) (fswap b c (b c)))
Crunching:
(forall r1 : R,
 ((if Rlt_le_dec r1 r then 0 else S (sample r0 (r1 - r))) <= S (length r0))%nat)
Crunching: (c < S a -> 0 = a -> permutation a (fswap b c a))
out of reach
Tactic call ran for 0.004 secs (0.003u,0.001s) (failure)
Crunching:
(forall n0 : nat,
 (forall m : nat, (m < n0)%nat -> (sample x n <= m)%nat) ->
 (sample x n <= n0)%nat)
Crunching: (b n = a -> permutation a (fswap b n a))
out of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
Crunching: (b n = a -> permutation a (fswap b n a))
Crunching: (H1 <= fst (Nat.divmod (HP + p) 1 0 1) <= ub)
Crunching: (∣0⟩ = basis_vector 2 0)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching: (H4 <= (HP + p) / 2 <= l)
Crunching:
(exists N : nat,
   forall n : nat, (n >= N)%nat -> R_dist (PI_2_3_7_tg n) 0 < Hn)
rewrite if_dtt
if (proj1_sig x =? proj1_sig k)
then (fun _ : (proj1_sig x =? proj1_sig k) = true => AA tt)
else
(fun E0 : (proj1_sig x =? proj1_sig k) = false =>
 BB
   ((if proj1_sig x <? proj1_sig k as b1
      return ((proj1_sig x <? proj1_sig k) = b1 -> ltN n)
     then
      fun E1 : (proj1_sig x <? proj1_sig k) = true =>
      ltN_of_nat (proj1_sig x) n (ltN_pop_lemma1 n k x E1)
     else
      fun E1 : (proj1_sig x <? proj1_sig k) = false =>
      ltN_of_nat (Init.Nat.pred (proj1_sig x)) n (ltN_pop_lemma2 n k x E1 E0))
      eq_refl))
Crunching: (H4 <= (HP + 0) / 2)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (permutation (b c) (fswap b c (b c)))
Crunching: (permutation (b c) (fswap b c (b c)))
Crunching:
(forall r1 : R,
 ((if Rlt_le_dec r1 r then 0 else S (sample r0 (r1 - r))) <= S (length r0))%nat)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching: (c < S a -> 0 = a -> permutation a (fswap b c a))
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching: (∣0⟩ = basis_vector 2 0)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
ordering_function_ex :
forall B : Ensemble Ord,
exists ! S : Ensemble Ord, exists f : Ord -> Ord, ordering_function f S B

ordering_function_ex is not universe polymorphic
Arguments ordering_function_ex B
ordering_function_ex is opaque
Expands to: Constant hydras.Schutte.Ordering_Functions.ordering_function_ex
ordering_function_unicity :
forall [B A1 A2 : Ensemble Ord] [f1 f2 : Ord -> Ord],
ordering_function f1 A1 B ->
ordering_function f2 A2 B -> fun_equiv f1 f2 A1 A2

ordering_function_unicity is not universe polymorphic
Arguments ordering_function_unicity [B A1 A2] [f1 f2]%function_scope O1 O2
ordering_function_unicity is opaque
Expands to: Constant
hydras.Schutte.Ordering_Functions.ordering_function_unicity
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
out of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
Crunching: (∣1⟩ = basis_vector 2 1)
out of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
out of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
fun Z : UU0 =>
uniform_sigma_lifting (M:=[the monad of ExceptMonad.acto Z]) 
  ?op ?t (Exception.naturality Z)
     : forall Z : UU0,
       imonad_transformer.lifting_monadT
         (M:=[the monad of ExceptMonad.acto Z]) ?op
         (t:=imonad_transformer.FMT.Exports.imonad_transformer_FMT__to__imonad_transformer_MonadT
               ?t)
         (slifting (M:=[the monad of ExceptMonad.acto Z]) 
            ?op ?t (Exception.naturality Z))
where
?E : [Z : UU0 |- functor]
?op : [Z : UU0 |- ?E .-operation [the monad of ExceptMonad.acto Z]]
?t : [Z : UU0 |- imonad_transformer.FMT.type]
Crunching: (update P F b le_mn2 = P le_mn2)
Crunching: (forall x0 : nat, x0 < S n' -> v x0 x y = v (f x0) x y)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching:
(R -> R -> big_sum n eps0_pos = big_sum (fun i0 : nat => n (i i0)) eps0_pos)
out of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
Crunching: (0%nat <> 1%nat -> (1 <= 0)%nat)
Crunching: (l < eps0_pos -> H1 l = H1 (n l))
Crunching: (l < eps0_pos -> H1 l = H1 (n l))
Crunching:
(big_sum H1 eps0_pos x y = big_sum (fun i : nat => H1 (H4 i)) eps0_pos x y)
Crunching: (∣0⟩ = basis_vector 2 0)
out of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
Crunching: (0 <= r -> 0 < 0 -> (sample [] r < length [])%nat)
Crunching: (?x < ?x)
Crunching: (0%nat <> 1%nat -> (1 <= 0)%nat)
Crunching: (0%nat <> 1%nat -> (1 <= 0)%nat)
Crunching: (update P F Ne x = P x)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching: (1 <= 0)%nat
Crunching: (1 <= 0)%nat
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching: (x = y)
Crunching: (update P F b le_mn2 = P le_mn2)
Crunching: (update P F b le_mn2 = P le_mn2)
Crunching:
(forall y : nat,
 (Hpq >= 2 ^ m)%nat \/ (y >= 2 ^ m)%nat -> pad n m H Hpq y = 0)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching: False
Crunching:
(forall y : nat, (f >= 2 ^ m)%nat \/ (y >= 2 ^ m)%nat -> pad n m H f y = 0)
Crunching: False
Crunching: (x = z z0 -> update z z0 x = z)
Crunching: False
Crunching: False
Crunching: (nat -> False)
Crunching: (∣1⟩ = basis_vector 2 1)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching: (sum_over_list RS' <= r -> sample RS' r = length RS')
uniform_sigma_lifting (M:=[the monad of option_monad]) 
  ?op ?t Option.naturality
     : imonad_transformer.lifting_monadT (M:=[the monad of option_monad]) 
         ?op
         (t:=imonad_transformer.FMT.Exports.imonad_transformer_FMT__to__imonad_transformer_MonadT
               ?t)
         (slifting (M:=[the monad of option_monad]) ?op ?t Option.naturality)
where
?E : [ |- functor]
?op : [ |- ?E .-operation [the monad of option_monad]]
?t : [ |- imonad_transformer.FMT.type]
'A_R' is now a registered translation.
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (0 <= m' \/ 0 <= cv -> perm_mat 0 p m' cv = 0%R)
Crunching: (x = z z0 -> update z z0 x = z)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (x = z z0 -> update z z0 x = z)
Finished transaction in 76.289 secs (74.246u,1.618s) (successful)
rewrite match_option_dtt
match (List.nth_error l (proj1_sig x1)) with
| None =>
(fun E : List.nth_error l (proj1_sig x1) = None =>
 match
   slist_nth_lemma1
     (exist (fun l : list A => (length l =? S n) = true) (l0 :: l)%list Hl0)
     (ltN_S x1) E return A
 with
 end)
| Some m => (fun (a : A) (_ : List.nth_error l (proj1_sig x1) = Some a) => a)
rewrite match_option_dtt
match (List.nth_error l (proj1_sig x1)) with
| None =>
(fun E : List.nth_error l (proj1_sig x1) = None =>
 match
   slist_nth_lemma1
     (exist (fun l : list A => (length l =? S n) = true) (l0 :: l)%list Hl0)
     (ltN_S x1) E return A
 with
 end)
| Some m => (fun (a : A) (_ : List.nth_error l (proj1_sig x1) = Some a) => a)
rewrite match_option_dtt
match (List.nth_error l (proj1_sig x1)) with
| None =>
(fun E : List.nth_error l (proj1_sig x1) = None =>
 match
   slist_nth_lemma1
     (exist (fun l : list A => (length l =? S n) = true) (l0 :: l)%list Hl0)
     (ltN_S x1) E return A
 with
 end)
| Some m => (fun (a : A) (_ : List.nth_error l (proj1_sig x1) = Some a) => a)
rewrite match_option_dtt
match (List.nth_error l (proj1_sig x1)) with
| None =>
(fun E : List.nth_error l (proj1_sig x1) = None =>
 match
   slist_nth_lemma1
     (exist (fun l : list A => (length l =? S n) = true) (l0 :: l)%list Hl0)
     (ltN_S x1) E return A
 with
 end)
| Some m => (fun (a : A) (_ : List.nth_error l (proj1_sig x1) = Some a) => a)
Crunching: (x = z z0 -> update z z0 x = z)
Crunching: (sum_over_list RS' <= r -> sample RS' r = length RS')
Crunching: (x = z z0 -> update z z0 x = z)
clear  H1  :  (False -> b1 = false)
Crunching: (x = z z0 -> update z z0 x = z)
rewrite if_dtt
if (pA a)
then (fun E : pA a = true => p (exist (fun a0 : A => pA a0 = true) a E))
else (fun _ : pA a = false => false)
Crunching: (x = z z0 -> update z z0 x = z)
Crunching: (x = z z0 -> update z z0 x = z)
Crunching: (x = z z0 -> update z z0 x = z)
Crunching: (x = z z0 -> update z z0 x = z)
Finished transaction in 14.644 secs (14.314u,0.284s) (successful)
Crunching:
(forall (start : nat) (A B : Square (2 ^ Hnm)),
 pad start Hpq A × pad start Hpq B = pad start Hpq (A × B))
Crunching: (update k a cl = k)
Crunching: (forall b' : l1, update (update H n p) n b' = update H n b')
Crunching: (perm_mat 0 y H6 H' = 0%R)
Crunching: (perm_mat x y H6 H' = 0%R)
Crunching: (sample (l1 ++ l2) r = sample l1 r)
Crunching: (sample (l1 ++ l2) r = sample l1 r)
Crunching: (WF_Unitary (perm_mat x y))
Crunching: (x < sum_over_list Hnm -> sample (Hnm ++ Hpq) x = sample Hnm x)
Crunching: (x < sum_over_list Hnm -> sample (Hnm ++ Hpq) x = sample Hnm x)
Crunching: (x < sum_over_list Hnm -> sample (Hnm ++ Hpq) x = sample Hnm x)
Crunching: (x < sum_over_list Hnm -> sample (Hnm ++ Hpq) x = sample Hnm x)
Crunching: (x < sum_over_list Hnm -> sample (Hnm ++ Hpq) x = sample Hnm x)
Crunching: (x < sum_over_list Hnm -> sample (Hnm ++ Hpq) x = sample Hnm x)
Crunching:
(forall n : nat,
 (forall m : nat, m < n -> WF_Unitary (perm_mat x y)) ->
 WF_Unitary (perm_mat x y))
Crunching: (x < sum_over_list Hnm -> sample (Hnm ++ Hpq) x = sample Hnm x)
Crunching: (x < sum_over_list Hnm -> sample (Hnm ++ Hpq) x = sample Hnm x)
Crunching: (x < sum_over_list Hnm -> sample (Hnm ++ Hpq) x = sample Hnm x)
Crunching: (x < sum_over_list Hnm -> sample (Hnm ++ Hpq) x = sample Hnm x)
Crunching: (x < sum_over_list Hnm -> sample (Hnm ++ Hpq) x = sample Hnm x)
Crunching: (x < sum_over_list Hnm -> sample (Hnm ++ Hpq) x = sample Hnm x)
uniform_sigma_lifting (M:=[the monad of ListMonad.acto]) 
  ?op ?t List.naturality
     : imonad_transformer.lifting_monadT (M:=[the monad of ListMonad.acto])
         ?op
         (t:=imonad_transformer.FMT.Exports.imonad_transformer_FMT__to__imonad_transformer_MonadT
               ?t)
         (slifting (M:=[the monad of ListMonad.acto]) ?op ?t List.naturality)
where
?E : [ |- functor]
?op : [ |- ?E .-operation [the monad of ListMonad.acto]]
?t : [ |- imonad_transformer.FMT.type]
'S_R' is now a registered translation.
'A_R' is now a registered translation.
Crunching: (pad 0 dim (I 2) = I (2 ^ dim))
Crunching: (pad 0 1 (I 2) = I (2 ^ 1))
Crunching: (forall y0 : nat, q >= x \/ y0 >= x -> perm_mat x y q y0 = 0%R)
Crunching: (I (2 ^ dim) = pad 0 dim (I 2))
Crunching: (forall b' : l1, update (update H n p) n b' = update H n b')
Crunching: (update (update H x0 p) x0 LT = update H x0 LT)
Crunching: (0%R = perm_mat 0 y H6 H')
Crunching: (perm_mat 0 y H6 H' = 0%R)
Crunching: (perm_mat x y H6 H' = 0%R)
Crunching: (perm_mat x y H6 H' = 0%R)
Crunching: (perm_mat x y H6 H' = 0%R)
Crunching: (pad 0 dim (I 2) = I (2 ^ dim))
Crunching: Z
Crunching: (pad 0 1 (I 2) = I (2 ^ 1))
Finished transaction in 25.071 secs (24.883u,0.147s) (successful)
Crunching: (pad 0 1 (I 2) = I (2 ^ 1))
Crunching: Z
Crunching: (0 <= NZ <= H4 -> H4 * NZ + NZ * H4 <= NZ * NZ + H4 * H4)
Crunching: (b * NZ + NZ * b <= NZ * NZ + b * b)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching: (perm_mat 0 y H6 H' = 0%R)
Crunching: Z
Crunching: (forall y0 : nat, H4 >= x \/ y0 >= x -> perm_mat x y H4 y0 = 0%R)
Crunching: (I (2 ^ dim) = pad 0 dim (I 2))
Crunching: ((nat -> x) -> False)
Crunching: (update k Hyp b' = update (update k Hyp H11) Hyp b')
Crunching: False
Crunching: (WF_Unitary (perm_mat x y))
Crunching: (WF_Unitary (perm_mat x y))
simplified dependent [if true]
Ha : (pA a)  = true
if (pA a)
then (fun E : pA a = true => p1 (exist (fun a0 : A => pA a0 = true) a E))
else (fun E : pA a = false => p0 (exist (fun a0 : A => pA a0 = false) a E))
Crunching:
((q >= 2 ^ abs)%nat \/ (Hqgt0 >= 2 ^ abs)%nat ->
 (if 0 + 1 <=? abs then I (2 ^ 0) ⊗ I 2 ⊗ I (2 ^ (abs - (0 + 1))) else Zero)
   q Hqgt0 = 0)
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 (ltN_count (stail p)) (ltN_pred_lemma0 k k0 E)))
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 (ltN_count (stail p)) (ltN_pred_lemma0 k k0 E)))
Crunching:
(forall n : nat,
 (forall m : nat, m < n -> WF_Unitary (perm_mat x y)) ->
 WF_Unitary (perm_mat x y))
simplified dependent [if false]
Ha : (pA a)  = true
if (pA a)
then (fun E : pA a = true => p1 (exist (fun a0 : A => pA a0 = true) a E))
else (fun E : pA a = false => p0 (exist (fun a0 : A => pA a0 = false) a E))
Crunching: (WF_Unitary (perm_mat x y))
Crunching:
((q >= 2 ^ abs)%nat \/ (Hqgt0 >= 2 ^ abs)%nat ->
 (if 0 + 1 <=? abs then I (2 ^ 0) ⊗ I 2 ⊗ I (2 ^ (abs - (0 + 1))) else Zero)
   q Hqgt0 = 0)
Crunching:
(forall n : nat,
 (forall m : nat, m < n -> WF_Unitary (perm_mat x y)) ->
 WF_Unitary (perm_mat x y))
Finished transaction in 10.389 secs (10.291u,0.083s) (successful)
Crunching: (forall b' : l1, update (update H n p) n b' = update H n b')
Crunching: (x = 0 -> 0 <= Rabs x)
Crunching: (update (update H x0 p) x0 LT = update H x0 LT)
Crunching: (sample (l1 ++ l2) r = sample l1 r)
Crunching: (sample (l1 ++ l2) r = sample l1 r)
Crunching: (x < sum_over_list Hnm -> sample (Hnm ++ Hpq) x = sample Hnm x)
Crunching: (x < sum_over_list Hnm -> sample (Hnm ++ Hpq) x = sample Hnm x)
Crunching: (x < sum_over_list Hnm -> sample (Hnm ++ Hpq) x = sample Hnm x)
Crunching: (x < sum_over_list Hnm -> sample (Hnm ++ Hpq) x = sample Hnm x)
Crunching: (x < sum_over_list Hnm -> sample (Hnm ++ Hpq) x = sample Hnm x)
Crunching: (x < sum_over_list Hnm -> sample (Hnm ++ Hpq) x = sample Hnm x)
Crunching: (x < sum_over_list Hnm -> sample (Hnm ++ Hpq) x = sample Hnm x)
Crunching: (x < sum_over_list Hnm -> sample (Hnm ++ Hpq) x = sample Hnm x)
Crunching: (x < sum_over_list Hnm -> sample (Hnm ++ Hpq) x = sample Hnm x)
Crunching: (x < sum_over_list Hnm -> sample (Hnm ++ Hpq) x = sample Hnm x)
Crunching: (x < sum_over_list Hnm -> sample (Hnm ++ Hpq) x = sample Hnm x)
Crunching: (x < sum_over_list Hnm -> sample (Hnm ++ Hpq) x = sample Hnm x)
Crunching: (x < sum_over_list Hnm -> sample (Hnm ++ Hpq) x = sample Hnm x)
Crunching: (x < sum_over_list Hnm -> sample (Hnm ++ Hpq) x = sample Hnm x)
Crunching: (pad 0 dim (I 2) = I (2 ^ dim))
Crunching: (x < sum_over_list Hnm -> sample (Hnm ++ Hpq) x = sample Hnm x)
Crunching: (x < sum_over_list Hnm -> sample (Hnm ++ Hpq) x = sample Hnm x)
Crunching: (x < sum_over_list Hnm -> sample (Hnm ++ Hpq) x = sample Hnm x)
Crunching: (x < sum_over_list Hnm -> sample (Hnm ++ Hpq) x = sample Hnm x)
Crunching: (x < sum_over_list Hnm -> sample (Hnm ++ Hpq) x = sample Hnm x)
Crunching: (x < sum_over_list Hnm -> sample (Hnm ++ Hpq) x = sample Hnm x)
Crunching: (x < sum_over_list Hnm -> sample (Hnm ++ Hpq) x = sample Hnm x)
Crunching: (x < sum_over_list Hnm -> sample (Hnm ++ Hpq) x = sample Hnm x)
Crunching: (x < sum_over_list Hnm -> sample (Hnm ++ Hpq) x = sample Hnm x)
Crunching: (x < sum_over_list Hnm -> sample (Hnm ++ Hpq) x = sample Hnm x)
Crunching: (x < sum_over_list Hnm -> sample (Hnm ++ Hpq) x = sample Hnm x)
Crunching: (x < sum_over_list Hnm -> sample (Hnm ++ Hpq) x = sample Hnm x)
Crunching: (x < sum_over_list Hnm -> sample (Hnm ++ Hpq) x = sample Hnm x)
Crunching: (x < sum_over_list Hnm -> sample (Hnm ++ Hpq) x = sample Hnm x)
Crunching:
((if Rlt_le_dec g a then 0%nat else S (sample (l1 ++ []) (g - a))) =
 (if Rlt_le_dec g a then 0%nat else S (sample l1 (g - a))))
Crunching: (sample ((a :: l1) ++ []) g = sample (a :: l1) g)
Crunching:
((if Rlt_le_dec g a then 0%nat else S (sample (l1 ++ []) (g - a))) =
 (if Rlt_le_dec g a then 0%nat else S (sample l1 (g - a))))
Crunching: (sample ((a :: l1) ++ []) g = sample (a :: l1) g)
Crunching: (pad 0 dim (I 2) = I (2 ^ dim))
Crunching:
((if Rlt_le_dec DF a then 0%nat else S (sample (l1 ++ []) (DF + - a))) =
 (if Rlt_le_dec DF a then 0%nat else S (sample l1 (DF + - a))))
Crunching:
((if Rlt_le_dec DF a then 0%nat else S (sample (l1 ++ []) (DF + - a))) =
 (if Rlt_le_dec DF a then 0%nat else S (sample l1 (DF + - a))))
Crunching:
((if Rlt_le_dec DF a then 0%nat else S (sample (l1 ++ []) (DF + - a))) =
 (if Rlt_le_dec DF a then 0%nat else S (sample l1 (DF + - a))))
Crunching: (forall y0 : nat, q >= x \/ y0 >= x -> perm_mat x y q y0 = 0%R)
Crunching:
((if Rlt_le_dec DF a then 0%nat else S (sample (l1 ++ []) (DF + - a))) =
 (if Rlt_le_dec DF a then 0%nat else S (sample l1 (DF + - a))))
Crunching:
((if Rlt_le_dec DF a then 0%nat else S (sample (l1 ++ []) (DF + - a))) =
 (if Rlt_le_dec DF a then 0%nat else S (sample l1 (DF + - a))))
Crunching:
((if Rlt_le_dec DF a then 0%nat else S (sample (l1 ++ []) (DF + - a))) =
 (if Rlt_le_dec DF a then 0%nat else S (sample l1 (DF + - a))))
Crunching:
((if Rlt_le_dec DF a then 0%nat else S (sample (l1 ++ []) (DF + - a))) =
 (if Rlt_le_dec DF a then 0%nat else S (sample l1 (DF + - a))))
rewrite match_option_dtt
match (List.nth_error x (proj1_sig x0)) with
| None =>
(fun E : List.nth_error x (proj1_sig x0) = None =>
 match
   slist_nth_lemma1 (exist (fun l : list A => (length l =? n) = true) x e) x0
     E return A
 with
 end)
| Some m => (fun (a : A) (_ : List.nth_error x (proj1_sig x0) = Some a) => a)
Crunching:
((if Rlt_le_dec DF a then 0%nat else S (sample (l1 ++ []) (DF + - a))) =
 (if Rlt_le_dec DF a then 0%nat else S (sample l1 (DF + - a))))
rewrite match_option_dtt
match (List.nth_error x (proj1_sig x0)) with
| None =>
(fun E : List.nth_error x (proj1_sig x0) = None =>
 match
   slist_nth_lemma1 (exist (fun l : list A => (length l =? n) = true) x e) x0
     E return A
 with
 end)
| Some m => (fun (a : A) (_ : List.nth_error x (proj1_sig x0) = Some a) => a)
Crunching: (WF_Unitary (perm_mat x y))
Crunching:
(forall n : nat,
 (forall m : nat, m < n -> WF_Unitary (perm_mat x y)) ->
 WF_Unitary (perm_mat x y))
Crunching: (pad 0 dim (I 2) = I (2 ^ dim))
Crunching: (forall x y z : R, - z < y - x -> x < y + z)
Crunching:
(forall (dim n : nat) (u : Square 2),
 WF_Matrix u -> WF_Matrix (pad_u dim n u))
Crunching:
(sample (l2 ++ Ha) H = (length l2 + sample Ha (H - sum_over_list l2))%nat)
fun S : UU0 =>
uniform_sigma_lifting (M:=[the monad of StateMonad.acto S]) 
  ?op ?t (State.naturality S)
     : forall S : UU0,
       imonad_transformer.lifting_monadT
         (M:=[the monad of StateMonad.acto S]) ?op
         (t:=imonad_transformer.FMT.Exports.imonad_transformer_FMT__to__imonad_transformer_MonadT
               ?t)
         (slifting (M:=[the monad of StateMonad.acto S]) 
            ?op ?t (State.naturality S))
where
?E : [S : UU0 |- functor]
?op : [S : UU0 |- ?E .-operation [the monad of StateMonad.acto S]]
?t : [S : UU0 |- imonad_transformer.FMT.type]
Crunching: Z
Finished transaction in 24.403 secs (24.061u,0.187s) (successful)
rewrite match_option_dtt
match (List.nth_error x (proj1_sig x0)) with
| None =>
(fun E : List.nth_error x (proj1_sig x0) = None =>
 match
   slist_nth_lemma1 (exist (fun l : list A => (length l =? n) = true) x e) x0
     E return A
 with
 end)
| Some m => (fun (a : A) (_ : List.nth_error x (proj1_sig x0) = Some a) => a)
rewrite match_option_dtt
match (List.nth_error x (proj1_sig x0)) with
| None =>
(fun E : List.nth_error x (proj1_sig x0) = None =>
 match
   slist_nth_lemma1 (exist (fun l : list A => (length l =? n) = true) x e) x0
     E return A
 with
 end)
| Some m => (fun (a : A) (_ : List.nth_error x (proj1_sig x0) = Some a) => a)
rewrite match_option_dtt
match (List.nth_error x (proj1_sig x0)) with
| None =>
(fun E : List.nth_error x (proj1_sig x0) = None =>
 match
   slist_nth_lemma1 (exist (fun l : list A => (length l =? n) = true) x e) x0
     E return A
 with
 end)
| Some m => (fun (a : A) (_ : List.nth_error x (proj1_sig x0) = Some a) => a)
rewrite match_option_dtt
match (List.nth_error x (proj1_sig x0)) with
| None =>
(fun E : List.nth_error x (proj1_sig x0) = None =>
 match
   slist_nth_lemma1 (exist (fun l : list A => (length l =? n) = true) x e) x0
     E return A
 with
 end)
| Some m => (fun (a : A) (_ : List.nth_error x (proj1_sig x0) = Some a) => a)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching:
((Ha >= 2 ^ dim)%nat \/ (B >= 2 ^ dim)%nat -> pad_u dim 0 u Ha B = 0)
Crunching:
(forall x : nat,
 update (update Distr A abs) B a x = update (update Distr B a) A abs x)
Crunching: (update (update Distr A a) B LT = update (update Distr B LT) A a)
Crunching: ((perm_mat m n × perm_mat m A) x y = perm_mat m (n ∘ A)%prg x y)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching:
(sample (l2 ++ Ha) H = (length l2 + sample Ha (H - sum_over_list l2))%nat)
Crunching:
(f <> n' -> update (update env f r1) n' r2 = update (update env n' r2) f r1)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: ((perm_mat a Ha × perm_mat a g) i j = perm_mat a (Ha ∘ g)%prg i j)
simplified dependent [if true]
Ha : (pA a)  = true
if (pA a)
then (fun E : pA a = true => F (exist (fun a0 : A => pA a0 = true) a E))
else (fun _ : pA a = false => false)
Crunching: ((perm_mat a Ha × perm_mat a g) i j = perm_mat a (Ha ∘ g)%prg i j)
rewrite if_dtt
if (pA a1)
then (fun E : pA a1 = true => F (exist (fun a0 : A => pA a0 = true) a1 E))
else (fun _ : pA a1 = false => false)
simplified dependent [if true] in H0
Ha' : (pA a')  = true
if (pA a')
then (fun E : pA a' = true => F (exist (fun a0 : A => pA a0 = true) a' E))
else (fun _ : pA a' = false => false)
Crunching: (r <= sample (repeat 0%R r ++ H) r0)%nat
Crunching: (r <= sample (repeat 0%R r ++ H) r0)%nat
Crunching: (0 <= m -> (r <= sample (repeat 0%R r ++ H) m)%nat)
Crunching: (shift f 0 = f)
Crunching: (H <= sample (repeat 0%R H ++ m) H0)%nat
Crunching: (q * Hocc + Hocc * q <= 0)
Crunching: False
Crunching:
(forall (m n : nat) (u : Square 2),
 WF_Matrix u ->
 forall x y : nat,
 (x >= 2 ^ H3)%nat \/ (y >= 2 ^ H3)%nat -> pad_ctrl H3 m n u x y = 0)
Crunching: (forall f : nat -> n, shift f 0 = f)
Crunching: (pad_ctrl c H n u H4 y = 0)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching: (r <= sample (repeat 0%R r ++ H) r0)%nat
Crunching: (shift f 0 = f)
Crunching: (perm_mat 0 m x 0 = (if (x =? 0) && (x <? 0) then C1 else 0%R))
Crunching: (shift f 0 = f)
Crunching: (r <= sample (repeat 0%R r ++ H) r0)%nat
Crunching: (shift Hl 0 H = Hl H)
Crunching: (r <= sample (repeat 0%R r ++ H) m)%nat
Crunching: (r <= sample (repeat 0%R r ++ H) m)%nat
Crunching: (forall f : nat -> n, shift f 0 = f)
Crunching: (C2 <> 0)
Crunching: (0 <= m -> (r <= sample (repeat 0%R r ++ H) m)%nat)
Crunching: (0 <= m -> (r <= sample (repeat 0%R r ++ H) m)%nat)
Crunching: (perm_mat 0 m x 0 = (if (x =? 0) && (x <? 0) then C1 else 0%R))
Crunching: (shift f 0 = f)
Crunching:
(forall y : nat,
 (Hfalse >= 2 ^ dim)%nat \/ (y >= 2 ^ dim)%nat ->
 pad_ctrl dim m n u Hfalse y = 0)
Crunching: (shift f 0 = f)
Crunching:
(forall y : nat,
 (Hfalse >= 2 ^ dim)%nat \/ (y >= 2 ^ dim)%nat ->
 pad_ctrl dim m n u Hfalse y = 0)
Crunching: (perm_mat 0 m x 0 = (if (x =? 0) && (x <? 0) then C1 else 0%R))
Crunching: (positive -> shift f 0 = f -> shift f 0 = f)
Crunching:
(forall y : nat,
 (Hfalse >= 2 ^ dim)%nat \/ (y >= 2 ^ dim)%nat ->
 pad_ctrl dim m n u Hfalse y = 0)
Crunching: (H <= sample (repeat 0%R H ++ m) H0)%nat
Crunching: (shift (shift n b) a = shift n (a + b))
Crunching: (shift (shift f j) i x = shift f (i + j) x)
Crunching: (permutation (2 ^ a) (qubit_perm_to_nat_perm a n))
Crunching: (shift (shift p0 θ) l = shift p0 (l + θ))
Crunching: (shift (shift p0 θ) l = shift p0 (l + θ))
Crunching:
(0 < l / 2 -> forall j : nat, shift (shift p0 j) l = shift p0 (l + j))
Crunching:
((forall x1 : nat,
  x1 < x -> x' x1 < x /\ x0 x1 < x /\ x0 (x' x1) = x1 /\ x' (x0 x1) = x1) ->
 permutation (2 ^ x) (qubit_perm_to_nat_perm x x'))
Crunching:
((forall r1 r2 : R, r1 < r2 -> ~ r2 < r1) ->
 (forall r1 r2 : R, r1 < r2 \/ r1 > r2 -> r1 <> r2) ->
 forall f : nat -> bool,
 pr_outcome_sum (env :: k) f =
 (if f 0%nat
  then (env + pr_outcome_sum k (fun y : nat => f (S y)))%R
  else pr_outcome_sum k (fun y : nat => f (S y))))
Crunching: (permutation (2 ^ a) (qubit_perm_to_nat_perm a n))
Crunching: (permutation (2 ^ a) (qubit_perm_to_nat_perm a n))
Crunching: (shift (shift n b) a = shift n (a + b))
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching:
(pr_outcome_sum (m :: n) IH =
 (if IH 0%nat
  then (m + pr_outcome_sum n (fun y : nat => IH (S y)))%R
  else pr_outcome_sum n (fun y : nat => IH (S y))))
Crunching:
((forall (A : Type) (x y z : A), x = y -> y = z -> x = z) ->
 (forall r1 r2 r3 : R, (r1 < r2)%R -> (r2 < r3)%R -> (r1 < r3)%R) ->
 (forall r1 r2 r3 r4 : R, r1 = r2 -> (r2 < r4)%R -> r4 = r3 -> (r1 < r3)%R) ->
 forall j : nat, shift (shift H7 j) HE = shift H7 (HE + j))
Crunching:
((forall x1 : nat,
  x1 < x -> x' x1 < x /\ x0 x1 < x /\ x0 (x' x1) = x1 /\ x' (x0 x1) = x1) ->
 permutation (2 ^ x) (qubit_perm_to_nat_perm x x'))
Crunching:
((forall x1 : nat,
  x1 < x -> x' x1 < x /\ x0 x1 < x /\ x0 (x' x1) = x1 /\ x' (x0 x1) = x1) ->
 permutation (2 ^ x) (qubit_perm_to_nat_perm x x'))
Crunching: (permutation (2 ^ a) (qubit_perm_to_nat_perm a n))
Crunching: (permutation (2 ^ a) (qubit_perm_to_nat_perm a n))
Tactic call ran for 0.01 secs (0.011u,0.s) (success)
Crunching: (shift (shift f j) i x = shift f (i + j) x)
Crunching: (shift (shift f j) i x = shift f (i + j) x)
Crunching: (shift (shift f j) i hyp_sn = shift f (i + j) hyp_sn)
Tactic call ran for 0.007 secs (0.007u,0.s) (success)
Crunching: positive
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (shift (shift H w) LT = shift H (LT + w))
Crunching: ((fun n : nat => ?eps > 0) n)
Crunching:
((forall r1 r2 : R, r1 < r2 -> ~ r2 < r1) ->
 (forall r1 r2 : R, r1 < r2 \/ r1 > r2 -> r1 <> r2) ->
 forall f : nat -> bool,
 pr_outcome_sum (env :: k) f =
 (if f 0%nat
  then (env + pr_outcome_sum k (fun y : nat => f (S y)))%R
  else pr_outcome_sum k (fun y : nat => f (S y))))
Crunching: (shift (shift p0 θ) l = shift p0 (l + θ))
Crunching: (shift (shift p0 θ) l = shift p0 (l + θ))
Crunching: (shift (shift p0 θ) l = shift p0 (l + θ))
Crunching: (shift (shift p0 θ) l = shift p0 (l + θ))
Crunching:
((forall x1 : nat,
  x1 < x -> x' x1 < x /\ x0 x1 < x /\ x0 (x' x1) = x1 /\ x' (x0 x1) = x1) ->
 permutation (2 ^ x) (qubit_perm_to_nat_perm x x'))
Crunching: (shift (shift p0 θ) l = shift p0 (l + θ))
Crunching: (shift (shift p0 θ) l = shift p0 (l + θ))
Crunching: (shift (shift p0 θ) l = shift p0 (l + θ))
Crunching:
(0 < l / 2 -> forall j : nat, shift (shift p0 j) l = shift p0 (l + j))
type_is_by_reference: type -> bool
is_numeric_type: type -> bool
type_is_by_value: type -> bool
is_long_type: type -> bool
is_pointer_type: type -> bool
is_anyfloat_type: type -> bool
is_ptrofs_type: type -> bool
bool_type: type -> bool
is_int32_type: type -> bool
is_int_type: type -> bool
is_scalar_type: type -> bool
is_float_type: type -> bool
is_single_type: type -> bool
type_is_volatile: type -> bool
same_base_type: type -> type -> bool
is_neutral_cast: type -> type -> bool
eqb_type: type -> type -> bool
composite_compute.complete_legal_cosu_type: composite_env -> type -> bool
complete_type: composite_env -> type -> bool
complete_or_function_type: composite_env -> type -> bool
align_mem.LegalAlignasStrong.legal_alignas_type:
  composite_env -> Maps.PTree.t Z -> Maps.PTree.t bool -> type -> bool
align_mem.LegalAlignasFacts.LegalAlignas.legal_alignas_type:
  composite_env -> Maps.PTree.t Z -> Maps.PTree.t bool -> type -> bool
align_mem.LegalAlignasStrict.legal_alignas_type:
  composite_env -> Maps.PTree.t Z -> Maps.PTree.t bool -> type -> bool
align_mem.LegalAlignasStrongFacts.LegalAlignas.legal_alignas_type:
  composite_env -> Maps.PTree.t Z -> Maps.PTree.t bool -> type -> bool
align_mem.LegalAlignasStrictFacts.LegalAlignas.legal_alignas_type:
  composite_env -> Maps.PTree.t Z -> Maps.PTree.t bool -> type -> bool
Crunching:
((forall x1 : nat,
  x1 < x -> x' x1 < x /\ x0 x1 < x /\ x0 (x' x1) = x1 /\ x' (x0 x1) = x1) ->
 permutation (2 ^ x) (qubit_perm_to_nat_perm x x'))
Crunching:
((forall x1 : nat,
  x1 < x -> x' x1 < x /\ x0 x1 < x /\ x0 (x' x1) = x1 /\ x' (x0 x1) = x1) ->
 permutation (2 ^ x) (qubit_perm_to_nat_perm x x'))
Crunching:
((forall x1 : nat,
  x1 < x -> x' x1 < x /\ x0 x1 < x /\ x0 (x' x1) = x1 /\ x' (x0 x1) = x1) ->
 permutation (2 ^ x) (qubit_perm_to_nat_perm x x'))
out of reach
Tactic call ran for 0.001 secs (0.u,0.s) (failure)
Crunching: (permutation (2 ^ a) (qubit_perm_to_nat_perm a n))
Crunching: (permutation (2 ^ a) (qubit_perm_to_nat_perm a n))
Crunching: (permutation (2 ^ a) (qubit_perm_to_nat_perm a n))
     = (exist (fun k : nat => (k <? 6) = true) 0 eq_refl,
       (exist (fun k : nat => (k <? 5) = true) 0 eq_refl,
       (exist (fun k : nat => (k <? 4) = true) 0 eq_refl,
       (exist (fun k : nat => (k <? 3) = true) 0 eq_refl,
       (exist (fun k : nat => (k <? 2) = true) 0 eq_refl,
       (exist (fun k : nat => (k <? 1) = true) 0 eq_refl, tt))))))
     : decr_list (fun n : nat => ltN (S n)) 6
Crunching: (nat -> False)
Crunching:
(pr_outcome_sum (m :: n) IH =
 (if IH 0%nat
  then (m + pr_outcome_sum n (fun y : nat => IH (S y)))%R
  else pr_outcome_sum n (fun y : nat => IH (S y))))
Crunching: (shift (shift n b) a = shift n (a + b))
Crunching: positive
Crunching: positive
Crunching: (∣1⟩ = basis_vector 2 1)
rewrite if_dtt
if (proj1_sig x <? proj1_sig k)
then
(fun E1 : (proj1_sig x <? proj1_sig k) = true =>
 ltN_of_nat (proj1_sig x) (S n) (ltN_intro_lemma1 n k x E1))
else
(fun E1 : (proj1_sig x <? proj1_sig k) = false =>
 ltN_of_nat (S (proj1_sig x)) (S n) (ltN_intro_lemma2 n k x E1))
Crunching: False
Crunching: False
rewrite if_dtt
if (proj1_sig x <? proj1_sig k)
then
(fun E1 : (proj1_sig x <? proj1_sig k) = true =>
 ltN_of_nat (proj1_sig x) (S n) (ltN_intro_lemma1 n k x E1))
else
(fun E1 : (proj1_sig x <? proj1_sig k) = false =>
 ltN_of_nat (S (proj1_sig x)) (S n) (ltN_intro_lemma2 n k x E1))
Crunching: (fswap s2 x 0 x = s2 0)
Crunching: (permutation (2 ^ cv) (qubit_perm_to_nat_perm cv H))
rewrite if_dtt
if (proj1_sig x <? proj1_sig k)
then
(fun E1 : (proj1_sig x <? proj1_sig k) = true =>
 ltN_of_nat (proj1_sig x) (S n) (ltN_intro_lemma1 n k x E1))
else
(fun E1 : (proj1_sig x <? proj1_sig k) = false =>
 ltN_of_nat (S (proj1_sig x)) (S n) (ltN_intro_lemma2 n k x E1))
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.001 secs (0.u,0.s) (failure)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
Crunching:
(forall (n : nat) (p : nat -> nat) (f : nat -> bool),
 permutation n p ->
 perm_to_matrix n p × f_to_vec n f = f_to_vec n (fun x : nat => f (p x)))
Crunching: (fswap G Gfix H3 Gfix = G H3)
Crunching:
(forall (n : nat) (p : nat -> nat) (f : nat -> bool),
 permutation n p ->
 (fun x z : nat =>
  Σ (fun y : nat => (perm_to_matrix n p x y * f_to_vec n f y z)%C) (2 ^ n)) =
 f_to_vec n (fun x : nat => f (p x)))
rewrite if_dtt
if (proj1_sig x <? proj1_sig k)
then
(fun E1 : (proj1_sig x <? proj1_sig k) = true =>
 ltN_of_nat (proj1_sig x) (S n) (ltN_intro_lemma1 n k x E1))
else
(fun E1 : (proj1_sig x <? proj1_sig k) = false =>
 ltN_of_nat (S (proj1_sig x)) (S n) (ltN_intro_lemma2 n k x E1))
Crunching: (fswap s2 x 0 x = s2 0)
Crunching: (perm_to_matrix 0 p = I 1)
Crunching: (fswap n m p m = n p)
Crunching:
(forall y : nat,
 (p >= 2 ^ dim)%nat \/ (y >= 2 ^ dim)%nat ->
 (if start + Hxlex0 <=? dim
  then I (2 ^ start) ⊗ Hyley0 ⊗ I (2 ^ (dim - (start + Hxlex0)))
  else Zero) p y = 0)
Crunching:
((fun x z : nat =>
  Σ
    (fun y0 : nat =>
     (perm_to_matrix 0 y x y0 * (if (y0 =? z) && (y0 <? 1) then C1 else 0%R))%C)
    1) = (fun x y : nat => if (x =? y) && (x <? 1) then C1 else 0%R))
Crunching: (list2D_to_matrix [[e]] = perm_to_matrix 0 y × f_to_vec 0 z)
Crunching: (list2D_to_matrix [[C1]] = f_to_vec 0 (fun x : nat => z (y x)))
Crunching:
(forall (n : nat) (p : nat -> nat) (f : nat -> bool),
 permutation n p ->
 perm_to_matrix n p × f_to_vec n f = f_to_vec n (fun x : nat => f (p x)))
Crunching:
(pr_outcome_sum (a :: l1 ++ l2) f =
 (pr_outcome_sum (a :: l1) f +
  pr_outcome_sum l2 (fun x : nat => f (S (length l1 + x))))%R)
Crunching:
(pr_outcome_sum (a :: l1 ++ l2) f =
 (pr_outcome_sum (a :: l1) f +
  pr_outcome_sum l2 (fun x : nat => f (S (length l1 + x))))%R)
rewrite if_dtt
if (proj1_sig x <? proj1_sig k)
then
(fun E1 : (proj1_sig x <? proj1_sig k) = true =>
 ltN_of_nat (proj1_sig x) (S n) (ltN_intro_lemma1 n k x E1))
else
(fun E1 : (proj1_sig x <? proj1_sig k) = false =>
 ltN_of_nat (S (proj1_sig x)) (S n) (ltN_intro_lemma2 n k x E1))
Crunching: (fswap G Gfix H3 Gfix = G H3)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (?R2 l a -> fswap f x 0 l = f a)
Crunching: (f l = fswap f x 0 a)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Crunching: (?R2 l a -> fswap f x 0 l = f a)
Crunching: (f l = fswap f x 0 a)
Crunching: (?R2 l a -> fswap f x 0 l = f a)
Crunching: (f l = fswap f x 0 a)
Crunching:
((fun b : nat -> bool =>
  f_to_vec p (fun x0 : nat => x (q x0)) x0 y =
  Σ (fun y0 : nat => (perm_to_matrix p q x0 y0 * f_to_vec p b y0 y)%C)
    (2 ^ p)) x)
Crunching:
(pr_outcome_sum (r :: r0 ++ abs) f =
 (pr_outcome_sum (r :: r0) f +
  pr_outcome_sum abs (fun x : nat => f (S (length r0 + x))))%R)
Crunching:
(pr_outcome_sum (r :: r0 ++ abs) f =
 (pr_outcome_sum (r :: r0) f +
  pr_outcome_sum abs (fun x : nat => f (S (length r0 + x))))%R)
Crunching: (?R2 l a -> fswap f x 0 l = f a)
clear  H2  :  (False -> False)
Crunching: (?R2 l a -> fswap f x 0 l = f a)
clear  H2  :  (False -> False)
clear  H2  :  (False -> False)
Crunching:
(forall y : nat,
 (H2 >= 2 ^ H0)%nat \/ (y >= 2 ^ H0)%nat -> pad y0 H0 intx H2 y = 0)
Crunching:
(forall f : nat -> bool,
 pr_outcome_sum ((r :: r0) ++ LT) f =
 (pr_outcome_sum (r :: r0) f +
  pr_outcome_sum LT (fun x : nat => f (length (r :: r0) + x)%nat))%R)
rewrite if_dtt
if (proj1_sig x <? proj1_sig k)
then
(fun E1 : (proj1_sig x <? proj1_sig k) = true =>
 ltN_of_nat (proj1_sig x) (S n) (ltN_intro_lemma1 n k x E1))
else
(fun E1 : (proj1_sig x <? proj1_sig k) = false =>
 ltN_of_nat (S (proj1_sig x)) (S n) (ltN_intro_lemma2 n k x E1))
Crunching: (- - r = 0%R)
Crunching: (fswap f x y x = f y)
Crunching: (WF_Unitary (pad q r p))
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
clear  H2  :  (False -> False)
rewrite if_dtt
if (n =? S r)
then
(fun E : (n =? S r) = true =>
 ltN_of_nat 0 n
   (ltN_S_mod_lemma1 (exist (fun k : nat => (k <? n) = true) r Hr) E))
else
(fun E : (n =? S r) = false =>
 ltN_of_nat (S r) n
   (ltN_S_mod_lemma2 (exist (fun k : nat => (k <? n) = true) r Hr) E))
clear  H2  :  (False -> False)
Crunching: (fswap s2 x 0 x = s2 0)
clear  H2  :  (False -> False)
out of reach
Tactic call ran for 0.005 secs (0.003u,0.001s) (failure)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.001u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Crunching: (fswap s2 0 x x = s2 0)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.004 secs (0.003u,0.001s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Crunching:
(WF_Matrix (perm_to_matrix a n) /\
 (perm_to_matrix a n) † × perm_to_matrix a n = I (2 ^ a))
Tactic call ran for 0.003 secs (0.001u,0.002s) (success)
Tactic call ran for 0.007 secs (0.007u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Crunching:
(WF_Matrix (perm_to_matrix a n) /\
 (perm_to_matrix a n) † × perm_to_matrix a n = I (2 ^ a))
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Crunching: (WF_Matrix u -> (u) † × u = I 2 -> WF_Unitary (pad_u dim n u))
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Crunching: (WF_Matrix u -> (u) † × u = I 2 -> WF_Unitary (pad_u dim n u))
Tactic call ran for 0.006 secs (0.006u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
Tactic call ran for 0.003 secs (0.002u,0.001s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.006 secs (0.005u,0.001s) (success)
out of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
Tactic call ran for 0.003 secs (0.002u,0.s) (success)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching:
(forall x y : nat,
 ((fix pow (n m : nat) {struct m} : nat :=
     match m with
     | 0 => 1
     | S m0 =>
         (fix mul (n0 m1 : nat) {struct n0} : nat :=
            match n0 with
            | 0 => 0
            | S p =>
                (fix add (n1 m2 : nat) {struct n1} : nat :=
                   match n1 with
                   | 0 => m2
                   | S p0 => S (add p0 m2)
                   end) m1 (mul p m1)
            end) n (pow n m0)
     end) 2 eps <= x)%nat \/
 ((fix pow (n m : nat) {struct m} : nat :=
     match m with
     | 0 => 1
     | S m0 =>
         (fix mul (n0 m1 : nat) {struct n0} : nat :=
            match n0 with
            | 0 => 0
            | S p =>
                (fix add (n1 m2 : nat) {struct n1} : nat :=
                   match n1 with
                   | 0 => m2
                   | S p0 => S (add p0 m2)
                   end) m1 (mul p m1)
            end) n (pow n m0)
     end) 2 eps <= y)%nat ->
 (if
   (fix leb (n m : nat) {struct n} : bool :=
      match n with
      | 0%nat => true
      | S n' => match m with
                | 0%nat => false
                | S m' => leb n' m'
                end
      end)
     ((fix add (n m : nat) {struct n} : nat :=
         match n with
         | 0%nat => m
         | S p => S (add p m)
         end) n 1%nat) eps
  then
   fun x0 y0 : nat =>
   ((((let (x1, _) :=
         if
          if
           (fix eqb (n m : nat) {struct n} : bool :=
              match n with
              | 0%nat => match m with
                         | 0%nat => true
                         | S _ => false
                         end
              | S n' => match m with
                        | 0%nat => false
                        | S m' => eqb n' m'
                        end
              end)
             (let (x1, _) :=
                (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                   match x1 with
                   | 0%nat => (q, u)
                   | S x' =>
                       match u with
                       | 0%nat => divmod x' y1 (S q) y1
                       | S u' => divmod x' y1 q u'
                       end
                   end)
                  match
                    (fix pow (n m : nat) {struct m} : nat :=
                       match m with
                       | 0%nat => 1%nat
                       | S m0 =>
                           (fix mul (n0 m1 : nat) {struct n0} : nat :=
                              match n0 with
                              | 0%nat => 0%nat
                              | S p =>
                                  (fix add ... : nat := ...
                                                 ...
                                                 ...
                                                 end) m1 
                                    (mul p m1)
                              end) n (pow n m0)
                       end) 2%nat
                      ((fix sub (n m : nat) {struct n} : nat :=
                          match n with
                          | 0%nat => n
                          | S k =>
                              match m with
                              | 0%nat => n
                              | S l => sub k l
                              end
                          end) eps
                         ((fix add (n m : nat) {struct n} : nat :=
                             match n with
                             | 0%nat => m
                             | S p => S (add p m)
                             end) n 1%nat))
                  with
                  | 0%nat =>
                      (fix pow (n m : nat) {struct m} : nat :=
                         match m with
                         | 0%nat => 1%nat
                         | S m0 =>
                             (fix mul (n0 m1 : nat) {struct n0} : nat :=
                                match n0 with
                                | 0%nat => 0%nat
                                | S p =>
                                    (fix add (n1 m2 : nat) {struct n1} :
                                         nat :=
                                       match ... with
                                       | ... => m2
                                       | ... => S ...
                                       end) m1 (mul p m1)
                                end) n (pow n m0)
                         end) 2%nat
                        ((fix sub (n m : nat) {struct n} : nat :=
                            match n with
                            | 0%nat => n
                            | S k =>
                                match m with
                                | 0%nat => n
                                | S l => sub k l
                                end
                            end) eps
                           ((fix add (n m : nat) {struct n} : nat :=
                               match n with
                               | 0%nat => m
                               | S p => S (add p m)
                               end) n 1%nat))
                  | S y' =>
                      let (x1, _) :=
                        (fix divmod (x1 y1 q u : nat) {struct x1} :
                             nat * nat :=
                           match x1 with
                           | 0%nat => (q, u)
                           | S x' =>
                               match u with
                               | 0%nat => divmod x' y1 (S q) y1
                               | S u' => divmod x' y1 q u'
                               end
                           end) x0 y' 0%nat y' in
                      x1
                  end 1%nat 0%nat 1%nat in
              x1)
             (let (x1, _) :=
                (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                   match x1 with
                   | 0%nat => (q, u)
                   | S x' =>
                       match u with
                       | 0%nat => divmod x' y1 (S q) y1
                       | S u' => divmod x' y1 q u'
                       end
                   end)
                  match
                    (fix pow (n m : nat) {struct m} : nat :=
                       match m with
                       | 0%nat => 1%nat
                       | S m0 =>
                           (fix mul (n0 m1 : nat) {struct n0} : nat :=
                              match n0 with
                              | 0%nat => 0%nat
                              | S p =>
                                  (fix add ... : nat := ...
                                                 ...
                                                 ...
                                                 end) m1 
                                    (mul p m1)
                              end) n (pow n m0)
                       end) 2%nat
                      ((fix sub (n m : nat) {struct n} : nat :=
                          match n with
                          | 0%nat => n
                          | S k =>
                              match m with
                              | 0%nat => n
                              | S l => sub k l
                              end
                          end) eps
                         ((fix add (n m : nat) {struct n} : nat :=
                             match n with
                             | 0%nat => m
                             | S p => S (add p m)
                             end) n 1%nat))
                  with
                  | 0%nat =>
                      (fix pow (n m : nat) {struct m} : nat :=
                         match m with
                         | 0%nat => 1%nat
                         | S m0 =>
                             (fix mul (n0 m1 : nat) {struct n0} : nat :=
                                match n0 with
                                | 0%nat => 0%nat
                                | S p =>
                                    (fix add (n1 m2 : nat) {struct n1} :
                                         nat :=
                                       match ... with
                                       | ... => m2
                                       | ... => S ...
                                       end) m1 (mul p m1)
                                end) n (pow n m0)
                         end) 2%nat
                        ((fix sub (n m : nat) {struct n} : nat :=
                            match n with
                            | 0%nat => n
                            | S k =>
                                match m with
                                | 0%nat => n
                                | S l => sub k l
                                end
                            end) eps
                           ((fix add (n m : nat) {struct n} : nat :=
                               match n with
                               | 0%nat => m
                               | S p => S (add p m)
                               end) n 1%nat))
                  | S y' =>
                      let (x1, _) :=
                        (fix divmod (x1 y1 q u : nat) {struct x1} :
                             nat * nat :=
                           match x1 with
                           | 0%nat => (q, u)
                           | S x' =>
                               match u with
                               | 0%nat => divmod x' y1 (S q) y1
                               | S u' => divmod x' y1 q u'
                               end
                           end) y0 y' 0%nat y' in
                      x1
                  end 1%nat 0%nat 1%nat in
              x1)
          then
           match
             (fix pow (n m : nat) {struct m} : nat :=
                match m with
                | 0%nat => 1%nat
                | S m0 =>
                    (fix mul (n0 m1 : nat) {struct n0} : nat :=
                       match n0 with
                       | 0%nat => 0%nat
                       | S p =>
                           (fix add (n1 m2 : nat) {struct n1} : nat :=
                              match n1 with
                              | 0%nat => m2
                              | S p0 => S (add p0 m2)
                              end) m1 (mul p m1)
                       end) n (pow n m0)
                end) 2%nat n
           with
           | 0%nat => false
           | S m' =>
               (fix leb (n m : nat) {struct n} : bool :=
                  match n with
                  | 0%nat => true
                  | S n' =>
                      match m with
                      | 0%nat => false
                      | S m'0 => leb n' m'0
                      end
                  end)
                 (let (x1, _) :=
                    (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                       match x1 with
                       | 0%nat => (q, u)
                       | S x' =>
                           match u with
                           | 0%nat => divmod x' y1 (S q) y1
                           | S u' => divmod x' y1 q u'
                           end
                       end)
                      match
                        (fix pow (n m : nat) {struct m} : nat :=
                           match m with
                           | 0%nat => 1%nat
                           | S m0 =>
                               (fix mul (n0 m1 : nat) {struct n0} : nat :=
                                  match n0 with
                                  | 0%nat => 0%nat
                                  | S p => (...) m1 (...)
                                  end) n (pow n m0)
                           end) 2%nat
                          ((fix sub (n m : nat) {struct n} : nat :=
                              match n with
                              | 0%nat => n
                              | S k =>
                                  match m with
                                  | 0%nat => n
                                  | S l => sub k l
                                  end
                              end) eps
                             ((fix add (n m : nat) {struct n} : nat :=
                                 match n with
                                 | 0%nat => m
                                 | S p => S (add p m)
                                 end) n 1%nat))
                      with
                      | 0%nat =>
                          (fix pow (n m : nat) {struct m} : nat :=
                             match m with
                             | 0%nat => 1%nat
                             | S m0 =>
                                 (fix mul (n0 m1 : nat) {struct n0} : nat :=
                                    match n0 with
                                    | 0%nat => 0%nat
                                    | S p =>
                                        (fix add ... : nat := ...
                                                 ...
                                                 ...
                                                 end) m1 
                                          (mul p m1)
                                    end) n (pow n m0)
                             end) 2%nat
                            ((fix sub (n m : nat) {struct n} : nat :=
                                match n with
                                | 0%nat => n
                                | S k =>
                                    match m with
                                    | 0%nat => n
                                    | S l => sub k l
                                    end
                                end) eps
                               ((fix add (n m : nat) {struct n} : nat :=
                                   match n with
                                   | 0%nat => m
                                   | S p => S (add p m)
                                   end) n 1%nat))
                      | S y' =>
                          let (x1, _) :=
                            (fix divmod (x1 y1 q u : nat) {struct x1} :
                                 nat * nat :=
                               match x1 with
                               | 0%nat => (q, u)
                               | S x' =>
                                   match u with
                                   | 0%nat => divmod x' y1 (S q) y1
                                   | S u' => divmod x' y1 q u'
                                   end
                               end) x0 y' 0%nat y' in
                          x1
                      end 1%nat 0%nat 1%nat in
                  x1) m'
           end
          else false
         then (R1, R0)
         else (R0, R0) in
       x1) *
      (let (x1, _) :=
         EQ
           match
             (let (_, y1) :=
                (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                   match x1 with
                   | 0%nat => (q, u)
                   | S x' =>
                       match u with
                       | 0%nat => divmod x' y1 (S q) y1
                       | S u' => divmod x' y1 q u'
                       end
                   end)
                  match
                    (fix pow (n m : nat) {struct m} : nat :=
                       match m with
                       | 0%nat => 1%nat
                       | S m0 =>
                           (fix mul (n0 m1 : nat) {struct n0} : nat :=
                              match n0 with
                              | 0%nat => 0%nat
                              | S p =>
                                  (fix add ... : nat := ...
                                                 ...
                                                 ...
                                                 end) m1 
                                    (mul p m1)
                              end) n (pow n m0)
                       end) 2%nat
                      ((fix sub (n m : nat) {struct n} : nat :=
                          match n with
                          | 0%nat => n
                          | S k =>
                              match m with
                              | 0%nat => n
                              | S l => sub k l
                              end
                          end) eps
                         ((fix add (n m : nat) {struct n} : nat :=
                             match n with
                             | 0%nat => m
                             | S p => S (add p m)
                             end) n 1%nat))
                  with
                  | 0%nat =>
                      (fix pow (n m : nat) {struct m} : nat :=
                         match m with
                         | 0%nat => 1%nat
                         | S m0 =>
                             (fix mul (n0 m1 : nat) {struct n0} : nat :=
                                match n0 with
                                | 0%nat => 0%nat
                                | S p =>
                                    (fix add (n1 m2 : nat) {struct n1} :
                                         nat :=
                                       match ... with
                                       | ... => m2
                                       | ... => S ...
                                       end) m1 (mul p m1)
                                end) n (pow n m0)
                         end) 2%nat
                        ((fix sub (n m : nat) {struct n} : nat :=
                            match n with
                            | 0%nat => n
                            | S k =>
                                match m with
                                | 0%nat => n
                                | S l => sub k l
                                end
                            end) eps
                           ((fix add (n m : nat) {struct n} : nat :=
                               match n with
                               | 0%nat => m
                               | S p => S (add p m)
                               end) n 1%nat))
                  | S y' =>
                      let (x1, _) :=
                        (fix divmod (x1 y1 q u : nat) {struct x1} :
                             nat * nat :=
                           match x1 with
                           | 0%nat => (q, u)
                           | S x' =>
                               match u with
                               | 0%nat => divmod x' y1 (S q) y1
                               | S u' => divmod x' y1 q u'
                               end
                           end) x0 y' 0%nat y' in
                      x1
                  end 1%nat 0%nat 1%nat in
              y1)
           with
           | 0%nat => 1%nat
           | S _ => 0%nat
           end
           match
             (let (_, y1) :=
                (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                   match x1 with
                   | 0%nat => (q, u)
                   | S x' =>
                       match u with
                       | 0%nat => divmod x' y1 (S q) y1
                       | S u' => divmod x' y1 q u'
                       end
                   end)
                  match
                    (fix pow (n m : nat) {struct m} : nat :=
                       match m with
                       | 0%nat => 1%nat
                       | S m0 =>
                           (fix mul (n0 m1 : nat) {struct n0} : nat :=
                              match n0 with
                              | 0%nat => 0%nat
                              | S p =>
                                  (fix add ... : nat := ...
                                                 ...
                                                 ...
                                                 end) m1 
                                    (mul p m1)
                              end) n (pow n m0)
                       end) 2%nat
                      ((fix sub (n m : nat) {struct n} : nat :=
                          match n with
                          | 0%nat => n
                          | S k =>
                              match m with
                              | 0%nat => n
                              | S l => sub k l
                              end
                          end) eps
                         ((fix add (n m : nat) {struct n} : nat :=
                             match n with
                             | 0%nat => m
                             | S p => S (add p m)
                             end) n 1%nat))
                  with
                  | 0%nat =>
                      (fix pow (n m : nat) {struct m} : nat :=
                         match m with
                         | 0%nat => 1%nat
                         | S m0 =>
                             (fix mul (n0 m1 : nat) {struct n0} : nat :=
                                match n0 with
                                | 0%nat => 0%nat
                                | S p =>
                                    (fix add (n1 m2 : nat) {struct n1} :
                                         nat :=
                                       match ... with
                                       | ... => m2
                                       | ... => S ...
                                       end) m1 (mul p m1)
                                end) n (pow n m0)
                         end) 2%nat
                        ((fix sub (n m : nat) {struct n} : nat :=
                            match n with
                            | 0%nat => n
                            | S k =>
                                match m with
                                | 0%nat => n
                                | S l => sub k l
                                end
                            end) eps
                           ((fix add (n m : nat) {struct n} : nat :=
                               match n with
                               | 0%nat => m
                               | S p => S (add p m)
                               end) n 1%nat))
                  | S y' =>
                      let (x1, _) :=
                        (fix divmod (x1 y1 q u : nat) {struct x1} :
                             nat * nat :=
                           match x1 with
                           | 0%nat => (q, u)
                           | S x' =>
                               match u with
                               | 0%nat => divmod x' y1 (S q) y1
                               | S u' => divmod x' y1 q u'
                               end
                           end) y0 y' 0%nat y' in
                      x1
                  end 1%nat 0%nat 1%nat in
              y1)
           with
           | 0%nat => 1%nat
           | S _ => 0%nat
           end in
       x1) +
      -
      ((let (_, y1) :=
          if
           if
            (fix eqb (n m : nat) {struct n} : bool :=
               match n with
               | 0%nat => match m with
                          | 0%nat => true
                          | S _ => false
                          end
               | S n' =>
                   match m with
                   | 0%nat => false
                   | S m' => eqb n' m'
                   end
               end)
              (let (x1, _) :=
                 (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                    match x1 with
                    | 0%nat => (q, u)
                    | S x' =>
                        match u with
                        | 0%nat => divmod x' y1 (S q) y1
                        | S u' => divmod x' y1 q u'
                        end
                    end)
                   match
                     (fix pow (n m : nat) {struct m} : nat :=
                        match m with
                        | 0%nat => 1%nat
                        | S m0 =>
                            (fix mul (n0 m1 : nat) {struct n0} : nat :=
                               match n0 with
                               | 0%nat => 0%nat
                               | S p => (...) m1 (...)
                               end) n (pow n m0)
                        end) 2%nat
                       ((fix sub (n m : nat) {struct n} : nat :=
                           match n with
                           | 0%nat => n
                           | S k =>
                               match m with
                               | 0%nat => n
                               | S l => sub k l
                               end
                           end) eps
                          ((fix add (n m : nat) {struct n} : nat :=
                              match n with
                              | 0%nat => m
                              | S p => S (add p m)
                              end) n 1%nat))
                   with
                   | 0%nat =>
                       (fix pow (n m : nat) {struct m} : nat :=
                          match m with
                          | 0%nat => 1%nat
                          | S m0 =>
                              (fix mul (n0 m1 : nat) {struct n0} : nat :=
                                 match n0 with
                                 | 0%nat => 0%nat
                                 | S p =>
                                     (fix add ... : nat := ...
                                                 ...
                                                 ...
                                                 end) m1 
                                       (mul p m1)
                                 end) n (pow n m0)
                          end) 2%nat
                         ((fix sub (n m : nat) {struct n} : nat :=
                             match n with
                             | 0%nat => n
                             | S k =>
                                 match m with
                                 | 0%nat => n
                                 | S l => sub k l
                                 end
                             end) eps
                            ((fix add (n m : nat) {struct n} : nat :=
                                match n with
                                | 0%nat => m
                                | S p => S (add p m)
                                end) n 1%nat))
                   | S y' =>
                       let (x1, _) :=
                         (fix divmod (x1 y1 q u : nat) {struct x1} :
                              nat * nat :=
                            match x1 with
                            | 0%nat => (q, u)
                            | S x' =>
                                match u with
                                | 0%nat => divmod x' y1 (S q) y1
                                | S u' => divmod x' y1 q u'
                                end
                            end) x0 y' 0%nat y' in
                       x1
                   end 1%nat 0%nat 1%nat in
               x1)
              (let (x1, _) :=
                 (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                    match x1 with
                    | 0%nat => (q, u)
                    | S x' =>
                        match u with
                        | 0%nat => divmod x' y1 (S q) y1
                        | S u' => divmod x' y1 q u'
                        end
                    end)
                   match
                     (fix pow (n m : nat) {struct m} : nat :=
                        match m with
                        | 0%nat => 1%nat
                        | S m0 =>
                            (fix mul (n0 m1 : nat) {struct n0} : nat :=
                               match n0 with
                               | 0%nat => 0%nat
                               | S p => (...) m1 (...)
                               end) n (pow n m0)
                        end) 2%nat
                       ((fix sub (n m : nat) {struct n} : nat :=
                           match n with
                           | 0%nat => n
                           | S k =>
                               match m with
                               | 0%nat => n
                               | S l => sub k l
                               end
                           end) eps
                          ((fix add (n m : nat) {struct n} : nat :=
                              match n with
                              | 0%nat => m
                              | S p => S (add p m)
                              end) n 1%nat))
                   with
                   | 0%nat =>
                       (fix pow (n m : nat) {struct m} : nat :=
                          match m with
                          | 0%nat => 1%nat
                          | S m0 =>
                              (fix mul (n0 m1 : nat) {struct n0} : nat :=
                                 match n0 with
                                 | 0%nat => 0%nat
                                 | S p =>
                                     (fix add ... : nat := ...
                                                 ...
                                                 ...
                                                 end) m1 
                                       (mul p m1)
                                 end) n (pow n m0)
                          end) 2%nat
                         ((fix sub (n m : nat) {struct n} : nat :=
                             match n with
                             | 0%nat => n
                             | S k =>
                                 match m with
                                 | 0%nat => n
                                 | S l => sub k l
                                 end
                             end) eps
                            ((fix add (n m : nat) {struct n} : nat :=
                                match n with
                                | 0%nat => m
                                | S p => S (add p m)
                                end) n 1%nat))
                   | S y' =>
                       let (x1, _) :=
                         (fix divmod (x1 y1 q u : nat) {struct x1} :
                              nat * nat :=
                            match x1 with
                            | 0%nat => (q, u)
                            | S x' =>
                                match u with
                                | 0%nat => divmod x' y1 (S q) y1
                                | S u' => divmod x' y1 q u'
                                end
                            end) y0 y' 0%nat y' in
                       x1
                   end 1%nat 0%nat 1%nat in
               x1)
           then
            match
              (fix pow (n m : nat) {struct m} : nat :=
                 match m with
                 | 0%nat => 1%nat
                 | S m0 =>
                     (fix mul (n0 m1 : nat) {struct n0} : nat :=
                        match n0 with
                        | 0%nat => 0%nat
                        | S p =>
                            (fix add (n1 m2 : nat) {struct n1} : nat :=
                               match n1 with
                               | 0%nat => m2
                               | S p0 => S (...)
                               end) m1 (mul p m1)
                        end) n (pow n m0)
                 end) 2%nat n
            with
            | 0%nat => false
            | S m' =>
                (fix leb (n m : nat) {struct n} : bool :=
                   match n with
                   | 0%nat => true
                   | S n' =>
                       match m with
                       | 0%nat => false
                       | S m'0 => leb n' m'0
                       end
                   end)
                  (let (x1, _) :=
                     (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                        match x1 with
                        | 0%nat => (q, u)
                        | S x' =>
                            match u with
                            | 0%nat => divmod x' y1 (S q) y1
                            | S u' => divmod x' y1 q u'
                            end
                        end)
                       match
                         (fix pow (n m : nat) {struct m} : nat :=
                            match m with
                            | 0%nat => 1%nat
                            | S m0 =>
                                (fix mul ... {struct n0} : nat :=
                                   match ... with
                                   | ... 0%nat
                                   | ... ...
                                   end) n (pow n m0)
                            end) 2%nat
                           ((fix sub (n m : nat) {struct n} : nat :=
                               match n with
                               | 0%nat => n
                               | S k =>
                                   match ... with
                                   | ... => n
                                   | ... => sub k l
                                   end
                               end) eps
                              ((fix add (n m : nat) {struct n} : nat :=
                                  match ... with
                                  | ... => m
                                  | ... => S ...
                                  end) n 1%nat))
                       with
                       | 0%nat =>
                           (fix pow (n m : nat) {struct m} : nat :=
                              match m with
                              | 0%nat => 1%nat
                              | S m0 =>
                                  (fix mul (n0 m1 : nat) {struct n0} : nat :=
                                     match n0 with
                                     | 0%nat => 0%nat
                                     | S p => (...) m1 (...)
                                     end) n (pow n m0)
                              end) 2%nat
                             ((fix sub (n m : nat) {struct n} : nat :=
                                 match n with
                                 | 0%nat => n
                                 | S k =>
                                     match m with
                                     | 0%nat => n
                                     | S l => sub k l
                                     end
                                 end) eps
                                ((fix add (n m : nat) {struct n} : nat :=
                                    match n with
                                    | 0%nat => m
                                    | S p => S (add p m)
                                    end) n 1%nat))
                       | S y' =>
                           let (x1, _) :=
                             (fix divmod (x1 y1 q u : nat) {struct x1} :
                                  nat * nat :=
                                match x1 with
                                | 0%nat => (q, u)
                                | S x' =>
                                    match u with
                                    | 0%nat => divmod x' y1 (S q) y1
                                    | S u' => divmod x' y1 q u'
                                    end
                                end) x0 y' 0%nat y' in
                           x1
                       end 1%nat 0%nat 1%nat in
                   x1) m'
            end
           else false
          then (R1, R0)
          else (R0, R0) in
        y1) *
       (let (_, y1) :=
          EQ
            match
              (let (_, y1) :=
                 (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                    match x1 with
                    | 0%nat => (q, u)
                    | S x' =>
                        match u with
                        | 0%nat => divmod x' y1 (S q) y1
                        | S u' => divmod x' y1 q u'
                        end
                    end)
                   match
                     (fix pow (n m : nat) {struct m} : nat :=
                        match m with
                        | 0%nat => 1%nat
                        | S m0 =>
                            (fix mul (n0 m1 : nat) {struct n0} : nat :=
                               match n0 with
                               | 0%nat => 0%nat
                               | S p => (...) m1 (...)
                               end) n (pow n m0)
                        end) 2%nat
                       ((fix sub (n m : nat) {struct n} : nat :=
                           match n with
                           | 0%nat => n
                           | S k =>
                               match m with
                               | 0%nat => n
                               | S l => sub k l
                               end
                           end) eps
                          ((fix add (n m : nat) {struct n} : nat :=
                              match n with
                              | 0%nat => m
                              | S p => S (add p m)
                              end) n 1%nat))
                   with
                   | 0%nat =>
                       (fix pow (n m : nat) {struct m} : nat :=
                          match m with
                          | 0%nat => 1%nat
                          | S m0 =>
                              (fix mul (n0 m1 : nat) {struct n0} : nat :=
                                 match n0 with
                                 | 0%nat => 0%nat
                                 | S p =>
                                     (fix add ... : nat := ...
                                                 ...
                                                 ...
                                                 end) m1 
                                       (mul p m1)
                                 end) n (pow n m0)
                          end) 2%nat
                         ((fix sub (n m : nat) {struct n} : nat :=
                             match n with
                             | 0%nat => n
                             | S k =>
                                 match m with
                                 | 0%nat => n
                                 | S l => sub k l
                                 end
                             end) eps
                            ((fix add (n m : nat) {struct n} : nat :=
                                match n with
                                | 0%nat => m
                                | S p => S (add p m)
                                end) n 1%nat))
                   | S y' =>
                       let (x1, _) :=
                         (fix divmod (x1 y1 q u : nat) {struct x1} :
                              nat * nat :=
                            match x1 with
                            | 0%nat => (q, u)
                            | S x' =>
                                match u with
                                | 0%nat => divmod x' y1 (S q) y1
                                | S u' => divmod x' y1 q u'
                                end
                            end) x0 y' 0%nat y' in
                       x1
                   end 1%nat 0%nat 1%nat in
               y1)
            with
            | 0%nat => 1%nat
            | S _ => 0%nat
            end
            match
              (let (_, y1) :=
                 (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                    match x1 with
                    | 0%nat => (q, u)
                    | S x' =>
                        match u with
                        | 0%nat => divmod x' y1 (S q) y1
                        | S u' => divmod x' y1 q u'
                        end
                    end)
                   match
                     (fix pow (n m : nat) {struct m} : nat :=
                        match m with
                        | 0%nat => 1%nat
                        | S m0 =>
                            (fix mul (n0 m1 : nat) {struct n0} : nat :=
                               match n0 with
                               | 0%nat => 0%nat
                               | S p => (...) m1 (...)
                               end) n (pow n m0)
                        end) 2%nat
                       ((fix sub (n m : nat) {struct n} : nat :=
                           match n with
                           | 0%nat => n
                           | S k =>
                               match m with
                               | 0%nat => n
                               | S l => sub k l
                               end
                           end) eps
                          ((fix add (n m : nat) {struct n} : nat :=
                              match n with
                              | 0%nat => m
                              | S p => S (add p m)
                              end) n 1%nat))
                   with
                   | 0%nat =>
                       (fix pow (n m : nat) {struct m} : nat :=
                          match m with
                          | 0%nat => 1%nat
                          | S m0 =>
                              (fix mul (n0 m1 : nat) {struct n0} : nat :=
                                 match n0 with
                                 | 0%nat => 0%nat
                                 | S p =>
                                     (fix add ... : nat := ...
                                                 ...
                                                 ...
                                                 end) m1 
                                       (mul p m1)
                                 end) n (pow n m0)
                          end) 2%nat
                         ((fix sub (n m : nat) {struct n} : nat :=
                             match n with
                             | 0%nat => n
                             | S k =>
                                 match m with
                                 | 0%nat => n
                                 | S l => sub k l
                                 end
                             end) eps
                            ((fix add (n m : nat) {struct n} : nat :=
                                match n with
                                | 0%nat => m
                                | S p => S (add p m)
                                end) n 1%nat))
                   | S y' =>
                       let (x1, _) :=
                         (fix divmod (x1 y1 q u : nat) {struct x1} :
                              nat * nat :=
                            match x1 with
                            | 0%nat => (q, u)
                            | S x' =>
                                match u with
                                | 0%nat => divmod x' y1 (S q) y1
                                | S u' => divmod x' y1 q u'
                                end
                            end) y0 y' 0%nat y' in
                       x1
                   end 1%nat 0%nat 1%nat in
               y1)
            with
            | 0%nat => 1%nat
            | S _ => 0%nat
            end in
        y1))) *
     (let (x1, _) :=
        if
         if
          (fix eqb (n m : nat) {struct n} : bool :=
             match n with
             | 0%nat => match m with
                        | 0%nat => true
                        | S _ => false
                        end
             | S n' => match m with
                       | 0%nat => false
                       | S m' => eqb n' m'
                       end
             end)
            match
              (fix pow (n m : nat) {struct m} : nat :=
                 match m with
                 | 0%nat => 1%nat
                 | S m0 =>
                     (fix mul (n0 m1 : nat) {struct n0} : nat :=
                        match n0 with
                        | 0%nat => 0%nat
                        | S p =>
                            (fix add (n1 m2 : nat) {struct n1} : nat :=
                               match n1 with
                               | 0%nat => m2
                               | S p0 => S (add p0 m2)
                               end) m1 (mul p m1)
                        end) n (pow n m0)
                 end) 2%nat
                ((fix sub (n m : nat) {struct n} : nat :=
                    match n with
                    | 0%nat => n
                    | S k => match m with
                             | 0%nat => n
                             | S l => sub k l
                             end
                    end) eps
                   ((fix add (n m : nat) {struct n} : nat :=
                       match n with
                       | 0%nat => m
                       | S p => S (add p m)
                       end) n 1%nat))
            with
            | 0%nat => x0
            | S y' =>
                (fix sub (n m : nat) {struct n} : nat :=
                   match n with
                   | 0%nat => n
                   | S k => match m with
                            | 0%nat => n
                            | S l => sub k l
                            end
                   end) y'
                  (let (_, y1) :=
                     (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                        match x1 with
                        | 0%nat => (q, u)
                        | S x' =>
                            match u with
                            | 0%nat => divmod x' y1 (S q) y1
                            | S u' => divmod x' y1 q u'
                            end
                        end) x0 y' 0%nat y' in
                   y1)
            end
            match
              (fix pow (n m : nat) {struct m} : nat :=
                 match m with
                 | 0%nat => 1%nat
                 | S m0 =>
                     (fix mul (n0 m1 : nat) {struct n0} : nat :=
                        match n0 with
                        | 0%nat => 0%nat
                        | S p =>
                            (fix add (n1 m2 : nat) {struct n1} : nat :=
                               match n1 with
                               | 0%nat => m2
                               | S p0 => S (add p0 m2)
                               end) m1 (mul p m1)
                        end) n (pow n m0)
                 end) 2%nat
                ((fix sub (n m : nat) {struct n} : nat :=
                    match n with
                    | 0%nat => n
                    | S k => match m with
                             | 0%nat => n
                             | S l => sub k l
                             end
                    end) eps
                   ((fix add (n m : nat) {struct n} : nat :=
                       match n with
                       | 0%nat => m
                       | S p => S (add p m)
                       end) n 1%nat))
            with
            | 0%nat => y0
            | S y' =>
                (fix sub (n m : nat) {struct n} : nat :=
                   match n with
                   | 0%nat => n
                   | S k => match m with
                            | 0%nat => n
                            | S l => sub k l
                            end
                   end) y'
                  (let (_, y1) :=
                     (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                        match x1 with
                        | 0%nat => (q, u)
                        | S x' =>
                            match u with
                            | 0%nat => divmod x' y1 (S q) y1
                            | S u' => divmod x' y1 q u'
                            end
                        end) y0 y' 0%nat y' in
                   y1)
            end
         then
          match
            (fix pow (n m : nat) {struct m} : nat :=
               match m with
               | 0%nat => 1%nat
               | S m0 =>
                   (fix mul (n0 m1 : nat) {struct n0} : nat :=
                      match n0 with
                      | 0%nat => 0%nat
                      | S p =>
                          (fix add (n1 m2 : nat) {struct n1} : nat :=
                             match n1 with
                             | 0%nat => m2
                             | S p0 => S (add p0 m2)
                             end) m1 (mul p m1)
                      end) n (pow n m0)
               end) 2%nat
              ((fix sub (n m : nat) {struct n} : nat :=
                  match n with
                  | 0%nat => n
                  | S k => match m with
                           | 0%nat => n
                           | S l => sub k l
                           end
                  end) eps
                 ((fix add (n m : nat) {struct n} : nat :=
                     match n with
                     | 0%nat => m
                     | S p => S (add p m)
                     end) n 1%nat))
          with
          | 0%nat => false
          | S m' =>
              (fix leb (n m : nat) {struct n} : bool :=
                 match n with
                 | 0%nat => true
                 | S n' =>
                     match m with
                     | 0%nat => false
                     | S m'0 => leb n' m'0
                     end
                 end)
                match
                  (fix pow (n m : nat) {struct m} : nat :=
                     match m with
                     | 0%nat => 1%nat
                     | S m0 =>
                         (fix mul (n0 m1 : nat) {struct n0} : nat :=
                            match n0 with
                            | 0%nat => 0%nat
                            | S p =>
                                (fix add (n1 m2 : nat) {struct n1} : nat :=
                                   match n1 with
                                   | 0%nat => m2
                                   | S p0 => S (add p0 m2)
                                   end) m1 (mul p m1)
                            end) n (pow n m0)
                     end) 2%nat
                    ((fix sub (n m : nat) {struct n} : nat :=
                        match n with
                        | 0%nat => n
                        | S k =>
                            match m with
                            | 0%nat => n
                            | S l => sub k l
                            end
                        end) eps
                       ((fix add (n m : nat) {struct n} : nat :=
                           match n with
                           | 0%nat => m
                           | S p => S (add p m)
                           end) n 1%nat))
                with
                | 0%nat => x0
                | S y' =>
                    (fix sub (n m : nat) {struct n} : nat :=
                       match n with
                       | 0%nat => n
                       | S k =>
                           match m with
                           | 0%nat => n
                           | S l => sub k l
                           end
                       end) y'
                      (let (_, y1) :=
                         (fix divmod (x1 y1 q u : nat) {struct x1} :
                              nat * nat :=
                            match x1 with
                            | 0%nat => (q, u)
                            | S x' =>
                                match u with
                                | 0%nat => divmod x' y1 (S q) y1
                                | S u' => divmod x' y1 q u'
                                end
                            end) x0 y' 0%nat y' in
                       y1)
                end m'
          end
         else false
        then (R1, R0)
        else (R0, R0) in
      x1) +
     -
     (((let (x1, _) :=
          if
           if
            (fix eqb (n m : nat) {struct n} : bool :=
               match n with
               | 0%nat => match m with
                          | 0%nat => true
                          | S _ => false
                          end
               | S n' =>
                   match m with
                   | 0%nat => false
                   | S m' => eqb n' m'
                   end
               end)
              (let (x1, _) :=
                 (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                    match x1 with
                    | 0%nat => (q, u)
                    | S x' =>
                        match u with
                        | 0%nat => divmod x' y1 (S q) y1
                        | S u' => divmod x' y1 q u'
                        end
                    end)
                   match
                     (fix pow (n m : nat) {struct m} : nat :=
                        match m with
                        | 0%nat => 1%nat
                        | S m0 =>
                            (fix mul (n0 m1 : nat) {struct n0} : nat :=
                               match n0 with
                               | 0%nat => 0%nat
                               | S p => (...) m1 (...)
                               end) n (pow n m0)
                        end) 2%nat
                       ((fix sub (n m : nat) {struct n} : nat :=
                           match n with
                           | 0%nat => n
                           | S k =>
                               match m with
                               | 0%nat => n
                               | S l => sub k l
                               end
                           end) eps
                          ((fix add (n m : nat) {struct n} : nat :=
                              match n with
                              | 0%nat => m
                              | S p => S (add p m)
                              end) n 1%nat))
                   with
                   | 0%nat =>
                       (fix pow (n m : nat) {struct m} : nat :=
                          match m with
                          | 0%nat => 1%nat
                          | S m0 =>
                              (fix mul (n0 m1 : nat) {struct n0} : nat :=
                                 match n0 with
                                 | 0%nat => 0%nat
                                 | S p =>
                                     (fix add ... : nat := ...
                                                 ...
                                                 ...
                                                 end) m1 
                                       (mul p m1)
                                 end) n (pow n m0)
                          end) 2%nat
                         ((fix sub (n m : nat) {struct n} : nat :=
                             match n with
                             | 0%nat => n
                             | S k =>
                                 match m with
                                 | 0%nat => n
                                 | S l => sub k l
                                 end
                             end) eps
                            ((fix add (n m : nat) {struct n} : nat :=
                                match n with
                                | 0%nat => m
                                | S p => S (add p m)
                                end) n 1%nat))
                   | S y' =>
                       let (x1, _) :=
                         (fix divmod (x1 y1 q u : nat) {struct x1} :
                              nat * nat :=
                            match x1 with
                            | 0%nat => (q, u)
                            | S x' =>
                                match u with
                                | 0%nat => divmod x' y1 (S q) y1
                                | S u' => divmod x' y1 q u'
                                end
                            end) x0 y' 0%nat y' in
                       x1
                   end 1%nat 0%nat 1%nat in
               x1)
              (let (x1, _) :=
                 (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                    match x1 with
                    | 0%nat => (q, u)
                    | S x' =>
                        match u with
                        | 0%nat => divmod x' y1 (S q) y1
                        | S u' => divmod x' y1 q u'
                        end
                    end)
                   match
                     (fix pow (n m : nat) {struct m} : nat :=
                        match m with
                        | 0%nat => 1%nat
                        | S m0 =>
                            (fix mul (n0 m1 : nat) {struct n0} : nat :=
                               match n0 with
                               | 0%nat => 0%nat
                               | S p => (...) m1 (...)
                               end) n (pow n m0)
                        end) 2%nat
                       ((fix sub (n m : nat) {struct n} : nat :=
                           match n with
                           | 0%nat => n
                           | S k =>
                               match m with
                               | 0%nat => n
                               | S l => sub k l
                               end
                           end) eps
                          ((fix add (n m : nat) {struct n} : nat :=
                              match n with
                              | 0%nat => m
                              | S p => S (add p m)
                              end) n 1%nat))
                   with
                   | 0%nat =>
                       (fix pow (n m : nat) {struct m} : nat :=
                          match m with
                          | 0%nat => 1%nat
                          | S m0 =>
                              (fix mul (n0 m1 : nat) {struct n0} : nat :=
                                 match n0 with
                                 | 0%nat => 0%nat
                                 | S p =>
                                     (fix add ... : nat := ...
                                                 ...
                                                 ...
                                                 end) m1 
                                       (mul p m1)
                                 end) n (pow n m0)
                          end) 2%nat
                         ((fix sub (n m : nat) {struct n} : nat :=
                             match n with
                             | 0%nat => n
                             | S k =>
                                 match m with
                                 | 0%nat => n
                                 | S l => sub k l
                                 end
                             end) eps
                            ((fix add (n m : nat) {struct n} : nat :=
                                match n with
                                | 0%nat => m
                                | S p => S (add p m)
                                end) n 1%nat))
                   | S y' =>
                       let (x1, _) :=
                         (fix divmod (x1 y1 q u : nat) {struct x1} :
                              nat * nat :=
                            match x1 with
                            | 0%nat => (q, u)
                            | S x' =>
                                match u with
                                | 0%nat => divmod x' y1 (S q) y1
                                | S u' => divmod x' y1 q u'
                                end
                            end) y0 y' 0%nat y' in
                       x1
                   end 1%nat 0%nat 1%nat in
               x1)
           then
            match
              (fix pow (n m : nat) {struct m} : nat :=
                 match m with
                 | 0%nat => 1%nat
                 | S m0 =>
                     (fix mul (n0 m1 : nat) {struct n0} : nat :=
                        match n0 with
                        | 0%nat => 0%nat
                        | S p =>
                            (fix add (n1 m2 : nat) {struct n1} : nat :=
                               match n1 with
                               | 0%nat => m2
                               | S p0 => S (...)
                               end) m1 (mul p m1)
                        end) n (pow n m0)
                 end) 2%nat n
            with
            | 0%nat => false
            | S m' =>
                (fix leb (n m : nat) {struct n} : bool :=
                   match n with
                   | 0%nat => true
                   | S n' =>
                       match m with
                       | 0%nat => false
                       | S m'0 => leb n' m'0
                       end
                   end)
                  (let (x1, _) :=
                     (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                        match x1 with
                        | 0%nat => (q, u)
                        | S x' =>
                            match u with
                            | 0%nat => divmod x' y1 (S q) y1
                            | S u' => divmod x' y1 q u'
                            end
                        end)
                       match
                         (fix pow (n m : nat) {struct m} : nat :=
                            match m with
                            | 0%nat => 1%nat
                            | S m0 =>
                                (fix mul ... {struct n0} : nat :=
                                   match ... with
                                   | ... 0%nat
                                   | ... ...
                                   end) n (pow n m0)
                            end) 2%nat
                           ((fix sub (n m : nat) {struct n} : nat :=
                               match n with
                               | 0%nat => n
                               | S k =>
                                   match ... with
                                   | ... => n
                                   | ... => sub k l
                                   end
                               end) eps
                              ((fix add (n m : nat) {struct n} : nat :=
                                  match ... with
                                  | ... => m
                                  | ... => S ...
                                  end) n 1%nat))
                       with
                       | 0%nat =>
                           (fix pow (n m : nat) {struct m} : nat :=
                              match m with
                              | 0%nat => 1%nat
                              | S m0 =>
                                  (fix mul (n0 m1 : nat) {struct n0} : nat :=
                                     match n0 with
                                     | 0%nat => 0%nat
                                     | S p => (...) m1 (...)
                                     end) n (pow n m0)
                              end) 2%nat
                             ((fix sub (n m : nat) {struct n} : nat :=
                                 match n with
                                 | 0%nat => n
                                 | S k =>
                                     match m with
                                     | 0%nat => n
                                     | S l => sub k l
                                     end
                                 end) eps
                                ((fix add (n m : nat) {struct n} : nat :=
                                    match n with
                                    | 0%nat => m
                                    | S p => S (add p m)
                                    end) n 1%nat))
                       | S y' =>
                           let (x1, _) :=
                             (fix divmod (x1 y1 q u : nat) {struct x1} :
                                  nat * nat :=
                                match x1 with
                                | 0%nat => (q, u)
                                | S x' =>
                                    match u with
                                    | 0%nat => divmod x' y1 (S q) y1
                                    | S u' => divmod x' y1 q u'
                                    end
                                end) x0 y' 0%nat y' in
                           x1
                       end 1%nat 0%nat 1%nat in
                   x1) m'
            end
           else false
          then (R1, R0)
          else (R0, R0) in
        x1) *
       (let (_, y1) :=
          EQ
            match
              (let (_, y1) :=
                 (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                    match x1 with
                    | 0%nat => (q, u)
                    | S x' =>
                        match u with
                        | 0%nat => divmod x' y1 (S q) y1
                        | S u' => divmod x' y1 q u'
                        end
                    end)
                   match
                     (fix pow (n m : nat) {struct m} : nat :=
                        match m with
                        | 0%nat => 1%nat
                        | S m0 =>
                            (fix mul (n0 m1 : nat) {struct n0} : nat :=
                               match n0 with
                               | 0%nat => 0%nat
                               | S p => (...) m1 (...)
                               end) n (pow n m0)
                        end) 2%nat
                       ((fix sub (n m : nat) {struct n} : nat :=
                           match n with
                           | 0%nat => n
                           | S k =>
                               match m with
                               | 0%nat => n
                               | S l => sub k l
                               end
                           end) eps
                          ((fix add (n m : nat) {struct n} : nat :=
                              match n with
                              | 0%nat => m
                              | S p => S (add p m)
                              end) n 1%nat))
                   with
                   | 0%nat =>
                       (fix pow (n m : nat) {struct m} : nat :=
                          match m with
                          | 0%nat => 1%nat
                          | S m0 =>
                              (fix mul (n0 m1 : nat) {struct n0} : nat :=
                                 match n0 with
                                 | 0%nat => 0%nat
                                 | S p =>
                                     (fix add ... : nat := ...
                                                 ...
                                                 ...
                                                 end) m1 
                                       (mul p m1)
                                 end) n (pow n m0)
                          end) 2%nat
                         ((fix sub (n m : nat) {struct n} : nat :=
                             match n with
                             | 0%nat => n
                             | S k =>
                                 match m with
                                 | 0%nat => n
                                 | S l => sub k l
                                 end
                             end) eps
                            ((fix add (n m : nat) {struct n} : nat :=
                                match n with
                                | 0%nat => m
                                | S p => S (add p m)
                                end) n 1%nat))
                   | S y' =>
                       let (x1, _) :=
                         (fix divmod (x1 y1 q u : nat) {struct x1} :
                              nat * nat :=
                            match x1 with
                            | 0%nat => (q, u)
                            | S x' =>
                                match u with
                                | 0%nat => divmod x' y1 (S q) y1
                                | S u' => divmod x' y1 q u'
                                end
                            end) x0 y' 0%nat y' in
                       x1
                   end 1%nat 0%nat 1%nat in
               y1)
            with
            | 0%nat => 1%nat
            | S _ => 0%nat
            end
            match
              (let (_, y1) :=
                 (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                    match x1 with
                    | 0%nat => (q, u)
                    | S x' =>
                        match u with
                        | 0%nat => divmod x' y1 (S q) y1
                        | S u' => divmod x' y1 q u'
                        end
                    end)
                   match
                     (fix pow (n m : nat) {struct m} : nat :=
                        match m with
                        | 0%nat => 1%nat
                        | S m0 =>
                            (fix mul (n0 m1 : nat) {struct n0} : nat :=
                               match n0 with
                               | 0%nat => 0%nat
                               | S p => (...) m1 (...)
                               end) n (pow n m0)
                        end) 2%nat
                       ((fix sub (n m : nat) {struct n} : nat :=
                           match n with
                           | 0%nat => n
                           | S k =>
                               match m with
                               | 0%nat => n
                               | S l => sub k l
                               end
                           end) eps
                          ((fix add (n m : nat) {struct n} : nat :=
                              match n with
                              | 0%nat => m
                              | S p => S (add p m)
                              end) n 1%nat))
                   with
                   | 0%nat =>
                       (fix pow (n m : nat) {struct m} : nat :=
                          match m with
                          | 0%nat => 1%nat
                          | S m0 =>
                              (fix mul (n0 m1 : nat) {struct n0} : nat :=
                                 match n0 with
                                 | 0%nat => 0%nat
                                 | S p =>
                                     (fix add ... : nat := ...
                                                 ...
                                                 ...
                                                 end) m1 
                                       (mul p m1)
                                 end) n (pow n m0)
                          end) 2%nat
                         ((fix sub (n m : nat) {struct n} : nat :=
                             match n with
                             | 0%nat => n
                             | S k =>
                                 match m with
                                 | 0%nat => n
                                 | S l => sub k l
                                 end
                             end) eps
                            ((fix add (n m : nat) {struct n} : nat :=
                                match n with
                                | 0%nat => m
                                | S p => S (add p m)
                                end) n 1%nat))
                   | S y' =>
                       let (x1, _) :=
                         (fix divmod (x1 y1 q u : nat) {struct x1} :
                              nat * nat :=
                            match x1 with
                            | 0%nat => (q, u)
                            | S x' =>
                                match u with
                                | 0%nat => divmod x' y1 (S q) y1
                                | S u' => divmod x' y1 q u'
                                end
                            end) y0 y' 0%nat y' in
                       x1
                   end 1%nat 0%nat 1%nat in
               y1)
            with
            | 0%nat => 1%nat
            | S _ => 0%nat
            end in
        y1) +
       (let (_, y1) :=
          if
           if
            (fix eqb (n m : nat) {struct n} : bool :=
               match n with
               | 0%nat => match m with
                          | 0%nat => true
                          | S _ => false
                          end
               | S n' =>
                   match m with
                   | 0%nat => false
                   | S m' => eqb n' m'
                   end
               end)
              (let (x1, _) :=
                 (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                    match x1 with
                    | 0%nat => (q, u)
                    | S x' =>
                        match u with
                        | 0%nat => divmod x' y1 (S q) y1
                        | S u' => divmod x' y1 q u'
                        end
                    end)
                   match
                     (fix pow (n m : nat) {struct m} : nat :=
                        match m with
                        | 0%nat => 1%nat
                        | S m0 =>
                            (fix mul (n0 m1 : nat) {struct n0} : nat :=
                               match n0 with
                               | 0%nat => 0%nat
                               | S p => (...) m1 (...)
                               end) n (pow n m0)
                        end) 2%nat
                       ((fix sub (n m : nat) {struct n} : nat :=
                           match n with
                           | 0%nat => n
                           | S k =>
                               match m with
                               | 0%nat => n
                               | S l => sub k l
                               end
                           end) eps
                          ((fix add (n m : nat) {struct n} : nat :=
                              match n with
                              | 0%nat => m
                              | S p => S (add p m)
                              end) n 1%nat))
                   with
                   | 0%nat =>
                       (fix pow (n m : nat) {struct m} : nat :=
                          match m with
                          | 0%nat => 1%nat
                          | S m0 =>
                              (fix mul (n0 m1 : nat) {struct n0} : nat :=
                                 match n0 with
                                 | 0%nat => 0%nat
                                 | S p =>
                                     (fix add ... : nat := ...
                                                 ...
                                                 ...
                                                 end) m1 
                                       (mul p m1)
                                 end) n (pow n m0)
                          end) 2%nat
                         ((fix sub (n m : nat) {struct n} : nat :=
                             match n with
                             | 0%nat => n
                             | S k =>
                                 match m with
                                 | 0%nat => n
                                 | S l => sub k l
                                 end
                             end) eps
                            ((fix add (n m : nat) {struct n} : nat :=
                                match n with
                                | 0%nat => m
                                | S p => S (add p m)
                                end) n 1%nat))
                   | S y' =>
                       let (x1, _) :=
                         (fix divmod (x1 y1 q u : nat) {struct x1} :
                              nat * nat :=
                            match x1 with
                            | 0%nat => (q, u)
                            | S x' =>
                                match u with
                                | 0%nat => divmod x' y1 (S q) y1
                                | S u' => divmod x' y1 q u'
                                end
                            end) x0 y' 0%nat y' in
                       x1
                   end 1%nat 0%nat 1%nat in
               x1)
              (let (x1, _) :=
                 (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                    match x1 with
                    | 0%nat => (q, u)
                    | S x' =>
                        match u with
                        | 0%nat => divmod x' y1 (S q) y1
                        | S u' => divmod x' y1 q u'
                        end
                    end)
                   match
                     (fix pow (n m : nat) {struct m} : nat :=
                        match m with
                        | 0%nat => 1%nat
                        | S m0 =>
                            (fix mul (n0 m1 : nat) {struct n0} : nat :=
                               match n0 with
                               | 0%nat => 0%nat
                               | S p => (...) m1 (...)
                               end) n (pow n m0)
                        end) 2%nat
                       ((fix sub (n m : nat) {struct n} : nat :=
                           match n with
                           | 0%nat => n
                           | S k =>
                               match m with
                               | 0%nat => n
                               | S l => sub k l
                               end
                           end) eps
                          ((fix add (n m : nat) {struct n} : nat :=
                              match n with
                              | 0%nat => m
                              | S p => S (add p m)
                              end) n 1%nat))
                   with
                   | 0%nat =>
                       (fix pow (n m : nat) {struct m} : nat :=
                          match m with
                          | 0%nat => 1%nat
                          | S m0 =>
                              (fix mul (n0 m1 : nat) {struct n0} : nat :=
                                 match n0 with
                                 | 0%nat => 0%nat
                                 | S p =>
                                     (fix add ... : nat := ...
                                                 ...
                                                 ...
                                                 end) m1 
                                       (mul p m1)
                                 end) n (pow n m0)
                          end) 2%nat
                         ((fix sub (n m : nat) {struct n} : nat :=
                             match n with
                             | 0%nat => n
                             | S k =>
                                 match m with
                                 | 0%nat => n
                                 | S l => sub k l
                                 end
                             end) eps
                            ((fix add (n m : nat) {struct n} : nat :=
                                match n with
                                | 0%nat => m
                                | S p => S (add p m)
                                end) n 1%nat))
                   | S y' =>
                       let (x1, _) :=
                         (fix divmod (x1 y1 q u : nat) {struct x1} :
                              nat * nat :=
                            match x1 with
                            | 0%nat => (q, u)
                            | S x' =>
                                match u with
                                | 0%nat => divmod x' y1 (S q) y1
                                | S u' => divmod x' y1 q u'
                                end
                            end) y0 y' 0%nat y' in
                       x1
                   end 1%nat 0%nat 1%nat in
               x1)
           then
            match
              (fix pow (n m : nat) {struct m} : nat :=
                 match m with
                 | 0%nat => 1%nat
                 | S m0 =>
                     (fix mul (n0 m1 : nat) {struct n0} : nat :=
                        match n0 with
                        | 0%nat => 0%nat
                        | S p =>
                            (fix add (n1 m2 : nat) {struct n1} : nat :=
                               match n1 with
                               | 0%nat => m2
                               | S p0 => S (...)
                               end) m1 (mul p m1)
                        end) n (pow n m0)
                 end) 2%nat n
            with
            | 0%nat => false
            | S m' =>
                (fix leb (n m : nat) {struct n} : bool :=
                   match n with
                   | 0%nat => true
                   | S n' =>
                       match m with
                       | 0%nat => false
                       | S m'0 => leb n' m'0
                       end
                   end)
                  (let (x1, _) :=
                     (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                        match x1 with
                        | 0%nat => (q, u)
                        | S x' =>
                            match u with
                            | 0%nat => divmod x' y1 (S q) y1
                            | S u' => divmod x' y1 q u'
                            end
                        end)
                       match
                         (fix pow (n m : nat) {struct m} : nat :=
                            match m with
                            | 0%nat => 1%nat
                            | S m0 =>
                                (fix mul ... {struct n0} : nat :=
                                   match ... with
                                   | ... 0%nat
                                   | ... ...
                                   end) n (pow n m0)
                            end) 2%nat
                           ((fix sub (n m : nat) {struct n} : nat :=
                               match n with
                               | 0%nat => n
                               | S k =>
                                   match ... with
                                   | ... => n
                                   | ... => sub k l
                                   end
                               end) eps
                              ((fix add (n m : nat) {struct n} : nat :=
                                  match ... with
                                  | ... => m
                                  | ... => S ...
                                  end) n 1%nat))
                       with
                       | 0%nat =>
                           (fix pow (n m : nat) {struct m} : nat :=
                              match m with
                              | 0%nat => 1%nat
                              | S m0 =>
                                  (fix mul (n0 m1 : nat) {struct n0} : nat :=
                                     match n0 with
                                     | 0%nat => 0%nat
                                     | S p => (...) m1 (...)
                                     end) n (pow n m0)
                              end) 2%nat
                             ((fix sub (n m : nat) {struct n} : nat :=
                                 match n with
                                 | 0%nat => n
                                 | S k =>
                                     match m with
                                     | 0%nat => n
                                     | S l => sub k l
                                     end
                                 end) eps
                                ((fix add (n m : nat) {struct n} : nat :=
                                    match n with
                                    | 0%nat => m
                                    | S p => S (add p m)
                                    end) n 1%nat))
                       | S y' =>
                           let (x1, _) :=
                             (fix divmod (x1 y1 q u : nat) {struct x1} :
                                  nat * nat :=
                                match x1 with
                                | 0%nat => (q, u)
                                | S x' =>
                                    match u with
                                    | 0%nat => divmod x' y1 (S q) y1
                                    | S u' => divmod x' y1 q u'
                                    end
                                end) x0 y' 0%nat y' in
                           x1
                       end 1%nat 0%nat 1%nat in
                   x1) m'
            end
           else false
          then (R1, R0)
          else (R0, R0) in
        y1) *
       (let (x1, _) :=
          EQ
            match
              (let (_, y1) :=
                 (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                    match x1 with
                    | 0%nat => (q, u)
                    | S x' =>
                        match u with
                        | 0%nat => divmod x' y1 (S q) y1
                        | S u' => divmod x' y1 q u'
                        end
                    end)
                   match
                     (fix pow (n m : nat) {struct m} : nat :=
                        match m with
                        | 0%nat => 1%nat
                        | S m0 =>
                            (fix mul (n0 m1 : nat) {struct n0} : nat :=
                               match n0 with
                               | 0%nat => 0%nat
                               | S p => (...) m1 (...)
                               end) n (pow n m0)
                        end) 2%nat
                       ((fix sub (n m : nat) {struct n} : nat :=
                           match n with
                           | 0%nat => n
                           | S k =>
                               match m with
                               | 0%nat => n
                               | S l => sub k l
                               end
                           end) eps
                          ((fix add (n m : nat) {struct n} : nat :=
                              match n with
                              | 0%nat => m
                              | S p => S (add p m)
                              end) n 1%nat))
                   with
                   | 0%nat =>
                       (fix pow (n m : nat) {struct m} : nat :=
                          match m with
                          | 0%nat => 1%nat
                          | S m0 =>
                              (fix mul (n0 m1 : nat) {struct n0} : nat :=
                                 match n0 with
                                 | 0%nat => 0%nat
                                 | S p =>
                                     (fix add ... : nat := ...
                                                 ...
                                                 ...
                                                 end) m1 
                                       (mul p m1)
                                 end) n (pow n m0)
                          end) 2%nat
                         ((fix sub (n m : nat) {struct n} : nat :=
                             match n with
                             | 0%nat => n
                             | S k =>
                                 match m with
                                 | 0%nat => n
                                 | S l => sub k l
                                 end
                             end) eps
                            ((fix add (n m : nat) {struct n} : nat :=
                                match n with
                                | 0%nat => m
                                | S p => S (add p m)
                                end) n 1%nat))
                   | S y' =>
                       let (x1, _) :=
                         (fix divmod (x1 y1 q u : nat) {struct x1} :
                              nat * nat :=
                            match x1 with
                            | 0%nat => (q, u)
                            | S x' =>
                                match u with
                                | 0%nat => divmod x' y1 (S q) y1
                                | S u' => divmod x' y1 q u'
                                end
                            end) x0 y' 0%nat y' in
                       x1
                   end 1%nat 0%nat 1%nat in
               y1)
            with
            | 0%nat => 1%nat
            | S _ => 0%nat
            end
            match
              (let (_, y1) :=
                 (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                    match x1 with
                    | 0%nat => (q, u)
                    | S x' =>
                        match u with
                        | 0%nat => divmod x' y1 (S q) y1
                        | S u' => divmod x' y1 q u'
                        end
                    end)
                   match
                     (fix pow (n m : nat) {struct m} : nat :=
                        match m with
                        | 0%nat => 1%nat
                        | S m0 =>
                            (fix mul (n0 m1 : nat) {struct n0} : nat :=
                               match n0 with
                               | 0%nat => 0%nat
                               | S p => (...) m1 (...)
                               end) n (pow n m0)
                        end) 2%nat
                       ((fix sub (n m : nat) {struct n} : nat :=
                           match n with
                           | 0%nat => n
                           | S k =>
                               match m with
                               | 0%nat => n
                               | S l => sub k l
                               end
                           end) eps
                          ((fix add (n m : nat) {struct n} : nat :=
                              match n with
                              | 0%nat => m
                              | S p => S (add p m)
                              end) n 1%nat))
                   with
                   | 0%nat =>
                       (fix pow (n m : nat) {struct m} : nat :=
                          match m with
                          | 0%nat => 1%nat
                          | S m0 =>
                              (fix mul (n0 m1 : nat) {struct n0} : nat :=
                                 match n0 with
                                 | 0%nat => 0%nat
                                 | S p =>
                                     (fix add ... : nat := ...
                                                 ...
                                                 ...
                                                 end) m1 
                                       (mul p m1)
                                 end) n (pow n m0)
                          end) 2%nat
                         ((fix sub (n m : nat) {struct n} : nat :=
                             match n with
                             | 0%nat => n
                             | S k =>
                                 match m with
                                 | 0%nat => n
                                 | S l => sub k l
                                 end
                             end) eps
                            ((fix add (n m : nat) {struct n} : nat :=
                                match n with
                                | 0%nat => m
                                | S p => S (add p m)
                                end) n 1%nat))
                   | S y' =>
                       let (x1, _) :=
                         (fix divmod (x1 y1 q u : nat) {struct x1} :
                              nat * nat :=
                            match x1 with
                            | 0%nat => (q, u)
                            | S x' =>
                                match u with
                                | 0%nat => divmod x' y1 (S q) y1
                                | S u' => divmod x' y1 q u'
                                end
                            end) y0 y' 0%nat y' in
                       x1
                   end 1%nat 0%nat 1%nat in
               y1)
            with
            | 0%nat => 1%nat
            | S _ => 0%nat
            end in
        x1)) *
      (let (_, y1) :=
         if
          if
           (fix eqb (n m : nat) {struct n} : bool :=
              match n with
              | 0%nat => match m with
                         | 0%nat => true
                         | S _ => false
                         end
              | S n' => match m with
                        | 0%nat => false
                        | S m' => eqb n' m'
                        end
              end)
             match
               (fix pow (n m : nat) {struct m} : nat :=
                  match m with
                  | 0%nat => 1%nat
                  | S m0 =>
                      (fix mul (n0 m1 : nat) {struct n0} : nat :=
                         match n0 with
                         | 0%nat => 0%nat
                         | S p =>
                             (fix add (n1 m2 : nat) {struct n1} : nat :=
                                match n1 with
                                | 0%nat => m2
                                | S p0 => S (add p0 m2)
                                end) m1 (mul p m1)
                         end) n (pow n m0)
                  end) 2%nat
                 ((fix sub (n m : nat) {struct n} : nat :=
                     match n with
                     | 0%nat => n
                     | S k => match m with
                              | 0%nat => n
                              | S l => sub k l
                              end
                     end) eps
                    ((fix add (n m : nat) {struct n} : nat :=
                        match n with
                        | 0%nat => m
                        | S p => S (add p m)
                        end) n 1%nat))
             with
             | 0%nat => x0
             | S y' =>
                 (fix sub (n m : nat) {struct n} : nat :=
                    match n with
                    | 0%nat => n
                    | S k => match m with
                             | 0%nat => n
                             | S l => sub k l
                             end
                    end) y'
                   (let (_, y1) :=
                      (fix divmod (x1 y1 q u : nat) {struct x1} :
                           nat * nat :=
                         match x1 with
                         | 0%nat => (q, u)
                         | S x' =>
                             match u with
                             | 0%nat => divmod x' y1 (S q) y1
                             | S u' => divmod x' y1 q u'
                             end
                         end) x0 y' 0%nat y' in
                    y1)
             end
             match
               (fix pow (n m : nat) {struct m} : nat :=
                  match m with
                  | 0%nat => 1%nat
                  | S m0 =>
                      (fix mul (n0 m1 : nat) {struct n0} : nat :=
                         match n0 with
                         | 0%nat => 0%nat
                         | S p =>
                             (fix add (n1 m2 : nat) {struct n1} : nat :=
                                match n1 with
                                | 0%nat => m2
                                | S p0 => S (add p0 m2)
                                end) m1 (mul p m1)
                         end) n (pow n m0)
                  end) 2%nat
                 ((fix sub (n m : nat) {struct n} : nat :=
                     match n with
                     | 0%nat => n
                     | S k => match m with
                              | 0%nat => n
                              | S l => sub k l
                              end
                     end) eps
                    ((fix add (n m : nat) {struct n} : nat :=
                        match n with
                        | 0%nat => m
                        | S p => S (add p m)
                        end) n 1%nat))
             with
             | 0%nat => y0
             | S y' =>
                 (fix sub (n m : nat) {struct n} : nat :=
                    match n with
                    | 0%nat => n
                    | S k => match m with
                             | 0%nat => n
                             | S l => sub k l
                             end
                    end) y'
                   (let (_, y1) :=
                      (fix divmod (x1 y1 q u : nat) {struct x1} :
                           nat * nat :=
                         match x1 with
                         | 0%nat => (q, u)
                         | S x' =>
                             match u with
                             | 0%nat => divmod x' y1 (S q) y1
                             | S u' => divmod x' y1 q u'
                             end
                         end) y0 y' 0%nat y' in
                    y1)
             end
          then
           match
             (fix pow (n m : nat) {struct m} : nat :=
                match m with
                | 0%nat => 1%nat
                | S m0 =>
                    (fix mul (n0 m1 : nat) {struct n0} : nat :=
                       match n0 with
                       | 0%nat => 0%nat
                       | S p =>
                           (fix add (n1 m2 : nat) {struct n1} : nat :=
                              match n1 with
                              | 0%nat => m2
                              | S p0 => S (add p0 m2)
                              end) m1 (mul p m1)
                       end) n (pow n m0)
                end) 2%nat
               ((fix sub (n m : nat) {struct n} : nat :=
                   match n with
                   | 0%nat => n
                   | S k => match m with
                            | 0%nat => n
                            | S l => sub k l
                            end
                   end) eps
                  ((fix add (n m : nat) {struct n} : nat :=
                      match n with
                      | 0%nat => m
                      | S p => S (add p m)
                      end) n 1%nat))
           with
           | 0%nat => false
           | S m' =>
               (fix leb (n m : nat) {struct n} : bool :=
                  match n with
                  | 0%nat => true
                  | S n' =>
                      match m with
                      | 0%nat => false
                      | S m'0 => leb n' m'0
                      end
                  end)
                 match
                   (fix pow (n m : nat) {struct m} : nat :=
                      match m with
                      | 0%nat => 1%nat
                      | S m0 =>
                          (fix mul (n0 m1 : nat) {struct n0} : nat :=
                             match n0 with
                             | 0%nat => 0%nat
                             | S p =>
                                 (fix add (n1 m2 : nat) {struct n1} : nat :=
                                    match n1 with
                                    | 0%nat => m2
                                    | S p0 => S (...)
                                    end) m1 (mul p m1)
                             end) n (pow n m0)
                      end) 2%nat
                     ((fix sub (n m : nat) {struct n} : nat :=
                         match n with
                         | 0%nat => n
                         | S k =>
                             match m with
                             | 0%nat => n
                             | S l => sub k l
                             end
                         end) eps
                        ((fix add (n m : nat) {struct n} : nat :=
                            match n with
                            | 0%nat => m
                            | S p => S (add p m)
                            end) n 1%nat))
                 with
                 | 0%nat => x0
                 | S y' =>
                     (fix sub (n m : nat) {struct n} : nat :=
                        match n with
                        | 0%nat => n
                        | S k =>
                            match m with
                            | 0%nat => n
                            | S l => sub k l
                            end
                        end) y'
                       (let (_, y1) :=
                          (fix divmod (x1 y1 q u : nat) {struct x1} :
                               nat * nat :=
                             match x1 with
                             | 0%nat => (q, u)
                             | S x' =>
                                 match u with
                                 | 0%nat => divmod x' y1 (S q) y1
                                 | S u' => divmod x' y1 q u'
                                 end
                             end) x0 y' 0%nat y' in
                        y1)
                 end m'
           end
          else false
         then (R1, R0)
         else (R0, R0) in
       y1)))%R,
   (((let (x1, _) :=
        if
         if
          (fix eqb (n m : nat) {struct n} : bool :=
             match n with
             | 0%nat => match m with
                        | 0%nat => true
                        | S _ => false
                        end
             | S n' => match m with
                       | 0%nat => false
                       | S m' => eqb n' m'
                       end
             end)
            (let (x1, _) :=
               (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                  match x1 with
                  | 0%nat => (q, u)
                  | S x' =>
                      match u with
                      | 0%nat => divmod x' y1 (S q) y1
                      | S u' => divmod x' y1 q u'
                      end
                  end)
                 match
                   (fix pow (n m : nat) {struct m} : nat :=
                      match m with
                      | 0%nat => 1%nat
                      | S m0 =>
                          (fix mul (n0 m1 : nat) {struct n0} : nat :=
                             match n0 with
                             | 0%nat => 0%nat
                             | S p =>
                                 (fix add ... : nat := ...
                                                 ...
                                                 ...
                                                 end) m1 
                                   (mul p m1)
                             end) n (pow n m0)
                      end) 2%nat
                     ((fix sub (n m : nat) {struct n} : nat :=
                         match n with
                         | 0%nat => n
                         | S k =>
                             match m with
                             | 0%nat => n
                             | S l => sub k l
                             end
                         end) eps
                        ((fix add (n m : nat) {struct n} : nat :=
                            match n with
                            | 0%nat => m
                            | S p => S (add p m)
                            end) n 1%nat))
                 with
                 | 0%nat =>
                     (fix pow (n m : nat) {struct m} : nat :=
                        match m with
                        | 0%nat => 1%nat
                        | S m0 =>
                            (fix mul (n0 m1 : nat) {struct n0} : nat :=
                               match n0 with
                               | 0%nat => 0%nat
                               | S p =>
                                   (fix add (n1 m2 : nat) {struct n1} :
                                        nat :=
                                      match ... with
                                      | ... => m2
                                      | ... => S ...
                                      end) m1 (mul p m1)
                               end) n (pow n m0)
                        end) 2%nat
                       ((fix sub (n m : nat) {struct n} : nat :=
                           match n with
                           | 0%nat => n
                           | S k =>
                               match m with
                               | 0%nat => n
                               | S l => sub k l
                               end
                           end) eps
                          ((fix add (n m : nat) {struct n} : nat :=
                              match n with
                              | 0%nat => m
                              | S p => S (add p m)
                              end) n 1%nat))
                 | S y' =>
                     let (x1, _) :=
                       (fix divmod (x1 y1 q u : nat) {struct x1} :
                            nat * nat :=
                          match x1 with
                          | 0%nat => (q, u)
                          | S x' =>
                              match u with
                              | 0%nat => divmod x' y1 (S q) y1
                              | S u' => divmod x' y1 q u'
                              end
                          end) x0 y' 0%nat y' in
                     x1
                 end 1%nat 0%nat 1%nat in
             x1)
            (let (x1, _) :=
               (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                  match x1 with
                  | 0%nat => (q, u)
                  | S x' =>
                      match u with
                      | 0%nat => divmod x' y1 (S q) y1
                      | S u' => divmod x' y1 q u'
                      end
                  end)
                 match
                   (fix pow (n m : nat) {struct m} : nat :=
                      match m with
                      | 0%nat => 1%nat
                      | S m0 =>
                          (fix mul (n0 m1 : nat) {struct n0} : nat :=
                             match n0 with
                             | 0%nat => 0%nat
                             | S p =>
                                 (fix add ... : nat := ...
                                                 ...
                                                 ...
                                                 end) m1 
                                   (mul p m1)
                             end) n (pow n m0)
                      end) 2%nat
                     ((fix sub (n m : nat) {struct n} : nat :=
                         match n with
                         | 0%nat => n
                         | S k =>
                             match m with
                             | 0%nat => n
                             | S l => sub k l
                             end
                         end) eps
                        ((fix add (n m : nat) {struct n} : nat :=
                            match n with
                            | 0%nat => m
                            | S p => S (add p m)
                            end) n 1%nat))
                 with
                 | 0%nat =>
                     (fix pow (n m : nat) {struct m} : nat :=
                        match m with
                        | 0%nat => 1%nat
                        | S m0 =>
                            (fix mul (n0 m1 : nat) {struct n0} : nat :=
                               match n0 with
                               | 0%nat => 0%nat
                               | S p =>
                                   (fix add (n1 m2 : nat) {struct n1} :
                                        nat :=
                                      match ... with
                                      | ... => m2
                                      | ... => S ...
                                      end) m1 (mul p m1)
                               end) n (pow n m0)
                        end) 2%nat
                       ((fix sub (n m : nat) {struct n} : nat :=
                           match n with
                           | 0%nat => n
                           | S k =>
                               match m with
                               | 0%nat => n
                               | S l => sub k l
                               end
                           end) eps
                          ((fix add (n m : nat) {struct n} : nat :=
                              match n with
                              | 0%nat => m
                              | S p => S (add p m)
                              end) n 1%nat))
                 | S y' =>
                     let (x1, _) :=
                       (fix divmod (x1 y1 q u : nat) {struct x1} :
                            nat * nat :=
                          match x1 with
                          | 0%nat => (q, u)
                          | S x' =>
                              match u with
                              | 0%nat => divmod x' y1 (S q) y1
                              | S u' => divmod x' y1 q u'
                              end
                          end) y0 y' 0%nat y' in
                     x1
                 end 1%nat 0%nat 1%nat in
             x1)
         then
          match
            (fix pow (n m : nat) {struct m} : nat :=
               match m with
               | 0%nat => 1%nat
               | S m0 =>
                   (fix mul (n0 m1 : nat) {struct n0} : nat :=
                      match n0 with
                      | 0%nat => 0%nat
                      | S p =>
                          (fix add (n1 m2 : nat) {struct n1} : nat :=
                             match n1 with
                             | 0%nat => m2
                             | S p0 => S (add p0 m2)
                             end) m1 (mul p m1)
                      end) n (pow n m0)
               end) 2%nat n
          with
          | 0%nat => false
          | S m' =>
              (fix leb (n m : nat) {struct n} : bool :=
                 match n with
                 | 0%nat => true
                 | S n' =>
                     match m with
                     | 0%nat => false
                     | S m'0 => leb n' m'0
                     end
                 end)
                (let (x1, _) :=
                   (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                      match x1 with
                      | 0%nat => (q, u)
                      | S x' =>
                          match u with
                          | 0%nat => divmod x' y1 (S q) y1
                          | S u' => divmod x' y1 q u'
                          end
                      end)
                     match
                       (fix pow (n m : nat) {struct m} : nat :=
                          match m with
                          | 0%nat => 1%nat
                          | S m0 =>
                              (fix mul (n0 m1 : nat) {struct n0} : nat :=
                                 match n0 with
                                 | 0%nat => 0%nat
                                 | S p => (...) m1 (...)
                                 end) n (pow n m0)
                          end) 2%nat
                         ((fix sub (n m : nat) {struct n} : nat :=
                             match n with
                             | 0%nat => n
                             | S k =>
                                 match m with
                                 | 0%nat => n
                                 | S l => sub k l
                                 end
                             end) eps
                            ((fix add (n m : nat) {struct n} : nat :=
                                match n with
                                | 0%nat => m
                                | S p => S (add p m)
                                end) n 1%nat))
                     with
                     | 0%nat =>
                         (fix pow (n m : nat) {struct m} : nat :=
                            match m with
                            | 0%nat => 1%nat
                            | S m0 =>
                                (fix mul (n0 m1 : nat) {struct n0} : nat :=
                                   match n0 with
                                   | 0%nat => 0%nat
                                   | S p =>
                                       (fix add ... : nat := ...
                                                 ...
                                                 ...
                                                 end) m1 
                                         (mul p m1)
                                   end) n (pow n m0)
                            end) 2%nat
                           ((fix sub (n m : nat) {struct n} : nat :=
                               match n with
                               | 0%nat => n
                               | S k =>
                                   match m with
                                   | 0%nat => n
                                   | S l => sub k l
                                   end
                               end) eps
                              ((fix add (n m : nat) {struct n} : nat :=
                                  match n with
                                  | 0%nat => m
                                  | S p => S (add p m)
                                  end) n 1%nat))
                     | S y' =>
                         let (x1, _) :=
                           (fix divmod (x1 y1 q u : nat) {struct x1} :
                                nat * nat :=
                              match x1 with
                              | 0%nat => (q, u)
                              | S x' =>
                                  match u with
                                  | 0%nat => divmod x' y1 (S q) y1
                                  | S u' => divmod x' y1 q u'
                                  end
                              end) x0 y' 0%nat y' in
                         x1
                     end 1%nat 0%nat 1%nat in
                 x1) m'
          end
         else false
        then (R1, R0)
        else (R0, R0) in
      x1) *
     (let (x1, _) :=
        EQ
          match
            (let (_, y1) :=
               (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                  match x1 with
                  | 0%nat => (q, u)
                  | S x' =>
                      match u with
                      | 0%nat => divmod x' y1 (S q) y1
                      | S u' => divmod x' y1 q u'
                      end
                  end)
                 match
                   (fix pow (n m : nat) {struct m} : nat :=
                      match m with
                      | 0%nat => 1%nat
                      | S m0 =>
                          (fix mul (n0 m1 : nat) {struct n0} : nat :=
                             match n0 with
                             | 0%nat => 0%nat
                             | S p =>
                                 (fix add ... : nat := ...
                                                 ...
                                                 ...
                                                 end) m1 
                                   (mul p m1)
                             end) n (pow n m0)
                      end) 2%nat
                     ((fix sub (n m : nat) {struct n} : nat :=
                         match n with
                         | 0%nat => n
                         | S k =>
                             match m with
                             | 0%nat => n
                             | S l => sub k l
                             end
                         end) eps
                        ((fix add (n m : nat) {struct n} : nat :=
                            match n with
                            | 0%nat => m
                            | S p => S (add p m)
                            end) n 1%nat))
                 with
                 | 0%nat =>
                     (fix pow (n m : nat) {struct m} : nat :=
                        match m with
                        | 0%nat => 1%nat
                        | S m0 =>
                            (fix mul (n0 m1 : nat) {struct n0} : nat :=
                               match n0 with
                               | 0%nat => 0%nat
                               | S p =>
                                   (fix add (n1 m2 : nat) {struct n1} :
                                        nat :=
                                      match ... with
                                      | ... => m2
                                      | ... => S ...
                                      end) m1 (mul p m1)
                               end) n (pow n m0)
                        end) 2%nat
                       ((fix sub (n m : nat) {struct n} : nat :=
                           match n with
                           | 0%nat => n
                           | S k =>
                               match m with
                               | 0%nat => n
                               | S l => sub k l
                               end
                           end) eps
                          ((fix add (n m : nat) {struct n} : nat :=
                              match n with
                              | 0%nat => m
                              | S p => S (add p m)
                              end) n 1%nat))
                 | S y' =>
                     let (x1, _) :=
                       (fix divmod (x1 y1 q u : nat) {struct x1} :
                            nat * nat :=
                          match x1 with
                          | 0%nat => (q, u)
                          | S x' =>
                              match u with
                              | 0%nat => divmod x' y1 (S q) y1
                              | S u' => divmod x' y1 q u'
                              end
                          end) x0 y' 0%nat y' in
                     x1
                 end 1%nat 0%nat 1%nat in
             y1)
          with
          | 0%nat => 1%nat
          | S _ => 0%nat
          end
          match
            (let (_, y1) :=
               (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                  match x1 with
                  | 0%nat => (q, u)
                  | S x' =>
                      match u with
                      | 0%nat => divmod x' y1 (S q) y1
                      | S u' => divmod x' y1 q u'
                      end
                  end)
                 match
                   (fix pow (n m : nat) {struct m} : nat :=
                      match m with
                      | 0%nat => 1%nat
                      | S m0 =>
                          (fix mul (n0 m1 : nat) {struct n0} : nat :=
                             match n0 with
                             | 0%nat => 0%nat
                             | S p =>
                                 (fix add ... : nat := ...
                                                 ...
                                                 ...
                                                 end) m1 
                                   (mul p m1)
                             end) n (pow n m0)
                      end) 2%nat
                     ((fix sub (n m : nat) {struct n} : nat :=
                         match n with
                         | 0%nat => n
                         | S k =>
                             match m with
                             | 0%nat => n
                             | S l => sub k l
                             end
                         end) eps
                        ((fix add (n m : nat) {struct n} : nat :=
                            match n with
                            | 0%nat => m
                            | S p => S (add p m)
                            end) n 1%nat))
                 with
                 | 0%nat =>
                     (fix pow (n m : nat) {struct m} : nat :=
                        match m with
                        | 0%nat => 1%nat
                        | S m0 =>
                            (fix mul (n0 m1 : nat) {struct n0} : nat :=
                               match n0 with
                               | 0%nat => 0%nat
                               | S p =>
                                   (fix add (n1 m2 : nat) {struct n1} :
                                        nat :=
                                      match ... with
                                      | ... => m2
                                      | ... => S ...
                                      end) m1 (mul p m1)
                               end) n (pow n m0)
                        end) 2%nat
                       ((fix sub (n m : nat) {struct n} : nat :=
                           match n with
                           | 0%nat => n
                           | S k =>
                               match m with
                               | 0%nat => n
                               | S l => sub k l
                               end
                           end) eps
                          ((fix add (n m : nat) {struct n} : nat :=
                              match n with
                              | 0%nat => m
                              | S p => S (add p m)
                              end) n 1%nat))
                 | S y' =>
                     let (x1, _) :=
                       (fix divmod (x1 y1 q u : nat) {struct x1} :
                            nat * nat :=
                          match x1 with
                          | 0%nat => (q, u)
                          | S x' =>
                              match u with
                              | 0%nat => divmod x' y1 (S q) y1
                              | S u' => divmod x' y1 q u'
                              end
                          end) y0 y' 0%nat y' in
                     x1
                 end 1%nat 0%nat 1%nat in
             y1)
          with
          | 0%nat => 1%nat
          | S _ => 0%nat
          end in
      x1) +
     -
     ((let (_, y1) :=
         if
          if
           (fix eqb (n m : nat) {struct n} : bool :=
              match n with
              | 0%nat => match m with
                         | 0%nat => true
                         | S _ => false
                         end
              | S n' => match m with
                        | 0%nat => false
                        | S m' => eqb n' m'
                        end
              end)
             (let (x1, _) :=
                (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                   match x1 with
                   | 0%nat => (q, u)
                   | S x' =>
                       match u with
                       | 0%nat => divmod x' y1 (S q) y1
                       | S u' => divmod x' y1 q u'
                       end
                   end)
                  match
                    (fix pow (n m : nat) {struct m} : nat :=
                       match m with
                       | 0%nat => 1%nat
                       | S m0 =>
                           (fix mul (n0 m1 : nat) {struct n0} : nat :=
                              match n0 with
                              | 0%nat => 0%nat
                              | S p => (...) m1 (...)
                              end) n (pow n m0)
                       end) 2%nat
                      ((fix sub (n m : nat) {struct n} : nat :=
                          match n with
                          | 0%nat => n
                          | S k =>
                              match m with
                              | 0%nat => n
                              | S l => sub k l
                              end
                          end) eps
                         ((fix add (n m : nat) {struct n} : nat :=
                             match n with
                             | 0%nat => m
                             | S p => S (add p m)
                             end) n 1%nat))
                  with
                  | 0%nat =>
                      (fix pow (n m : nat) {struct m} : nat :=
                         match m with
                         | 0%nat => 1%nat
                         | S m0 =>
                             (fix mul (n0 m1 : nat) {struct n0} : nat :=
                                match n0 with
                                | 0%nat => 0%nat
                                | S p =>
                                    (fix add ... : nat := ...
                                                 ...
                                                 ...
                                                 end) m1 
                                      (mul p m1)
                                end) n (pow n m0)
                         end) 2%nat
                        ((fix sub (n m : nat) {struct n} : nat :=
                            match n with
                            | 0%nat => n
                            | S k =>
                                match m with
                                | 0%nat => n
                                | S l => sub k l
                                end
                            end) eps
                           ((fix add (n m : nat) {struct n} : nat :=
                               match n with
                               | 0%nat => m
                               | S p => S (add p m)
                               end) n 1%nat))
                  | S y' =>
                      let (x1, _) :=
                        (fix divmod (x1 y1 q u : nat) {struct x1} :
                             nat * nat :=
                           match x1 with
                           | 0%nat => (q, u)
                           | S x' =>
                               match u with
                               | 0%nat => divmod x' y1 (S q) y1
                               | S u' => divmod x' y1 q u'
                               end
                           end) x0 y' 0%nat y' in
                      x1
                  end 1%nat 0%nat 1%nat in
              x1)
             (let (x1, _) :=
                (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                   match x1 with
                   | 0%nat => (q, u)
                   | S x' =>
                       match u with
                       | 0%nat => divmod x' y1 (S q) y1
                       | S u' => divmod x' y1 q u'
                       end
                   end)
                  match
                    (fix pow (n m : nat) {struct m} : nat :=
                       match m with
                       | 0%nat => 1%nat
                       | S m0 =>
                           (fix mul (n0 m1 : nat) {struct n0} : nat :=
                              match n0 with
                              | 0%nat => 0%nat
                              | S p => (...) m1 (...)
                              end) n (pow n m0)
                       end) 2%nat
                      ((fix sub (n m : nat) {struct n} : nat :=
                          match n with
                          | 0%nat => n
                          | S k =>
                              match m with
                              | 0%nat => n
                              | S l => sub k l
                              end
                          end) eps
                         ((fix add (n m : nat) {struct n} : nat :=
                             match n with
                             | 0%nat => m
                             | S p => S (add p m)
                             end) n 1%nat))
                  with
                  | 0%nat =>
                      (fix pow (n m : nat) {struct m} : nat :=
                         match m with
                         | 0%nat => 1%nat
                         | S m0 =>
                             (fix mul (n0 m1 : nat) {struct n0} : nat :=
                                match n0 with
                                | 0%nat => 0%nat
                                | S p =>
                                    (fix add ... : nat := ...
                                                 ...
                                                 ...
                                                 end) m1 
                                      (mul p m1)
                                end) n (pow n m0)
                         end) 2%nat
                        ((fix sub (n m : nat) {struct n} : nat :=
                            match n with
                            | 0%nat => n
                            | S k =>
                                match m with
                                | 0%nat => n
                                | S l => sub k l
                                end
                            end) eps
                           ((fix add (n m : nat) {struct n} : nat :=
                               match n with
                               | 0%nat => m
                               | S p => S (add p m)
                               end) n 1%nat))
                  | S y' =>
                      let (x1, _) :=
                        (fix divmod (x1 y1 q u : nat) {struct x1} :
                             nat * nat :=
                           match x1 with
                           | 0%nat => (q, u)
                           | S x' =>
                               match u with
                               | 0%nat => divmod x' y1 (S q) y1
                               | S u' => divmod x' y1 q u'
                               end
                           end) y0 y' 0%nat y' in
                      x1
                  end 1%nat 0%nat 1%nat in
              x1)
          then
           match
             (fix pow (n m : nat) {struct m} : nat :=
                match m with
                | 0%nat => 1%nat
                | S m0 =>
                    (fix mul (n0 m1 : nat) {struct n0} : nat :=
                       match n0 with
                       | 0%nat => 0%nat
                       | S p =>
                           (fix add (n1 m2 : nat) {struct n1} : nat :=
                              match n1 with
                              | 0%nat => m2
                              | S p0 => S (...)
                              end) m1 (mul p m1)
                       end) n (pow n m0)
                end) 2%nat n
           with
           | 0%nat => false
           | S m' =>
               (fix leb (n m : nat) {struct n} : bool :=
                  match n with
                  | 0%nat => true
                  | S n' =>
                      match m with
                      | 0%nat => false
                      | S m'0 => leb n' m'0
                      end
                  end)
                 (let (x1, _) :=
                    (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                       match x1 with
                       | 0%nat => (q, u)
                       | S x' =>
                           match u with
                           | 0%nat => divmod x' y1 (S q) y1
                           | S u' => divmod x' y1 q u'
                           end
                       end)
                      match
                        (fix pow (n m : nat) {struct m} : nat :=
                           match m with
                           | 0%nat => 1%nat
                           | S m0 =>
                               (fix mul ... {struct n0} : nat :=
                                  match ... with
                                  | ... 0%nat
                                  | ... ...
                                  end) n (pow n m0)
                           end) 2%nat
                          ((fix sub (n m : nat) {struct n} : nat :=
                              match n with
                              | 0%nat => n
                              | S k =>
                                  match ... with
                                  | ... => n
                                  | ... => sub k l
                                  end
                              end) eps
                             ((fix add (n m : nat) {struct n} : nat :=
                                 match ... with
                                 | ... => m
                                 | ... => S ...
                                 end) n 1%nat))
                      with
                      | 0%nat =>
                          (fix pow (n m : nat) {struct m} : nat :=
                             match m with
                             | 0%nat => 1%nat
                             | S m0 =>
                                 (fix mul (n0 m1 : nat) {struct n0} : nat :=
                                    match n0 with
                                    | 0%nat => 0%nat
                                    | S p => (...) m1 (...)
                                    end) n (pow n m0)
                             end) 2%nat
                            ((fix sub (n m : nat) {struct n} : nat :=
                                match n with
                                | 0%nat => n
                                | S k =>
                                    match m with
                                    | 0%nat => n
                                    | S l => sub k l
                                    end
                                end) eps
                               ((fix add (n m : nat) {struct n} : nat :=
                                   match n with
                                   | 0%nat => m
                                   | S p => S (add p m)
                                   end) n 1%nat))
                      | S y' =>
                          let (x1, _) :=
                            (fix divmod (x1 y1 q u : nat) {struct x1} :
                                 nat * nat :=
                               match x1 with
                               | 0%nat => (q, u)
                               | S x' =>
                                   match u with
                                   | 0%nat => divmod x' y1 (S q) y1
                                   | S u' => divmod x' y1 q u'
                                   end
                               end) x0 y' 0%nat y' in
                          x1
                      end 1%nat 0%nat 1%nat in
                  x1) m'
           end
          else false
         then (R1, R0)
         else (R0, R0) in
       y1) *
      (let (_, y1) :=
         EQ
           match
             (let (_, y1) :=
                (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                   match x1 with
                   | 0%nat => (q, u)
                   | S x' =>
                       match u with
                       | 0%nat => divmod x' y1 (S q) y1
                       | S u' => divmod x' y1 q u'
                       end
                   end)
                  match
                    (fix pow (n m : nat) {struct m} : nat :=
                       match m with
                       | 0%nat => 1%nat
                       | S m0 =>
                           (fix mul (n0 m1 : nat) {struct n0} : nat :=
                              match n0 with
                              | 0%nat => 0%nat
                              | S p => (...) m1 (...)
                              end) n (pow n m0)
                       end) 2%nat
                      ((fix sub (n m : nat) {struct n} : nat :=
                          match n with
                          | 0%nat => n
                          | S k =>
                              match m with
                              | 0%nat => n
                              | S l => sub k l
                              end
                          end) eps
                         ((fix add (n m : nat) {struct n} : nat :=
                             match n with
                             | 0%nat => m
                             | S p => S (add p m)
                             end) n 1%nat))
                  with
                  | 0%nat =>
                      (fix pow (n m : nat) {struct m} : nat :=
                         match m with
                         | 0%nat => 1%nat
                         | S m0 =>
                             (fix mul (n0 m1 : nat) {struct n0} : nat :=
                                match n0 with
                                | 0%nat => 0%nat
                                | S p =>
                                    (fix add ... : nat := ...
                                                 ...
                                                 ...
                                                 end) m1 
                                      (mul p m1)
                                end) n (pow n m0)
                         end) 2%nat
                        ((fix sub (n m : nat) {struct n} : nat :=
                            match n with
                            | 0%nat => n
                            | S k =>
                                match m with
                                | 0%nat => n
                                | S l => sub k l
                                end
                            end) eps
                           ((fix add (n m : nat) {struct n} : nat :=
                               match n with
                               | 0%nat => m
                               | S p => S (add p m)
                               end) n 1%nat))
                  | S y' =>
                      let (x1, _) :=
                        (fix divmod (x1 y1 q u : nat) {struct x1} :
                             nat * nat :=
                           match x1 with
                           | 0%nat => (q, u)
                           | S x' =>
                               match u with
                               | 0%nat => divmod x' y1 (S q) y1
                               | S u' => divmod x' y1 q u'
                               end
                           end) x0 y' 0%nat y' in
                      x1
                  end 1%nat 0%nat 1%nat in
              y1)
           with
           | 0%nat => 1%nat
           | S _ => 0%nat
           end
           match
             (let (_, y1) :=
                (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                   match x1 with
                   | 0%nat => (q, u)
                   | S x' =>
                       match u with
                       | 0%nat => divmod x' y1 (S q) y1
                       | S u' => divmod x' y1 q u'
                       end
                   end)
                  match
                    (fix pow (n m : nat) {struct m} : nat :=
                       match m with
                       | 0%nat => 1%nat
                       | S m0 =>
                           (fix mul (n0 m1 : nat) {struct n0} : nat :=
                              match n0 with
                              | 0%nat => 0%nat
                              | S p => (...) m1 (...)
                              end) n (pow n m0)
                       end) 2%nat
                      ((fix sub (n m : nat) {struct n} : nat :=
                          match n with
                          | 0%nat => n
                          | S k =>
                              match m with
                              | 0%nat => n
                              | S l => sub k l
                              end
                          end) eps
                         ((fix add (n m : nat) {struct n} : nat :=
                             match n with
                             | 0%nat => m
                             | S p => S (add p m)
                             end) n 1%nat))
                  with
                  | 0%nat =>
                      (fix pow (n m : nat) {struct m} : nat :=
                         match m with
                         | 0%nat => 1%nat
                         | S m0 =>
                             (fix mul (n0 m1 : nat) {struct n0} : nat :=
                                match n0 with
                                | 0%nat => 0%nat
                                | S p =>
                                    (fix add ... : nat := ...
                                                 ...
                                                 ...
                                                 end) m1 
                                      (mul p m1)
                                end) n (pow n m0)
                         end) 2%nat
                        ((fix sub (n m : nat) {struct n} : nat :=
                            match n with
                            | 0%nat => n
                            | S k =>
                                match m with
                                | 0%nat => n
                                | S l => sub k l
                                end
                            end) eps
                           ((fix add (n m : nat) {struct n} : nat :=
                               match n with
                               | 0%nat => m
                               | S p => S (add p m)
                               end) n 1%nat))
                  | S y' =>
                      let (x1, _) :=
                        (fix divmod (x1 y1 q u : nat) {struct x1} :
                             nat * nat :=
                           match x1 with
                           | 0%nat => (q, u)
                           | S x' =>
                               match u with
                               | 0%nat => divmod x' y1 (S q) y1
                               | S u' => divmod x' y1 q u'
                               end
                           end) y0 y' 0%nat y' in
                      x1
                  end 1%nat 0%nat 1%nat in
              y1)
           with
           | 0%nat => 1%nat
           | S _ => 0%nat
           end in
       y1))) *
    (let (_, y1) :=
       if
        if
         (fix eqb (n m : nat) {struct n} : bool :=
            match n with
            | 0%nat => match m with
                       | 0%nat => true
                       | S _ => false
                       end
            | S n' => match m with
                      | 0%nat => false
                      | S m' => eqb n' m'
                      end
            end)
           match
             (fix pow (n m : nat) {struct m} : nat :=
                match m with
                | 0%nat => 1%nat
                | S m0 =>
                    (fix mul (n0 m1 : nat) {struct n0} : nat :=
                       match n0 with
                       | 0%nat => 0%nat
                       | S p =>
                           (fix add (n1 m2 : nat) {struct n1} : nat :=
                              match n1 with
                              | 0%nat => m2
                              | S p0 => S (add p0 m2)
                              end) m1 (mul p m1)
                       end) n (pow n m0)
                end) 2%nat
               ((fix sub (n m : nat) {struct n} : nat :=
                   match n with
                   | 0%nat => n
                   | S k => match m with
                            | 0%nat => n
                            | S l => sub k l
                            end
                   end) eps
                  ((fix add (n m : nat) {struct n} : nat :=
                      match n with
                      | 0%nat => m
                      | S p => S (add p m)
                      end) n 1%nat))
           with
           | 0%nat => x0
           | S y' =>
               (fix sub (n m : nat) {struct n} : nat :=
                  match n with
                  | 0%nat => n
                  | S k => match m with
                           | 0%nat => n
                           | S l => sub k l
                           end
                  end) y'
                 (let (_, y1) :=
                    (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                       match x1 with
                       | 0%nat => (q, u)
                       | S x' =>
                           match u with
                           | 0%nat => divmod x' y1 (S q) y1
                           | S u' => divmod x' y1 q u'
                           end
                       end) x0 y' 0%nat y' in
                  y1)
           end
           match
             (fix pow (n m : nat) {struct m} : nat :=
                match m with
                | 0%nat => 1%nat
                | S m0 =>
                    (fix mul (n0 m1 : nat) {struct n0} : nat :=
                       match n0 with
                       | 0%nat => 0%nat
                       | S p =>
                           (fix add (n1 m2 : nat) {struct n1} : nat :=
                              match n1 with
                              | 0%nat => m2
                              | S p0 => S (add p0 m2)
                              end) m1 (mul p m1)
                       end) n (pow n m0)
                end) 2%nat
               ((fix sub (n m : nat) {struct n} : nat :=
                   match n with
                   | 0%nat => n
                   | S k => match m with
                            | 0%nat => n
                            | S l => sub k l
                            end
                   end) eps
                  ((fix add (n m : nat) {struct n} : nat :=
                      match n with
                      | 0%nat => m
                      | S p => S (add p m)
                      end) n 1%nat))
           with
           | 0%nat => y0
           | S y' =>
               (fix sub (n m : nat) {struct n} : nat :=
                  match n with
                  | 0%nat => n
                  | S k => match m with
                           | 0%nat => n
                           | S l => sub k l
                           end
                  end) y'
                 (let (_, y1) :=
                    (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                       match x1 with
                       | 0%nat => (q, u)
                       | S x' =>
                           match u with
                           | 0%nat => divmod x' y1 (S q) y1
                           | S u' => divmod x' y1 q u'
                           end
                       end) y0 y' 0%nat y' in
                  y1)
           end
        then
         match
           (fix pow (n m : nat) {struct m} : nat :=
              match m with
              | 0%nat => 1%nat
              | S m0 =>
                  (fix mul (n0 m1 : nat) {struct n0} : nat :=
                     match n0 with
                     | 0%nat => 0%nat
                     | S p =>
                         (fix add (n1 m2 : nat) {struct n1} : nat :=
                            match n1 with
                            | 0%nat => m2
                            | S p0 => S (add p0 m2)
                            end) m1 (mul p m1)
                     end) n (pow n m0)
              end) 2%nat
             ((fix sub (n m : nat) {struct n} : nat :=
                 match n with
                 | 0%nat => n
                 | S k => match m with
                          | 0%nat => n
                          | S l => sub k l
                          end
                 end) eps
                ((fix add (n m : nat) {struct n} : nat :=
                    match n with
                    | 0%nat => m
                    | S p => S (add p m)
                    end) n 1%nat))
         with
         | 0%nat => false
         | S m' =>
             (fix leb (n m : nat) {struct n} : bool :=
                match n with
                | 0%nat => true
                | S n' =>
                    match m with
                    | 0%nat => false
                    | S m'0 => leb n' m'0
                    end
                end)
               match
                 (fix pow (n m : nat) {struct m} : nat :=
                    match m with
                    | 0%nat => 1%nat
                    | S m0 =>
                        (fix mul (n0 m1 : nat) {struct n0} : nat :=
                           match n0 with
                           | 0%nat => 0%nat
                           | S p =>
                               (fix add (n1 m2 : nat) {struct n1} : nat :=
                                  match n1 with
                                  | 0%nat => m2
                                  | S p0 => S (add p0 m2)
                                  end) m1 (mul p m1)
                           end) n (pow n m0)
                    end) 2%nat
                   ((fix sub (n m : nat) {struct n} : nat :=
                       match n with
                       | 0%nat => n
                       | S k =>
                           match m with
                           | 0%nat => n
                           | S l => sub k l
                           end
                       end) eps
                      ((fix add (n m : nat) {struct n} : nat :=
                          match n with
                          | 0%nat => m
                          | S p => S (add p m)
                          end) n 1%nat))
               with
               | 0%nat => x0
               | S y' =>
                   (fix sub (n m : nat) {struct n} : nat :=
                      match n with
                      | 0%nat => n
                      | S k => match m with
                               | 0%nat => n
                               | S l => sub k l
                               end
                      end) y'
                     (let (_, y1) :=
                        (fix divmod (x1 y1 q u : nat) {struct x1} :
                             nat * nat :=
                           match x1 with
                           | 0%nat => (q, u)
                           | S x' =>
                               match u with
                               | 0%nat => divmod x' y1 (S q) y1
                               | S u' => divmod x' y1 q u'
                               end
                           end) x0 y' 0%nat y' in
                      y1)
               end m'
         end
        else false
       then (R1, R0)
       else (R0, R0) in
     y1) +
    ((let (x1, _) :=
        if
         if
          (fix eqb (n m : nat) {struct n} : bool :=
             match n with
             | 0%nat => match m with
                        | 0%nat => true
                        | S _ => false
                        end
             | S n' => match m with
                       | 0%nat => false
                       | S m' => eqb n' m'
                       end
             end)
            (let (x1, _) :=
               (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                  match x1 with
                  | 0%nat => (q, u)
                  | S x' =>
                      match u with
                      | 0%nat => divmod x' y1 (S q) y1
                      | S u' => divmod x' y1 q u'
                      end
                  end)
                 match
                   (fix pow (n m : nat) {struct m} : nat :=
                      match m with
                      | 0%nat => 1%nat
                      | S m0 =>
                          (fix mul (n0 m1 : nat) {struct n0} : nat :=
                             match n0 with
                             | 0%nat => 0%nat
                             | S p =>
                                 (fix add ... : nat := ...
                                                 ...
                                                 ...
                                                 end) m1 
                                   (mul p m1)
                             end) n (pow n m0)
                      end) 2%nat
                     ((fix sub (n m : nat) {struct n} : nat :=
                         match n with
                         | 0%nat => n
                         | S k =>
                             match m with
                             | 0%nat => n
                             | S l => sub k l
                             end
                         end) eps
                        ((fix add (n m : nat) {struct n} : nat :=
                            match n with
                            | 0%nat => m
                            | S p => S (add p m)
                            end) n 1%nat))
                 with
                 | 0%nat =>
                     (fix pow (n m : nat) {struct m} : nat :=
                        match m with
                        | 0%nat => 1%nat
                        | S m0 =>
                            (fix mul (n0 m1 : nat) {struct n0} : nat :=
                               match n0 with
                               | 0%nat => 0%nat
                               | S p =>
                                   (fix add (n1 m2 : nat) {struct n1} :
                                        nat :=
                                      match ... with
                                      | ... => m2
                                      | ... => S ...
                                      end) m1 (mul p m1)
                               end) n (pow n m0)
                        end) 2%nat
                       ((fix sub (n m : nat) {struct n} : nat :=
                           match n with
                           | 0%nat => n
                           | S k =>
                               match m with
                               | 0%nat => n
                               | S l => sub k l
                               end
                           end) eps
                          ((fix add (n m : nat) {struct n} : nat :=
                              match n with
                              | 0%nat => m
                              | S p => S (add p m)
                              end) n 1%nat))
                 | S y' =>
                     let (x1, _) :=
                       (fix divmod (x1 y1 q u : nat) {struct x1} :
                            nat * nat :=
                          match x1 with
                          | 0%nat => (q, u)
                          | S x' =>
                              match u with
                              | 0%nat => divmod x' y1 (S q) y1
                              | S u' => divmod x' y1 q u'
                              end
                          end) x0 y' 0%nat y' in
                     x1
                 end 1%nat 0%nat 1%nat in
             x1)
            (let (x1, _) :=
               (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                  match x1 with
                  | 0%nat => (q, u)
                  | S x' =>
                      match u with
                      | 0%nat => divmod x' y1 (S q) y1
                      | S u' => divmod x' y1 q u'
                      end
                  end)
                 match
                   (fix pow (n m : nat) {struct m} : nat :=
                      match m with
                      | 0%nat => 1%nat
                      | S m0 =>
                          (fix mul (n0 m1 : nat) {struct n0} : nat :=
                             match n0 with
                             | 0%nat => 0%nat
                             | S p =>
                                 (fix add ... : nat := ...
                                                 ...
                                                 ...
                                                 end) m1 
                                   (mul p m1)
                             end) n (pow n m0)
                      end) 2%nat
                     ((fix sub (n m : nat) {struct n} : nat :=
                         match n with
                         | 0%nat => n
                         | S k =>
                             match m with
                             | 0%nat => n
                             | S l => sub k l
                             end
                         end) eps
                        ((fix add (n m : nat) {struct n} : nat :=
                            match n with
                            | 0%nat => m
                            | S p => S (add p m)
                            end) n 1%nat))
                 with
                 | 0%nat =>
                     (fix pow (n m : nat) {struct m} : nat :=
                        match m with
                        | 0%nat => 1%nat
                        | S m0 =>
                            (fix mul (n0 m1 : nat) {struct n0} : nat :=
                               match n0 with
                               | 0%nat => 0%nat
                               | S p =>
                                   (fix add (n1 m2 : nat) {struct n1} :
                                        nat :=
                                      match ... with
                                      | ... => m2
                                      | ... => S ...
                                      end) m1 (mul p m1)
                               end) n (pow n m0)
                        end) 2%nat
                       ((fix sub (n m : nat) {struct n} : nat :=
                           match n with
                           | 0%nat => n
                           | S k =>
                               match m with
                               | 0%nat => n
                               | S l => sub k l
                               end
                           end) eps
                          ((fix add (n m : nat) {struct n} : nat :=
                              match n with
                              | 0%nat => m
                              | S p => S (add p m)
                              end) n 1%nat))
                 | S y' =>
                     let (x1, _) :=
                       (fix divmod (x1 y1 q u : nat) {struct x1} :
                            nat * nat :=
                          match x1 with
                          | 0%nat => (q, u)
                          | S x' =>
                              match u with
                              | 0%nat => divmod x' y1 (S q) y1
                              | S u' => divmod x' y1 q u'
                              end
                          end) y0 y' 0%nat y' in
                     x1
                 end 1%nat 0%nat 1%nat in
             x1)
         then
          match
            (fix pow (n m : nat) {struct m} : nat :=
               match m with
               | 0%nat => 1%nat
               | S m0 =>
                   (fix mul (n0 m1 : nat) {struct n0} : nat :=
                      match n0 with
                      | 0%nat => 0%nat
                      | S p =>
                          (fix add (n1 m2 : nat) {struct n1} : nat :=
                             match n1 with
                             | 0%nat => m2
                             | S p0 => S (add p0 m2)
                             end) m1 (mul p m1)
                      end) n (pow n m0)
               end) 2%nat n
          with
          | 0%nat => false
          | S m' =>
              (fix leb (n m : nat) {struct n} : bool :=
                 match n with
                 | 0%nat => true
                 | S n' =>
                     match m with
                     | 0%nat => false
                     | S m'0 => leb n' m'0
                     end
                 end)
                (let (x1, _) :=
                   (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                      match x1 with
                      | 0%nat => (q, u)
                      | S x' =>
                          match u with
                          | 0%nat => divmod x' y1 (S q) y1
                          | S u' => divmod x' y1 q u'
                          end
                      end)
                     match
                       (fix pow (n m : nat) {struct m} : nat :=
                          match m with
                          | 0%nat => 1%nat
                          | S m0 =>
                              (fix mul (n0 m1 : nat) {struct n0} : nat :=
                                 match n0 with
                                 | 0%nat => 0%nat
                                 | S p => (...) m1 (...)
                                 end) n (pow n m0)
                          end) 2%nat
                         ((fix sub (n m : nat) {struct n} : nat :=
                             match n with
                             | 0%nat => n
                             | S k =>
                                 match m with
                                 | 0%nat => n
                                 | S l => sub k l
                                 end
                             end) eps
                            ((fix add (n m : nat) {struct n} : nat :=
                                match n with
                                | 0%nat => m
                                | S p => S (add p m)
                                end) n 1%nat))
                     with
                     | 0%nat =>
                         (fix pow (n m : nat) {struct m} : nat :=
                            match m with
                            | 0%nat => 1%nat
                            | S m0 =>
                                (fix mul (n0 m1 : nat) {struct n0} : nat :=
                                   match n0 with
                                   | 0%nat => 0%nat
                                   | S p =>
                                       (fix add ... : nat := ...
                                                 ...
                                                 ...
                                                 end) m1 
                                         (mul p m1)
                                   end) n (pow n m0)
                            end) 2%nat
                           ((fix sub (n m : nat) {struct n} : nat :=
                               match n with
                               | 0%nat => n
                               | S k =>
                                   match m with
                                   | 0%nat => n
                                   | S l => sub k l
                                   end
                               end) eps
                              ((fix add (n m : nat) {struct n} : nat :=
                                  match n with
                                  | 0%nat => m
                                  | S p => S (add p m)
                                  end) n 1%nat))
                     | S y' =>
                         let (x1, _) :=
                           (fix divmod (x1 y1 q u : nat) {struct x1} :
                                nat * nat :=
                              match x1 with
                              | 0%nat => (q, u)
                              | S x' =>
                                  match u with
                                  | 0%nat => divmod x' y1 (S q) y1
                                  | S u' => divmod x' y1 q u'
                                  end
                              end) x0 y' 0%nat y' in
                         x1
                     end 1%nat 0%nat 1%nat in
                 x1) m'
          end
         else false
        then (R1, R0)
        else (R0, R0) in
      x1) *
     (let (_, y1) :=
        EQ
          match
            (let (_, y1) :=
               (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                  match x1 with
                  | 0%nat => (q, u)
                  | S x' =>
                      match u with
                      | 0%nat => divmod x' y1 (S q) y1
                      | S u' => divmod x' y1 q u'
                      end
                  end)
                 match
                   (fix pow (n m : nat) {struct m} : nat :=
                      match m with
                      | 0%nat => 1%nat
                      | S m0 =>
                          (fix mul (n0 m1 : nat) {struct n0} : nat :=
                             match n0 with
                             | 0%nat => 0%nat
                             | S p =>
                                 (fix add ... : nat := ...
                                                 ...
                                                 ...
                                                 end) m1 
                                   (mul p m1)
                             end) n (pow n m0)
                      end) 2%nat
                     ((fix sub (n m : nat) {struct n} : nat :=
                         match n with
                         | 0%nat => n
                         | S k =>
                             match m with
                             | 0%nat => n
                             | S l => sub k l
                             end
                         end) eps
                        ((fix add (n m : nat) {struct n} : nat :=
                            match n with
                            | 0%nat => m
                            | S p => S (add p m)
                            end) n 1%nat))
                 with
                 | 0%nat =>
                     (fix pow (n m : nat) {struct m} : nat :=
                        match m with
                        | 0%nat => 1%nat
                        | S m0 =>
                            (fix mul (n0 m1 : nat) {struct n0} : nat :=
                               match n0 with
                               | 0%nat => 0%nat
                               | S p =>
                                   (fix add (n1 m2 : nat) {struct n1} :
                                        nat :=
                                      match ... with
                                      | ... => m2
                                      | ... => S ...
                                      end) m1 (mul p m1)
                               end) n (pow n m0)
                        end) 2%nat
                       ((fix sub (n m : nat) {struct n} : nat :=
                           match n with
                           | 0%nat => n
                           | S k =>
                               match m with
                               | 0%nat => n
                               | S l => sub k l
                               end
                           end) eps
                          ((fix add (n m : nat) {struct n} : nat :=
                              match n with
                              | 0%nat => m
                              | S p => S (add p m)
                              end) n 1%nat))
                 | S y' =>
                     let (x1, _) :=
                       (fix divmod (x1 y1 q u : nat) {struct x1} :
                            nat * nat :=
                          match x1 with
                          | 0%nat => (q, u)
                          | S x' =>
                              match u with
                              | 0%nat => divmod x' y1 (S q) y1
                              | S u' => divmod x' y1 q u'
                              end
                          end) x0 y' 0%nat y' in
                     x1
                 end 1%nat 0%nat 1%nat in
             y1)
          with
          | 0%nat => 1%nat
          | S _ => 0%nat
          end
          match
            (let (_, y1) :=
               (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                  match x1 with
                  | 0%nat => (q, u)
                  | S x' =>
                      match u with
                      | 0%nat => divmod x' y1 (S q) y1
                      | S u' => divmod x' y1 q u'
                      end
                  end)
                 match
                   (fix pow (n m : nat) {struct m} : nat :=
                      match m with
                      | 0%nat => 1%nat
                      | S m0 =>
                          (fix mul (n0 m1 : nat) {struct n0} : nat :=
                             match n0 with
                             | 0%nat => 0%nat
                             | S p =>
                                 (fix add ... : nat := ...
                                                 ...
                                                 ...
                                                 end) m1 
                                   (mul p m1)
                             end) n (pow n m0)
                      end) 2%nat
                     ((fix sub (n m : nat) {struct n} : nat :=
                         match n with
                         | 0%nat => n
                         | S k =>
                             match m with
                             | 0%nat => n
                             | S l => sub k l
                             end
                         end) eps
                        ((fix add (n m : nat) {struct n} : nat :=
                            match n with
                            | 0%nat => m
                            | S p => S (add p m)
                            end) n 1%nat))
                 with
                 | 0%nat =>
                     (fix pow (n m : nat) {struct m} : nat :=
                        match m with
                        | 0%nat => 1%nat
                        | S m0 =>
                            (fix mul (n0 m1 : nat) {struct n0} : nat :=
                               match n0 with
                               | 0%nat => 0%nat
                               | S p =>
                                   (fix add (n1 m2 : nat) {struct n1} :
                                        nat :=
                                      match ... with
                                      | ... => m2
                                      | ... => S ...
                                      end) m1 (mul p m1)
                               end) n (pow n m0)
                        end) 2%nat
                       ((fix sub (n m : nat) {struct n} : nat :=
                           match n with
                           | 0%nat => n
                           | S k =>
                               match m with
                               | 0%nat => n
                               | S l => sub k l
                               end
                           end) eps
                          ((fix add (n m : nat) {struct n} : nat :=
                              match n with
                              | 0%nat => m
                              | S p => S (add p m)
                              end) n 1%nat))
                 | S y' =>
                     let (x1, _) :=
                       (fix divmod (x1 y1 q u : nat) {struct x1} :
                            nat * nat :=
                          match x1 with
                          | 0%nat => (q, u)
                          | S x' =>
                              match u with
                              | 0%nat => divmod x' y1 (S q) y1
                              | S u' => divmod x' y1 q u'
                              end
                          end) y0 y' 0%nat y' in
                     x1
                 end 1%nat 0%nat 1%nat in
             y1)
          with
          | 0%nat => 1%nat
          | S _ => 0%nat
          end in
      y1) +
     (let (_, y1) :=
        if
         if
          (fix eqb (n m : nat) {struct n} : bool :=
             match n with
             | 0%nat => match m with
                        | 0%nat => true
                        | S _ => false
                        end
             | S n' => match m with
                       | 0%nat => false
                       | S m' => eqb n' m'
                       end
             end)
            (let (x1, _) :=
               (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                  match x1 with
                  | 0%nat => (q, u)
                  | S x' =>
                      match u with
                      | 0%nat => divmod x' y1 (S q) y1
                      | S u' => divmod x' y1 q u'
                      end
                  end)
                 match
                   (fix pow (n m : nat) {struct m} : nat :=
                      match m with
                      | 0%nat => 1%nat
                      | S m0 =>
                          (fix mul (n0 m1 : nat) {struct n0} : nat :=
                             match n0 with
                             | 0%nat => 0%nat
                             | S p =>
                                 (fix add ... : nat := ...
                                                 ...
                                                 ...
                                                 end) m1 
                                   (mul p m1)
                             end) n (pow n m0)
                      end) 2%nat
                     ((fix sub (n m : nat) {struct n} : nat :=
                         match n with
                         | 0%nat => n
                         | S k =>
                             match m with
                             | 0%nat => n
                             | S l => sub k l
                             end
                         end) eps
                        ((fix add (n m : nat) {struct n} : nat :=
                            match n with
                            | 0%nat => m
                            | S p => S (add p m)
                            end) n 1%nat))
                 with
                 | 0%nat =>
                     (fix pow (n m : nat) {struct m} : nat :=
                        match m with
                        | 0%nat => 1%nat
                        | S m0 =>
                            (fix mul (n0 m1 : nat) {struct n0} : nat :=
                               match n0 with
                               | 0%nat => 0%nat
                               | S p =>
                                   (fix add (n1 m2 : nat) {struct n1} :
                                        nat :=
                                      match ... with
                                      | ... => m2
                                      | ... => S ...
                                      end) m1 (mul p m1)
                               end) n (pow n m0)
                        end) 2%nat
                       ((fix sub (n m : nat) {struct n} : nat :=
                           match n with
                           | 0%nat => n
                           | S k =>
                               match m with
                               | 0%nat => n
                               | S l => sub k l
                               end
                           end) eps
                          ((fix add (n m : nat) {struct n} : nat :=
                              match n with
                              | 0%nat => m
                              | S p => S (add p m)
                              end) n 1%nat))
                 | S y' =>
                     let (x1, _) :=
                       (fix divmod (x1 y1 q u : nat) {struct x1} :
                            nat * nat :=
                          match x1 with
                          | 0%nat => (q, u)
                          | S x' =>
                              match u with
                              | 0%nat => divmod x' y1 (S q) y1
                              | S u' => divmod x' y1 q u'
                              end
                          end) x0 y' 0%nat y' in
                     x1
                 end 1%nat 0%nat 1%nat in
             x1)
            (let (x1, _) :=
               (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                  match x1 with
                  | 0%nat => (q, u)
                  | S x' =>
                      match u with
                      | 0%nat => divmod x' y1 (S q) y1
                      | S u' => divmod x' y1 q u'
                      end
                  end)
                 match
                   (fix pow (n m : nat) {struct m} : nat :=
                      match m with
                      | 0%nat => 1%nat
                      | S m0 =>
                          (fix mul (n0 m1 : nat) {struct n0} : nat :=
                             match n0 with
                             | 0%nat => 0%nat
                             | S p =>
                                 (fix add ... : nat := ...
                                                 ...
                                                 ...
                                                 end) m1 
                                   (mul p m1)
                             end) n (pow n m0)
                      end) 2%nat
                     ((fix sub (n m : nat) {struct n} : nat :=
                         match n with
                         | 0%nat => n
                         | S k =>
                             match m with
                             | 0%nat => n
                             | S l => sub k l
                             end
                         end) eps
                        ((fix add (n m : nat) {struct n} : nat :=
                            match n with
                            | 0%nat => m
                            | S p => S (add p m)
                            end) n 1%nat))
                 with
                 | 0%nat =>
                     (fix pow (n m : nat) {struct m} : nat :=
                        match m with
                        | 0%nat => 1%nat
                        | S m0 =>
                            (fix mul (n0 m1 : nat) {struct n0} : nat :=
                               match n0 with
                               | 0%nat => 0%nat
                               | S p =>
                                   (fix add (n1 m2 : nat) {struct n1} :
                                        nat :=
                                      match ... with
                                      | ... => m2
                                      | ... => S ...
                                      end) m1 (mul p m1)
                               end) n (pow n m0)
                        end) 2%nat
                       ((fix sub (n m : nat) {struct n} : nat :=
                           match n with
                           | 0%nat => n
                           | S k =>
                               match m with
                               | 0%nat => n
                               | S l => sub k l
                               end
                           end) eps
                          ((fix add (n m : nat) {struct n} : nat :=
                              match n with
                              | 0%nat => m
                              | S p => S (add p m)
                              end) n 1%nat))
                 | S y' =>
                     let (x1, _) :=
                       (fix divmod (x1 y1 q u : nat) {struct x1} :
                            nat * nat :=
                          match x1 with
                          | 0%nat => (q, u)
                          | S x' =>
                              match u with
                              | 0%nat => divmod x' y1 (S q) y1
                              | S u' => divmod x' y1 q u'
                              end
                          end) y0 y' 0%nat y' in
                     x1
                 end 1%nat 0%nat 1%nat in
             x1)
         then
          match
            (fix pow (n m : nat) {struct m} : nat :=
               match m with
               | 0%nat => 1%nat
               | S m0 =>
                   (fix mul (n0 m1 : nat) {struct n0} : nat :=
                      match n0 with
                      | 0%nat => 0%nat
                      | S p =>
                          (fix add (n1 m2 : nat) {struct n1} : nat :=
                             match n1 with
                             | 0%nat => m2
                             | S p0 => S (add p0 m2)
                             end) m1 (mul p m1)
                      end) n (pow n m0)
               end) 2%nat n
          with
          | 0%nat => false
          | S m' =>
              (fix leb (n m : nat) {struct n} : bool :=
                 match n with
                 | 0%nat => true
                 | S n' =>
                     match m with
                     | 0%nat => false
                     | S m'0 => leb n' m'0
                     end
                 end)
                (let (x1, _) :=
                   (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                      match x1 with
                      | 0%nat => (q, u)
                      | S x' =>
                          match u with
                          | 0%nat => divmod x' y1 (S q) y1
                          | S u' => divmod x' y1 q u'
                          end
                      end)
                     match
                       (fix pow (n m : nat) {struct m} : nat :=
                          match m with
                          | 0%nat => 1%nat
                          | S m0 =>
                              (fix mul (n0 m1 : nat) {struct n0} : nat :=
                                 match n0 with
                                 | 0%nat => 0%nat
                                 | S p => (...) m1 (...)
                                 end) n (pow n m0)
                          end) 2%nat
                         ((fix sub (n m : nat) {struct n} : nat :=
                             match n with
                             | 0%nat => n
                             | S k =>
                                 match m with
                                 | 0%nat => n
                                 | S l => sub k l
                                 end
                             end) eps
                            ((fix add (n m : nat) {struct n} : nat :=
                                match n with
                                | 0%nat => m
                                | S p => S (add p m)
                                end) n 1%nat))
                     with
                     | 0%nat =>
                         (fix pow (n m : nat) {struct m} : nat :=
                            match m with
                            | 0%nat => 1%nat
                            | S m0 =>
                                (fix mul (n0 m1 : nat) {struct n0} : nat :=
                                   match n0 with
                                   | 0%nat => 0%nat
                                   | S p =>
                                       (fix add ... : nat := ...
                                                 ...
                                                 ...
                                                 end) m1 
                                         (mul p m1)
                                   end) n (pow n m0)
                            end) 2%nat
                           ((fix sub (n m : nat) {struct n} : nat :=
                               match n with
                               | 0%nat => n
                               | S k =>
                                   match m with
                                   | 0%nat => n
                                   | S l => sub k l
                                   end
                               end) eps
                              ((fix add (n m : nat) {struct n} : nat :=
                                  match n with
                                  | 0%nat => m
                                  | S p => S (add p m)
                                  end) n 1%nat))
                     | S y' =>
                         let (x1, _) :=
                           (fix divmod (x1 y1 q u : nat) {struct x1} :
                                nat * nat :=
                              match x1 with
                              | 0%nat => (q, u)
                              | S x' =>
                                  match u with
                                  | 0%nat => divmod x' y1 (S q) y1
                                  | S u' => divmod x' y1 q u'
                                  end
                              end) x0 y' 0%nat y' in
                         x1
                     end 1%nat 0%nat 1%nat in
                 x1) m'
          end
         else false
        then (R1, R0)
        else (R0, R0) in
      y1) *
     (let (x1, _) :=
        EQ
          match
            (let (_, y1) :=
               (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                  match x1 with
                  | 0%nat => (q, u)
                  | S x' =>
                      match u with
                      | 0%nat => divmod x' y1 (S q) y1
                      | S u' => divmod x' y1 q u'
                      end
                  end)
                 match
                   (fix pow (n m : nat) {struct m} : nat :=
                      match m with
                      | 0%nat => 1%nat
                      | S m0 =>
                          (fix mul (n0 m1 : nat) {struct n0} : nat :=
                             match n0 with
                             | 0%nat => 0%nat
                             | S p =>
                                 (fix add ... : nat := ...
                                                 ...
                                                 ...
                                                 end) m1 
                                   (mul p m1)
                             end) n (pow n m0)
                      end) 2%nat
                     ((fix sub (n m : nat) {struct n} : nat :=
                         match n with
                         | 0%nat => n
                         | S k =>
                             match m with
                             | 0%nat => n
                             | S l => sub k l
                             end
                         end) eps
                        ((fix add (n m : nat) {struct n} : nat :=
                            match n with
                            | 0%nat => m
                            | S p => S (add p m)
                            end) n 1%nat))
                 with
                 | 0%nat =>
                     (fix pow (n m : nat) {struct m} : nat :=
                        match m with
                        | 0%nat => 1%nat
                        | S m0 =>
                            (fix mul (n0 m1 : nat) {struct n0} : nat :=
                               match n0 with
                               | 0%nat => 0%nat
                               | S p =>
                                   (fix add (n1 m2 : nat) {struct n1} :
                                        nat :=
                                      match ... with
                                      | ... => m2
                                      | ... => S ...
                                      end) m1 (mul p m1)
                               end) n (pow n m0)
                        end) 2%nat
                       ((fix sub (n m : nat) {struct n} : nat :=
                           match n with
                           | 0%nat => n
                           | S k =>
                               match m with
                               | 0%nat => n
                               | S l => sub k l
                               end
                           end) eps
                          ((fix add (n m : nat) {struct n} : nat :=
                              match n with
                              | 0%nat => m
                              | S p => S (add p m)
                              end) n 1%nat))
                 | S y' =>
                     let (x1, _) :=
                       (fix divmod (x1 y1 q u : nat) {struct x1} :
                            nat * nat :=
                          match x1 with
                          | 0%nat => (q, u)
                          | S x' =>
                              match u with
                              | 0%nat => divmod x' y1 (S q) y1
                              | S u' => divmod x' y1 q u'
                              end
                          end) x0 y' 0%nat y' in
                     x1
                 end 1%nat 0%nat 1%nat in
             y1)
          with
          | 0%nat => 1%nat
          | S _ => 0%nat
          end
          match
            (let (_, y1) :=
               (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                  match x1 with
                  | 0%nat => (q, u)
                  | S x' =>
                      match u with
                      | 0%nat => divmod x' y1 (S q) y1
                      | S u' => divmod x' y1 q u'
                      end
                  end)
                 match
                   (fix pow (n m : nat) {struct m} : nat :=
                      match m with
                      | 0%nat => 1%nat
                      | S m0 =>
                          (fix mul (n0 m1 : nat) {struct n0} : nat :=
                             match n0 with
                             | 0%nat => 0%nat
                             | S p =>
                                 (fix add ... : nat := ...
                                                 ...
                                                 ...
                                                 end) m1 
                                   (mul p m1)
                             end) n (pow n m0)
                      end) 2%nat
                     ((fix sub (n m : nat) {struct n} : nat :=
                         match n with
                         | 0%nat => n
                         | S k =>
                             match m with
                             | 0%nat => n
                             | S l => sub k l
                             end
                         end) eps
                        ((fix add (n m : nat) {struct n} : nat :=
                            match n with
                            | 0%nat => m
                            | S p => S (add p m)
                            end) n 1%nat))
                 with
                 | 0%nat =>
                     (fix pow (n m : nat) {struct m} : nat :=
                        match m with
                        | 0%nat => 1%nat
                        | S m0 =>
                            (fix mul (n0 m1 : nat) {struct n0} : nat :=
                               match n0 with
                               | 0%nat => 0%nat
                               | S p =>
                                   (fix add (n1 m2 : nat) {struct n1} :
                                        nat :=
                                      match ... with
                                      | ... => m2
                                      | ... => S ...
                                      end) m1 (mul p m1)
                               end) n (pow n m0)
                        end) 2%nat
                       ((fix sub (n m : nat) {struct n} : nat :=
                           match n with
                           | 0%nat => n
                           | S k =>
                               match m with
                               | 0%nat => n
                               | S l => sub k l
                               end
                           end) eps
                          ((fix add (n m : nat) {struct n} : nat :=
                              match n with
                              | 0%nat => m
                              | S p => S (add p m)
                              end) n 1%nat))
                 | S y' =>
                     let (x1, _) :=
                       (fix divmod (x1 y1 q u : nat) {struct x1} :
                            nat * nat :=
                          match x1 with
                          | 0%nat => (q, u)
                          | S x' =>
                              match u with
                              | 0%nat => divmod x' y1 (S q) y1
                              | S u' => divmod x' y1 q u'
                              end
                          end) y0 y' 0%nat y' in
                     x1
                 end 1%nat 0%nat 1%nat in
             y1)
          with
          | 0%nat => 1%nat
          | S _ => 0%nat
          end in
      x1)) *
    (let (x1, _) :=
       if
        if
         (fix eqb (n m : nat) {struct n} : bool :=
            match n with
            | 0%nat => match m with
                       | 0%nat => true
                       | S _ => false
                       end
            | S n' => match m with
                      | 0%nat => false
                      | S m' => eqb n' m'
                      end
            end)
           match
             (fix pow (n m : nat) {struct m} : nat :=
                match m with
                | 0%nat => 1%nat
                | S m0 =>
                    (fix mul (n0 m1 : nat) {struct n0} : nat :=
                       match n0 with
                       | 0%nat => 0%nat
                       | S p =>
                           (fix add (n1 m2 : nat) {struct n1} : nat :=
                              match n1 with
                              | 0%nat => m2
                              | S p0 => S (add p0 m2)
                              end) m1 (mul p m1)
                       end) n (pow n m0)
                end) 2%nat
               ((fix sub (n m : nat) {struct n} : nat :=
                   match n with
                   | 0%nat => n
                   | S k => match m with
                            | 0%nat => n
                            | S l => sub k l
                            end
                   end) eps
                  ((fix add (n m : nat) {struct n} : nat :=
                      match n with
                      | 0%nat => m
                      | S p => S (add p m)
                      end) n 1%nat))
           with
           | 0%nat => x0
           | S y' =>
               (fix sub (n m : nat) {struct n} : nat :=
                  match n with
                  | 0%nat => n
                  | S k => match m with
                           | 0%nat => n
                           | S l => sub k l
                           end
                  end) y'
                 (let (_, y1) :=
                    (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                       match x1 with
                       | 0%nat => (q, u)
                       | S x' =>
                           match u with
                           | 0%nat => divmod x' y1 (S q) y1
                           | S u' => divmod x' y1 q u'
                           end
                       end) x0 y' 0%nat y' in
                  y1)
           end
           match
             (fix pow (n m : nat) {struct m} : nat :=
                match m with
                | 0%nat => 1%nat
                | S m0 =>
                    (fix mul (n0 m1 : nat) {struct n0} : nat :=
                       match n0 with
                       | 0%nat => 0%nat
                       | S p =>
                           (fix add (n1 m2 : nat) {struct n1} : nat :=
                              match n1 with
                              | 0%nat => m2
                              | S p0 => S (add p0 m2)
                              end) m1 (mul p m1)
                       end) n (pow n m0)
                end) 2%nat
               ((fix sub (n m : nat) {struct n} : nat :=
                   match n with
                   | 0%nat => n
                   | S k => match m with
                            | 0%nat => n
                            | S l => sub k l
                            end
                   end) eps
                  ((fix add (n m : nat) {struct n} : nat :=
                      match n with
                      | 0%nat => m
                      | S p => S (add p m)
                      end) n 1%nat))
           with
           | 0%nat => y0
           | S y' =>
               (fix sub (n m : nat) {struct n} : nat :=
                  match n with
                  | 0%nat => n
                  | S k => match m with
                           | 0%nat => n
                           | S l => sub k l
                           end
                  end) y'
                 (let (_, y1) :=
                    (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                       match x1 with
                       | 0%nat => (q, u)
                       | S x' =>
                           match u with
                           | 0%nat => divmod x' y1 (S q) y1
                           | S u' => divmod x' y1 q u'
                           end
                       end) y0 y' 0%nat y' in
                  y1)
           end
        then
         match
           (fix pow (n m : nat) {struct m} : nat :=
              match m with
              | 0%nat => 1%nat
              | S m0 =>
                  (fix mul (n0 m1 : nat) {struct n0} : nat :=
                     match n0 with
                     | 0%nat => 0%nat
                     | S p =>
                         (fix add (n1 m2 : nat) {struct n1} : nat :=
                            match n1 with
                            | 0%nat => m2
                            | S p0 => S (add p0 m2)
                            end) m1 (mul p m1)
                     end) n (pow n m0)
              end) 2%nat
             ((fix sub (n m : nat) {struct n} : nat :=
                 match n with
                 | 0%nat => n
                 | S k => match m with
                          | 0%nat => n
                          | S l => sub k l
                          end
                 end) eps
                ((fix add (n m : nat) {struct n} : nat :=
                    match n with
                    | 0%nat => m
                    | S p => S (add p m)
                    end) n 1%nat))
         with
         | 0%nat => false
         | S m' =>
             (fix leb (n m : nat) {struct n} : bool :=
                match n with
                | 0%nat => true
                | S n' =>
                    match m with
                    | 0%nat => false
                    | S m'0 => leb n' m'0
                    end
                end)
               match
                 (fix pow (n m : nat) {struct m} : nat :=
                    match m with
                    | 0%nat => 1%nat
                    | S m0 =>
                        (fix mul (n0 m1 : nat) {struct n0} : nat :=
                           match n0 with
                           | 0%nat => 0%nat
                           | S p =>
                               (fix add (n1 m2 : nat) {struct n1} : nat :=
                                  match n1 with
                                  | 0%nat => m2
                                  | S p0 => S (add p0 m2)
                                  end) m1 (mul p m1)
                           end) n (pow n m0)
                    end) 2%nat
                   ((fix sub (n m : nat) {struct n} : nat :=
                       match n with
                       | 0%nat => n
                       | S k =>
                           match m with
                           | 0%nat => n
                           | S l => sub k l
                           end
                       end) eps
                      ((fix add (n m : nat) {struct n} : nat :=
                          match n with
                          | 0%nat => m
                          | S p => S (add p m)
                          end) n 1%nat))
               with
               | 0%nat => x0
               | S y' =>
                   (fix sub (n m : nat) {struct n} : nat :=
                      match n with
                      | 0%nat => n
                      | S k => match m with
                               | 0%nat => n
                               | S l => sub k l
                               end
                      end) y'
                     (let (_, y1) :=
                        (fix divmod (x1 y1 q u : nat) {struct x1} :
                             nat * nat :=
                           match x1 with
                           | 0%nat => (q, u)
                           | S x' =>
                               match u with
                               | 0%nat => divmod x' y1 (S q) y1
                               | S u' => divmod x' y1 q u'
                               end
                           end) x0 y' 0%nat y' in
                      y1)
               end m'
         end
        else false
       then (R1, R0)
       else (R0, R0) in
     x1))%R)
  else fun _ _ : nat => (R0, R0)) x y = (R0, R0))
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
out of reach
Tactic call ran for 0.005 secs (0.002u,0.001s) (failure)
Tactic call ran for 0.003 secs (0.002u,0.001s) (success)
Tactic call ran for 0.006 secs (0.006u,0.s) (success)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching:
(forall u : Square 2, (m < n)%nat -> WF_Unitary u -> WF_Unitary (pad_u n m u))
Crunching: ((z >= 2 ^ n)%nat \/ (t >= 2 ^ n)%nat -> pad_u n m u z t = 0)
Crunching: (WF_Unitary (pad_u n m H1))
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.006 secs (0.005u,0.001s) (success)
Crunching: (perm_to_matrix 0 p n x = 0%R)
Tactic call ran for 0.003 secs (0.002u,0.001s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Crunching: (perm_to_matrix H q x Zx = R0)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Crunching: ((x < H)%nat -> WF_Unitary l -> WF_Unitary (pad_u H x l))
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Crunching: (fswap H7 Hnd Hnd = H7)
Crunching: (nat -> False)
Crunching:
(WF_Matrix (perm_to_matrix a n) /\
 (perm_to_matrix a n) † × perm_to_matrix a n = I (2 ^ a))
Crunching: (nat -> False)
Crunching:
((qubit_perm_to_nat_perm n f ∘ qubit_perm_to_nat_perm n g)%prg =
 qubit_perm_to_nat_perm n (g ∘ f)%prg)
Crunching: (nat -> False)
Crunching: (nat -> False)
Crunching: (nat -> False)
Crunching:
((qubit_perm_to_nat_perm n f ∘ qubit_perm_to_nat_perm n g)%prg =
 qubit_perm_to_nat_perm n (g ∘ f)%prg)
Crunching: (fswap H7 Hnd Hnd = H7)
Crunching: (fswap f x x x0 = f x0)
Crunching:
((qubit_perm_to_nat_perm q m ∘ qubit_perm_to_nat_perm q H1)%prg =
 qubit_perm_to_nat_perm q (H1 ∘ m)%prg)
Tactic call ran for 0.01 secs (0.01u,0.s) (success)
Crunching:
((qubit_perm_to_nat_perm n f ∘ qubit_perm_to_nat_perm n g)%prg =
 qubit_perm_to_nat_perm n (g ∘ f)%prg)
Crunching: (nat -> False)
Crunching:
((qubit_perm_to_nat_perm n f ∘ qubit_perm_to_nat_perm n g)%prg =
 qubit_perm_to_nat_perm n (g ∘ f)%prg)
Crunching: (nat -> False)
Crunching:
(pr_outcome_sum (Ha :: a) abs =
 ((if abs 0%nat then Ha else 0) + pr_outcome_sum a (fun i : nat => abs (S i)))%R)
Crunching:
((-1 + 0)%R = (-1)%R ->
 (0 + -1)%R = (-1)%R ->
 (qubit_perm_to_nat_perm q Hl ∘ qubit_perm_to_nat_perm q g)%prg =
 qubit_perm_to_nat_perm q (g ∘ Hl)%prg)
Crunching:
(0 <= H2 <= Hfalse -> Hfalse * H2 + H2 * Hfalse <= H2 * H2 + Hfalse * Hfalse)
Crunching: (nat -> False)
Crunching: nat
Crunching: (nat -> False)
Tactic call ran for 0.01 secs (0.01u,0.s) (success)
Crunching: (nat -> False)
Crunching: (nat -> False)
Crunching: (nat -> False)
Crunching: (nat -> False)
Crunching:
((qubit_perm_to_nat_perm q m ∘ qubit_perm_to_nat_perm q H1)%prg =
 qubit_perm_to_nat_perm q (H1 ∘ m)%prg)
Crunching:
((qubit_perm_to_nat_perm q m ∘ qubit_perm_to_nat_perm q H1)%prg =
 qubit_perm_to_nat_perm q (H1 ∘ m)%prg)
Crunching: (nat -> False)
Crunching: (nat -> False)
Crunching: (nat -> False)
Crunching: (nat -> False)
Crunching: (nat -> False)
Crunching: (nat -> False)
Crunching: (nat -> False)
Crunching: (nat -> False)
Tactic call ran for 0.01 secs (0.01u,0.s) (success)
Crunching: (nat -> False)
Crunching: (nat -> False)
Crunching: (nat -> False)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching:
(Σ (fun y0 : nat => (perm_to_matrix m n 0 y0 * perm_to_matrix m o y0 y)%C) x0 =
 perm_to_matrix m (fun x : nat => o (n x)) 0 y0)
Crunching:
(Morphisms.respectful ?R3 eq
   (Σ (fun y0 : nat => (perm_to_matrix m n x y0 * perm_to_matrix m o y0 y)%C))
   (perm_to_matrix m (fun x : nat => o (n x)) x))
rewrite if_dtt
if (n =? proj1_sig r)
then
(fun E : (n =? proj1_sig r) = true =>
 ltN_of_nat 0 (S n) (ltN_S_mod_lemma1 r E))
else
(fun E : (n =? proj1_sig r) = false =>
 ltN_of_nat (S (proj1_sig r)) (S n) (ltN_S_mod_lemma2 r E))
Crunching:
(Σ (fun y0 : nat => (perm_to_matrix m n 0 y0 * perm_to_matrix m o y0 y)%C) x0 =
 perm_to_matrix m (fun x : nat => o (n x)) 0 y0)
Crunching:
(Morphisms.respectful ?R3 eq
   (Σ (fun y0 : nat => (perm_to_matrix m n x y0 * perm_to_matrix m o y0 y)%C))
   (perm_to_matrix m (fun x : nat => o (n x)) x))
Crunching: (pr_outcome_sum l a = pr_outcome_sum l Ha)
Crunching: (pr_outcome_sum l a = pr_outcome_sum l Ha)
Crunching: (pr_outcome_sum l a = pr_outcome_sum l Ha)
Crunching: (pr_outcome_sum l a = pr_outcome_sum l Ha)
Crunching: (pr_outcome_sum l a = pr_outcome_sum l Ha)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching:
(perm_to_matrix p q × perm_to_matrix p n = perm_to_matrix p (n ∘ q)%prg)
Crunching:
(perm_to_matrix a b × perm_to_matrix a Hb = perm_to_matrix a (Hb ∘ b)%prg)
Tactic call ran for 0.01 secs (0.01u,0.s) (success)
Crunching:
((fix Ffix (x : nat) (x0 : nat -> bool) {struct x} : nat -> nat -> R * R :=
    match x with
    | 0 =>
        fun x1 x2 : nat =>
        if
         if
          (fix Ffix0 (x3 x4 : nat) {struct x3} : bool :=
             match x3 with
             | 0 => match x4 with
                    | 0 => true
                    | S _ => false
                    end
             | S x5 => match x4 with
                       | 0 => false
                       | S x6 => Ffix0 x5 x6
                       end
             end) x1 x2
         then
          (fix Ffix0 (x3 x4 : nat) {struct x3} : bool :=
             match x3 with
             | 0 => true
             | S x5 => match x4 with
                       | 0 => false
                       | S x6 => Ffix0 x5 x6
                       end
             end) x1 0
         else false
        then (R1, R0)
        else (R0, R0)
    | S x1 =>
        fun x2 x3 : nat =>
        (((let (H, _) :=
             Ffix x1 x0
               (let (H, _) :=
                  (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                     match x4 with
                     | 0%nat => (x6, x7)
                     | S x8 =>
                         match x7 with
                         | 0%nat => Ffix0 x8 x5 (S x6) x5
                         | S x9 => Ffix0 x8 x5 x6 x9
                         end
                     end) x2 1%nat 0%nat 1%nat in
                H)
               (let (H, _) :=
                  (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                     match x4 with
                     | 0%nat => (x6, x7)
                     | S x8 =>
                         match x7 with
                         | 0%nat => Ffix0 x8 x5 (S x6) x5
                         | S x9 => Ffix0 x8 x5 x6 x9
                         end
                     end) x3 0%nat 0%nat 0%nat in
                H) in
           H) *
          (let (H, _) :=
             (if
               (fix Ffix0 (x4 x5 : nat) {struct x4} : bool :=
                  match x4 with
                  | 0%nat => match x5 with
                             | 0%nat => true
                             | S _ => false
                             end
                  | S x6 =>
                      match x5 with
                      | 0%nat => false
                      | S x7 => Ffix0 x6 x7
                      end
                  end) (if x0 x1 then 1%nat else 0%nat) 0%nat
              then
               fun x4 x5 : nat =>
               match x4 with
               | 0%nat =>
                   match x5 with
                   | 0%nat => (R1, R0)
                   | S _ => (R0, R0)
                   end
               | 1%nat => match x5 with
                          | 0%nat | _ => (R0, R0)
                          end
               | S (S _) => (R0, R0)
               end
              else
               fun x4 x5 : nat =>
               match x4 with
               | 0%nat => match x5 with
                          | 0%nat | _ => (R0, R0)
                          end
               | 1%nat =>
                   match x5 with
                   | 0%nat => (R1, R0)
                   | S _ => (R0, R0)
                   end
               | S (S _) => (R0, R0)
               end)
               match
                 (let (_, H) :=
                    (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                       match x4 with
                       | 0%nat => (x6, x7)
                       | S x8 =>
                           match x7 with
                           | 0%nat => Ffix0 x8 x5 (S x6) x5
                           | S x9 => Ffix0 x8 x5 x6 x9
                           end
                       end) x2 1%nat 0%nat 1%nat in
                  H)
               with
               | 0%nat => 1%nat
               | S _ => 0%nat
               end 0%nat in
           H) +
          -
          ((let (_, H) :=
              Ffix x1 x0
                (let (H, _) :=
                   (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                      match x4 with
                      | 0%nat => (x6, x7)
                      | S x8 =>
                          match x7 with
                          | 0%nat => Ffix0 x8 x5 (S x6) x5
                          | S x9 => Ffix0 x8 x5 x6 x9
                          end
                      end) x2 1%nat 0%nat 1%nat in
                 H)
                (let (H, _) :=
                   (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                      match x4 with
                      | 0%nat => (x6, x7)
                      | S x8 =>
                          match x7 with
                          | 0%nat => Ffix0 x8 x5 (S x6) x5
                          | S x9 => Ffix0 x8 x5 x6 x9
                          end
                      end) x3 0%nat 0%nat 0%nat in
                 H) in
            H) *
           (let (_, H) :=
              (if
                (fix Ffix0 (x4 x5 : nat) {struct x4} : bool :=
                   match x4 with
                   | 0%nat =>
                       match x5 with
                       | 0%nat => true
                       | S _ => false
                       end
                   | S x6 =>
                       match x5 with
                       | 0%nat => false
                       | S x7 => Ffix0 x6 x7
                       end
                   end) (if x0 x1 then 1%nat else 0%nat) 0%nat
               then
                fun x4 x5 : nat =>
                match x4 with
                | 0%nat =>
                    match x5 with
                    | 0%nat => (R1, R0)
                    | S _ => (R0, R0)
                    end
                | 1%nat => match x5 with
                           | 0%nat | _ => (R0, R0)
                           end
                | S (S _) => (R0, R0)
                end
               else
                fun x4 x5 : nat =>
                match x4 with
                | 0%nat => match x5 with
                           | 0%nat | _ => (R0, R0)
                           end
                | 1%nat =>
                    match x5 with
                    | 0%nat => (R1, R0)
                    | S _ => (R0, R0)
                    end
                | S (S _) => (R0, R0)
                end)
                match
                  (let (_, H) :=
                     (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} :
                          nat * nat :=
                        match x4 with
                        | 0%nat => (x6, x7)
                        | S x8 =>
                            match x7 with
                            | 0%nat => Ffix0 x8 x5 (S x6) x5
                            | S x9 => Ffix0 x8 x5 x6 x9
                            end
                        end) x2 1%nat 0%nat 1%nat in
                   H)
                with
                | 0%nat => 1%nat
                | S _ => 0%nat
                end 0%nat in
            H)))%R,
        ((let (H, _) :=
            Ffix x1 x0
              (let (H, _) :=
                 (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                    match x4 with
                    | 0%nat => (x6, x7)
                    | S x8 =>
                        match x7 with
                        | 0%nat => Ffix0 x8 x5 (S x6) x5
                        | S x9 => Ffix0 x8 x5 x6 x9
                        end
                    end) x2 1%nat 0%nat 1%nat in
               H)
              (let (H, _) :=
                 (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                    match x4 with
                    | 0%nat => (x6, x7)
                    | S x8 =>
                        match x7 with
                        | 0%nat => Ffix0 x8 x5 (S x6) x5
                        | S x9 => Ffix0 x8 x5 x6 x9
                        end
                    end) x3 0%nat 0%nat 0%nat in
               H) in
          H) *
         (let (_, H) :=
            (if
              (fix Ffix0 (x4 x5 : nat) {struct x4} : bool :=
                 match x4 with
                 | 0%nat => match x5 with
                            | 0%nat => true
                            | S _ => false
                            end
                 | S x6 =>
                     match x5 with
                     | 0%nat => false
                     | S x7 => Ffix0 x6 x7
                     end
                 end) (if x0 x1 then 1%nat else 0%nat) 0%nat
             then
              fun x4 x5 : nat =>
              match x4 with
              | 0%nat =>
                  match x5 with
                  | 0%nat => (R1, R0)
                  | S _ => (R0, R0)
                  end
              | 1%nat => match x5 with
                         | 0%nat | _ => (R0, R0)
                         end
              | S (S _) => (R0, R0)
              end
             else
              fun x4 x5 : nat =>
              match x4 with
              | 0%nat => match x5 with
                         | 0%nat | _ => (R0, R0)
                         end
              | 1%nat =>
                  match x5 with
                  | 0%nat => (R1, R0)
                  | S _ => (R0, R0)
                  end
              | S (S _) => (R0, R0)
              end)
              match
                (let (_, H) :=
                   (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                      match x4 with
                      | 0%nat => (x6, x7)
                      | S x8 =>
                          match x7 with
                          | 0%nat => Ffix0 x8 x5 (S x6) x5
                          | S x9 => Ffix0 x8 x5 x6 x9
                          end
                      end) x2 1%nat 0%nat 1%nat in
                 H)
              with
              | 0%nat => 1%nat
              | S _ => 0%nat
              end 0%nat in
          H) +
         (let (_, H) :=
            Ffix x1 x0
              (let (H, _) :=
                 (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                    match x4 with
                    | 0%nat => (x6, x7)
                    | S x8 =>
                        match x7 with
                        | 0%nat => Ffix0 x8 x5 (S x6) x5
                        | S x9 => Ffix0 x8 x5 x6 x9
                        end
                    end) x2 1%nat 0%nat 1%nat in
               H)
              (let (H, _) :=
                 (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                    match x4 with
                    | 0%nat => (x6, x7)
                    | S x8 =>
                        match x7 with
                        | 0%nat => Ffix0 x8 x5 (S x6) x5
                        | S x9 => Ffix0 x8 x5 x6 x9
                        end
                    end) x3 0%nat 0%nat 0%nat in
               H) in
          H) *
         (let (H, _) :=
            (if
              (fix Ffix0 (x4 x5 : nat) {struct x4} : bool :=
                 match x4 with
                 | 0%nat => match x5 with
                            | 0%nat => true
                            | S _ => false
                            end
                 | S x6 =>
                     match x5 with
                     | 0%nat => false
                     | S x7 => Ffix0 x6 x7
                     end
                 end) (if x0 x1 then 1%nat else 0%nat) 0%nat
             then
              fun x4 x5 : nat =>
              match x4 with
              | 0%nat =>
                  match x5 with
                  | 0%nat => (R1, R0)
                  | S _ => (R0, R0)
                  end
              | 1%nat => match x5 with
                         | 0%nat | _ => (R0, R0)
                         end
              | S (S _) => (R0, R0)
              end
             else
              fun x4 x5 : nat =>
              match x4 with
              | 0%nat => match x5 with
                         | 0%nat | _ => (R0, R0)
                         end
              | 1%nat =>
                  match x5 with
                  | 0%nat => (R1, R0)
                  | S _ => (R0, R0)
                  end
              | S (S _) => (R0, R0)
              end)
              match
                (let (_, H) :=
                   (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                      match x4 with
                      | 0%nat => (x6, x7)
                      | S x8 =>
                          match x7 with
                          | 0%nat => Ffix0 x8 x5 (S x6) x5
                          | S x9 => Ffix0 x8 x5 x6 x9
                          end
                      end) x2 1%nat 0%nat 1%nat in
                 H)
              with
              | 0%nat => 1%nat
              | S _ => 0%nat
              end 0%nat in
          H))%R)
    end) P Q 0 y = (R0, R0))
Crunching: (∣0⟩ = basis_vector 2 0)
Tactic call ran for 0.009 secs (0.008u,0.s) (success)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Tactic call ran for 0.008 secs (0.008u,0.s) (success)
Crunching: (p x)
Crunching:
((fix Ffix (x : nat) (x0 : nat -> bool) {struct x} : nat -> nat -> R * R :=
    match x with
    | 0 =>
        fun x1 x2 : nat =>
        if
         if
          (fix Ffix0 (x3 x4 : nat) {struct x3} : bool :=
             match x3 with
             | 0 => match x4 with
                    | 0 => true
                    | S _ => false
                    end
             | S x5 => match x4 with
                       | 0 => false
                       | S x6 => Ffix0 x5 x6
                       end
             end) x1 x2
         then
          (fix Ffix0 (x3 x4 : nat) {struct x3} : bool :=
             match x3 with
             | 0 => true
             | S x5 => match x4 with
                       | 0 => false
                       | S x6 => Ffix0 x5 x6
                       end
             end) x1 0
         else false
        then (R1, R0)
        else (R0, R0)
    | S x1 =>
        fun x2 x3 : nat =>
        (((let (H, _) :=
             Ffix x1 x0
               (let (H, _) :=
                  (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                     match x4 with
                     | 0%nat => (x6, x7)
                     | S x8 =>
                         match x7 with
                         | 0%nat => Ffix0 x8 x5 (S x6) x5
                         | S x9 => Ffix0 x8 x5 x6 x9
                         end
                     end) x2 1%nat 0%nat 1%nat in
                H)
               (let (H, _) :=
                  (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                     match x4 with
                     | 0%nat => (x6, x7)
                     | S x8 =>
                         match x7 with
                         | 0%nat => Ffix0 x8 x5 (S x6) x5
                         | S x9 => Ffix0 x8 x5 x6 x9
                         end
                     end) x3 0%nat 0%nat 0%nat in
                H) in
           H) *
          (let (H, _) :=
             (if
               (fix Ffix0 (x4 x5 : nat) {struct x4} : bool :=
                  match x4 with
                  | 0%nat => match x5 with
                             | 0%nat => true
                             | S _ => false
                             end
                  | S x6 =>
                      match x5 with
                      | 0%nat => false
                      | S x7 => Ffix0 x6 x7
                      end
                  end) (if x0 x1 then 1%nat else 0%nat) 0%nat
              then
               fun x4 x5 : nat =>
               match x4 with
               | 0%nat =>
                   match x5 with
                   | 0%nat => (R1, R0)
                   | S _ => (R0, R0)
                   end
               | 1%nat => match x5 with
                          | 0%nat | _ => (R0, R0)
                          end
               | S (S _) => (R0, R0)
               end
              else
               fun x4 x5 : nat =>
               match x4 with
               | 0%nat => match x5 with
                          | 0%nat | _ => (R0, R0)
                          end
               | 1%nat =>
                   match x5 with
                   | 0%nat => (R1, R0)
                   | S _ => (R0, R0)
                   end
               | S (S _) => (R0, R0)
               end)
               match
                 (let (_, H) :=
                    (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                       match x4 with
                       | 0%nat => (x6, x7)
                       | S x8 =>
                           match x7 with
                           | 0%nat => Ffix0 x8 x5 (S x6) x5
                           | S x9 => Ffix0 x8 x5 x6 x9
                           end
                       end) x2 1%nat 0%nat 1%nat in
                  H)
               with
               | 0%nat => 1%nat
               | S _ => 0%nat
               end 0%nat in
           H) +
          -
          ((let (_, H) :=
              Ffix x1 x0
                (let (H, _) :=
                   (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                      match x4 with
                      | 0%nat => (x6, x7)
                      | S x8 =>
                          match x7 with
                          | 0%nat => Ffix0 x8 x5 (S x6) x5
                          | S x9 => Ffix0 x8 x5 x6 x9
                          end
                      end) x2 1%nat 0%nat 1%nat in
                 H)
                (let (H, _) :=
                   (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                      match x4 with
                      | 0%nat => (x6, x7)
                      | S x8 =>
                          match x7 with
                          | 0%nat => Ffix0 x8 x5 (S x6) x5
                          | S x9 => Ffix0 x8 x5 x6 x9
                          end
                      end) x3 0%nat 0%nat 0%nat in
                 H) in
            H) *
           (let (_, H) :=
              (if
                (fix Ffix0 (x4 x5 : nat) {struct x4} : bool :=
                   match x4 with
                   | 0%nat =>
                       match x5 with
                       | 0%nat => true
                       | S _ => false
                       end
                   | S x6 =>
                       match x5 with
                       | 0%nat => false
                       | S x7 => Ffix0 x6 x7
                       end
                   end) (if x0 x1 then 1%nat else 0%nat) 0%nat
               then
                fun x4 x5 : nat =>
                match x4 with
                | 0%nat =>
                    match x5 with
                    | 0%nat => (R1, R0)
                    | S _ => (R0, R0)
                    end
                | 1%nat => match x5 with
                           | 0%nat | _ => (R0, R0)
                           end
                | S (S _) => (R0, R0)
                end
               else
                fun x4 x5 : nat =>
                match x4 with
                | 0%nat => match x5 with
                           | 0%nat | _ => (R0, R0)
                           end
                | 1%nat =>
                    match x5 with
                    | 0%nat => (R1, R0)
                    | S _ => (R0, R0)
                    end
                | S (S _) => (R0, R0)
                end)
                match
                  (let (_, H) :=
                     (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} :
                          nat * nat :=
                        match x4 with
                        | 0%nat => (x6, x7)
                        | S x8 =>
                            match x7 with
                            | 0%nat => Ffix0 x8 x5 (S x6) x5
                            | S x9 => Ffix0 x8 x5 x6 x9
                            end
                        end) x2 1%nat 0%nat 1%nat in
                   H)
                with
                | 0%nat => 1%nat
                | S _ => 0%nat
                end 0%nat in
            H)))%R,
        ((let (H, _) :=
            Ffix x1 x0
              (let (H, _) :=
                 (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                    match x4 with
                    | 0%nat => (x6, x7)
                    | S x8 =>
                        match x7 with
                        | 0%nat => Ffix0 x8 x5 (S x6) x5
                        | S x9 => Ffix0 x8 x5 x6 x9
                        end
                    end) x2 1%nat 0%nat 1%nat in
               H)
              (let (H, _) :=
                 (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                    match x4 with
                    | 0%nat => (x6, x7)
                    | S x8 =>
                        match x7 with
                        | 0%nat => Ffix0 x8 x5 (S x6) x5
                        | S x9 => Ffix0 x8 x5 x6 x9
                        end
                    end) x3 0%nat 0%nat 0%nat in
               H) in
          H) *
         (let (_, H) :=
            (if
              (fix Ffix0 (x4 x5 : nat) {struct x4} : bool :=
                 match x4 with
                 | 0%nat => match x5 with
                            | 0%nat => true
                            | S _ => false
                            end
                 | S x6 =>
                     match x5 with
                     | 0%nat => false
                     | S x7 => Ffix0 x6 x7
                     end
                 end) (if x0 x1 then 1%nat else 0%nat) 0%nat
             then
              fun x4 x5 : nat =>
              match x4 with
              | 0%nat =>
                  match x5 with
                  | 0%nat => (R1, R0)
                  | S _ => (R0, R0)
                  end
              | 1%nat => match x5 with
                         | 0%nat | _ => (R0, R0)
                         end
              | S (S _) => (R0, R0)
              end
             else
              fun x4 x5 : nat =>
              match x4 with
              | 0%nat => match x5 with
                         | 0%nat | _ => (R0, R0)
                         end
              | 1%nat =>
                  match x5 with
                  | 0%nat => (R1, R0)
                  | S _ => (R0, R0)
                  end
              | S (S _) => (R0, R0)
              end)
              match
                (let (_, H) :=
                   (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                      match x4 with
                      | 0%nat => (x6, x7)
                      | S x8 =>
                          match x7 with
                          | 0%nat => Ffix0 x8 x5 (S x6) x5
                          | S x9 => Ffix0 x8 x5 x6 x9
                          end
                      end) x2 1%nat 0%nat 1%nat in
                 H)
              with
              | 0%nat => 1%nat
              | S _ => 0%nat
              end 0%nat in
          H) +
         (let (_, H) :=
            Ffix x1 x0
              (let (H, _) :=
                 (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                    match x4 with
                    | 0%nat => (x6, x7)
                    | S x8 =>
                        match x7 with
                        | 0%nat => Ffix0 x8 x5 (S x6) x5
                        | S x9 => Ffix0 x8 x5 x6 x9
                        end
                    end) x2 1%nat 0%nat 1%nat in
               H)
              (let (H, _) :=
                 (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                    match x4 with
                    | 0%nat => (x6, x7)
                    | S x8 =>
                        match x7 with
                        | 0%nat => Ffix0 x8 x5 (S x6) x5
                        | S x9 => Ffix0 x8 x5 x6 x9
                        end
                    end) x3 0%nat 0%nat 0%nat in
               H) in
          H) *
         (let (H, _) :=
            (if
              (fix Ffix0 (x4 x5 : nat) {struct x4} : bool :=
                 match x4 with
                 | 0%nat => match x5 with
                            | 0%nat => true
                            | S _ => false
                            end
                 | S x6 =>
                     match x5 with
                     | 0%nat => false
                     | S x7 => Ffix0 x6 x7
                     end
                 end) (if x0 x1 then 1%nat else 0%nat) 0%nat
             then
              fun x4 x5 : nat =>
              match x4 with
              | 0%nat =>
                  match x5 with
                  | 0%nat => (R1, R0)
                  | S _ => (R0, R0)
                  end
              | 1%nat => match x5 with
                         | 0%nat | _ => (R0, R0)
                         end
              | S (S _) => (R0, R0)
              end
             else
              fun x4 x5 : nat =>
              match x4 with
              | 0%nat => match x5 with
                         | 0%nat | _ => (R0, R0)
                         end
              | 1%nat =>
                  match x5 with
                  | 0%nat => (R1, R0)
                  | S _ => (R0, R0)
                  end
              | S (S _) => (R0, R0)
              end)
              match
                (let (_, H) :=
                   (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                      match x4 with
                      | 0%nat => (x6, x7)
                      | S x8 =>
                          match x7 with
                          | 0%nat => Ffix0 x8 x5 (S x6) x5
                          | S x9 => Ffix0 x8 x5 x6 x9
                          end
                      end) x2 1%nat 0%nat 1%nat in
                 H)
              with
              | 0%nat => 1%nat
              | S _ => 0%nat
              end 0%nat in
          H))%R)
    end) P Q 0 y = (R0, R0))
Crunching:
((fix Ffix (x : nat) (x0 : nat -> bool) {struct x} : nat -> nat -> R * R :=
    match x with
    | 0 =>
        fun x1 x2 : nat =>
        if
         if
          (fix Ffix0 (x3 x4 : nat) {struct x3} : bool :=
             match x3 with
             | 0 => match x4 with
                    | 0 => true
                    | S _ => false
                    end
             | S x5 => match x4 with
                       | 0 => false
                       | S x6 => Ffix0 x5 x6
                       end
             end) x1 x2
         then
          (fix Ffix0 (x3 x4 : nat) {struct x3} : bool :=
             match x3 with
             | 0 => true
             | S x5 => match x4 with
                       | 0 => false
                       | S x6 => Ffix0 x5 x6
                       end
             end) x1 0
         else false
        then (R1, R0)
        else (R0, R0)
    | S x1 =>
        fun x2 x3 : nat =>
        (((let (H, _) :=
             Ffix x1 x0
               (let (H, _) :=
                  (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                     match x4 with
                     | 0%nat => (x6, x7)
                     | S x8 =>
                         match x7 with
                         | 0%nat => Ffix0 x8 x5 (S x6) x5
                         | S x9 => Ffix0 x8 x5 x6 x9
                         end
                     end) x2 1%nat 0%nat 1%nat in
                H)
               (let (H, _) :=
                  (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                     match x4 with
                     | 0%nat => (x6, x7)
                     | S x8 =>
                         match x7 with
                         | 0%nat => Ffix0 x8 x5 (S x6) x5
                         | S x9 => Ffix0 x8 x5 x6 x9
                         end
                     end) x3 0%nat 0%nat 0%nat in
                H) in
           H) *
          (let (H, _) :=
             (if
               (fix Ffix0 (x4 x5 : nat) {struct x4} : bool :=
                  match x4 with
                  | 0%nat => match x5 with
                             | 0%nat => true
                             | S _ => false
                             end
                  | S x6 =>
                      match x5 with
                      | 0%nat => false
                      | S x7 => Ffix0 x6 x7
                      end
                  end) (if x0 x1 then 1%nat else 0%nat) 0%nat
              then
               fun x4 x5 : nat =>
               match x4 with
               | 0%nat =>
                   match x5 with
                   | 0%nat => (R1, R0)
                   | S _ => (R0, R0)
                   end
               | 1%nat => match x5 with
                          | 0%nat | _ => (R0, R0)
                          end
               | S (S _) => (R0, R0)
               end
              else
               fun x4 x5 : nat =>
               match x4 with
               | 0%nat => match x5 with
                          | 0%nat | _ => (R0, R0)
                          end
               | 1%nat =>
                   match x5 with
                   | 0%nat => (R1, R0)
                   | S _ => (R0, R0)
                   end
               | S (S _) => (R0, R0)
               end)
               match
                 (let (_, H) :=
                    (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                       match x4 with
                       | 0%nat => (x6, x7)
                       | S x8 =>
                           match x7 with
                           | 0%nat => Ffix0 x8 x5 (S x6) x5
                           | S x9 => Ffix0 x8 x5 x6 x9
                           end
                       end) x2 1%nat 0%nat 1%nat in
                  H)
               with
               | 0%nat => 1%nat
               | S _ => 0%nat
               end 0%nat in
           H) +
          -
          ((let (_, H) :=
              Ffix x1 x0
                (let (H, _) :=
                   (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                      match x4 with
                      | 0%nat => (x6, x7)
                      | S x8 =>
                          match x7 with
                          | 0%nat => Ffix0 x8 x5 (S x6) x5
                          | S x9 => Ffix0 x8 x5 x6 x9
                          end
                      end) x2 1%nat 0%nat 1%nat in
                 H)
                (let (H, _) :=
                   (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                      match x4 with
                      | 0%nat => (x6, x7)
                      | S x8 =>
                          match x7 with
                          | 0%nat => Ffix0 x8 x5 (S x6) x5
                          | S x9 => Ffix0 x8 x5 x6 x9
                          end
                      end) x3 0%nat 0%nat 0%nat in
                 H) in
            H) *
           (let (_, H) :=
              (if
                (fix Ffix0 (x4 x5 : nat) {struct x4} : bool :=
                   match x4 with
                   | 0%nat =>
                       match x5 with
                       | 0%nat => true
                       | S _ => false
                       end
                   | S x6 =>
                       match x5 with
                       | 0%nat => false
                       | S x7 => Ffix0 x6 x7
                       end
                   end) (if x0 x1 then 1%nat else 0%nat) 0%nat
               then
                fun x4 x5 : nat =>
                match x4 with
                | 0%nat =>
                    match x5 with
                    | 0%nat => (R1, R0)
                    | S _ => (R0, R0)
                    end
                | 1%nat => match x5 with
                           | 0%nat | _ => (R0, R0)
                           end
                | S (S _) => (R0, R0)
                end
               else
                fun x4 x5 : nat =>
                match x4 with
                | 0%nat => match x5 with
                           | 0%nat | _ => (R0, R0)
                           end
                | 1%nat =>
                    match x5 with
                    | 0%nat => (R1, R0)
                    | S _ => (R0, R0)
                    end
                | S (S _) => (R0, R0)
                end)
                match
                  (let (_, H) :=
                     (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} :
                          nat * nat :=
                        match x4 with
                        | 0%nat => (x6, x7)
                        | S x8 =>
                            match x7 with
                            | 0%nat => Ffix0 x8 x5 (S x6) x5
                            | S x9 => Ffix0 x8 x5 x6 x9
                            end
                        end) x2 1%nat 0%nat 1%nat in
                   H)
                with
                | 0%nat => 1%nat
                | S _ => 0%nat
                end 0%nat in
            H)))%R,
        ((let (H, _) :=
            Ffix x1 x0
              (let (H, _) :=
                 (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                    match x4 with
                    | 0%nat => (x6, x7)
                    | S x8 =>
                        match x7 with
                        | 0%nat => Ffix0 x8 x5 (S x6) x5
                        | S x9 => Ffix0 x8 x5 x6 x9
                        end
                    end) x2 1%nat 0%nat 1%nat in
               H)
              (let (H, _) :=
                 (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                    match x4 with
                    | 0%nat => (x6, x7)
                    | S x8 =>
                        match x7 with
                        | 0%nat => Ffix0 x8 x5 (S x6) x5
                        | S x9 => Ffix0 x8 x5 x6 x9
                        end
                    end) x3 0%nat 0%nat 0%nat in
               H) in
          H) *
         (let (_, H) :=
            (if
              (fix Ffix0 (x4 x5 : nat) {struct x4} : bool :=
                 match x4 with
                 | 0%nat => match x5 with
                            | 0%nat => true
                            | S _ => false
                            end
                 | S x6 =>
                     match x5 with
                     | 0%nat => false
                     | S x7 => Ffix0 x6 x7
                     end
                 end) (if x0 x1 then 1%nat else 0%nat) 0%nat
             then
              fun x4 x5 : nat =>
              match x4 with
              | 0%nat =>
                  match x5 with
                  | 0%nat => (R1, R0)
                  | S _ => (R0, R0)
                  end
              | 1%nat => match x5 with
                         | 0%nat | _ => (R0, R0)
                         end
              | S (S _) => (R0, R0)
              end
             else
              fun x4 x5 : nat =>
              match x4 with
              | 0%nat => match x5 with
                         | 0%nat | _ => (R0, R0)
                         end
              | 1%nat =>
                  match x5 with
                  | 0%nat => (R1, R0)
                  | S _ => (R0, R0)
                  end
              | S (S _) => (R0, R0)
              end)
              match
                (let (_, H) :=
                   (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                      match x4 with
                      | 0%nat => (x6, x7)
                      | S x8 =>
                          match x7 with
                          | 0%nat => Ffix0 x8 x5 (S x6) x5
                          | S x9 => Ffix0 x8 x5 x6 x9
                          end
                      end) x2 1%nat 0%nat 1%nat in
                 H)
              with
              | 0%nat => 1%nat
              | S _ => 0%nat
              end 0%nat in
          H) +
         (let (_, H) :=
            Ffix x1 x0
              (let (H, _) :=
                 (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                    match x4 with
                    | 0%nat => (x6, x7)
                    | S x8 =>
                        match x7 with
                        | 0%nat => Ffix0 x8 x5 (S x6) x5
                        | S x9 => Ffix0 x8 x5 x6 x9
                        end
                    end) x2 1%nat 0%nat 1%nat in
               H)
              (let (H, _) :=
                 (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                    match x4 with
                    | 0%nat => (x6, x7)
                    | S x8 =>
                        match x7 with
                        | 0%nat => Ffix0 x8 x5 (S x6) x5
                        | S x9 => Ffix0 x8 x5 x6 x9
                        end
                    end) x3 0%nat 0%nat 0%nat in
               H) in
          H) *
         (let (H, _) :=
            (if
              (fix Ffix0 (x4 x5 : nat) {struct x4} : bool :=
                 match x4 with
                 | 0%nat => match x5 with
                            | 0%nat => true
                            | S _ => false
                            end
                 | S x6 =>
                     match x5 with
                     | 0%nat => false
                     | S x7 => Ffix0 x6 x7
                     end
                 end) (if x0 x1 then 1%nat else 0%nat) 0%nat
             then
              fun x4 x5 : nat =>
              match x4 with
              | 0%nat =>
                  match x5 with
                  | 0%nat => (R1, R0)
                  | S _ => (R0, R0)
                  end
              | 1%nat => match x5 with
                         | 0%nat | _ => (R0, R0)
                         end
              | S (S _) => (R0, R0)
              end
             else
              fun x4 x5 : nat =>
              match x4 with
              | 0%nat => match x5 with
                         | 0%nat | _ => (R0, R0)
                         end
              | 1%nat =>
                  match x5 with
                  | 0%nat => (R1, R0)
                  | S _ => (R0, R0)
                  end
              | S (S _) => (R0, R0)
              end)
              match
                (let (_, H) :=
                   (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                      match x4 with
                      | 0%nat => (x6, x7)
                      | S x8 =>
                          match x7 with
                          | 0%nat => Ffix0 x8 x5 (S x6) x5
                          | S x9 => Ffix0 x8 x5 x6 x9
                          end
                      end) x2 1%nat 0%nat 1%nat in
                 H)
              with
              | 0%nat => 1%nat
              | S _ => 0%nat
              end 0%nat in
          H))%R)
    end) P Q 0 y = (R0, R0))
Crunching:
((fix Ffix (x : nat) (x0 : nat -> bool) {struct x} : nat -> nat -> R * R :=
    match x with
    | 0 =>
        fun x1 x2 : nat =>
        if
         if
          (fix Ffix0 (x3 x4 : nat) {struct x3} : bool :=
             match x3 with
             | 0 => match x4 with
                    | 0 => true
                    | S _ => false
                    end
             | S x5 => match x4 with
                       | 0 => false
                       | S x6 => Ffix0 x5 x6
                       end
             end) x1 x2
         then
          (fix Ffix0 (x3 x4 : nat) {struct x3} : bool :=
             match x3 with
             | 0 => true
             | S x5 => match x4 with
                       | 0 => false
                       | S x6 => Ffix0 x5 x6
                       end
             end) x1 0
         else false
        then (R1, R0)
        else (R0, R0)
    | S x1 =>
        fun x2 x3 : nat =>
        (((let (H, _) :=
             Ffix x1 x0
               (let (H, _) :=
                  (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                     match x4 with
                     | 0%nat => (x6, x7)
                     | S x8 =>
                         match x7 with
                         | 0%nat => Ffix0 x8 x5 (S x6) x5
                         | S x9 => Ffix0 x8 x5 x6 x9
                         end
                     end) x2 1%nat 0%nat 1%nat in
                H)
               (let (H, _) :=
                  (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                     match x4 with
                     | 0%nat => (x6, x7)
                     | S x8 =>
                         match x7 with
                         | 0%nat => Ffix0 x8 x5 (S x6) x5
                         | S x9 => Ffix0 x8 x5 x6 x9
                         end
                     end) x3 0%nat 0%nat 0%nat in
                H) in
           H) *
          (let (H, _) :=
             (if
               (fix Ffix0 (x4 x5 : nat) {struct x4} : bool :=
                  match x4 with
                  | 0%nat => match x5 with
                             | 0%nat => true
                             | S _ => false
                             end
                  | S x6 =>
                      match x5 with
                      | 0%nat => false
                      | S x7 => Ffix0 x6 x7
                      end
                  end) (if x0 x1 then 1%nat else 0%nat) 0%nat
              then
               fun x4 x5 : nat =>
               match x4 with
               | 0%nat =>
                   match x5 with
                   | 0%nat => (R1, R0)
                   | S _ => (R0, R0)
                   end
               | 1%nat => match x5 with
                          | 0%nat | _ => (R0, R0)
                          end
               | S (S _) => (R0, R0)
               end
              else
               fun x4 x5 : nat =>
               match x4 with
               | 0%nat => match x5 with
                          | 0%nat | _ => (R0, R0)
                          end
               | 1%nat =>
                   match x5 with
                   | 0%nat => (R1, R0)
                   | S _ => (R0, R0)
                   end
               | S (S _) => (R0, R0)
               end)
               match
                 (let (_, H) :=
                    (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                       match x4 with
                       | 0%nat => (x6, x7)
                       | S x8 =>
                           match x7 with
                           | 0%nat => Ffix0 x8 x5 (S x6) x5
                           | S x9 => Ffix0 x8 x5 x6 x9
                           end
                       end) x2 1%nat 0%nat 1%nat in
                  H)
               with
               | 0%nat => 1%nat
               | S _ => 0%nat
               end 0%nat in
           H) +
          -
          ((let (_, H) :=
              Ffix x1 x0
                (let (H, _) :=
                   (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                      match x4 with
                      | 0%nat => (x6, x7)
                      | S x8 =>
                          match x7 with
                          | 0%nat => Ffix0 x8 x5 (S x6) x5
                          | S x9 => Ffix0 x8 x5 x6 x9
                          end
                      end) x2 1%nat 0%nat 1%nat in
                 H)
                (let (H, _) :=
                   (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                      match x4 with
                      | 0%nat => (x6, x7)
                      | S x8 =>
                          match x7 with
                          | 0%nat => Ffix0 x8 x5 (S x6) x5
                          | S x9 => Ffix0 x8 x5 x6 x9
                          end
                      end) x3 0%nat 0%nat 0%nat in
                 H) in
            H) *
           (let (_, H) :=
              (if
                (fix Ffix0 (x4 x5 : nat) {struct x4} : bool :=
                   match x4 with
                   | 0%nat =>
                       match x5 with
                       | 0%nat => true
                       | S _ => false
                       end
                   | S x6 =>
                       match x5 with
                       | 0%nat => false
                       | S x7 => Ffix0 x6 x7
                       end
                   end) (if x0 x1 then 1%nat else 0%nat) 0%nat
               then
                fun x4 x5 : nat =>
                match x4 with
                | 0%nat =>
                    match x5 with
                    | 0%nat => (R1, R0)
                    | S _ => (R0, R0)
                    end
                | 1%nat => match x5 with
                           | 0%nat | _ => (R0, R0)
                           end
                | S (S _) => (R0, R0)
                end
               else
                fun x4 x5 : nat =>
                match x4 with
                | 0%nat => match x5 with
                           | 0%nat | _ => (R0, R0)
                           end
                | 1%nat =>
                    match x5 with
                    | 0%nat => (R1, R0)
                    | S _ => (R0, R0)
                    end
                | S (S _) => (R0, R0)
                end)
                match
                  (let (_, H) :=
                     (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} :
                          nat * nat :=
                        match x4 with
                        | 0%nat => (x6, x7)
                        | S x8 =>
                            match x7 with
                            | 0%nat => Ffix0 x8 x5 (S x6) x5
                            | S x9 => Ffix0 x8 x5 x6 x9
                            end
                        end) x2 1%nat 0%nat 1%nat in
                   H)
                with
                | 0%nat => 1%nat
                | S _ => 0%nat
                end 0%nat in
            H)))%R,
        ((let (H, _) :=
            Ffix x1 x0
              (let (H, _) :=
                 (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                    match x4 with
                    | 0%nat => (x6, x7)
                    | S x8 =>
                        match x7 with
                        | 0%nat => Ffix0 x8 x5 (S x6) x5
                        | S x9 => Ffix0 x8 x5 x6 x9
                        end
                    end) x2 1%nat 0%nat 1%nat in
               H)
              (let (H, _) :=
                 (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                    match x4 with
                    | 0%nat => (x6, x7)
                    | S x8 =>
                        match x7 with
                        | 0%nat => Ffix0 x8 x5 (S x6) x5
                        | S x9 => Ffix0 x8 x5 x6 x9
                        end
                    end) x3 0%nat 0%nat 0%nat in
               H) in
          H) *
         (let (_, H) :=
            (if
              (fix Ffix0 (x4 x5 : nat) {struct x4} : bool :=
                 match x4 with
                 | 0%nat => match x5 with
                            | 0%nat => true
                            | S _ => false
                            end
                 | S x6 =>
                     match x5 with
                     | 0%nat => false
                     | S x7 => Ffix0 x6 x7
                     end
                 end) (if x0 x1 then 1%nat else 0%nat) 0%nat
             then
              fun x4 x5 : nat =>
              match x4 with
              | 0%nat =>
                  match x5 with
                  | 0%nat => (R1, R0)
                  | S _ => (R0, R0)
                  end
              | 1%nat => match x5 with
                         | 0%nat | _ => (R0, R0)
                         end
              | S (S _) => (R0, R0)
              end
             else
              fun x4 x5 : nat =>
              match x4 with
              | 0%nat => match x5 with
                         | 0%nat | _ => (R0, R0)
                         end
              | 1%nat =>
                  match x5 with
                  | 0%nat => (R1, R0)
                  | S _ => (R0, R0)
                  end
              | S (S _) => (R0, R0)
              end)
              match
                (let (_, H) :=
                   (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                      match x4 with
                      | 0%nat => (x6, x7)
                      | S x8 =>
                          match x7 with
                          | 0%nat => Ffix0 x8 x5 (S x6) x5
                          | S x9 => Ffix0 x8 x5 x6 x9
                          end
                      end) x2 1%nat 0%nat 1%nat in
                 H)
              with
              | 0%nat => 1%nat
              | S _ => 0%nat
              end 0%nat in
          H) +
         (let (_, H) :=
            Ffix x1 x0
              (let (H, _) :=
                 (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                    match x4 with
                    | 0%nat => (x6, x7)
                    | S x8 =>
                        match x7 with
                        | 0%nat => Ffix0 x8 x5 (S x6) x5
                        | S x9 => Ffix0 x8 x5 x6 x9
                        end
                    end) x2 1%nat 0%nat 1%nat in
               H)
              (let (H, _) :=
                 (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                    match x4 with
                    | 0%nat => (x6, x7)
                    | S x8 =>
                        match x7 with
                        | 0%nat => Ffix0 x8 x5 (S x6) x5
                        | S x9 => Ffix0 x8 x5 x6 x9
                        end
                    end) x3 0%nat 0%nat 0%nat in
               H) in
          H) *
         (let (H, _) :=
            (if
              (fix Ffix0 (x4 x5 : nat) {struct x4} : bool :=
                 match x4 with
                 | 0%nat => match x5 with
                            | 0%nat => true
                            | S _ => false
                            end
                 | S x6 =>
                     match x5 with
                     | 0%nat => false
                     | S x7 => Ffix0 x6 x7
                     end
                 end) (if x0 x1 then 1%nat else 0%nat) 0%nat
             then
              fun x4 x5 : nat =>
              match x4 with
              | 0%nat =>
                  match x5 with
                  | 0%nat => (R1, R0)
                  | S _ => (R0, R0)
                  end
              | 1%nat => match x5 with
                         | 0%nat | _ => (R0, R0)
                         end
              | S (S _) => (R0, R0)
              end
             else
              fun x4 x5 : nat =>
              match x4 with
              | 0%nat => match x5 with
                         | 0%nat | _ => (R0, R0)
                         end
              | 1%nat =>
                  match x5 with
                  | 0%nat => (R1, R0)
                  | S _ => (R0, R0)
                  end
              | S (S _) => (R0, R0)
              end)
              match
                (let (_, H) :=
                   (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                      match x4 with
                      | 0%nat => (x6, x7)
                      | S x8 =>
                          match x7 with
                          | 0%nat => Ffix0 x8 x5 (S x6) x5
                          | S x9 => Ffix0 x8 x5 x6 x9
                          end
                      end) x2 1%nat 0%nat 1%nat in
                 H)
              with
              | 0%nat => 1%nat
              | S _ => 0%nat
              end 0%nat in
          H))%R)
    end) P Q 0 y = (R0, R0))
Crunching:
((fix Ffix (x : nat) (x0 : nat -> bool) {struct x} : nat -> nat -> R * R :=
    match x with
    | 0 =>
        fun x1 x2 : nat =>
        if
         if
          (fix Ffix0 (x3 x4 : nat) {struct x3} : bool :=
             match x3 with
             | 0 => match x4 with
                    | 0 => true
                    | S _ => false
                    end
             | S x5 => match x4 with
                       | 0 => false
                       | S x6 => Ffix0 x5 x6
                       end
             end) x1 x2
         then
          (fix Ffix0 (x3 x4 : nat) {struct x3} : bool :=
             match x3 with
             | 0 => true
             | S x5 => match x4 with
                       | 0 => false
                       | S x6 => Ffix0 x5 x6
                       end
             end) x1 0
         else false
        then (R1, R0)
        else (R0, R0)
    | S x1 =>
        fun x2 x3 : nat =>
        (((let (H, _) :=
             Ffix x1 x0
               (let (H, _) :=
                  (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                     match x4 with
                     | 0%nat => (x6, x7)
                     | S x8 =>
                         match x7 with
                         | 0%nat => Ffix0 x8 x5 (S x6) x5
                         | S x9 => Ffix0 x8 x5 x6 x9
                         end
                     end) x2 1%nat 0%nat 1%nat in
                H)
               (let (H, _) :=
                  (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                     match x4 with
                     | 0%nat => (x6, x7)
                     | S x8 =>
                         match x7 with
                         | 0%nat => Ffix0 x8 x5 (S x6) x5
                         | S x9 => Ffix0 x8 x5 x6 x9
                         end
                     end) x3 0%nat 0%nat 0%nat in
                H) in
           H) *
          (let (H, _) :=
             (if
               (fix Ffix0 (x4 x5 : nat) {struct x4} : bool :=
                  match x4 with
                  | 0%nat => match x5 with
                             | 0%nat => true
                             | S _ => false
                             end
                  | S x6 =>
                      match x5 with
                      | 0%nat => false
                      | S x7 => Ffix0 x6 x7
                      end
                  end) (if x0 x1 then 1%nat else 0%nat) 0%nat
              then
               fun x4 x5 : nat =>
               match x4 with
               | 0%nat =>
                   match x5 with
                   | 0%nat => (R1, R0)
                   | S _ => (R0, R0)
                   end
               | 1%nat => match x5 with
                          | 0%nat | _ => (R0, R0)
                          end
               | S (S _) => (R0, R0)
               end
              else
               fun x4 x5 : nat =>
               match x4 with
               | 0%nat => match x5 with
                          | 0%nat | _ => (R0, R0)
                          end
               | 1%nat =>
                   match x5 with
                   | 0%nat => (R1, R0)
                   | S _ => (R0, R0)
                   end
               | S (S _) => (R0, R0)
               end)
               match
                 (let (_, H) :=
                    (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                       match x4 with
                       | 0%nat => (x6, x7)
                       | S x8 =>
                           match x7 with
                           | 0%nat => Ffix0 x8 x5 (S x6) x5
                           | S x9 => Ffix0 x8 x5 x6 x9
                           end
                       end) x2 1%nat 0%nat 1%nat in
                  H)
               with
               | 0%nat => 1%nat
               | S _ => 0%nat
               end 0%nat in
           H) +
          -
          ((let (_, H) :=
              Ffix x1 x0
                (let (H, _) :=
                   (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                      match x4 with
                      | 0%nat => (x6, x7)
                      | S x8 =>
                          match x7 with
                          | 0%nat => Ffix0 x8 x5 (S x6) x5
                          | S x9 => Ffix0 x8 x5 x6 x9
                          end
                      end) x2 1%nat 0%nat 1%nat in
                 H)
                (let (H, _) :=
                   (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                      match x4 with
                      | 0%nat => (x6, x7)
                      | S x8 =>
                          match x7 with
                          | 0%nat => Ffix0 x8 x5 (S x6) x5
                          | S x9 => Ffix0 x8 x5 x6 x9
                          end
                      end) x3 0%nat 0%nat 0%nat in
                 H) in
            H) *
           (let (_, H) :=
              (if
                (fix Ffix0 (x4 x5 : nat) {struct x4} : bool :=
                   match x4 with
                   | 0%nat =>
                       match x5 with
                       | 0%nat => true
                       | S _ => false
                       end
                   | S x6 =>
                       match x5 with
                       | 0%nat => false
                       | S x7 => Ffix0 x6 x7
                       end
                   end) (if x0 x1 then 1%nat else 0%nat) 0%nat
               then
                fun x4 x5 : nat =>
                match x4 with
                | 0%nat =>
                    match x5 with
                    | 0%nat => (R1, R0)
                    | S _ => (R0, R0)
                    end
                | 1%nat => match x5 with
                           | 0%nat | _ => (R0, R0)
                           end
                | S (S _) => (R0, R0)
                end
               else
                fun x4 x5 : nat =>
                match x4 with
                | 0%nat => match x5 with
                           | 0%nat | _ => (R0, R0)
                           end
                | 1%nat =>
                    match x5 with
                    | 0%nat => (R1, R0)
                    | S _ => (R0, R0)
                    end
                | S (S _) => (R0, R0)
                end)
                match
                  (let (_, H) :=
                     (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} :
                          nat * nat :=
                        match x4 with
                        | 0%nat => (x6, x7)
                        | S x8 =>
                            match x7 with
                            | 0%nat => Ffix0 x8 x5 (S x6) x5
                            | S x9 => Ffix0 x8 x5 x6 x9
                            end
                        end) x2 1%nat 0%nat 1%nat in
                   H)
                with
                | 0%nat => 1%nat
                | S _ => 0%nat
                end 0%nat in
            H)))%R,
        ((let (H, _) :=
            Ffix x1 x0
              (let (H, _) :=
                 (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                    match x4 with
                    | 0%nat => (x6, x7)
                    | S x8 =>
                        match x7 with
                        | 0%nat => Ffix0 x8 x5 (S x6) x5
                        | S x9 => Ffix0 x8 x5 x6 x9
                        end
                    end) x2 1%nat 0%nat 1%nat in
               H)
              (let (H, _) :=
                 (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                    match x4 with
                    | 0%nat => (x6, x7)
                    | S x8 =>
                        match x7 with
                        | 0%nat => Ffix0 x8 x5 (S x6) x5
                        | S x9 => Ffix0 x8 x5 x6 x9
                        end
                    end) x3 0%nat 0%nat 0%nat in
               H) in
          H) *
         (let (_, H) :=
            (if
              (fix Ffix0 (x4 x5 : nat) {struct x4} : bool :=
                 match x4 with
                 | 0%nat => match x5 with
                            | 0%nat => true
                            | S _ => false
                            end
                 | S x6 =>
                     match x5 with
                     | 0%nat => false
                     | S x7 => Ffix0 x6 x7
                     end
                 end) (if x0 x1 then 1%nat else 0%nat) 0%nat
             then
              fun x4 x5 : nat =>
              match x4 with
              | 0%nat =>
                  match x5 with
                  | 0%nat => (R1, R0)
                  | S _ => (R0, R0)
                  end
              | 1%nat => match x5 with
                         | 0%nat | _ => (R0, R0)
                         end
              | S (S _) => (R0, R0)
              end
             else
              fun x4 x5 : nat =>
              match x4 with
              | 0%nat => match x5 with
                         | 0%nat | _ => (R0, R0)
                         end
              | 1%nat =>
                  match x5 with
                  | 0%nat => (R1, R0)
                  | S _ => (R0, R0)
                  end
              | S (S _) => (R0, R0)
              end)
              match
                (let (_, H) :=
                   (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                      match x4 with
                      | 0%nat => (x6, x7)
                      | S x8 =>
                          match x7 with
                          | 0%nat => Ffix0 x8 x5 (S x6) x5
                          | S x9 => Ffix0 x8 x5 x6 x9
                          end
                      end) x2 1%nat 0%nat 1%nat in
                 H)
              with
              | 0%nat => 1%nat
              | S _ => 0%nat
              end 0%nat in
          H) +
         (let (_, H) :=
            Ffix x1 x0
              (let (H, _) :=
                 (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                    match x4 with
                    | 0%nat => (x6, x7)
                    | S x8 =>
                        match x7 with
                        | 0%nat => Ffix0 x8 x5 (S x6) x5
                        | S x9 => Ffix0 x8 x5 x6 x9
                        end
                    end) x2 1%nat 0%nat 1%nat in
               H)
              (let (H, _) :=
                 (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                    match x4 with
                    | 0%nat => (x6, x7)
                    | S x8 =>
                        match x7 with
                        | 0%nat => Ffix0 x8 x5 (S x6) x5
                        | S x9 => Ffix0 x8 x5 x6 x9
                        end
                    end) x3 0%nat 0%nat 0%nat in
               H) in
          H) *
         (let (H, _) :=
            (if
              (fix Ffix0 (x4 x5 : nat) {struct x4} : bool :=
                 match x4 with
                 | 0%nat => match x5 with
                            | 0%nat => true
                            | S _ => false
                            end
                 | S x6 =>
                     match x5 with
                     | 0%nat => false
                     | S x7 => Ffix0 x6 x7
                     end
                 end) (if x0 x1 then 1%nat else 0%nat) 0%nat
             then
              fun x4 x5 : nat =>
              match x4 with
              | 0%nat =>
                  match x5 with
                  | 0%nat => (R1, R0)
                  | S _ => (R0, R0)
                  end
              | 1%nat => match x5 with
                         | 0%nat | _ => (R0, R0)
                         end
              | S (S _) => (R0, R0)
              end
             else
              fun x4 x5 : nat =>
              match x4 with
              | 0%nat => match x5 with
                         | 0%nat | _ => (R0, R0)
                         end
              | 1%nat =>
                  match x5 with
                  | 0%nat => (R1, R0)
                  | S _ => (R0, R0)
                  end
              | S (S _) => (R0, R0)
              end)
              match
                (let (_, H) :=
                   (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                      match x4 with
                      | 0%nat => (x6, x7)
                      | S x8 =>
                          match x7 with
                          | 0%nat => Ffix0 x8 x5 (S x6) x5
                          | S x9 => Ffix0 x8 x5 x6 x9
                          end
                      end) x2 1%nat 0%nat 1%nat in
                 H)
              with
              | 0%nat => 1%nat
              | S _ => 0%nat
              end 0%nat in
          H))%R)
    end) P Q 0 y = (R0, R0))
Crunching:
((fix Ffix (x : nat) (x0 : nat -> bool) {struct x} : nat -> nat -> R * R :=
    match x with
    | 0 =>
        fun x1 x2 : nat =>
        if
         if
          (fix Ffix0 (x3 x4 : nat) {struct x3} : bool :=
             match x3 with
             | 0 => match x4 with
                    | 0 => true
                    | S _ => false
                    end
             | S x5 => match x4 with
                       | 0 => false
                       | S x6 => Ffix0 x5 x6
                       end
             end) x1 x2
         then
          (fix Ffix0 (x3 x4 : nat) {struct x3} : bool :=
             match x3 with
             | 0 => true
             | S x5 => match x4 with
                       | 0 => false
                       | S x6 => Ffix0 x5 x6
                       end
             end) x1 0
         else false
        then (R1, R0)
        else (R0, R0)
    | S x1 =>
        fun x2 x3 : nat =>
        (((let (H, _) :=
             Ffix x1 x0
               (let (H, _) :=
                  (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                     match x4 with
                     | 0%nat => (x6, x7)
                     | S x8 =>
                         match x7 with
                         | 0%nat => Ffix0 x8 x5 (S x6) x5
                         | S x9 => Ffix0 x8 x5 x6 x9
                         end
                     end) x2 1%nat 0%nat 1%nat in
                H)
               (let (H, _) :=
                  (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                     match x4 with
                     | 0%nat => (x6, x7)
                     | S x8 =>
                         match x7 with
                         | 0%nat => Ffix0 x8 x5 (S x6) x5
                         | S x9 => Ffix0 x8 x5 x6 x9
                         end
                     end) x3 0%nat 0%nat 0%nat in
                H) in
           H) *
          (let (H, _) :=
             (if
               (fix Ffix0 (x4 x5 : nat) {struct x4} : bool :=
                  match x4 with
                  | 0%nat => match x5 with
                             | 0%nat => true
                             | S _ => false
                             end
                  | S x6 =>
                      match x5 with
                      | 0%nat => false
                      | S x7 => Ffix0 x6 x7
                      end
                  end) (if x0 x1 then 1%nat else 0%nat) 0%nat
              then
               fun x4 x5 : nat =>
               match x4 with
               | 0%nat =>
                   match x5 with
                   | 0%nat => (R1, R0)
                   | S _ => (R0, R0)
                   end
               | 1%nat => match x5 with
                          | 0%nat | _ => (R0, R0)
                          end
               | S (S _) => (R0, R0)
               end
              else
               fun x4 x5 : nat =>
               match x4 with
               | 0%nat => match x5 with
                          | 0%nat | _ => (R0, R0)
                          end
               | 1%nat =>
                   match x5 with
                   | 0%nat => (R1, R0)
                   | S _ => (R0, R0)
                   end
               | S (S _) => (R0, R0)
               end)
               match
                 (let (_, H) :=
                    (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                       match x4 with
                       | 0%nat => (x6, x7)
                       | S x8 =>
                           match x7 with
                           | 0%nat => Ffix0 x8 x5 (S x6) x5
                           | S x9 => Ffix0 x8 x5 x6 x9
                           end
                       end) x2 1%nat 0%nat 1%nat in
                  H)
               with
               | 0%nat => 1%nat
               | S _ => 0%nat
               end 0%nat in
           H) +
          -
          ((let (_, H) :=
              Ffix x1 x0
                (let (H, _) :=
                   (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                      match x4 with
                      | 0%nat => (x6, x7)
                      | S x8 =>
                          match x7 with
                          | 0%nat => Ffix0 x8 x5 (S x6) x5
                          | S x9 => Ffix0 x8 x5 x6 x9
                          end
                      end) x2 1%nat 0%nat 1%nat in
                 H)
                (let (H, _) :=
                   (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                      match x4 with
                      | 0%nat => (x6, x7)
                      | S x8 =>
                          match x7 with
                          | 0%nat => Ffix0 x8 x5 (S x6) x5
                          | S x9 => Ffix0 x8 x5 x6 x9
                          end
                      end) x3 0%nat 0%nat 0%nat in
                 H) in
            H) *
           (let (_, H) :=
              (if
                (fix Ffix0 (x4 x5 : nat) {struct x4} : bool :=
                   match x4 with
                   | 0%nat =>
                       match x5 with
                       | 0%nat => true
                       | S _ => false
                       end
                   | S x6 =>
                       match x5 with
                       | 0%nat => false
                       | S x7 => Ffix0 x6 x7
                       end
                   end) (if x0 x1 then 1%nat else 0%nat) 0%nat
               then
                fun x4 x5 : nat =>
                match x4 with
                | 0%nat =>
                    match x5 with
                    | 0%nat => (R1, R0)
                    | S _ => (R0, R0)
                    end
                | 1%nat => match x5 with
                           | 0%nat | _ => (R0, R0)
                           end
                | S (S _) => (R0, R0)
                end
               else
                fun x4 x5 : nat =>
                match x4 with
                | 0%nat => match x5 with
                           | 0%nat | _ => (R0, R0)
                           end
                | 1%nat =>
                    match x5 with
                    | 0%nat => (R1, R0)
                    | S _ => (R0, R0)
                    end
                | S (S _) => (R0, R0)
                end)
                match
                  (let (_, H) :=
                     (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} :
                          nat * nat :=
                        match x4 with
                        | 0%nat => (x6, x7)
                        | S x8 =>
                            match x7 with
                            | 0%nat => Ffix0 x8 x5 (S x6) x5
                            | S x9 => Ffix0 x8 x5 x6 x9
                            end
                        end) x2 1%nat 0%nat 1%nat in
                   H)
                with
                | 0%nat => 1%nat
                | S _ => 0%nat
                end 0%nat in
            H)))%R,
        ((let (H, _) :=
            Ffix x1 x0
              (let (H, _) :=
                 (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                    match x4 with
                    | 0%nat => (x6, x7)
                    | S x8 =>
                        match x7 with
                        | 0%nat => Ffix0 x8 x5 (S x6) x5
                        | S x9 => Ffix0 x8 x5 x6 x9
                        end
                    end) x2 1%nat 0%nat 1%nat in
               H)
              (let (H, _) :=
                 (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                    match x4 with
                    | 0%nat => (x6, x7)
                    | S x8 =>
                        match x7 with
                        | 0%nat => Ffix0 x8 x5 (S x6) x5
                        | S x9 => Ffix0 x8 x5 x6 x9
                        end
                    end) x3 0%nat 0%nat 0%nat in
               H) in
          H) *
         (let (_, H) :=
            (if
              (fix Ffix0 (x4 x5 : nat) {struct x4} : bool :=
                 match x4 with
                 | 0%nat => match x5 with
                            | 0%nat => true
                            | S _ => false
                            end
                 | S x6 =>
                     match x5 with
                     | 0%nat => false
                     | S x7 => Ffix0 x6 x7
                     end
                 end) (if x0 x1 then 1%nat else 0%nat) 0%nat
             then
              fun x4 x5 : nat =>
              match x4 with
              | 0%nat =>
                  match x5 with
                  | 0%nat => (R1, R0)
                  | S _ => (R0, R0)
                  end
              | 1%nat => match x5 with
                         | 0%nat | _ => (R0, R0)
                         end
              | S (S _) => (R0, R0)
              end
             else
              fun x4 x5 : nat =>
              match x4 with
              | 0%nat => match x5 with
                         | 0%nat | _ => (R0, R0)
                         end
              | 1%nat =>
                  match x5 with
                  | 0%nat => (R1, R0)
                  | S _ => (R0, R0)
                  end
              | S (S _) => (R0, R0)
              end)
              match
                (let (_, H) :=
                   (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                      match x4 with
                      | 0%nat => (x6, x7)
                      | S x8 =>
                          match x7 with
                          | 0%nat => Ffix0 x8 x5 (S x6) x5
                          | S x9 => Ffix0 x8 x5 x6 x9
                          end
                      end) x2 1%nat 0%nat 1%nat in
                 H)
              with
              | 0%nat => 1%nat
              | S _ => 0%nat
              end 0%nat in
          H) +
         (let (_, H) :=
            Ffix x1 x0
              (let (H, _) :=
                 (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                    match x4 with
                    | 0%nat => (x6, x7)
                    | S x8 =>
                        match x7 with
                        | 0%nat => Ffix0 x8 x5 (S x6) x5
                        | S x9 => Ffix0 x8 x5 x6 x9
                        end
                    end) x2 1%nat 0%nat 1%nat in
               H)
              (let (H, _) :=
                 (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                    match x4 with
                    | 0%nat => (x6, x7)
                    | S x8 =>
                        match x7 with
                        | 0%nat => Ffix0 x8 x5 (S x6) x5
                        | S x9 => Ffix0 x8 x5 x6 x9
                        end
                    end) x3 0%nat 0%nat 0%nat in
               H) in
          H) *
         (let (H, _) :=
            (if
              (fix Ffix0 (x4 x5 : nat) {struct x4} : bool :=
                 match x4 with
                 | 0%nat => match x5 with
                            | 0%nat => true
                            | S _ => false
                            end
                 | S x6 =>
                     match x5 with
                     | 0%nat => false
                     | S x7 => Ffix0 x6 x7
                     end
                 end) (if x0 x1 then 1%nat else 0%nat) 0%nat
             then
              fun x4 x5 : nat =>
              match x4 with
              | 0%nat =>
                  match x5 with
                  | 0%nat => (R1, R0)
                  | S _ => (R0, R0)
                  end
              | 1%nat => match x5 with
                         | 0%nat | _ => (R0, R0)
                         end
              | S (S _) => (R0, R0)
              end
             else
              fun x4 x5 : nat =>
              match x4 with
              | 0%nat => match x5 with
                         | 0%nat | _ => (R0, R0)
                         end
              | 1%nat =>
                  match x5 with
                  | 0%nat => (R1, R0)
                  | S _ => (R0, R0)
                  end
              | S (S _) => (R0, R0)
              end)
              match
                (let (_, H) :=
                   (fix Ffix0 (x4 x5 x6 x7 : nat) {struct x4} : nat * nat :=
                      match x4 with
                      | 0%nat => (x6, x7)
                      | S x8 =>
                          match x7 with
                          | 0%nat => Ffix0 x8 x5 (S x6) x5
                          | S x9 => Ffix0 x8 x5 x6 x9
                          end
                      end) x2 1%nat 0%nat 1%nat in
                 H)
              with
              | 0%nat => 1%nat
              | S _ => 0%nat
              end 0%nat in
          H))%R)
    end) P Q 0 y = (R0, R0))
Crunching: ((/ √ 2)%R = 0)
Crunching: (forall x y z : R, y <= z - x -> x + y <= z)
Crunching: (p x)
Crunching: ((/ √ 2)%R = 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching:
(forall f : nat -> bool,
 (forall i : nat, (i < length [])%nat -> f i = false) ->
 pr_outcome_sum [] f = 0)
Crunching:
(list2D_to_matrix [[e]] = perm_to_matrix 0 a × perm_to_matrix 0 s1')
Crunching:
(list2D_to_matrix [[perm_to_matrix 0 s1' 0 0]] =
 perm_to_matrix 0 (s1' ∘ a)%prg)
Crunching: (m ~= 0)
rewrite if_dtt
if (n =? S (proj1_sig k))
then
(fun E : (n =? S (proj1_sig k)) = true =>
 ltN_of_nat 0 n (ltN_S_mod_lemma1 k E))
else
(fun E : (n =? S (proj1_sig k)) = false =>
 ltN_of_nat (S (proj1_sig k)) n (ltN_S_mod_lemma2 k E))
Crunching:
((0%nat = m -> False) ->
 (0 < q)%nat ->
 (m < q)%nat ->
 WF_Matrix (pad_swap q 0 m) /\
 (pad_swap q 0 m) † × pad_swap q 0 m = I (2 ^ q))
Crunching:
((fun i j : nat => if (i =? x * 2 ^ n + y) && (j =? 0) then C1 else 0%R) =
 (fun x0 y0 : nat =>
  ((if (x0 / 2 ^ n =? x) && (y0 / 1 =? 0) then C1 else 0%R) *
   (if (x0 mod 2 ^ n =? y) && (y0 mod 1 =? 0) then C1 else 0%R))%C))
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching:
(forall f : nat -> bool,
 (forall i : nat, (i < length [])%nat -> f i = false) ->
 pr_outcome_sum [] f = 0)
Th_13_5_2 :
forall [A B : Ensemble Ord] [f : Ord -> Ord],
ordering_function f A B -> Closed B -> continuous f A B

Th_13_5_2 is not universe polymorphic
Arguments Th_13_5_2 [A B] [f]%function_scope f_ord B_closed
Th_13_5_2 is opaque
Expands to: Constant hydras.Schutte.Ordering_Functions.Th_13_5_2
     = @^~ 8
     : M nat
     = tt
     : [the monad of idfun] unit
     = @^~ None
     : [the contMonad of ContMonad.acto bool] (option nat)
     = @^~ (Some 3)
     : [the contMonad of ContMonad.acto bool] (option nat)
Crunching:
(∣0⟩ ⊗ (fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) =
 (fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R))
Crunching:
(∣1⟩ ⊗ (fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) =
 (fun i j : nat => if (i =? k + n) && (j =? 0) then C1 else 0%R))
Crunching:
((fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩ =
 (fun i j : nat => if (i =? 2 * k) && (j =? 0) then C1 else 0%R))
Crunching:
((fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) ⊗ ∣1⟩ =
 (fun i j : nat => if (i =? 2 * k + 1) && (j =? 0) then C1 else 0%R))
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣1⟩ = basis_vector 2 1)
T1mul_a0E: forall c : T1, c * zero = zero
T1mul1n: forall x : T1, one * x = x
T1muln0: forall x : T1, x * zero = zero
mul_fin_omega: forall n : nat, \F n.+1 * T1omega = T1omega
mul_int_limit: forall (n : nat) [y : T1], T1limit y -> \F n.+1 * y = y
exp_FO:
  forall (z : T1) (n : nat) [v : T1_eqType],
  v != zero -> exp_F z n * exp_O z v = exp_O z v
mult_a_0: forall a : hT1, (a * T1.zero)%t1 = T1.zero
mult_1_a: forall [a : hT1], nf a -> (\F 1 * a)%t1 = a
mult_fin_omega: forall n : nat, (FS n * T1.T1omega)%t1 = T1.T1omega
L7:
  forall (n : nat) [c : hT1] (p : nat),
  c <> T1.zero -> (FS n * T1.cons c p T1.zero)%t1 = T1.cons c p T1.zero
Ex3: (\F 5 * T1.T1omega)%t1 = T1.T1omega
     = Eq
     : comparison
     = Eq
     : comparison
Constant gaia.schutte.ssete9.CantorOrdinal.T1omega
Notation hydras.Epsilon0.T1.T1omega
  (shorter name to refer to it in current context is T1.T1omega)
test : forall a b : word, foo a b = foo b a

test is not universe polymorphic
Arguments test a b
test is opaque
Expands to: Constant bedrock2Examples.LiveVerif.swap.LiveVerif.test
Crunching: (pr_outcome_sum (x :: y) Hxeqy <= 0)
     = @^~ 8
     : M nat
     = tt
     : [the monad of idfun] unit
     = @^~ None
     : [the contMonad of ContMonad.acto bool] (option nat)
     = @^~ (Some 3)
     : [the contMonad of ContMonad.acto bool] (option nat)
test :
forall {word : word 32}, word.ok word -> forall a b : word, foo a b = foo b a

test is not universe polymorphic
Arguments test {word word_ok} a b
test is opaque
Expands to: Constant bedrock2Examples.LiveVerif.swap.test
     = st_get >>=
       ((fix denote (A : UU0) (p : program A) {struct p} : ?M A :=
           match p in (program T) return (?M T) with
           | @p_ret _ _ A0 v => Ret v
           | @p_bind _ _ A0 B m f => denote A0 m >>= (denote B \o f)
           | @p_cond _ _ A0 true p1 _ => denote A0 p1
           | @p_cond _ _ A0 false _ p2 => denote A0 p2
           | p_repeat n p0 =>
               (fix loop (m : nat) : ?M unit :=
                  match m with
                  | 0 => Ret tt
                  | m'.+1 => denote unit p0 >> loop m'
                  end) n
           | p_while fuel c p0 =>
               (fix loop (m : nat) : ?M unit :=
                  match m with
                  | 0 => Ret tt
                  | m'.+1 =>
                      st_get >>=
                      (fun s : nat =>
                       if c s then denote unit p0 >> loop m' else Ret tt)
                  end) fuel
           | p_get => st_get
           | p_put s' => st_put s'
           | p_mark t => st_mark t
           end) nat \o
          (fun n : nat =>
           p_do _ : unit <- p_put n.+1; p_do _ : unit <- p_mark n; p_ret n))
     : ?M nat
     = (0, (1, [:: 0]))
     : nat * (nat * seq nat)
     = (0, (1, [:: 0]))
     : nat * (nat * seq nat)
     = eT [:: 0] (eT 0 (e 1))
     : {l : seq nat &
       {a : nat &
       {s' : nat | step_star (0, p_nonce `; stop nat) l (s', stop nat a)}}}
     = (false, (2, [:: 0; 1]))
     : bool * (nat * seq nat)
     = (false, (2, [:: 0; 1]))
     : bool * (nat * seq nat)
     = eT [:: 0; 1] (eT false (e 2))
     : {l : seq nat &
       {a : bool_eqType &
       {s' : nat
       | step_star (0, p_nonce_twice `; stop bool_eqType) l
           (s', stop bool_eqType a)}}}
     = (tt, (0, [:: false; false; false; false; false; true]))
     : unit * (nat * seq bool)
     = (tt, (0, [:: false; false; false; false; false; true]))
     : unit * (nat * seq bool)
     = eT [:: false; false; false; false; false; true] (eT tt (e 0))
     : {l : seq bool &
       {a : unit &
       {s' : nat
       | step_star (5, p_countdown 100 `; stop unit) l (s', stop unit a)}}}
     = eT [::] (eT tt (e 21))
     : {l : seq unit &
       {a : unit &
       {s' : nat
       | step_star (0, p_multiply 3 7 `; stop unit) l (s', stop unit a)}}}
     = eT [::] (eT tt (e (1, 3)))
     : {l : seq unit &
       {a : unit &
       {s' : nat * nat
       | step_star (0, 0, p_division 22 7 `; stop unit) l (s', stop unit a)}}}
     = Some (eT [::] (eT stop unit tt (e (1, 3))))
     : option
         {l : seq unit &
         {f' : continuation &
         {s' : nat * nat
         | step_n 15 (0, 0, p_division 22 7 `; stop unit) l (s', f')}}}
Finished transaction in 8.402 secs (8.383u,0.018s) (successful)
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 n (ltN_pred_lemma0 k k0 E)))
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 n (ltN_pred_lemma0 k k0 E)))
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 n (ltN_pred_lemma0 k k0 E)))
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 n (ltN_pred_lemma0 k k0 E)))
clear  H0a'  :  (False -> cmpA a a' <> Lt)
rewrite if_dtt
if (proj1_sig k1 + proj1_sig k2 <? n)
then
(fun E : (proj1_sig k1 + proj1_sig k2 <? n) = true =>
 ltN_of_nat (proj1_sig k1 + proj1_sig k2) n E)
else
(fun E : (proj1_sig k1 + proj1_sig k2 <? n) = false =>
 ltN_of_nat (proj1_sig k1 + proj1_sig k2 - n) n (ltN_plus_mod_lemma1 k1 k2 E))
Finished transaction in 60.695 secs (60.562u,0.129s) (successful)
Crunching: (list2D_to_matrix [[e]; [e0]] = / √ 2 .* ∣ 0 ⟩ .+ / √ 2 .* ∣ 1 ⟩)
Crunching:
(list2D_to_matrix [[e]; [e0]] =
 hadamard × list2D_to_matrix [[/ √ 2]; [/ √ 2]])
Crunching:
(list2D_to_matrix
   [[C1 / √ 2 * / √ 2 + C1 / √ 2 * / √ 2];
   [C1 / √ 2 * / √ 2 + - (C1 / √ 2) * / √ 2]] = ∣ 0 ⟩)
Crunching:
(list2D_to_matrix [[e]; [e0]] = / √ 2 .* ∣ 0 ⟩ .+ - / √ 2 .* ∣ 1 ⟩)
Crunching:
(list2D_to_matrix [[e]; [e0]] =
 hadamard × list2D_to_matrix [[/ √ 2]; [- / √ 2]])
Crunching:
(list2D_to_matrix
   [[C1 / √ 2 * / √ 2 + C1 / √ 2 * - / √ 2];
   [C1 / √ 2 * / √ 2 + - (C1 / √ 2) * - / √ 2]] = 
 ∣ 1 ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift θ × ∣ true ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift θ × ∣ false ⟩)
Crunching: (list2D_to_matrix [[0]; [Cexp θ]] = Cexp (true * θ) .* ∣ true ⟩)
Crunching: (list2D_to_matrix [[C1]; [0]] = Cexp (false * θ) .* ∣ false ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = hadamard × ∣ true ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = hadamard × ∣ false ⟩)
Crunching:
(list2D_to_matrix [[C1 / √ 2]; [- (C1 / √ 2)]] =
 / √ 2 .* (∣ 0 ⟩ .+ (-1) ^ true .* ∣ 1 ⟩))
Crunching:
(list2D_to_matrix [[C1 / √ 2]; [C1 / √ 2]] =
 / √ 2 .* (∣ 0 ⟩ .+ (-1) ^ false .* ∣ 1 ⟩))
Crunching: ((∣ 0 ⟩) ⊤ = ⟨ 0 ∣)
Crunching: ((∣ 1 ⟩) ⊤ = ⟨ 1 ∣)
Crunching: ((⟨ 0 ∣) ⊤ = ∣ 0 ⟩)
Crunching: ((⟨ 1 ∣) ⊤ = ∣ 1 ⟩)
Crunching: ((⟨ 1 ∣) † = ∣ 1 ⟩)
Crunching: ((∣ 1 ⟩) † = ⟨ 1 ∣)
Crunching: ((⟨ 0 ∣) † = ∣ 0 ⟩)
Crunching: ((∣ 0 ⟩) † = ⟨ 0 ∣)
Tactic call ran for 0.016 secs (0.016u,0.s) (success)
Tactic call ran for 0.005 secs (0.005u,0.s) (success)
Tactic call ran for 0.007 secs (0.007u,0.s) (success)
Crunching: (pr_outcome_sum (a :: l) x1 = sum_over_list (a :: l))
Crunching: (Rabs (/ 2) < 1)
Tactic call ran for 0.011 secs (0.011u,0.s) (success)
Crunching:
((forall i : nat, i < l -> H i = He i) -> f_to_vec l H = f_to_vec l He)
Tactic call ran for 0.006 secs (0.006u,0.s) (success)
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 (ltN_count (stail p)) (ltN_pred_lemma0 k k0 E)))
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 (ltN_count (stail p)) (ltN_pred_lemma0 k k0 E)))
Crunching:
(forall y : nat,
 H1 >= 2 ^ H10 \/ y >= 2 ^ H10 -> perm_to_matrix H10 H H1 y = 0%R)
Crunching: (pr_outcome_sum (a :: l) x1 = sum_over_list (a :: l))
Crunching:
((forall i : nat, (i < length (x0 :: p0))%nat -> HF i = true) ->
 pr_outcome_sum (x0 :: p0) HF = sum_over_list (x0 :: p0))
Crunching: (perm_to_matrix n x f e2 = 0%R)
Crunching: (Rabs (/ 2) < 1)
Tactic call ran for 0.006 secs (0.006u,0.s) (success)
Crunching: (Rabs (/ 2) < 1)
Crunching: (forall a b c : nat, a < b -> b < c -> S a < c)
Crunching: (m < n)
Crunching:
((forall i : nat, i < l -> H i = He i) -> f_to_vec l H = f_to_vec l He)
rewrite if_dtt
if (n =? S r)
then
(fun E : (n =? S r) = true =>
 ltN_of_nat 0 n
   (ltN_S_mod_lemma1 (exist (fun k : nat => (k <? n) = true) r Hr) E))
else
(fun E : (n =? S r) = false =>
 ltN_of_nat (S r) n
   (ltN_S_mod_lemma2 (exist (fun k : nat => (k <? n) = true) r Hr) E))
clear  H1  :  (False -> b1 = false)
rewrite if_dtt
if (n =? proj1_sig r)
then
(fun E : (n =? proj1_sig r) = true =>
 ltN_of_nat 0 (S n) (ltN_S_mod_lemma1 r E))
else
(fun E : (n =? proj1_sig r) = false =>
 ltN_of_nat (S (proj1_sig r)) (S n) (ltN_S_mod_lemma2 r E))
Crunching: (pr_outcome_sum (a :: l) x1 = sum_over_list (a :: l))
Crunching: (pr_outcome_sum (a :: l) M = sum_over_list (a :: l))
Crunching:
(forall f : nat -> bool,
 pr_outcome_sum [] f =
 (sum_over_list [] - pr_outcome_sum [] (fun x : nat => ¬ f x))%R)
Crunching:
(forall y : nat, a >= r \/ y >= 1 -> basis_vector r Hrpos a y = 0%R)
Crunching:
(pr_outcome_sum Pr eq =
 (sum_over_list Pr - pr_outcome_sum Pr (fun x : nat => ¬ eq x))%R)
Crunching:
(forall y : nat, a >= r \/ y >= 1 -> basis_vector r Hrpos a y = 0%R)
Crunching:
(forall y : nat, r <= H \/ 1 <= y -> basis_vector r Hrpos H y = 0%R)
Crunching:
((sum_over_list Pr - pr_outcome_sum Pr (fun x : nat => ¬ eq x))%R =
 pr_outcome_sum Pr eq)
Crunching:
(pr_outcome_sum Pr eq =
 (sum_over_list Pr - pr_outcome_sum Pr (fun x : nat => ¬ eq x))%R)
Crunching:
(pr_outcome_sum Pr eq =
 (sum_over_list Pr - pr_outcome_sum Pr (fun x : nat => ¬ eq x))%R)
Crunching:
((sum_over_list Pr - pr_outcome_sum Pr (fun x : nat => ¬ eq x))%R =
 pr_outcome_sum Pr eq)
Crunching:
(pr_outcome_sum Pr eq =
 (sum_over_list Pr - pr_outcome_sum Pr (fun x : nat => ¬ eq x))%R)
out of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.004 secs (0.002u,0.001s) (failure)
type_is_by_reference: type -> bool
is_numeric_type: type -> bool
type_is_by_value: type -> bool
is_long_type: type -> bool
is_pointer_type: type -> bool
is_anyfloat_type: type -> bool
is_ptrofs_type: type -> bool
bool_type: type -> bool
is_int32_type: type -> bool
is_int_type: type -> bool
is_scalar_type: type -> bool
is_float_type: type -> bool
is_single_type: type -> bool
type_is_volatile: type -> bool
same_base_type: type -> type -> bool
is_neutral_cast: type -> type -> bool
eqb_type: type -> type -> bool
composite_compute.complete_legal_cosu_type: composite_env -> type -> bool
complete_type: composite_env -> type -> bool
complete_or_function_type: composite_env -> type -> bool
align_mem.LegalAlignasStrong.legal_alignas_type:
  composite_env -> Maps.PTree.t Z -> Maps.PTree.t bool -> type -> bool
align_mem.LegalAlignasFacts.LegalAlignas.legal_alignas_type:
  composite_env -> Maps.PTree.t Z -> Maps.PTree.t bool -> type -> bool
align_mem.LegalAlignasStrict.legal_alignas_type:
  composite_env -> Maps.PTree.t Z -> Maps.PTree.t bool -> type -> bool
align_mem.LegalAlignasStrongFacts.LegalAlignas.legal_alignas_type:
  composite_env -> Maps.PTree.t Z -> Maps.PTree.t bool -> type -> bool
align_mem.LegalAlignasStrictFacts.LegalAlignas.legal_alignas_type:
  composite_env -> Maps.PTree.t Z -> Maps.PTree.t bool -> type -> bool
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
Crunching: (positive -> basis_vector (S Hrpos) Hrpos x y = 0%R)
rewrite if_dtt
if (n =? S (proj1_sig k))
then
(fun E : (n =? S (proj1_sig k)) = true =>
 ltN_of_nat 0 n (ltN_S_mod_lemma1 k E))
else
(fun E : (n =? S (proj1_sig k)) = false =>
 ltN_of_nat (S (proj1_sig k)) n (ltN_S_mod_lemma2 k E))
out of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
Crunching:
((fix big_sum (G : Type) (H : Monoid G) (f : nat -> G) (n : nat) {struct n} :
      G :=
    match n with
    | 0%nat => let (Gzero, Gplus, _, _, _) := H in Gzero
    | S n' =>
        (let (Gzero, Gplus, _, _, _) := H in Gplus) (big_sum G H f n') (f n')
    end) R
   {|
     Gzero := R0;
     Gplus := Rplus;
     Gplus_0_l :=
       fun g : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEc (RMicromega.CZ 0)) (EnvRing.PEX 1);
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs := EnvRing.PEX 1
            |} ()) [] eq_refl (fun _ : positive => g);
     Gplus_0_r :=
       fun g : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEc (RMicromega.CZ 0));
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs := EnvRing.PEX 1
            |} ()) [] eq_refl (fun _ : positive => g);
     Gplus_assoc :=
       fun g h i : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEX 1)
                  (EnvRing.PEadd (EnvRing.PEX 2) (EnvRing.PEX 3));
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs :=
                EnvRing.PEadd (EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEX 2))
                  (EnvRing.PEX 3)
            |} ()) [] eq_refl
         (fun p : positive =>
          match p with
          | (_~1)%positive => i
          | (_~0)%positive => h
          | 1%positive => g
          end)
   |}
   (fun i : nat =>
    if f i
    then
     (fix nth (n : nat) (l : list R) (default : R) {struct l} : R :=
        match n with
        | 0%nat => match l with
                   | [] => default
                   | x :: _ => x
                   end
        | S m => match l with
                 | [] => default
                 | _ :: t => nth m t default
                 end
        end) i HF R0
    else R0)
   ((fix length (l : list R) : nat :=
       match l with
       | [] => 0%nat
       | _ :: l' => S (length l')
       end) HF) =
 ((fix big_sum
     (G : Type) (H : Monoid G) (f : nat -> G) (n : nat) {struct n} : G :=
     match n with
     | 0%nat => let (Gzero, Gplus, _, _, _) := H in Gzero
     | S n' =>
         (let (Gzero, Gplus, _, _, _) := H in Gplus) 
           (big_sum G H f n') (f n')
     end) R
    {|
      Gzero := R0;
      Gplus := Rplus;
      Gplus_0_l :=
        fun g : R =>
        RMicromega.RTautoChecker_sound
          (Tauto.A Tauto.isProp
             {|
               RingMicromega.Flhs :=
                 EnvRing.PEadd (EnvRing.PEc (RMicromega.CZ 0))
                   (EnvRing.PEX 1);
               RingMicromega.Fop := RingMicromega.OpEq;
               RingMicromega.Frhs := EnvRing.PEX 1
             |} ()) [] eq_refl (fun _ : positive => g);
      Gplus_0_r :=
        fun g : R =>
        RMicromega.RTautoChecker_sound
          (Tauto.A Tauto.isProp
             {|
               RingMicromega.Flhs :=
                 EnvRing.PEadd (EnvRing.PEX 1)
                   (EnvRing.PEc (RMicromega.CZ 0));
               RingMicromega.Fop := RingMicromega.OpEq;
               RingMicromega.Frhs := EnvRing.PEX 1
             |} ()) [] eq_refl (fun _ : positive => g);
      Gplus_assoc :=
        fun g h i : R =>
        RMicromega.RTautoChecker_sound
          (Tauto.A Tauto.isProp
             {|
               RingMicromega.Flhs :=
                 EnvRing.PEadd (EnvRing.PEX 1)
                   (EnvRing.PEadd (EnvRing.PEX 2) (EnvRing.PEX 3));
               RingMicromega.Fop := RingMicromega.OpEq;
               RingMicromega.Frhs :=
                 EnvRing.PEadd
                   (EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEX 2))
                   (EnvRing.PEX 3)
             |} ()) [] eq_refl
          (fun p : positive =>
           match p with
           | (_~1)%positive => i
           | (_~0)%positive => h
           | 1%positive => g
           end)
    |}
    (fun i : nat =>
     (fix nth (n : nat) (l : list R) (default : R) {struct l} : R :=
        match n with
        | 0%nat => match l with
                   | [] => default
                   | x :: _ => x
                   end
        | S m => match l with
                 | [] => default
                 | _ :: t => nth m t default
                 end
        end) i HF R0)
    ((fix length (l : list R) : nat :=
        match l with
        | [] => 0%nat
        | _ :: l' => S (length l')
        end) HF) +
  -
  (fix big_sum
     (G : Type) (H : Monoid G) (f : nat -> G) (n : nat) {struct n} : G :=
     match n with
     | 0%nat => let (Gzero, Gplus, _, _, _) := H in Gzero
     | S n' =>
         (let (Gzero, Gplus, _, _, _) := H in Gplus) 
           (big_sum G H f n') (f n')
     end) R
    {|
      Gzero := R0;
      Gplus := Rplus;
      Gplus_0_l :=
        fun g : R =>
        RMicromega.RTautoChecker_sound
          (Tauto.A Tauto.isProp
             {|
               RingMicromega.Flhs :=
                 EnvRing.PEadd (EnvRing.PEc (RMicromega.CZ 0))
                   (EnvRing.PEX 1);
               RingMicromega.Fop := RingMicromega.OpEq;
               RingMicromega.Frhs := EnvRing.PEX 1
             |} ()) [] eq_refl (fun _ : positive => g);
      Gplus_0_r :=
        fun g : R =>
        RMicromega.RTautoChecker_sound
          (Tauto.A Tauto.isProp
             {|
               RingMicromega.Flhs :=
                 EnvRing.PEadd (EnvRing.PEX 1)
                   (EnvRing.PEc (RMicromega.CZ 0));
               RingMicromega.Fop := RingMicromega.OpEq;
               RingMicromega.Frhs := EnvRing.PEX 1
             |} ()) [] eq_refl (fun _ : positive => g);
      Gplus_assoc :=
        fun g h i : R =>
        RMicromega.RTautoChecker_sound
          (Tauto.A Tauto.isProp
             {|
               RingMicromega.Flhs :=
                 EnvRing.PEadd (EnvRing.PEX 1)
                   (EnvRing.PEadd (EnvRing.PEX 2) (EnvRing.PEX 3));
               RingMicromega.Fop := RingMicromega.OpEq;
               RingMicromega.Frhs :=
                 EnvRing.PEadd
                   (EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEX 2))
                   (EnvRing.PEX 3)
             |} ()) [] eq_refl
          (fun p : positive =>
           match p with
           | (_~1)%positive => i
           | (_~0)%positive => h
           | 1%positive => g
           end)
    |}
    (fun i : nat =>
     if if f i then false else true
     then
      (fix nth (n : nat) (l : list R) (default : R) {struct l} : R :=
         match n with
         | 0%nat => match l with
                    | [] => default
                    | x :: _ => x
                    end
         | S m =>
             match l with
             | [] => default
             | _ :: t => nth m t default
             end
         end) i HF R0
     else R0)
    ((fix length (l : list R) : nat :=
        match l with
        | [] => 0%nat
        | _ :: l' => S (length l')
        end) HF))%R)
out of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
Crunching: (list2D_to_matrix [[e]] = (basis_vector d n) † × basis_vector d n)
Crunching:
(list2D_to_matrix
   [[Σ (fun y : nat => ((basis_vector d n y 0) ^* * basis_vector d n y 0)%C)
       d]] = I 1)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching:
(0%R =
 Σ (fun y : nat => ((basis_vector d n y 0) ^* * basis_vector d n y 1)%C) d)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector d n y0 0) ^* * basis_vector d n y0 (S (S y)))%C) d)
Crunching:
(0%R =
 Σ (fun y : nat => ((basis_vector d n y 1) ^* * basis_vector d n y 0)%C) d)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector d n y0 1) ^* * basis_vector d n y0 (S y))%C) d)
Crunching:
(0%R =
 Σ
   (fun y : nat =>
    ((basis_vector d n y (S (S x))) ^* * basis_vector d n y 0)%C) d)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector d n y0 (S (S x))) ^* * basis_vector d n y0 (S y))%C) d)
Crunching:
(forall n : nat,
 n < start -> (basis_vector start n) † × basis_vector start n = I 1)
Crunching:
(0 < start -> (basis_vector start 0) † × basis_vector start 0 = I 1)
Crunching: (y < x -> (basis_vector x y) † × basis_vector x y = I 1)
Crunching: (n < Hyp' -> (basis_vector Hyp' n) † × basis_vector Hyp' n = I 1)
out of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
Crunching: (list2D_to_matrix [[e]] = (basis_vector d n) † × basis_vector d n)
Crunching:
(list2D_to_matrix
   [[Σ (fun y : nat => ((basis_vector d n y 0) ^* * basis_vector d n y 0)%C)
       d]] = I 1)
Crunching:
(0%R =
 Σ (fun y : nat => ((basis_vector d n y 0) ^* * basis_vector d n y 1)%C) d)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector d n y0 0) ^* * basis_vector d n y0 (S (S y)))%C) d)
Crunching:
(0%R =
 Σ (fun y : nat => ((basis_vector d n y 1) ^* * basis_vector d n y 0)%C) d)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector d n y0 1) ^* * basis_vector d n y0 (S y))%C) d)
Crunching:
(0%R =
 Σ
   (fun y : nat =>
    ((basis_vector d n y (S (S x))) ^* * basis_vector d n y 0)%C) d)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector d n y0 (S (S x))) ^* * basis_vector d n y0 (S y))%C) d)
Crunching:
(forall n : nat,
 n < start -> (basis_vector start n) † × basis_vector start n = I 1)
Crunching:
(0 < start -> (basis_vector start 0) † × basis_vector start 0 = I 1)
Crunching: (y < x -> (basis_vector x y) † × basis_vector x y = I 1)
Crunching: (list2D_to_matrix [[e]] = (basis_vector x y) † × basis_vector x y)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y0 : nat =>
        ((basis_vector x y y0 0) ^* * basis_vector x y y0 0)%C) x]] = 
 I 1)
Crunching:
(0%R =
 Σ (fun y0 : nat => ((basis_vector x y y0 0) ^* * basis_vector x y y0 1)%C) x)
Crunching:
(0%R =
 Σ
   (fun y1 : nat =>
    ((basis_vector x y y1 0) ^* * basis_vector x y y1 (S (S y0)))%C) x)
Crunching:
(0%R =
 Σ (fun y0 : nat => ((basis_vector x y y0 1) ^* * basis_vector x y y0 0)%C) x)
Crunching:
(0%R =
 Σ
   (fun y1 : nat =>
    ((basis_vector x y y1 1) ^* * basis_vector x y y1 (S y0))%C) x)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector x y y0 (S (S x0))) ^* * basis_vector x y y0 0)%C) x)
Crunching:
(0%R =
 Σ
   (fun y1 : nat =>
    ((basis_vector x y y1 (S (S x0))) ^* * basis_vector x y y1 (S y0))%C) x)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector Hyp' n) † × basis_vector Hyp' n)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y : nat =>
        ((basis_vector Hyp' n y 0) ^* * basis_vector Hyp' n y 0)%C) Hyp']] =
 (fun x y : nat => if (x =? y) && (x <? 1) then C1 else 0%R))
Crunching:
(0%R =
 Σ
   (fun y : nat => ((basis_vector Hyp' n y 0) ^* * basis_vector Hyp' n y 1)%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' n y0 0) ^* * basis_vector Hyp' n y0 (S (S y)))%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y : nat => ((basis_vector Hyp' n y 1) ^* * basis_vector Hyp' n y 0)%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' n y0 1) ^* * basis_vector Hyp' n y0 (S y))%C) Hyp')
Crunching:
(0%R =
 Σ
   (fun y : nat =>
    ((basis_vector Hyp' n y (S (S x))) ^* * basis_vector Hyp' n y 0)%C) Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' n y0 (S (S x))) ^* * basis_vector Hyp' n y0 (S y))%C)
   Hyp')
Crunching: (0 < Hyp' -> (basis_vector Hyp' 0) † × basis_vector Hyp' 0 = I 1)
Crunching:
(forall n : nat,
 n < Hyp' -> (basis_vector Hyp' n) † × basis_vector Hyp' n = I 1)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector Hyp' a) † × basis_vector Hyp' a)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y : nat =>
        ((basis_vector Hyp' a y 0) ^* * basis_vector Hyp' a y 0)%C) Hyp']] =
 I 1)
Crunching:
(0%R =
 Σ
   (fun y : nat => ((basis_vector Hyp' a y 0) ^* * basis_vector Hyp' a y 1)%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' a y0 0) ^* * basis_vector Hyp' a y0 (S (S y)))%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y : nat => ((basis_vector Hyp' a y 1) ^* * basis_vector Hyp' a y 0)%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' a y0 1) ^* * basis_vector Hyp' a y0 (S y))%C) Hyp')
Crunching:
(0%R =
 Σ
   (fun y : nat =>
    ((basis_vector Hyp' a y (S (S x))) ^* * basis_vector Hyp' a y 0)%C) Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' a y0 (S (S x))) ^* * basis_vector Hyp' a y0 (S y))%C)
   Hyp')
Crunching:
(list2D_to_matrix [[e]] = (basis_vector Hyp' n) † × basis_vector Hyp' n)
Crunching:
((fun x y : nat => if (x =? y) && (x <? 1) then C1 else 0%R) =
 list2D_to_matrix
   [[Σ
       (fun y : nat =>
        ((basis_vector Hyp' n y 0) ^* * basis_vector Hyp' n y 0)%C) Hyp']])
Crunching:
(0%R =
 Σ
   (fun y : nat => ((basis_vector Hyp' n y 0) ^* * basis_vector Hyp' n y 1)%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' n y0 0) ^* * basis_vector Hyp' n y0 (S (S y)))%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y : nat => ((basis_vector Hyp' n y 1) ^* * basis_vector Hyp' n y 0)%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' n y0 1) ^* * basis_vector Hyp' n y0 (S y))%C) Hyp')
Crunching:
(0%R =
 Σ
   (fun y : nat =>
    ((basis_vector Hyp' n y (S (S x))) ^* * basis_vector Hyp' n y 0)%C) Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' n y0 (S (S x))) ^* * basis_vector Hyp' n y0 (S y))%C)
   Hyp')
Crunching: (0 < Hyp' -> (basis_vector Hyp' 0) † × basis_vector Hyp' 0 = I 1)
Crunching: (n < Hyp' -> (basis_vector Hyp' n) † × basis_vector Hyp' n = I 1)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector Hyp' n) † × basis_vector Hyp' n)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y : nat =>
        ((basis_vector Hyp' n y 0) ^* * basis_vector Hyp' n y 0)%C) Hyp']] =
 (fun x y : nat => if (x =? y) && (x <? 1) then C1 else 0%R))
Crunching:
(0%R =
 Σ
   (fun y : nat => ((basis_vector Hyp' n y 0) ^* * basis_vector Hyp' n y 1)%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' n y0 0) ^* * basis_vector Hyp' n y0 (S (S y)))%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y : nat => ((basis_vector Hyp' n y 1) ^* * basis_vector Hyp' n y 0)%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' n y0 1) ^* * basis_vector Hyp' n y0 (S y))%C) Hyp')
Crunching:
(0%R =
 Σ
   (fun y : nat =>
    ((basis_vector Hyp' n y (S (S x))) ^* * basis_vector Hyp' n y 0)%C) Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' n y0 (S (S x))) ^* * basis_vector Hyp' n y0 (S y))%C)
   Hyp')
Crunching:
(list2D_to_matrix [[e]] = (basis_vector Hyp' n) † × basis_vector Hyp' n)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y : nat =>
        ((basis_vector Hyp' n y 0) ^* * basis_vector Hyp' n y 0)%C) Hyp']] =
 I 1)
Crunching:
(0%R =
 Σ
   (fun y : nat => ((basis_vector Hyp' n y 0) ^* * basis_vector Hyp' n y 1)%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' n y0 0) ^* * basis_vector Hyp' n y0 (S (S y)))%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y : nat => ((basis_vector Hyp' n y 1) ^* * basis_vector Hyp' n y 0)%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' n y0 1) ^* * basis_vector Hyp' n y0 (S y))%C) Hyp')
Crunching:
(0%R =
 Σ
   (fun y : nat =>
    ((basis_vector Hyp' n y (S (S x))) ^* * basis_vector Hyp' n y 0)%C) Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' n y0 (S (S x))) ^* * basis_vector Hyp' n y0 (S y))%C)
   Hyp')
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching: (forall n : nat, 0 <= (if Nat.eq_dec n 0 then 1 else INR n))
Crunching: (n < Hyp' -> (basis_vector Hyp' n) † × basis_vector Hyp' n = I 1)
Crunching:
(pr_outcome_sum [] m <= pr_outcome_sum [] (fun rnd : nat => m rnd || H rnd))
Crunching: (list2D_to_matrix [[e]] = (basis_vector d n) † × basis_vector d n)
Crunching:
(list2D_to_matrix
   [[Σ (fun y : nat => ((basis_vector d n y 0) ^* * basis_vector d n y 0)%C)
       d]] = I 1)
Crunching:
(0%R =
 Σ (fun y : nat => ((basis_vector d n y 0) ^* * basis_vector d n y 1)%C) d)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector d n y0 0) ^* * basis_vector d n y0 (S (S y)))%C) d)
Crunching:
(0%R =
 Σ (fun y : nat => ((basis_vector d n y 1) ^* * basis_vector d n y 0)%C) d)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector d n y0 1) ^* * basis_vector d n y0 (S y))%C) d)
Crunching:
(0%R =
 Σ
   (fun y : nat =>
    ((basis_vector d n y (S (S x))) ^* * basis_vector d n y 0)%C) d)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector d n y0 (S (S x))) ^* * basis_vector d n y0 (S y))%C) d)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching:
(cv_infty (fun n : nat => INR (S n)) ->
 Forall (fun x : R => 0 <= x) p ->
 pr_outcome_sum p q <= pr_outcome_sum p (fun rnd : nat => q rnd || He rnd))
Crunching:
(0 < 1 ->
 forall f2 : nat -> bool,
 Forall (fun x : R => 0 <= x) p ->
 pr_outcome_sum p q <= pr_outcome_sum p (fun rnd : nat => q rnd || f2 rnd))
Crunching:
(forall n : nat,
 n < start -> (basis_vector start n) † × basis_vector start n = I 1)
Crunching:
(0 < start -> (basis_vector start 0) † × basis_vector start 0 = I 1)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector start 0) † × basis_vector start 0)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y : nat =>
        ((basis_vector start 0 y 0) ^* * basis_vector start 0 y 0)%C) start]] =
 ?y)
Crunching:
(0%R =
 Σ
   (fun y : nat =>
    ((basis_vector start 0 y 0) ^* * basis_vector start 0 y 1)%C) start)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector start 0 y0 0) ^* * basis_vector start 0 y0 (S (S y)))%C)
   start)
Crunching:
(0%R =
 Σ
   (fun y : nat =>
    ((basis_vector start 0 y 1) ^* * basis_vector start 0 y 0)%C) start)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector start 0 y0 1) ^* * basis_vector start 0 y0 (S y))%C) start)
Crunching:
(0%R =
 Σ
   (fun y : nat =>
    ((basis_vector start 0 y (S (S x))) ^* * basis_vector start 0 y 0)%C)
   start)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector start 0 y0 (S (S x))) ^* * basis_vector start 0 y0 (S y))%C)
   start)
Crunching:
(l2 < start -> (basis_vector start l2) † × basis_vector start l2 = I 1)
Crunching: (y < x -> (basis_vector x y) † × basis_vector x y = I 1)
Crunching: (list2D_to_matrix [[e]] = (basis_vector x y) † × basis_vector x y)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y0 : nat =>
        ((basis_vector x y y0 0) ^* * basis_vector x y y0 0)%C) x]] = 
 I 1)
Crunching:
(0%R =
 Σ (fun y0 : nat => ((basis_vector x y y0 0) ^* * basis_vector x y y0 1)%C) x)
Crunching:
(0%R =
 Σ
   (fun y1 : nat =>
    ((basis_vector x y y1 0) ^* * basis_vector x y y1 (S (S y0)))%C) x)
Crunching:
(0%R =
 Σ (fun y0 : nat => ((basis_vector x y y0 1) ^* * basis_vector x y y0 0)%C) x)
Crunching:
(0%R =
 Σ
   (fun y1 : nat =>
    ((basis_vector x y y1 1) ^* * basis_vector x y y1 (S y0))%C) x)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector x y y0 (S (S x0))) ^* * basis_vector x y y0 0)%C) x)
Crunching:
(0%R =
 Σ
   (fun y1 : nat =>
    ((basis_vector x y y1 (S (S x0))) ^* * basis_vector x y y1 (S y0))%C) x)
Crunching: (list2D_to_matrix [[e]] = (basis_vector x y) † × basis_vector x y)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y0 : nat =>
        ((basis_vector x y y0 0) ^* * basis_vector x y y0 0)%C) x]] = 
 I 1)
Crunching:
(0%R =
 Σ (fun y0 : nat => ((basis_vector x y y0 0) ^* * basis_vector x y y0 1)%C) x)
Crunching:
(0%R =
 Σ
   (fun y1 : nat =>
    ((basis_vector x y y1 0) ^* * basis_vector x y y1 (S (S y0)))%C) x)
Crunching:
(0%R =
 Σ (fun y0 : nat => ((basis_vector x y y0 1) ^* * basis_vector x y y0 0)%C) x)
Crunching:
(0%R =
 Σ
   (fun y1 : nat =>
    ((basis_vector x y y1 1) ^* * basis_vector x y y1 (S y0))%C) x)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector x y y0 (S (S x0))) ^* * basis_vector x y y0 0)%C) x)
Crunching:
(0%R =
 Σ
   (fun y1 : nat =>
    ((basis_vector x y y1 (S (S x0))) ^* * basis_vector x y y1 (S y0))%C) x)
Crunching: (list2D_to_matrix [[e]] = (basis_vector x y) † × basis_vector x y)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y0 : nat =>
        ((basis_vector x y y0 0) ^* * basis_vector x y y0 0)%C) x]] = 
 I 1)
Crunching:
(0%R =
 Σ (fun y0 : nat => ((basis_vector x y y0 0) ^* * basis_vector x y y0 1)%C) x)
Crunching:
(0%R =
 Σ
   (fun y1 : nat =>
    ((basis_vector x y y1 0) ^* * basis_vector x y y1 (S (S y0)))%C) x)
Crunching:
(0%R =
 Σ (fun y0 : nat => ((basis_vector x y y0 1) ^* * basis_vector x y y0 0)%C) x)
Crunching:
(0%R =
 Σ
   (fun y1 : nat =>
    ((basis_vector x y y1 1) ^* * basis_vector x y y1 (S y0))%C) x)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector x y y0 (S (S x0))) ^* * basis_vector x y y0 0)%C) x)
Crunching:
(0%R =
 Σ
   (fun y1 : nat =>
    ((basis_vector x y y1 (S (S x0))) ^* * basis_vector x y y1 (S y0))%C) x)
Crunching: (list2D_to_matrix [[e]] = (basis_vector x y) † × basis_vector x y)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y0 : nat =>
        ((basis_vector x y y0 0) ^* * basis_vector x y y0 0)%C) x]] = 
 I 1)
Crunching:
(0%R =
 Σ (fun y0 : nat => ((basis_vector x y y0 0) ^* * basis_vector x y y0 1)%C) x)
Crunching:
(0%R =
 Σ
   (fun y1 : nat =>
    ((basis_vector x y y1 0) ^* * basis_vector x y y1 (S (S y0)))%C) x)
Crunching:
(0%R =
 Σ (fun y0 : nat => ((basis_vector x y y0 1) ^* * basis_vector x y y0 0)%C) x)
Crunching:
(0%R =
 Σ
   (fun y1 : nat =>
    ((basis_vector x y y1 1) ^* * basis_vector x y y1 (S y0))%C) x)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector x y y0 (S (S x0))) ^* * basis_vector x y y0 0)%C) x)
Crunching:
(0%R =
 Σ
   (fun y1 : nat =>
    ((basis_vector x y y1 (S (S x0))) ^* * basis_vector x y y1 (S y0))%C) x)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector Hyp' n) † × basis_vector Hyp' n)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y : nat =>
        ((basis_vector Hyp' n y 0) ^* * basis_vector Hyp' n y 0)%C) Hyp']] =
 (fun x y : nat => if (x =? y) && (x <? 1) then C1 else 0%R))
Crunching:
(0%R =
 Σ
   (fun y : nat => ((basis_vector Hyp' n y 0) ^* * basis_vector Hyp' n y 1)%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' n y0 0) ^* * basis_vector Hyp' n y0 (S (S y)))%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y : nat => ((basis_vector Hyp' n y 1) ^* * basis_vector Hyp' n y 0)%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' n y0 1) ^* * basis_vector Hyp' n y0 (S y))%C) Hyp')
Crunching:
(0%R =
 Σ
   (fun y : nat =>
    ((basis_vector Hyp' n y (S (S x))) ^* * basis_vector Hyp' n y 0)%C) Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' n y0 (S (S x))) ^* * basis_vector Hyp' n y0 (S y))%C)
   Hyp')
Crunching:
(list2D_to_matrix [[e]] = (basis_vector Hyp' n) † × basis_vector Hyp' n)
Crunching:
((fun x y : nat => if (x =? y) && (x <? 1) then C1 else 0%R) =
 list2D_to_matrix
   [[Σ
       (fun y : nat =>
        ((basis_vector Hyp' n y 0) ^* * basis_vector Hyp' n y 0)%C) Hyp']])
Crunching:
(0%R =
 Σ
   (fun y : nat => ((basis_vector Hyp' n y 0) ^* * basis_vector Hyp' n y 1)%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' n y0 0) ^* * basis_vector Hyp' n y0 (S (S y)))%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y : nat => ((basis_vector Hyp' n y 1) ^* * basis_vector Hyp' n y 0)%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' n y0 1) ^* * basis_vector Hyp' n y0 (S y))%C) Hyp')
Crunching:
(0%R =
 Σ
   (fun y : nat =>
    ((basis_vector Hyp' n y (S (S x))) ^* * basis_vector Hyp' n y 0)%C) Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' n y0 (S (S x))) ^* * basis_vector Hyp' n y0 (S y))%C)
   Hyp')
Crunching: (0 < Hyp' -> (basis_vector Hyp' 0) † × basis_vector Hyp' 0 = I 1)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector Hyp' 0) † × basis_vector Hyp' 0)
Crunching:
(I 1 =
 list2D_to_matrix
   [[Σ
       (fun y : nat =>
        ((basis_vector Hyp' 0 y 0) ^* * basis_vector Hyp' 0 y 0)%C) Hyp']])
Crunching:
(0%R =
 Σ
   (fun y : nat => ((basis_vector Hyp' 0 y 0) ^* * basis_vector Hyp' 0 y 1)%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' 0 y0 0) ^* * basis_vector Hyp' 0 y0 (S (S y)))%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y : nat => ((basis_vector Hyp' 0 y 1) ^* * basis_vector Hyp' 0 y 0)%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' 0 y0 1) ^* * basis_vector Hyp' 0 y0 (S y))%C) Hyp')
Crunching:
(0%R =
 Σ
   (fun y : nat =>
    ((basis_vector Hyp' 0 y (S (S x))) ^* * basis_vector Hyp' 0 y 0)%C) Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' 0 y0 (S (S x))) ^* * basis_vector Hyp' 0 y0 (S y))%C)
   Hyp')
Crunching:
(list2D_to_matrix [[e]] = (basis_vector Hyp' 0) † × basis_vector Hyp' 0)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y : nat =>
        ((basis_vector Hyp' 0 y 0) ^* * basis_vector Hyp' 0 y 0)%C) Hyp']] =
 I 1)
Crunching:
(0%R =
 Σ
   (fun y : nat => ((basis_vector Hyp' 0 y 0) ^* * basis_vector Hyp' 0 y 1)%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' 0 y0 0) ^* * basis_vector Hyp' 0 y0 (S (S y)))%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y : nat => ((basis_vector Hyp' 0 y 1) ^* * basis_vector Hyp' 0 y 0)%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' 0 y0 1) ^* * basis_vector Hyp' 0 y0 (S y))%C) Hyp')
Crunching:
(0%R =
 Σ
   (fun y : nat =>
    ((basis_vector Hyp' 0 y (S (S x))) ^* * basis_vector Hyp' 0 y 0)%C) Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' 0 y0 (S (S x))) ^* * basis_vector Hyp' 0 y0 (S y))%C)
   Hyp')
Crunching:
(forall q : positive,
 Z.abs_N (Z.rem (Z.pos H4) (Z.pos q)) = (N.pos H4 mod N.pos q)%N)
Crunching:
(forall n : nat,
 n < Hyp' -> (basis_vector Hyp' n) † × basis_vector Hyp' n = I 1)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector Hyp' a) † × basis_vector Hyp' a)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y : nat =>
        ((basis_vector Hyp' a y 0) ^* * basis_vector Hyp' a y 0)%C) Hyp']] =
 I 1)
Crunching:
(0%R =
 Σ
   (fun y : nat => ((basis_vector Hyp' a y 0) ^* * basis_vector Hyp' a y 1)%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' a y0 0) ^* * basis_vector Hyp' a y0 (S (S y)))%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y : nat => ((basis_vector Hyp' a y 1) ^* * basis_vector Hyp' a y 0)%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' a y0 1) ^* * basis_vector Hyp' a y0 (S y))%C) Hyp')
Crunching:
(0%R =
 Σ
   (fun y : nat =>
    ((basis_vector Hyp' a y (S (S x))) ^* * basis_vector Hyp' a y 0)%C) Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' a y0 (S (S x))) ^* * basis_vector Hyp' a y0 (S y))%C)
   Hyp')
Crunching:
(list2D_to_matrix [[e]] = (basis_vector Hyp' n) † × basis_vector Hyp' n)
Crunching:
((fun x y : nat => if (x =? y) && (x <? 1) then C1 else 0%R) =
 list2D_to_matrix
   [[Σ
       (fun y : nat =>
        ((basis_vector Hyp' n y 0) ^* * basis_vector Hyp' n y 0)%C) Hyp']])
Crunching:
(0%R =
 Σ
   (fun y : nat => ((basis_vector Hyp' n y 0) ^* * basis_vector Hyp' n y 1)%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' n y0 0) ^* * basis_vector Hyp' n y0 (S (S y)))%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y : nat => ((basis_vector Hyp' n y 1) ^* * basis_vector Hyp' n y 0)%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' n y0 1) ^* * basis_vector Hyp' n y0 (S y))%C) Hyp')
Crunching:
(0%R =
 Σ
   (fun y : nat =>
    ((basis_vector Hyp' n y (S (S x))) ^* * basis_vector Hyp' n y 0)%C) Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' n y0 (S (S x))) ^* * basis_vector Hyp' n y0 (S y))%C)
   Hyp')
Crunching:
(pr_outcome_sum (a :: l) n <=
 pr_outcome_sum (a :: l) (fun rnd : nat => n rnd || H7 rnd))
Crunching:
(list2D_to_matrix [[e]] = (basis_vector Hyp' n) † × basis_vector Hyp' n)
Crunching:
(pr_outcome_sum (a :: l) n <=
 pr_outcome_sum (a :: l) (fun rnd : nat => n rnd || H7 rnd))
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y : nat =>
        ((basis_vector Hyp' n y 0) ^* * basis_vector Hyp' n y 0)%C) Hyp']] =
 (fun x y : nat => if (x =? y) && (x <? 1) then C1 else 0%R))
Crunching:
(0%R =
 Σ
   (fun y : nat => ((basis_vector Hyp' n y 0) ^* * basis_vector Hyp' n y 1)%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' n y0 0) ^* * basis_vector Hyp' n y0 (S (S y)))%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y : nat => ((basis_vector Hyp' n y 1) ^* * basis_vector Hyp' n y 0)%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' n y0 1) ^* * basis_vector Hyp' n y0 (S y))%C) Hyp')
Crunching:
(0%R =
 Σ
   (fun y : nat =>
    ((basis_vector Hyp' n y (S (S x))) ^* * basis_vector Hyp' n y 0)%C) Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' n y0 (S (S x))) ^* * basis_vector Hyp' n y0 (S y))%C)
   Hyp')
Crunching: (0 < Hyp' -> (basis_vector Hyp' 0) † × basis_vector Hyp' 0 = I 1)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector Hyp' 0) † × basis_vector Hyp' 0)
Crunching:
(I 1 =
 list2D_to_matrix
   [[Σ
       (fun y : nat =>
        ((basis_vector Hyp' 0 y 0) ^* * basis_vector Hyp' 0 y 0)%C) Hyp']])
Crunching:
(0%R =
 Σ
   (fun y : nat => ((basis_vector Hyp' 0 y 0) ^* * basis_vector Hyp' 0 y 1)%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' 0 y0 0) ^* * basis_vector Hyp' 0 y0 (S (S y)))%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y : nat => ((basis_vector Hyp' 0 y 1) ^* * basis_vector Hyp' 0 y 0)%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' 0 y0 1) ^* * basis_vector Hyp' 0 y0 (S y))%C) Hyp')
Crunching:
(0%R =
 Σ
   (fun y : nat =>
    ((basis_vector Hyp' 0 y (S (S x))) ^* * basis_vector Hyp' 0 y 0)%C) Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' 0 y0 (S (S x))) ^* * basis_vector Hyp' 0 y0 (S y))%C)
   Hyp')
Crunching:
(list2D_to_matrix [[e]] = (basis_vector Hyp' 0) † × basis_vector Hyp' 0)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y : nat =>
        ((basis_vector Hyp' 0 y 0) ^* * basis_vector Hyp' 0 y 0)%C) Hyp']] =
 I 1)
Crunching:
(0%R =
 Σ
   (fun y : nat => ((basis_vector Hyp' 0 y 0) ^* * basis_vector Hyp' 0 y 1)%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' 0 y0 0) ^* * basis_vector Hyp' 0 y0 (S (S y)))%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y : nat => ((basis_vector Hyp' 0 y 1) ^* * basis_vector Hyp' 0 y 0)%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' 0 y0 1) ^* * basis_vector Hyp' 0 y0 (S y))%C) Hyp')
Crunching:
(0%R =
 Σ
   (fun y : nat =>
    ((basis_vector Hyp' 0 y (S (S x))) ^* * basis_vector Hyp' 0 y 0)%C) Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' 0 y0 (S (S x))) ^* * basis_vector Hyp' 0 y0 (S y))%C)
   Hyp')
Crunching: (n < Hyp' -> (basis_vector Hyp' n) † × basis_vector Hyp' n = I 1)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector Hyp' n) † × basis_vector Hyp' n)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y : nat =>
        ((basis_vector Hyp' n y 0) ^* * basis_vector Hyp' n y 0)%C) Hyp']] =
 (fun x y : nat => if (x =? y) && (x <? 1) then C1 else 0%R))
Crunching:
(0%R =
 Σ
   (fun y : nat => ((basis_vector Hyp' n y 0) ^* * basis_vector Hyp' n y 1)%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' n y0 0) ^* * basis_vector Hyp' n y0 (S (S y)))%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y : nat => ((basis_vector Hyp' n y 1) ^* * basis_vector Hyp' n y 0)%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' n y0 1) ^* * basis_vector Hyp' n y0 (S y))%C) Hyp')
Crunching:
(0%R =
 Σ
   (fun y : nat =>
    ((basis_vector Hyp' n y (S (S x))) ^* * basis_vector Hyp' n y 0)%C) Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' n y0 (S (S x))) ^* * basis_vector Hyp' n y0 (S y))%C)
   Hyp')
Crunching: (n < Hyp' -> (basis_vector Hyp' n) † × basis_vector Hyp' n = I 1)
Crunching: (n < Hyp' -> (basis_vector Hyp' n) † × basis_vector Hyp' n = I 1)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector Hyp' n) † × basis_vector Hyp' n)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y : nat =>
        ((basis_vector Hyp' n y 0) ^* * basis_vector Hyp' n y 0)%C) Hyp']] =
 (fun x y : nat => if (x =? y) && (x <? 1) then C1 else 0%R))
Crunching:
(0%R =
 Σ
   (fun y : nat => ((basis_vector Hyp' n y 0) ^* * basis_vector Hyp' n y 1)%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' n y0 0) ^* * basis_vector Hyp' n y0 (S (S y)))%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y : nat => ((basis_vector Hyp' n y 1) ^* * basis_vector Hyp' n y 0)%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' n y0 1) ^* * basis_vector Hyp' n y0 (S y))%C) Hyp')
Crunching:
(0%R =
 Σ
   (fun y : nat =>
    ((basis_vector Hyp' n y (S (S x))) ^* * basis_vector Hyp' n y 0)%C) Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' n y0 (S (S x))) ^* * basis_vector Hyp' n y0 (S y))%C)
   Hyp')
Crunching:
(list2D_to_matrix [[e]] = (basis_vector Hyp' n) † × basis_vector Hyp' n)
Crunching:
((fun x y : nat => if (x =? y) && (x <? 1) then C1 else 0%R) =
 list2D_to_matrix
   [[Σ
       (fun y : nat =>
        ((basis_vector Hyp' n y 0) ^* * basis_vector Hyp' n y 0)%C) Hyp']])
Crunching:
(0%R =
 Σ
   (fun y : nat => ((basis_vector Hyp' n y 0) ^* * basis_vector Hyp' n y 1)%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' n y0 0) ^* * basis_vector Hyp' n y0 (S (S y)))%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y : nat => ((basis_vector Hyp' n y 1) ^* * basis_vector Hyp' n y 0)%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' n y0 1) ^* * basis_vector Hyp' n y0 (S y))%C) Hyp')
Crunching:
(0%R =
 Σ
   (fun y : nat =>
    ((basis_vector Hyp' n y (S (S x))) ^* * basis_vector Hyp' n y 0)%C) Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' n y0 (S (S x))) ^* * basis_vector Hyp' n y0 (S y))%C)
   Hyp')
Crunching:
(list2D_to_matrix [[e]] = (basis_vector Hyp' n) † × basis_vector Hyp' n)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y : nat =>
        ((basis_vector Hyp' n y 0) ^* * basis_vector Hyp' n y 0)%C) Hyp']] =
 (fun x y : nat => if (x =? y) && (x <? 1) then C1 else 0%R))
Crunching:
(0%R =
 Σ
   (fun y : nat => ((basis_vector Hyp' n y 0) ^* * basis_vector Hyp' n y 1)%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' n y0 0) ^* * basis_vector Hyp' n y0 (S (S y)))%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y : nat => ((basis_vector Hyp' n y 1) ^* * basis_vector Hyp' n y 0)%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' n y0 1) ^* * basis_vector Hyp' n y0 (S y))%C) Hyp')
Crunching:
(0%R =
 Σ
   (fun y : nat =>
    ((basis_vector Hyp' n y (S (S x))) ^* * basis_vector Hyp' n y 0)%C) Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' n y0 (S (S x))) ^* * basis_vector Hyp' n y0 (S y))%C)
   Hyp')
Crunching:
(list2D_to_matrix [[e]] = (basis_vector Hyp' n) † × basis_vector Hyp' n)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y : nat =>
        ((basis_vector Hyp' n y 0) ^* * basis_vector Hyp' n y 0)%C) Hyp']] =
 I 1)
Crunching:
(0%R =
 Σ
   (fun y : nat => ((basis_vector Hyp' n y 0) ^* * basis_vector Hyp' n y 1)%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' n y0 0) ^* * basis_vector Hyp' n y0 (S (S y)))%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y : nat => ((basis_vector Hyp' n y 1) ^* * basis_vector Hyp' n y 0)%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' n y0 1) ^* * basis_vector Hyp' n y0 (S y))%C) Hyp')
Crunching:
(0%R =
 Σ
   (fun y : nat =>
    ((basis_vector Hyp' n y (S (S x))) ^* * basis_vector Hyp' n y 0)%C) Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' n y0 (S (S x))) ^* * basis_vector Hyp' n y0 (S y))%C)
   Hyp')
Crunching:
(list2D_to_matrix [[e]] = (basis_vector Hyp' x) † × basis_vector Hyp' x)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y : nat =>
        ((basis_vector Hyp' x y 0) ^* * basis_vector Hyp' x y 0)%C) Hyp']] =
 I 1)
Crunching:
(0%R =
 Σ
   (fun y : nat => ((basis_vector Hyp' x y 0) ^* * basis_vector Hyp' x y 1)%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' x y0 0) ^* * basis_vector Hyp' x y0 (S (S y)))%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y : nat => ((basis_vector Hyp' x y 1) ^* * basis_vector Hyp' x y 0)%C)
   Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' x y0 1) ^* * basis_vector Hyp' x y0 (S y))%C) Hyp')
Crunching:
(0%R =
 Σ
   (fun y : nat =>
    ((basis_vector Hyp' x y (S (S x0))) ^* * basis_vector Hyp' x y 0)%C) Hyp')
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector Hyp' x y0 (S (S x0))) ^* * basis_vector Hyp' x y0 (S y))%C)
   Hyp')
Crunching: (x < Hyp' -> (basis_vector Hyp' x) † × basis_vector Hyp' x = I 1)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector (S x) x) † × basis_vector (S x) x)
Crunching:
(list2D_to_matrix
   [[(Σ
        (fun y : nat =>
         (basis_vector (S x) x y 0) ^* * basis_vector (S x) x y 0) x +
      (basis_vector (S x) x x 0) ^* * basis_vector (S x) x x 0)%C]] = 
 I 1)
Crunching:
(0%R =
 (Σ (fun y : nat => (basis_vector (S x) x y 0) ^* * basis_vector (S x) x y 1)
    x + (basis_vector (S x) x x 0) ^* * basis_vector (S x) x x 1)%C)
Crunching:
(0%R =
 (Σ
    (fun y0 : nat =>
     (basis_vector (S x) x y0 0) ^* * basis_vector (S x) x y0 (S (S y))) x +
  (basis_vector (S x) x x 0) ^* * basis_vector (S x) x x (S (S y)))%C)
Crunching:
(0%R =
 (Σ (fun y : nat => (basis_vector (S x) x y 1) ^* * basis_vector (S x) x y 0)
    x + (basis_vector (S x) x x 1) ^* * basis_vector (S x) x x 0)%C)
Crunching:
(0%R =
 (Σ
    (fun y0 : nat =>
     (basis_vector (S x) x y0 1) ^* * basis_vector (S x) x y0 (S y)) x +
  (basis_vector (S x) x x 1) ^* * basis_vector (S x) x x (S y))%C)
Crunching:
(0%R =
 (Σ
    (fun y : nat =>
     (basis_vector (S x) x y (S (S x0))) ^* * basis_vector (S x) x y 0) x +
  (basis_vector (S x) x x (S (S x0))) ^* * basis_vector (S x) x x 0)%C)
Crunching:
(0%R =
 (Σ
    (fun y0 : nat =>
     (basis_vector (S x) x y0 (S (S x0))) ^* * basis_vector (S x) x y0 (S y))
    x + (basis_vector (S x) x x (S (S x0))) ^* * basis_vector (S x) x x (S y))%C)
Crunching:
(forall f2 : nat -> bool,
 (forall x : nat, Hxy x = true -> f2 x = true) ->
 pr_outcome_sum l Hxy <= pr_outcome_sum l f2)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching:
(forall f2 : nat -> bool,
 (forall x : nat, Hxy x = true -> f2 x = true) ->
 pr_outcome_sum l Hxy <= pr_outcome_sum l f2)
Crunching:
(forall f2 : nat -> bool,
 (forall x : nat, Hxy x = true -> f2 x = true) ->
 pr_outcome_sum l Hxy <= pr_outcome_sum l f2)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching:
(forall f2 : nat -> bool,
 (forall x : nat, Hxy x = true -> f2 x = true) ->
 pr_outcome_sum l Hxy <= pr_outcome_sum l f2)
Crunching:
(WF_Matrix (basis_vector (S i) i) /\
 (basis_vector (S i) i) † × basis_vector (S i) i = I 1)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching:
(WF_Matrix (basis_vector (S i) i) /\
 (basis_vector (S i) i) † × basis_vector (S i) i = I 1)
Crunching:
(Morphisms.respectful ?R2 and WF_Matrix
   (eq ((basis_vector (S i) i) † × basis_vector (S i) i)))
Crunching: (basis_vector (S i) i HB x = 0%R)
Crunching: (HB >= S i \/ Hm >= 1 -> basis_vector (S i) i HB Hm = 0%R)
Crunching:
(WF_Matrix (basis_vector (S i) i) /\
 (basis_vector (S i) i) † × basis_vector (S i) i = I 1)
Crunching:
(WF_Matrix (basis_vector (S i) i) /\
 (basis_vector (S i) i) † × basis_vector (S i) i = I 1)
Crunching:
(Morphisms.respectful ?R2 and WF_Matrix
   (eq ((basis_vector (S i) i) † × basis_vector (S i) i)))
Crunching: (pr_outcome_sum N H6 <= pr_outcome_sum N f)
Crunching: (basis_vector (S i) i HB x = 0%R)
Crunching: (HB >= S i \/ Hm >= 1 -> basis_vector (S i) i HB Hm = 0%R)
Crunching: (Pure_State_Vector (basis_vector x y))
Crunching:
(forall f2 : nat -> bool,
 (forall x : nat, Hxy x = true -> f2 x = true) ->
 pr_outcome_sum l Hxy <= pr_outcome_sum l f2)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching:
(forall f2 : nat -> bool,
 (forall x : nat, Hxy x = true -> f2 x = true) ->
 pr_outcome_sum l Hxy <= pr_outcome_sum l f2)
out of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
Crunching:
(forall f2 : nat -> bool,
 (forall x : nat, Hxy x = true -> f2 x = true) ->
 pr_outcome_sum l Hxy <= pr_outcome_sum l f2)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching:
(forall f2 : nat -> bool,
 (forall x : nat, Hxy x = true -> f2 x = true) ->
 pr_outcome_sum l Hxy <= pr_outcome_sum l f2)
Crunching:
(forall f2 : nat -> bool,
 (forall x : nat, Hxy x = true -> f2 x = true) ->
 pr_outcome_sum l Hxy <= pr_outcome_sum l f2)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching:
(forall f2 : nat -> bool,
 (forall x : nat, Hxy x = true -> f2 x = true) ->
 pr_outcome_sum l Hxy <= pr_outcome_sum l f2)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching:
(forall f2 : nat -> bool,
 (forall x : nat, Hxy x = true -> f2 x = true) ->
 pr_outcome_sum l Hxy <= pr_outcome_sum l f2)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching:
(forall f2 : nat -> bool,
 (forall x : nat, Hxy x = true -> f2 x = true) ->
 pr_outcome_sum l Hxy <= pr_outcome_sum l f2)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching:
(forall f2 : nat -> bool,
 (forall x : nat, Hxy x = true -> f2 x = true) ->
 pr_outcome_sum l Hxy <= pr_outcome_sum l f2)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching:
(forall f2 : nat -> bool,
 (forall x : nat, Hxy x = true -> f2 x = true) ->
 pr_outcome_sum l Hxy <= pr_outcome_sum l f2)
out of reach
Tactic call ran for 0.005 secs (0.005u,0.s) (failure)
Crunching: (pr_outcome_sum l H7 <= pr_outcome_sum l n)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching:
(forall f2 : nat -> bool,
 (forall x : nat, Hxy x = true -> f2 x = true) ->
 pr_outcome_sum l Hxy <= pr_outcome_sum l f2)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (pr_outcome_sum l H7 <= pr_outcome_sum l n)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching:
(forall f2 : nat -> bool,
 (forall x : nat, Hxy x = true -> f2 x = true) ->
 pr_outcome_sum l Hxy <= pr_outcome_sum l f2)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector (S n) m) † × basis_vector (S n) n)
Crunching:
(list2D_to_matrix
   [[(Σ
        (fun y : nat =>
         (basis_vector (S n) m y 0) ^* * basis_vector (S n) n y 0) n +
      (basis_vector (S n) m n 0) ^* * basis_vector (S n) n n 0)%C]] = Zero)
Crunching:
(0%R =
 (Σ (fun y : nat => (basis_vector (S n) m y 0) ^* * basis_vector (S n) n y 1)
    n + (basis_vector (S n) m n 0) ^* * basis_vector (S n) n n 1)%C)
Crunching:
(0%R =
 (Σ
    (fun y0 : nat =>
     (basis_vector (S n) m y0 0) ^* * basis_vector (S n) n y0 (S (S y))) n +
  (basis_vector (S n) m n 0) ^* * basis_vector (S n) n n (S (S y)))%C)
Crunching:
(0%R =
 (Σ (fun y : nat => (basis_vector (S n) m y 1) ^* * basis_vector (S n) n y 0)
    n + (basis_vector (S n) m n 1) ^* * basis_vector (S n) n n 0)%C)
Crunching:
(0%R =
 (Σ
    (fun y0 : nat =>
     (basis_vector (S n) m y0 1) ^* * basis_vector (S n) n y0 (S y)) n +
  (basis_vector (S n) m n 1) ^* * basis_vector (S n) n n (S y))%C)
Crunching:
(0%R =
 (Σ
    (fun y : nat =>
     (basis_vector (S n) m y (S (S x))) ^* * basis_vector (S n) n y 0) n +
  (basis_vector (S n) m n (S (S x))) ^* * basis_vector (S n) n n 0)%C)
Crunching:
(0%R =
 (Σ
    (fun y0 : nat =>
     (basis_vector (S n) m y0 (S (S x))) ^* * basis_vector (S n) n y0 (S y))
    n + (basis_vector (S n) m n (S (S x))) ^* * basis_vector (S n) n n (S y))%C)
Crunching: (0 < 0 -> (basis_vector d 0) † × basis_vector d 0 = Zero)
Crunching: (list2D_to_matrix [[e]] = (basis_vector d m) † × basis_vector d 1)
Crunching:
(list2D_to_matrix
   [[Σ (fun y : nat => ((basis_vector d m y 0) ^* * basis_vector d 1 y 0)%C)
       d]] = Zero)
Crunching:
(0%R =
 Σ (fun y : nat => ((basis_vector d m y 0) ^* * basis_vector d 1 y 1)%C) d)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector d m y0 0) ^* * basis_vector d 1 y0 (S (S y)))%C) d)
Crunching:
(0%R =
 Σ (fun y : nat => ((basis_vector d m y 1) ^* * basis_vector d 1 y 0)%C) d)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector d m y0 1) ^* * basis_vector d 1 y0 (S y))%C) d)
Crunching:
(0%R =
 Σ
   (fun y : nat =>
    ((basis_vector d m y (S (S x))) ^* * basis_vector d 1 y 0)%C) d)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector d m y0 (S (S x))) ^* * basis_vector d 1 y0 (S y))%C) d)
Tactic call ran for 0.003 secs (0.002u,0.s) (success)
Crunching:
(list2D_to_matrix [[e]] =
 (basis_vector (S (Init.Nat.pred n)) m) †
 × basis_vector (S (Init.Nat.pred n)) HIn)
Crunching:
(list2D_to_matrix
   [[(Σ
        (fun y : nat =>
         (basis_vector (S (Init.Nat.pred n)) m y 0) ^* *
         basis_vector (S (Init.Nat.pred n)) HIn y 0) 
        (Init.Nat.pred n) +
      (basis_vector (S (Init.Nat.pred n)) m (Init.Nat.pred n) 0) ^* *
      basis_vector (S (Init.Nat.pred n)) HIn (Init.Nat.pred n) 0)%C]] = Zero)
Crunching:
(0%R =
 (Σ
    (fun y : nat =>
     (basis_vector (S (Init.Nat.pred n)) m y 0) ^* *
     basis_vector (S (Init.Nat.pred n)) HIn y 1) (Init.Nat.pred n) +
  (basis_vector (S (Init.Nat.pred n)) m (Init.Nat.pred n) 0) ^* *
  basis_vector (S (Init.Nat.pred n)) HIn (Init.Nat.pred n) 1)%C)
Crunching:
(0%R =
 (Σ
    (fun y0 : nat =>
     (basis_vector (S (Init.Nat.pred n)) m y0 0) ^* *
     basis_vector (S (Init.Nat.pred n)) HIn y0 (S (S y))) 
    (Init.Nat.pred n) +
  (basis_vector (S (Init.Nat.pred n)) m (Init.Nat.pred n) 0) ^* *
  basis_vector (S (Init.Nat.pred n)) HIn (Init.Nat.pred n) (S (S y)))%C)
Crunching:
(0%R =
 (Σ
    (fun y : nat =>
     (basis_vector (S (Init.Nat.pred n)) m y 1) ^* *
     basis_vector (S (Init.Nat.pred n)) HIn y 0) (Init.Nat.pred n) +
  (basis_vector (S (Init.Nat.pred n)) m (Init.Nat.pred n) 1) ^* *
  basis_vector (S (Init.Nat.pred n)) HIn (Init.Nat.pred n) 0)%C)
Crunching:
(0%R =
 (Σ
    (fun y0 : nat =>
     (basis_vector (S (Init.Nat.pred n)) m y0 1) ^* *
     basis_vector (S (Init.Nat.pred n)) HIn y0 (S y)) 
    (Init.Nat.pred n) +
  (basis_vector (S (Init.Nat.pred n)) m (Init.Nat.pred n) 1) ^* *
  basis_vector (S (Init.Nat.pred n)) HIn (Init.Nat.pred n) (S y))%C)
Crunching:
(0%R =
 (Σ
    (fun y : nat =>
     (basis_vector (S (Init.Nat.pred n)) m y (S (S x))) ^* *
     basis_vector (S (Init.Nat.pred n)) HIn y 0) (Init.Nat.pred n) +
  (basis_vector (S (Init.Nat.pred n)) m (Init.Nat.pred n) (S (S x))) ^* *
  basis_vector (S (Init.Nat.pred n)) HIn (Init.Nat.pred n) 0)%C)
Crunching:
(0%R =
 (Σ
    (fun y0 : nat =>
     (basis_vector (S (Init.Nat.pred n)) m y0 (S (S x))) ^* *
     basis_vector (S (Init.Nat.pred n)) HIn y0 (S y)) 
    (Init.Nat.pred n) +
  (basis_vector (S (Init.Nat.pred n)) m (Init.Nat.pred n) (S (S x))) ^* *
  basis_vector (S (Init.Nat.pred n)) HIn (Init.Nat.pred n) (S y))%C)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
out of reach
Tactic call ran for 0.01 secs (0.009u,0.s) (failure)
Crunching: (IPR 16 <= pr_outcome_sum k f)
Crunching: (- 0 <= pr_outcome_sum k f)
Crunching: (WF_Matrix b -> (b × basis_vector a H) Hb 0 = b Hb H)
out of reach
Tactic call ran for 0.009 secs (0.008u,0.s) (failure)
out of reach
Tactic call ran for 0.007 secs (0.007u,0.s) (failure)
Crunching: (1 < 1)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.005 secs (0.005u,0.s) (failure)
out of reach
Tactic call ran for 0.005 secs (0.005u,0.s) (failure)
Crunching: (interval_sum (fun x : R => H7 (x - a)%R) (rl + a) (s + a) r)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching:
(forall (A : Matrix H3 X) (i j : nat),
 WF_Matrix A -> Σ (fun y : nat => (A i y * basis_vector X j y 0)%C) X = A i j)
Crunching: ((A × basis_vector n j) i 0 = A i j)
out of reach
Tactic call ran for 0.005 secs (0.005u,0.s) (failure)
out of reach
Tactic call ran for 0.005 secs (0.005u,0.s) (failure)
Crunching: (WF_Matrix b -> (b × basis_vector a H) Hb 0 = b Hb H)
out of reach
Tactic call ran for 0.005 secs (0.005u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching: False
Crunching:
(interval_sum (fun x : R => q (x - eps)%R) (z + eps) (Hpos + eps) Hyp)
Crunching: (interval_sum (fun x : R => Maj2 (x - A)%R) (m + A) (n + A) o)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching: (forall x y : R, 0 < x -> y < 1 -> x * y < x)
out of reach
Tactic call ran for 0.006 secs (0.006u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching: (interval_sum (fun x : R => H7 (x - a)%R) (a + rl) (s + a) r)
Crunching: (interval_sum (fun x : R => H7 (x - a)%R) (rl + a) (s + a) r)
Crunching:
(interval_sum X0 H Az LS ->
 (forall x0 : R, H <= x0 < Az -> X0 x0 <-> x x0) -> interval_sum x H Az LS)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching:
(interval_sum IHP' Base Step H11 ->
 (forall x : R, (Base < x \/ Base = x) /\ x < Step -> IHP' x <-> z x) ->
 interval_sum z Base Step H11)
out of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
Crunching:
(interval_sum X0 H Az LS ->
 (forall x0 : R, H <= x0 < Az -> X0 x0 <-> x x0) -> interval_sum x H Az LS)
out of reach
Tactic call ran for 0.007 secs (0.007u,0.s) (failure)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (interval_sum P1 rl rr r -> interval_sum P2 rl rr r)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching:
(interval_sum (fun x : R => He (x + M)%R) (x + - M) (x_encad + - M) H ->
 interval_sum He x x_encad H)
Crunching: (interval_sum He x x_encad LT)
Crunching: (interval_sum He x x_encad (r2 - r1))
Crunching: (interval_sum He x x_encad LT)
Crunching: (interval_sum He x x_encad LT)
Crunching:
(interval_sum (fun x : R => He (x + Hxrange)%R) (a - Hxrange) (b - Hxrange) x ->
 interval_sum He a b x)
Crunching:
(interval_sum (fun x : R => He (x + M)%R) (x + - M) (x_encad + - M) H ->
 interval_sum He x x_encad H)
Crunching: (x ^ 5 <= x ^ 3)
out of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
Crunching: (interval_sum He x x_encad LT)
Crunching: (interval_sum He x x_encad LT)
Crunching: (interval_sum He x x_encad (r2 - r1))
Crunching: (interval_sum He x x_encad (r2 - r1))
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching: (x ^ 5 <= x ^ 3)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching: (interval_sum He x x_encad LT)
Crunching: (interval_sum He x x_encad (r2 - r1))
Crunching: (interval_sum He x x_encad (r2 - r1))
Crunching: (interval_sum He x x_encad LT)
Crunching:
((a = b * Ha + q -> a / Ha = b /\ a mod Ha = q) /\
 (a / Ha = b /\ a mod Ha = q -> a = b * Ha + q))
Crunching:
(interval_sum (fun x : R => He (x + a)%R) (x + - a) (x_encad + - a) LT ->
 R1 = R1 -> (R0 + R1)%R = R1 -> interval_sum He x x_encad LT)
Crunching: (a / S q = b /\ a mod S q = q <-> a = b * S q + q)
Crunching: (a = b * S q + q <-> a / S q = b /\ a mod S q = q)
Crunching: (interval_sum He x x_encad LT)
Crunching: (x ^ 5 <= x ^ 3)
Crunching: (p = H0 * x_pos + H2 -> p / x_pos = H0 /\ p mod x_pos = H2)
Crunching: (p = H0 * x_pos + H2 -> p / x_pos = H0 /\ p mod x_pos = H2)
Crunching: (interval_sum He x x_encad LT)
Crunching: (r >= 0)
Crunching:
(basis_vector (2 ^ (H3 + a)) (b * 2 ^ a + n) =
 basis_vector (2 ^ H3) b ⊗ basis_vector (2 ^ a) n)
out of reach
Tactic call ran for 0.246 secs (0.246u,0.s) (failure)
Crunching: (r >= 0)
Crunching: (r >= 0)
Crunching:
(z' < 2 ^ l' ->
 H6 < 2 ^ Hl' ->
 basis_vector (2 ^ (l' + Hl')) (z' * 2 ^ Hl' + H6) =
 basis_vector (2 ^ l') z' ⊗ basis_vector (2 ^ Hl') H6)
out of reach
Tactic call ran for 0.239 secs (0.238u,0.s) (failure)
Crunching: (0 < b)
     = st_get >>=
       ((fix denote (A : UU0) (p : program A) {struct p} : ?M A :=
           match p in (program T) return (?M T) with
           | @p_ret _ _ A0 v => Ret v
           | @p_bind _ _ A0 B m f => denote A0 m >>= (denote B \o f)
           | @p_cond _ _ A0 true p1 _ => denote A0 p1
           | @p_cond _ _ A0 false _ p2 => denote A0 p2
           | p_repeat n p0 =>
               (fix loop (m : nat) : ?M unit :=
                  match m with
                  | 0 => Ret tt
                  | m'.+1 => denote unit p0 >> loop m'
                  end) n
           | p_while fuel c p0 =>
               (fix loop (m : nat) : ?M unit :=
                  match m with
                  | 0 => Ret tt
                  | m'.+1 =>
                      st_get >>=
                      (fun s : nat =>
                       if c s then denote unit p0 >> loop m' else Ret tt)
                  end) fuel
           | p_get => st_get
           | p_put s' => st_put s'
           | p_mark t => st_mark t
           end) nat \o
          (fun n : nat =>
           p_do _ : unit <- p_put n.+1; p_do _ : unit <- p_mark n; p_ret n))
     : ?M nat
     = (0, (1, [:: 0]))
     : nat * (nat * seq nat)
     = (0, (1, [:: 0]))
     : nat * (nat * seq nat)
     = eT [:: 0] (eT 0 (e 1))
     : {l : seq nat &
       {a : nat &
       {s' : nat | step_star (0, p_nonce `; stop nat) l (s', stop nat a)}}}
     = (false, (2, [:: 0; 1]))
     : bool * (nat * seq nat)
     = (false, (2, [:: 0; 1]))
     : bool * (nat * seq nat)
     = eT [:: 0; 1] (eT false (e 2))
     : {l : seq nat &
       {a : bool_eqType &
       {s' : nat
       | step_star (0, p_nonce_twice `; stop bool_eqType) l
           (s', stop bool_eqType a)}}}
Crunching: (r < R0 -> R0 < r \/ r = R0)
     = (tt, (0, [:: false; false; false; false; false; true]))
     : unit * (nat * seq bool)
     = (tt, (0, [:: false; false; false; false; false; true]))
     : unit * (nat * seq bool)
     = eT [:: false; false; false; false; false; true] (eT tt (e 0))
     : {l : seq bool &
       {a : unit &
       {s' : nat
       | step_star (5, p_countdown 100 `; stop unit) l (s', stop unit a)}}}
Finished transaction in 14.813 secs (14.74u,0.046s) (successful)
Crunching:
(basis_vector (2 ^ (HE + n)) (v1 * 2 ^ n + y) =
 basis_vector (2 ^ HE) v1 ⊗ basis_vector (2 ^ n) y)
Crunching:
(((if Rle_dec x0 y then y else x0) < z -> x0 < z /\ y < z) /\
 (x0 < z /\ y < z -> (if Rle_dec x0 y then y else x0) < z))
Crunching:
((x0 < z /\ y < z -> (if Rle_dec x0 y then y else x0) < z) /\
 ((if Rle_dec x0 y then y else x0) < z -> x0 < z /\ y < z))
Crunching:
(((if Rle_dec x0 y then y else x0) < z -> x0 < z /\ y < z) /\
 (x0 < z /\ y < z -> (if Rle_dec x0 y then y else x0) < z))
Crunching: False
Crunching: False
Crunching:
(basis_vector (2 ^ (HE + H1)) (x * 2 ^ H1 + y) =
 basis_vector (2 ^ HE) x ⊗ basis_vector (2 ^ H1) y)
Crunching: (0 < t \/ 0 = t)
Crunching:
((fun i j : nat => if (i =? x * 2 ^ n + y) && (j =? 0) then C1 else 0%R) =
 (fun x0 y0 : nat =>
  ((if (x0 / 2 ^ n =? x) && (y0 / 1 =? 0) then C1 else 0%R) *
   (if (x0 mod 2 ^ n =? y) && (y0 mod 1 =? 0) then C1 else 0%R))%C))
Finished transaction in 452.013 secs (444.194u,3.336s) (successful)
Crunching:
(S
   ((fix Ffix (x : list bool) : nat :=
       match x with
       | [] => 0
       | x0 :: x1 =>
           (fix Ffix0 (x2 x3 : nat) {struct x2} : nat :=
              match x2 with
              | 0 => x3
              | S x4 => S (Ffix0 x4 x3)
              end) (if x0 then 1 else 0)
             ((fix Ffix0 (x2 x3 : nat) {struct x2} : nat :=
                 match x2 with
                 | 0 => x3
                 | S x4 => S (Ffix0 x4 x3)
                 end) (Ffix x1)
                ((fix Ffix0 (x2 x3 : nat) {struct x2} : nat :=
                    match x2 with
                    | 0 => x3
                    | S x4 => S (Ffix0 x4 x3)
                    end) (Ffix x1) 0))
       end)
      ((fix Ffix (x : nat) (x0 : nat -> bool) {struct x} : list bool :=
          match x with
          | 0 => []
          | S x1 => x0 x1 :: Ffix x1 x0
          end) a Ha)) <=
 (fix Ffix (x x0 : nat) {struct x0} : nat :=
    match x0 with
    | 0 => 1
    | S x1 =>
        (fix Ffix0 (x2 x3 : nat) {struct x2} : nat :=
           match x2 with
           | 0 => 0
           | S x4 =>
               (fix Ffix1 (x5 x6 : nat) {struct x5} : nat :=
                  match x5 with
                  | 0 => x6
                  | S x7 => S (Ffix1 x7 x6)
                  end) x3 (Ffix0 x4 x3)
           end) x (Ffix x x1)
    end) 2 a)
Crunching:
(S
   ((fix Ffix (x : list bool) : nat :=
       match x with
       | [] => 0
       | x0 :: x1 =>
           (fix Ffix0 (x2 x3 : nat) {struct x2} : nat :=
              match x2 with
              | 0 => x3
              | S x4 => S (Ffix0 x4 x3)
              end) (if x0 then 1 else 0)
             ((fix Ffix0 (x2 x3 : nat) {struct x2} : nat :=
                 match x2 with
                 | 0 => x3
                 | S x4 => S (Ffix0 x4 x3)
                 end) (Ffix x1)
                ((fix Ffix0 (x2 x3 : nat) {struct x2} : nat :=
                    match x2 with
                    | 0 => x3
                    | S x4 => S (Ffix0 x4 x3)
                    end) (Ffix x1) 0))
       end)
      ((fix Ffix (x : nat) (x0 : nat -> bool) {struct x} : list bool :=
          match x with
          | 0 => []
          | S x1 => x0 x1 :: Ffix x1 x0
          end) a Ha)) <=
 (fix Ffix (x x0 : nat) {struct x0} : nat :=
    match x0 with
    | 0 => 1
    | S x1 =>
        (fix Ffix0 (x2 x3 : nat) {struct x2} : nat :=
           match x2 with
           | 0 => 0
           | S x4 =>
               (fix Ffix1 (x5 x6 : nat) {struct x5} : nat :=
                  match x5 with
                  | 0 => x6
                  | S x7 => S (Ffix1 x7 x6)
                  end) x3 (Ffix0 x4 x3)
           end) x (Ffix x x1)
    end) 2 a)
Crunching:
(S
   ((fix Ffix (x : list bool) : nat :=
       match x with
       | [] => 0
       | x0 :: x1 =>
           (fix Ffix0 (x2 x3 : nat) {struct x2} : nat :=
              match x2 with
              | 0 => x3
              | S x4 => S (Ffix0 x4 x3)
              end) (if x0 then 1 else 0)
             ((fix Ffix0 (x2 x3 : nat) {struct x2} : nat :=
                 match x2 with
                 | 0 => x3
                 | S x4 => S (Ffix0 x4 x3)
                 end) (Ffix x1)
                ((fix Ffix0 (x2 x3 : nat) {struct x2} : nat :=
                    match x2 with
                    | 0 => x3
                    | S x4 => S (Ffix0 x4 x3)
                    end) (Ffix x1) 0))
       end)
      ((fix Ffix (x : nat) (x0 : nat -> bool) {struct x} : list bool :=
          match x with
          | 0 => []
          | S x1 => x0 x1 :: Ffix x1 x0
          end) a Ha)) <=
 (fix Ffix (x x0 : nat) {struct x0} : nat :=
    match x0 with
    | 0 => 1
    | S x1 =>
        (fix Ffix0 (x2 x3 : nat) {struct x2} : nat :=
           match x2 with
           | 0 => 0
           | S x4 =>
               (fix Ffix1 (x5 x6 : nat) {struct x5} : nat :=
                  match x5 with
                  | 0 => x6
                  | S x7 => S (Ffix1 x7 x6)
                  end) x3 (Ffix0 x4 x3)
           end) x (Ffix x x1)
    end) 2 a)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching:
(forall x : nat -> bool,
 S
   ((fix Ffix (x0 : list bool) : nat :=
       match x0 with
       | [] => 0
       | x1 :: x2 =>
           (fix Ffix0 (x3 x4 : nat) {struct x3} : nat :=
              match x3 with
              | 0 => x4
              | S x5 => S (Ffix0 x5 x4)
              end) (if x1 then 1 else 0)
             ((fix Ffix0 (x3 x4 : nat) {struct x3} : nat :=
                 match x3 with
                 | 0 => x4
                 | S x5 => S (Ffix0 x5 x4)
                 end) (Ffix x2)
                ((fix Ffix0 (x3 x4 : nat) {struct x3} : nat :=
                    match x3 with
                    | 0 => x4
                    | S x5 => S (Ffix0 x5 x4)
                    end) (Ffix x2) 0))
       end)
      ((fix Ffix (x0 : nat) (x1 : nat -> bool) {struct x0} : list bool :=
          match x0 with
          | 0 => []
          | S x2 => x1 x2 :: Ffix x2 x1
          end) H'1 x)) <=
 (fix Ffix (x0 x1 : nat) {struct x1} : nat :=
    match x1 with
    | 0 => 1
    | S x2 =>
        (fix Ffix0 (x3 x4 : nat) {struct x3} : nat :=
           match x3 with
           | 0 => 0
           | S x5 =>
               (fix Ffix1 (x6 x7 : nat) {struct x6} : nat :=
                  match x6 with
                  | 0 => x7
                  | S x8 => S (Ffix1 x8 x7)
                  end) x4 (Ffix0 x5 x4)
           end) x0 (Ffix x0 x2)
    end) 2 H'1)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.004 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching: ((cos 1)² <= (1 - 1 / 2 + 1 / 24)²)
Crunching:
(exists r2 : R,
   interval_sum p x H3 1 /\ interval_sum p H3 y r2 /\ (H4 - k)%R = (1 + r2)%R)
Crunching:
(exists r2 : R,
   interval_sum p x H3 1 /\
   interval_sum p H3 y r2 /\ (H4 + - k)%R = (1 + r2)%R)
Crunching:
(exists r2 : R,
   interval_sum p x H3 1 /\
   interval_sum p H3 y r2 /\ (H4 + - k)%R = (1 + r2)%R)
Crunching:
(exists r2 : R,
   interval_sum p x H3 1 /\
   interval_sum p H3 y r2 /\ (H4 + - k)%R = (1 + r2)%R)
Crunching:
(S
   ((fix Ffix (x : list bool) : nat :=
       match x with
       | [] => 0
       | x0 :: x1 =>
           (fix Ffix0 (x2 x3 : nat) {struct x2} : nat :=
              match x2 with
              | 0 => x3
              | S x4 => S (Ffix0 x4 x3)
              end) (if x0 then 1 else 0)
             ((fix Ffix0 (x2 x3 : nat) {struct x2} : nat :=
                 match x2 with
                 | 0 => x3
                 | S x4 => S (Ffix0 x4 x3)
                 end) (Ffix x1)
                ((fix Ffix0 (x2 x3 : nat) {struct x2} : nat :=
                    match x2 with
                    | 0 => x3
                    | S x4 => S (Ffix0 x4 x3)
                    end) (Ffix x1) 0))
       end)
      ((fix Ffix (x : nat) (x0 : nat -> bool) {struct x} : list bool :=
          match x with
          | 0 => []
          | S x1 => x0 x1 :: Ffix x1 x0
          end) a Ha)) <=
 (fix Ffix (x x0 : nat) {struct x0} : nat :=
    match x0 with
    | 0 => 1
    | S x1 =>
        (fix Ffix0 (x2 x3 : nat) {struct x2} : nat :=
           match x2 with
           | 0 => 0
           | S x4 =>
               (fix Ffix1 (x5 x6 : nat) {struct x5} : nat :=
                  match x5 with
                  | 0 => x6
                  | S x7 => S (Ffix1 x7 x6)
                  end) x3 (Ffix0 x4 x3)
           end) x (Ffix x x1)
    end) 2 a)
Crunching:
(forall x : nat -> bool,
 S
   ((fix Ffix (x0 : list bool) : nat :=
       match x0 with
       | [] => 0
       | x1 :: x2 =>
           (fix Ffix0 (x3 x4 : nat) {struct x3} : nat :=
              match x3 with
              | 0 => x4
              | S x5 => S (Ffix0 x5 x4)
              end) (if x1 then 1 else 0)
             ((fix Ffix0 (x3 x4 : nat) {struct x3} : nat :=
                 match x3 with
                 | 0 => x4
                 | S x5 => S (Ffix0 x5 x4)
                 end) (Ffix x2)
                ((fix Ffix0 (x3 x4 : nat) {struct x3} : nat :=
                    match x3 with
                    | 0 => x4
                    | S x5 => S (Ffix0 x5 x4)
                    end) (Ffix x2) 0))
       end)
      ((fix Ffix (x0 : nat) (x1 : nat -> bool) {struct x0} : list bool :=
          match x0 with
          | 0 => []
          | S x2 => x1 x2 :: Ffix x2 x1
          end) H'1 x)) <=
 (fix Ffix (x0 x1 : nat) {struct x1} : nat :=
    match x1 with
    | 0 => 1
    | S x2 =>
        (fix Ffix0 (x3 x4 : nat) {struct x3} : nat :=
           match x3 with
           | 0 => 0
           | S x5 =>
               (fix Ffix1 (x6 x7 : nat) {struct x6} : nat :=
                  match x6 with
                  | 0 => x7
                  | S x8 => S (Ffix1 x8 x7)
                  end) x4 (Ffix0 x5 x4)
           end) x0 (Ffix x0 x2)
    end) 2 H'1)
out of reach
Tactic call ran for 0.002 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
     = eT [::] (eT tt (e 21))
     : {l : seq unit &
       {a : unit &
       {s' : nat
       | step_star (0, p_multiply 3 7 `; stop unit) l (s', stop unit a)}}}
     = eT [::] (eT tt (e (1, 3)))
     : {l : seq unit &
       {a : unit &
       {s' : nat * nat
       | step_star (0, 0, p_division 22 7 `; stop unit) l (s', stop unit a)}}}
     = Some (eT [::] (eT stop unit tt (e (1, 3))))
     : option
         {l : seq unit &
         {f' : continuation &
         {s' : nat * nat
         | step_n 15 (0, 0, p_division 22 7 `; stop unit) l (s', f')}}}
Crunching:
((forall r : R, k < r < abs -> p r) ->
 (forall r : R, x < r < k -> ~ p r) ->
 (forall r : R, abs < r < y -> ~ p r) ->
 exists r2 : R,
   interval_sum p x H3 1 /\
   interval_sum p H3 y r2 /\ (abs + - k)%R = (1 + r2)%R)
Crunching:
((forall r : R, k < r < abs -> p r) ->
 (forall r : R, x < r < k -> ~ p r) ->
 (forall r : R, abs < r < y -> ~ p r) ->
 exists r2 : R,
   interval_sum p x H3 1 /\
   interval_sum p H3 y r2 /\ (abs + - k)%R = (1 + r2)%R)
Crunching: (S n <= m)
Crunching:
(z <= H12 <= H13 /\ H13 <= h ->
 (forall r : R, H12 < r < H13 -> p r) ->
 (forall r : R, z < r < H12 -> ~ p r) ->
 (forall r : R, H13 < r < h -> ~ p r) ->
 exists r2 : R,
   interval_sum p z H3 1 /\
   interval_sum p H3 h r2 /\ (H13 - H12)%R = (1 + r2)%R)
Crunching:
(S
   ((fix Ffix (x : list bool) : nat :=
       match x with
       | [] => 0
       | x0 :: x1 =>
           (fix Ffix0 (x2 x3 : nat) {struct x2} : nat :=
              match x2 with
              | 0 => x3
              | S x4 => S (Ffix0 x4 x3)
              end) (if x0 then 1 else 0)
             ((fix Ffix0 (x2 x3 : nat) {struct x2} : nat :=
                 match x2 with
                 | 0 => x3
                 | S x4 => S (Ffix0 x4 x3)
                 end) (Ffix x1)
                ((fix Ffix0 (x2 x3 : nat) {struct x2} : nat :=
                    match x2 with
                    | 0 => x3
                    | S x4 => S (Ffix0 x4 x3)
                    end) (Ffix x1) 0))
       end)
      ((fix Ffix (x : nat) (x0 : nat -> bool) {struct x} : list bool :=
          match x with
          | 0 => []
          | S x1 => x0 x1 :: Ffix x1 x0
          end) a Ha)) <=
 (fix Ffix (x x0 : nat) {struct x0} : nat :=
    match x0 with
    | 0 => 1
    | S x1 =>
        (fix Ffix0 (x2 x3 : nat) {struct x2} : nat :=
           match x2 with
           | 0 => 0
           | S x4 =>
               (fix Ffix1 (x5 x6 : nat) {struct x5} : nat :=
                  match x5 with
                  | 0 => x6
                  | S x7 => S (Ffix1 x7 x6)
                  end) x3 (Ffix0 x4 x3)
           end) x (Ffix x x1)
    end) 2 a)
out of reach
Tactic call ran for 0.002 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.001u,0.s) (failure)
Finished transaction in 36.61 secs (36.165u,0.359s) (successful)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
out of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
Crunching:
(forall rr r1 r2 : R,
 interval_sum x l rr r1 -> interval_sum x l rr r2 -> r1 = r2)
Crunching:
(forall x x0 : nat -> bool,
 (forall x1 : nat, S x1 <= HP -> x x1 = x0 x1) ->
 (fix Ffix (x2 : list bool) : nat :=
    match x2 with
    | [] => 0
    | x3 :: x4 =>
        (fix Ffix0 (x5 x6 : nat) {struct x5} : nat :=
           match x5 with
           | 0 => x6
           | S x7 => S (Ffix0 x7 x6)
           end) (if x3 then 1 else 0)
          ((fix Ffix0 (x5 x6 : nat) {struct x5} : nat :=
              match x5 with
              | 0 => x6
              | S x7 => S (Ffix0 x7 x6)
              end) (Ffix x4)
             ((fix Ffix0 (x5 x6 : nat) {struct x5} : nat :=
                 match x5 with
                 | 0 => x6
                 | S x7 => S (Ffix0 x7 x6)
                 end) (Ffix x4) 0))
    end)
   ((fix Ffix (x2 : nat) (x3 : nat -> bool) {struct x2} : list bool :=
       match x2 with
       | 0 => []
       | S x4 => x3 x4 :: Ffix x4 x3
       end) HP x) =
 (fix Ffix (x2 : list bool) : nat :=
    match x2 with
    | [] => 0
    | x3 :: x4 =>
        (fix Ffix0 (x5 x6 : nat) {struct x5} : nat :=
           match x5 with
           | 0 => x6
           | S x7 => S (Ffix0 x7 x6)
           end) (if x3 then 1 else 0)
          ((fix Ffix0 (x5 x6 : nat) {struct x5} : nat :=
              match x5 with
              | 0 => x6
              | S x7 => S (Ffix0 x7 x6)
              end) (Ffix x4)
             ((fix Ffix0 (x5 x6 : nat) {struct x5} : nat :=
                 match x5 with
                 | 0 => x6
                 | S x7 => S (Ffix0 x7 x6)
                 end) (Ffix x4) 0))
    end)
   ((fix Ffix (x2 : nat) (x3 : nat -> bool) {struct x2} : list bool :=
       match x2 with
       | 0 => []
       | S x4 => x3 x4 :: Ffix x4 x3
       end) HP x0))
Crunching:
((fix Ffix (x : list bool) : nat :=
    match x with
    | [] => 0
    | x0 :: x1 =>
        (fix Ffix0 (x2 x3 : nat) {struct x2} : nat :=
           match x2 with
           | 0 => x3
           | S x4 => S (Ffix0 x4 x3)
           end) (if x0 then 1 else 0)
          ((fix Ffix0 (x2 x3 : nat) {struct x2} : nat :=
              match x2 with
              | 0 => x3
              | S x4 => S (Ffix0 x4 x3)
              end) (Ffix x1)
             ((fix Ffix0 (x2 x3 : nat) {struct x2} : nat :=
                 match x2 with
                 | 0 => x3
                 | S x4 => S (Ffix0 x4 x3)
                 end) (Ffix x1) 0))
    end)
   ((fix Ffix (x : nat) (x0 : nat -> bool) {struct x} : list bool :=
       match x with
       | 0 => []
       | S x1 => x0 x1 :: Ffix x1 x0
       end) n x) =
 (fix Ffix (x : list bool) : nat :=
    match x with
    | [] => 0
    | x0 :: x1 =>
        (fix Ffix0 (x2 x3 : nat) {struct x2} : nat :=
           match x2 with
           | 0 => x3
           | S x4 => S (Ffix0 x4 x3)
           end) (if x0 then 1 else 0)
          ((fix Ffix0 (x2 x3 : nat) {struct x2} : nat :=
              match x2 with
              | 0 => x3
              | S x4 => S (Ffix0 x4 x3)
              end) (Ffix x1)
             ((fix Ffix0 (x2 x3 : nat) {struct x2} : nat :=
                 match x2 with
                 | 0 => x3
                 | S x4 => S (Ffix0 x4 x3)
                 end) (Ffix x1) 0))
    end)
   ((fix Ffix (x : nat) (x0 : nat -> bool) {struct x} : list bool :=
       match x with
       | 0 => []
       | S x1 => x0 x1 :: Ffix x1 x0
       end) n Hx))
out of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
out of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
Crunching:
((forall x : nat, S x <= An -> X0 x = n x) ->
 (fix Ffix (x0 : list bool) : nat :=
    match x0 with
    | [] => 0
    | x1 :: x2 =>
        (fix Ffix0 (x3 x4 : nat) {struct x3} : nat :=
           match x3 with
           | 0 => x4
           | S x5 => S (Ffix0 x5 x4)
           end) (if x1 then 1 else 0)
          ((fix Ffix0 (x3 x4 : nat) {struct x3} : nat :=
              match x3 with
              | 0 => x4
              | S x5 => S (Ffix0 x5 x4)
              end) (Ffix x2)
             ((fix Ffix0 (x3 x4 : nat) {struct x3} : nat :=
                 match x3 with
                 | 0 => x4
                 | S x5 => S (Ffix0 x5 x4)
                 end) (Ffix x2) 0))
    end)
   ((fix Ffix (x0 : nat) (x1 : nat -> bool) {struct x0} : list bool :=
       match x0 with
       | 0 => []
       | S x2 => x1 x2 :: Ffix x2 x1
       end) An X0) =
 (fix Ffix (x0 : list bool) : nat :=
    match x0 with
    | [] => 0
    | x1 :: x2 =>
        (fix Ffix0 (x3 x4 : nat) {struct x3} : nat :=
           match x3 with
           | 0 => x4
           | S x5 => S (Ffix0 x5 x4)
           end) (if x1 then 1 else 0)
          ((fix Ffix0 (x3 x4 : nat) {struct x3} : nat :=
              match x3 with
              | 0 => x4
              | S x5 => S (Ffix0 x5 x4)
              end) (Ffix x2)
             ((fix Ffix0 (x3 x4 : nat) {struct x3} : nat :=
                 match x3 with
                 | 0 => x4
                 | S x5 => S (Ffix0 x5 x4)
                 end) (Ffix x2) 0))
    end)
   ((fix Ffix (x0 : nat) (x1 : nat -> bool) {struct x0} : list bool :=
       match x0 with
       | 0 => []
       | S x2 => x1 x2 :: Ffix x2 x1
       end) An n))
Crunching:
(forall n : nat,
 (forall m : nat,
  m < n ->
  (fix Ffix (x : list bool) : nat :=
     match x with
     | [] => 0
     | x0 :: x1 =>
         (fix Ffix0 (x2 x3 : nat) {struct x2} : nat :=
            match x2 with
            | 0 => x3
            | S x4 => S (Ffix0 x4 x3)
            end) (if x0 then 1 else 0)
           ((fix Ffix0 (x2 x3 : nat) {struct x2} : nat :=
               match x2 with
               | 0 => x3
               | S x4 => S (Ffix0 x4 x3)
               end) (Ffix x1)
              ((fix Ffix0 (x2 x3 : nat) {struct x2} : nat :=
                  match x2 with
                  | 0 => x3
                  | S x4 => S (Ffix0 x4 x3)
                  end) (Ffix x1) 0))
     end)
    ((fix Ffix (x : nat) (x0 : nat -> bool) {struct x} : list bool :=
        match x with
        | 0 => []
        | S x1 => x0 x1 :: Ffix x1 x0
        end) z H12) = m) ->
 (fix Ffix (x : list bool) : nat :=
    match x with
    | [] => 0
    | x0 :: x1 =>
        (fix Ffix0 (x2 x3 : nat) {struct x2} : nat :=
           match x2 with
           | 0 => x3
           | S x4 => S (Ffix0 x4 x3)
           end) (if x0 then 1 else 0)
          ((fix Ffix0 (x2 x3 : nat) {struct x2} : nat :=
              match x2 with
              | 0 => x3
              | S x4 => S (Ffix0 x4 x3)
              end) (Ffix x1)
             ((fix Ffix0 (x2 x3 : nat) {struct x2} : nat :=
                 match x2 with
                 | 0 => x3
                 | S x4 => S (Ffix0 x4 x3)
                 end) (Ffix x1) 0))
    end)
   ((fix Ffix (x : nat) (x0 : nat -> bool) {struct x} : list bool :=
       match x with
       | 0 => []
       | S x1 => x0 x1 :: Ffix x1 x0
       end) z H12) = n)
Crunching:
(forall n : nat,
 (forall m : nat,
  m < n ->
  (fix Ffix (x : list bool) : nat :=
     match x with
     | [] => 0
     | x0 :: x1 =>
         (fix Ffix0 (x2 x3 : nat) {struct x2} : nat :=
            match x2 with
            | 0 => x3
            | S x4 => S (Ffix0 x4 x3)
            end) (if x0 then 1 else 0)
           ((fix Ffix0 (x2 x3 : nat) {struct x2} : nat :=
               match x2 with
               | 0 => x3
               | S x4 => S (Ffix0 x4 x3)
               end) (Ffix x1)
              ((fix Ffix0 (x2 x3 : nat) {struct x2} : nat :=
                  match x2 with
                  | 0 => x3
                  | S x4 => S (Ffix0 x4 x3)
                  end) (Ffix x1) 0))
     end)
    ((fix Ffix (x : nat) (x0 : nat -> bool) {struct x} : list bool :=
        match x with
        | 0 => []
        | S x1 => x0 x1 :: Ffix x1 x0
        end) z H12) = m) ->
 (fix Ffix (x : list bool) : nat :=
    match x with
    | [] => 0
    | x0 :: x1 =>
        (fix Ffix0 (x2 x3 : nat) {struct x2} : nat :=
           match x2 with
           | 0 => x3
           | S x4 => S (Ffix0 x4 x3)
           end) (if x0 then 1 else 0)
          ((fix Ffix0 (x2 x3 : nat) {struct x2} : nat :=
              match x2 with
              | 0 => x3
              | S x4 => S (Ffix0 x4 x3)
              end) (Ffix x1)
             ((fix Ffix0 (x2 x3 : nat) {struct x2} : nat :=
                 match x2 with
                 | 0 => x3
                 | S x4 => S (Ffix0 x4 x3)
                 end) (Ffix x1) 0))
    end)
   ((fix Ffix (x : nat) (x0 : nat -> bool) {struct x} : list bool :=
       match x with
       | 0 => []
       | S x1 => x0 x1 :: Ffix x1 x0
       end) z H12) = n)
Finished transaction in 39.174 secs (38.456u,0.397s) (successful)
Crunching:
(forall x1 : RbaseSymbolsImpl.R, exp_in x x1 -> 0 < z -> Rabs (x - x0) < z)
Crunching: (0%nat <> 1%nat -> PI = 0)
Crunching: (pr_P H1 m -> pr_P n m)
Crunching:
((forall rnd : R, 0 <= rnd < IZR (Z.succ 0) -> H1 rnd <-> e rnd) ->
 pr_P H1 H11 -> pr_P e H11)
Crunching: (pr_P b r)
Crunching: positive
Crunching: positive
Crunching: (pr_P E0 p)
Crunching: (pr_P E0 p)
Crunching: (1 = 1 -> 0 <= ?rnd < 1)
Crunching: (0%nat <> 1%nat -> PI = 0)
Crunching:
(forall r : R,
 (forall rnd : R, 0 <= rnd < 1 -> N2 rnd <-> H7 rnd) ->
 pr_P N2 r -> pr_P H7 r)
Crunching: (∣0⟩ = basis_vector 2 0)
Finished transaction in 86.393 secs (86.146u,0.18s) (successful)
Crunching:
(interval_sum (fun rnd : R => n (sample [] rnd) = true) 0 H
   (pr_outcome_sum [] n))
Crunching:
(interval_sum (fun rnd : R => n (sample [] rnd) = true) 0 H
   (pr_outcome_sum [] n))
Crunching: (f_to_vec H H10 = ?y)
Crunching: (x <= y)
Crunching:
(sum_over_list l = f2 ->
 interval_sum (fun rnd : R => f1 (sample l rnd) = true) 0 f2
   (pr_outcome_sum l f1))
Crunching:
(sum_over_list l = f2 ->
 interval_sum (fun rnd : R => f1 (sample l rnd) = true) 0 f2
   (pr_outcome_sum l f1))
Crunching: False
Crunching:
(interval_sum (fun rnd : R => Hf (sample f rnd) = true) 0 x0
   (big_sum (fun i : nat => if Hf i then nth i f 0 else 0) (length f)))
Crunching:
(f_to_vec a H x y = basis_vector (S (S x) ^ a) (funbool_to_nat a H) x y)
Crunching:
(f_to_vec a H x y = basis_vector (S (S x) ^ a) (funbool_to_nat a H) x y)
Crunching:
((forall h : R,
  (let (a, _) :=
     Alembert_C3
       (fun n : nat =>
        ((fix pow (r : R) (n0 : nat) {struct n0} : R :=
            match n0 with
            | 0%nat => R1
            | S n1 => r * pow r n1
            end) (- R1) n *
         /
         (fix INR (n0 : nat) : R :=
            match n0 with
            | 0%nat => R0
            | 1%nat => R1
            | S (S _ as n1) => INR n1 + R1
            end)
           ((fix fact (n0 : nat) : nat :=
               match n0 with
               | 0%nat => 1%nat
               | S n1 =>
                   (fix add (n2 m : nat) {struct n2} : nat :=
                      match n2 with
                      | 0%nat => m
                      | S p => S (add p m)
                      end) (fact n1)
                     ((fix mul (n2 m : nat) {struct n2} : nat :=
                         match n2 with
                         | 0%nat => 0%nat
                         | S p =>
                             (fix add (n3 m0 : nat) {struct n3} : nat :=
                                match n3 with
                                | 0%nat => m0
                                | S p0 => S (add p0 m0)
                                end) m (mul p m)
                         end) n1 (fact n1))
               end)
              ((fix add (n0 m : nat) {struct n0} : nat :=
                  match n0 with
                  | 0%nat => m
                  | S p => S (add p m)
                  end)
                 ((fix add (n0 m : nat) {struct n0} : nat :=
                     match n0 with
                     | 0%nat => m
                     | S p => S (add p m)
                     end) n
                    ((fix add (n0 m : nat) {struct n0} : nat :=
                        match n0 with
                        | 0%nat => m
                        | S p => S (add p m)
                        end) n 0%nat)) 1%nat)))%R)
       ((h + (R1 + R1) * (let (a, _) := PI_2_aux in a) * / (R1 + R1)) *
        (h + (R1 + R1) * (let (a, _) := PI_2_aux in a) * / (R1 + R1)))
       sin_no_R0 Alembert_sin in
   ((h + (R1 + R1) * (let (a0, _) := PI_2_aux in a0) * / (R1 + R1)) * a)%R) =
  (let (a, _) := exist_cos (h * h) in a)) ->
 (fix big_sum (G : Type) (H : Monoid G) (f : nat -> G) (n : nat) {struct n} :
      G :=
    match n with
    | 0%nat => let (Gzero, Gplus, _, _, _) := H in Gzero
    | S n' =>
        (let (Gzero, Gplus, _, _, _) := H in Gplus) (big_sum G H f n') (f n')
    end) R
   {|
     Gzero := R0;
     Gplus := Rplus;
     Gplus_0_l :=
       fun g : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEc (RMicromega.CZ 0)) (EnvRing.PEX 1);
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs := EnvRing.PEX 1
            |} ()) [] eq_refl (fun _ : positive => g);
     Gplus_0_r :=
       fun g : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEc (RMicromega.CZ 0));
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs := EnvRing.PEX 1
            |} ()) [] eq_refl (fun _ : positive => g);
     Gplus_assoc :=
       fun g h i : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEX 1)
                  (EnvRing.PEadd (EnvRing.PEX 2) (EnvRing.PEX 3));
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs :=
                EnvRing.PEadd (EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEX 2))
                  (EnvRing.PEX 3)
            |} ()) [] eq_refl
         (fun p : positive =>
          match p with
          | (_~1)%positive => i
          | (_~0)%positive => h
          | 1%positive => g
          end)
   |}
   (fun i : nat =>
    (fix nth (n : nat) (l : list R) (default : R) {struct l} : R :=
       match n with
       | 0%nat => match l with
                  | [] => default
                  | x :: _ => x
                  end
       | S m => match l with
                | [] => default
                | _ :: t => nth m t default
                end
       end) i f R0)
   ((fix length (l : list R) : nat :=
       match l with
       | [] => 0%nat
       | _ :: l' => S (length l')
       end) f) = x0 ->
 interval_sum
   (fun rnd : R =>
    Hf
      ((fix sample (l : list R) (r : R) {struct l} : nat :=
          match l with
          | [] => 0%nat
          | x :: l' =>
              if Rlt_le_dec r x then 0%nat else S (sample l' (r + - x)%R)
          end) f rnd) = true) R0 x0 R0)
Crunching: ((Cmod c ^ 2)%R = fst (Cmod c ^ 2))
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching:
(forall l1 l2 : list bool,
 binlist_to_nat (l1 ++ l2) =
 binlist_to_nat l1 + 2 ^ length l1 * binlist_to_nat l2)
Crunching:
(forall l1 l2 : list bool,
 binlist_to_nat (l1 ++ l2) =
 binlist_to_nat l1 + 2 ^ length l1 * binlist_to_nat l2)
Crunching:
(distribution y0 ->
 pr_P (fun rnd : R => p (sample y0 rnd) = true) (pr_outcome_sum y0 p))
Crunching:
(frac_part 0 = 0 ->
 pr_P (fun rnd : R => l (sample y0 rnd) = true) (pr_outcome_sum y0 l))
Crunching:
(distribution y0 ->
 pr_P (fun rnd : R => p (sample y0 rnd) = true) (pr_outcome_sum y0 p))
out of reach
Tactic call ran for 0.015 secs (0.006u,0.009s) (failure)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (forall x y z : R, Rmax x y < z <-> x < z /\ y < z)
out of reach
Tactic call ran for 0.005 secs (0.005u,0.s) (failure)
Crunching:
(interval_sum (fun rnd : R => cm (sample l rnd) = true) 0 1
   (pr_outcome_sum l cm))
Crunching:
(distribution y0 ->
 pr_P (fun rnd : R => p (sample y0 rnd) = true)
   (big_sum (fun i : nat => if p i then nth i y0 0 else 0) (length y0)))
Crunching:
(distribution y0 ->
 pr_P (fun rnd : R => p (sample y0 rnd) = true) (pr_outcome_sum y0 p))
Crunching:
(frac_part 0 = 0 ->
 pr_P (fun rnd : R => l (sample y0 rnd) = true) (pr_outcome_sum y0 l))
Crunching:
(distribution y0 ->
 pr_P (fun rnd : R => p (sample y0 rnd) = true)
   (big_sum (fun i : nat => if p i then nth i y0 0 else 0) (length y0)))
Crunching:
(distribution y0 ->
 pr_P (fun rnd : R => p (sample y0 rnd) = true) (pr_outcome_sum y0 p))
Crunching:
(frac_part 0 = 0 ->
 pr_P (fun rnd : R => l (sample y0 rnd) = true) (pr_outcome_sum y0 l))
Crunching:
(distribution y0 ->
 pr_P (fun rnd : R => p (sample y0 rnd) = true) (pr_outcome_sum y0 p))
Crunching:
(frac_part 0 = 0 ->
 pr_P (fun rnd : R => l (sample y0 rnd) = true) (pr_outcome_sum y0 l))
Crunching:
(distribution y0 ->
 pr_P (fun rnd : R => p (sample y0 rnd) = true) (pr_outcome_sum y0 p))
Crunching:
(frac_part 0 = 0 ->
 pr_P (fun rnd : R => l (sample y0 rnd) = true) (pr_outcome_sum y0 l))
Crunching:
(distribution y0 ->
 pr_P (fun rnd : R => p (sample y0 rnd) = true) (pr_outcome_sum y0 p))
Crunching:
(frac_part 0 = 0 ->
 pr_P (fun rnd : R => l (sample y0 rnd) = true) (pr_outcome_sum y0 l))
Crunching:
(distribution y0 ->
 pr_P (fun rnd : R => p (sample y0 rnd) = true) (pr_outcome_sum y0 p))
Crunching:
(frac_part 0 = 0 ->
 pr_P (fun rnd : R => l (sample y0 rnd) = true) (pr_outcome_sum y0 l))
Crunching:
(distribution y0 ->
 pr_P (fun rnd : R => p (sample y0 rnd) = true) (pr_outcome_sum y0 p))
Crunching:
(frac_part 0 = 0 ->
 pr_P (fun rnd : R => l (sample y0 rnd) = true) (pr_outcome_sum y0 l))
Crunching:
(distribution y0 ->
 pr_P (fun rnd : R => p (sample y0 rnd) = true) (pr_outcome_sum y0 p))
Crunching:
(frac_part 0 = 0 ->
 pr_P (fun rnd : R => l (sample y0 rnd) = true) (pr_outcome_sum y0 l))
Crunching:
(distribution y0 ->
 pr_P (fun rnd : R => p (sample y0 rnd) = true) (pr_outcome_sum y0 p))
Crunching:
(frac_part 0 = 0 ->
 pr_P (fun rnd : R => l (sample y0 rnd) = true) (pr_outcome_sum y0 l))
Crunching:
(distribution y0 ->
 pr_P (fun rnd : R => p (sample y0 rnd) = true) (pr_outcome_sum y0 p))
Crunching:
(pr_P (fun rnd : R => Hf (sample f rnd) = true) (pr_outcome_sum f Hf))
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (forall x y z : R, Rmax x y < z <-> x < z /\ y < z)
out of reach
Tactic call ran for 0.006 secs (0.006u,0.s) (failure)
Crunching: (x < z)
Crunching: (x < z)
Tactic call ran for 0.003 secs (0.002u,0.s) (success)
Crunching:
(exists r0 : R,
   0 <= r0 <= x /\ pr_P (fun rnd : R => Hr (sample n rnd) = true) r0)
Crunching:
(exists r0 : R,
   0 <= r0 <= x /\ pr_P (fun rnd : R => Hr (sample n rnd) = true) r0)
Crunching:
(exists r0 : R,
   0 <= r0 <= x /\ pr_P (fun rnd : R => Hr (sample n rnd) = true) r0)
Crunching:
(exists r0 : R,
   0 <= r0 <= x /\ pr_P (fun rnd : R => Hr (sample n rnd) = true) r0)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.006 secs (0.003u,0.s) (success)
Crunching:
(0 < 1 ->
 pr_outcome_sum y H13 <= H1 ->
 exists r0 : R,
   - 0 <= r0 <= H1 /\ pr_P (fun rnd : R => H13 (sample y rnd) = true) r0)
Crunching:
(pr_outcome_sum y H13 <= r ->
 exists r0 : R,
   - 0 <= r0 <= r /\ pr_P (fun rnd : R => H13 (sample y rnd) = true) r0)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Crunching:
(distribution y ->
 pr_outcome_sum y H13 <= l' ->
 exists r0 : R,
   0 <= r0 <= l' /\ pr_P (fun rnd : R => H13 (sample y rnd) = true) r0)
Crunching:
(distribution y ->
 pr_outcome_sum y H13 <= l' ->
 exists r0 : R,
   0 <= r0 <= l' /\ pr_P (fun rnd : R => H13 (sample y rnd) = true) r0)
Crunching:
(((0 < 1 \/ 0 = 1) /\ (1 < eps \/ 1 = eps)) /\
 pr_P (fun rnd : R => H13 (sample y rnd) = true) 1)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Crunching:
(forall (P : R -> Prop) (r1 r2 : R), pr_P P r1 -> pr_P P r2 -> r1 = r2)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Crunching: (z2 = H)
Crunching: (z2 = H)
Crunching:
(forall (P : R -> Prop) (r1 r2 : R), pr_P P r1 -> pr_P P r2 -> r1 = r2)
Crunching: (m = (- - (r0 - r1))%R)
Crunching: (m = (- - r2)%R)
Crunching: (m = (- - r2)%R)
Crunching: (z2 = H)
Crunching: (z2 = H)
Crunching: (z2 = H)
Crunching:
(forall (P : R -> Prop) (r1 r2 : R), pr_P P r1 -> pr_P P r2 -> r1 = r2)
simplified dependent [if true]
e : (x <? n1)  = true
if (x <? n1)
then (fun E0 : (x <? n1) = true => AA (ltN_of_nat x n1 E0))
else
(fun E0 : (x <? n1) = false =>
 BB (ltN_of_nat (x - n1) n2 (ltN_split_lemma1 (ltN_plus_lemma1 e) E0)))
Crunching: (m = (- - (r0 - r1))%R)
rewrite if_dtt
if (n1 + x <? n1)
then (fun E0 : (n1 + x <? n1) = true => AA (ltN_of_nat (n1 + x) n1 E0))
else
(fun E0 : (n1 + x <? n1) = false =>
 BB (ltN_of_nat (n1 + x - n1) n2 (ltN_split_lemma1 (plus_ltN_lemma1 e) E0)))
rewrite if_dtt
if (x <? n1)
then
(fun E0 : (x <? n1) = true =>
 AA (exist (fun k : nat => (k <? n1) = true) x E0))
else
(fun E0 : (x <? n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true) (x - n1) (ltN_split_lemma1 e E0)))
Crunching: (m = (- - r2)%R)
Crunching:
(binlist_to_nat (repeat true f) = 2 ^ f - 1 ->
 binlist_to_nat (repeat true (S f)) = 2 ^ S f - 1)
Crunching: (m = (- - r2)%R)
rewrite if_dtt
if (x0 <? n)
then
(fun E0 : (x0 <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) x0 E0))
else
(fun E0 : (x0 <? n) = false =>
 BB (exist (fun k : nat => (k <? 0) = true) (x0 - n) (ltN_split_lemma1 e E0)))
destruct  (Nat.add_0_r n)  in  x
rewrite if_dtt
if (S x <? S n1)
then
(fun E0 : (S x <? S n1) = true =>
 AA (exist (fun k : nat => (k <? S n1) = true) (S x) E0))
else
(fun E0 : (S x <? S n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true) (x - n1) (ltN_split_lemma1 e E0)))
simplified dependent [if true]
p : (S x <? S n1)  = true
if (S x <? S n1)
then
(fun E0 : (x <? n1) = true =>
 AA (exist (fun k : nat => (k <? n1) = true) x E0))
else
(fun E0 : (x <? n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true) (x - n1) (ltN_split_lemma1 e E0)))
simplified dependent [if false]
p : (S x <? S n1)  = true
if (S x <? S n1)
then
(fun E0 : (x <? n1) = true =>
 AA (exist (fun k : nat => (k <? n1) = true) x E0))
else
(fun E0 : (x <? n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true) (x - n1) (ltN_split_lemma1 e E0)))
Crunching:
(sum_over_list l = 1 ->
 pr_outcome_sum l f = r <-> pr_P (fun rnd : R => f (sample l rnd) = true) r)
Crunching:
(sum_over_list l = 1 ->
 pr_outcome_sum l f = r <-> pr_P (fun rnd : R => f (sample l rnd) = true) r)
Crunching:
(sum_over_list l = 1 ->
 pr_outcome_sum l f = r <-> pr_P (fun rnd : R => f (sample l rnd) = true) r)
Crunching:
(sum_over_list l = 1 ->
 pr_outcome_sum l f = r <-> pr_P (fun rnd : R => f (sample l rnd) = true) r)
Crunching:
(sum_over_list l = 1 ->
 pr_outcome_sum l f = r <-> pr_P (fun rnd : R => f (sample l rnd) = true) r)
Crunching:
(sum_over_list l = 1 ->
 pr_outcome_sum l f = r <-> pr_P (fun rnd : R => f (sample l rnd) = true) r)
Crunching:
(sum_over_list l = 1 ->
 pr_outcome_sum l f = r <-> pr_P (fun rnd : R => f (sample l rnd) = true) r)
Crunching:
(sum_over_list l = 1 ->
 pr_outcome_sum l f = r <-> pr_P (fun rnd : R => f (sample l rnd) = true) r)
Crunching:
(sum_over_list l = 1 ->
 pr_outcome_sum l f = r <-> pr_P (fun rnd : R => f (sample l rnd) = true) r)
rewrite if_dtt
if (proj1_sig x =? proj1_sig k)
then (fun _ : (proj1_sig x =? proj1_sig k) = true => AA tt)
else
(fun E0 : (proj1_sig x =? proj1_sig k) = false =>
 BB
   ((if proj1_sig x <? proj1_sig k as b1
      return ((proj1_sig x <? proj1_sig k) = b1 -> ltN n)
     then
      fun E1 : (proj1_sig x <? proj1_sig k) = true =>
      ltN_of_nat (proj1_sig x) n (ltN_pop_lemma1 n k x E1)
     else
      fun E1 : (proj1_sig x <? proj1_sig k) = false =>
      ltN_of_nat (Init.Nat.pred (proj1_sig x)) n (ltN_pop_lemma2 n k x E1 E0))
      eq_refl))
Tactic call ran for 0.004 secs (0.004u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Crunching:
((forall (A : Type) (x y z : A), x = y -> y = z -> x = z) ->
 (forall r1 r2 r3 : R, r1 < r2 -> r2 < r3 -> r1 < r3) ->
 (forall r1 r2 r3 r4 : R, r1 = r2 -> r2 < r4 -> r4 = r3 -> r1 < r3) ->
 pr_outcome_sum A n = WF <-> pr_P (fun rnd : R => n (sample A rnd) = true) WF)
Tactic call ran for 0.003 secs (0.001u,0.001s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Crunching:
((forall (A : Type) (x y z : A), x = y -> y = z -> x = z) ->
 (forall r1 r2 r3 : R, r1 < r2 -> r2 < r3 -> r1 < r3) ->
 (forall r1 r2 r3 r4 : R, r1 = r2 -> r2 < r4 -> r4 = r3 -> r1 < r3) ->
 pr_outcome_sum A n = WF <-> pr_P (fun rnd : R => n (sample A rnd) = true) WF)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Crunching:
((forall (A : Type) (x y z : A), x = y -> y = z -> x = z) ->
 (forall r1 r2 r3 : R, r1 < r2 -> r2 < r3 -> r1 < r3) ->
 (forall r1 r2 r3 r4 : R, r1 = r2 -> r2 < r4 -> r4 = r3 -> r1 < r3) ->
 pr_outcome_sum A n = WF <-> pr_P (fun rnd : R => n (sample A rnd) = true) WF)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.017 secs (0.017u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.006 secs (0.003u,0.002s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Crunching:
(pr_outcome_sum l f = r <->
 interval_sum (fun rnd : R => f (sample l rnd) = true) 0 1 r)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Crunching:
(big_sum (fun i : nat => nth i [] 0) (length []) = 1 ->
 (pr_outcome_sum [] f = r ->
  interval_sum (fun rnd : R => f (sample [] rnd) = true) 0 1 r) /\
 (interval_sum (fun rnd : R => f (sample [] rnd) = true) 0 1 r ->
  pr_outcome_sum [] f = r))
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Crunching: (0%nat <> 0%nat)
Tactic call ran for 0.002 secs (0.001u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Crunching: (Forall (fun x : R => 0 - 0 <= x) (map Cmod2 (a :: l)))
Tactic call ran for 0.009 secs (0.008u,0.001s) (success)
Crunching: (Forall (fun x : R => 0 - 0 <= x) (map Cmod2 (a :: l)))
Tactic call ran for 0.008 secs (0.008u,0.s) (success)
Tactic call ran for 0.01 secs (0.008u,0.s) (success)
Tactic call ran for 0.01 secs (0.01u,0.s) (success)
out of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Tactic call ran for 0.008 secs (0.007u,0.s) (success)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Tactic call ran for 0.008 secs (0.008u,0.s) (success)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Tactic call ran for 0.007 secs (0.007u,0.s) (success)
Crunching: (binlist_to_nat [] = b1)
Crunching: (binlist_to_nat [] = b1)
Crunching: (binlist_to_nat [] = b1)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (0 = m)
Crunching: (0 = m)
Crunching: (binlist_to_nat [] = b1)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (pad_u dim m A × pad_u dim 0 B = pad_u dim 0 B × pad_u dim m A)
Crunching: (0 = m)
Crunching: (0 = m)
Crunching: (pad_u dim m A × pad_u dim 0 B = pad_u dim 0 B × pad_u dim m A)
Crunching: (pad_u dim m A × pad_u dim 0 B = pad_u dim 0 B × pad_u dim m A)
out of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching:
(Forall (fun b : bool => b = true) l -> length (incr_bin l) = S (length l))
Crunching: (pad_u x m A' × pad_u x n B' = pad_u x n B' × pad_u x m A')
Crunching:
(Forall (fun b : bool => b = true) l -> length (incr_bin l) = S (length l))
Crunching:
((fix length (l : list bool) : nat :=
    match l with
    | [] => 0
    | _ :: l' => S (length l')
    end)
   ((fix incr_bin (l : list bool) : list bool :=
       match l with
       | [] => [true]
       | true :: t => false :: incr_bin t
       | false :: t => true :: t
       end) q) =
 S
   ((fix length (l : list bool) : nat :=
       match l with
       | [] => 0
       | _ :: l' => S (length l')
       end) q))
Crunching:
((fix length (l : list bool) : nat :=
    match l with
    | [] => 0
    | _ :: l' => S (length l')
    end)
   ((fix incr_bin (l : list bool) : list bool :=
       match l with
       | [] => [true]
       | true :: t => false :: incr_bin t
       | false :: t => true :: t
       end) q) =
 S
   ((fix length (l : list bool) : nat :=
       match l with
       | [] => 0
       | _ :: l' => S (length l')
       end) q))
Crunching:
(Forall (fun b : bool => b = true) l -> length (incr_bin l) = S (length l))
Crunching:
(0 <= P1 <= H' ->
 0 < LT ->
 (P1 + H') * (P1 ^ LT + H' ^ LT) <= 2 * (P1 * P1 ^ LT + H' * H' ^ LT))
Crunching:
(exp_in 0 1 ->
 sum_over_list (map Cmod2 (vec_to_list ψ)) =
 big_sum (fun i : nat => (Cmod (ψ i 0%nat) ^ 2)%R) d)
Crunching:
(0 <= alp <= H3 ->
 0 < x ->
 (alp + H3) * (alp ^ x + H3 ^ x) <= 2 * (alp * alp ^ x + H3 * H3 ^ x))
Crunching:
(0 < x' ->
 (Hx + H10) * (Hx ^ x' + H10 ^ x') <= 2 * (Hx * Hx ^ x' + H10 * H10 ^ x'))
Crunching:
((fix length (l : list bool) : nat :=
    match l with
    | [] => 0
    | _ :: l' => S (length l')
    end)
   ((fix incr_bin (l : list bool) : list bool :=
       match l with
       | [] => [true]
       | true :: t => false :: incr_bin t
       | false :: t => true :: t
       end) q) =
 S
   ((fix length (l : list bool) : nat :=
       match l with
       | [] => 0
       | _ :: l' => S (length l')
       end) q))
Crunching:
((fix length (l : list bool) : nat :=
    match l with
    | [] => 0
    | _ :: l' => S (length l')
    end)
   ((fix incr_bin (l : list bool) : list bool :=
       match l with
       | [] => [true]
       | true :: t => false :: incr_bin t
       | false :: t => true :: t
       end) q) =
 S
   ((fix length (l : list bool) : nat :=
       match l with
       | [] => 0
       | _ :: l' => S (length l')
       end) q))
Crunching:
((fix length (l : list bool) : nat :=
    match l with
    | [] => 0
    | _ :: l' => S (length l')
    end)
   ((fix incr_bin (l : list bool) : list bool :=
       match l with
       | [] => [true]
       | true :: t => false :: incr_bin t
       | false :: t => true :: t
       end) q) =
 S
   ((fix length (l : list bool) : nat :=
       match l with
       | [] => 0
       | _ :: l' => S (length l')
       end) q))
Crunching:
((fix length (l : list bool) : nat :=
    match l with
    | [] => 0
    | _ :: l' => S (length l')
    end)
   ((fix incr_bin (l : list bool) : list bool :=
       match l with
       | [] => [true]
       | true :: t => false :: incr_bin t
       | false :: t => true :: t
       end) q) =
 S
   ((fix length (l : list bool) : nat :=
       match l with
       | [] => 0
       | _ :: l' => S (length l')
       end) q))
Crunching:
(Forall (fun b : bool => b = true) l -> length (incr_bin l) = S (length l))
Crunching:
(exp_in 0 1 ->
 sum_over_list (map Cmod2 (vec_to_list ψ)) =
 big_sum (fun i : nat => (Cmod (ψ i 0%nat) ^ 2)%R) d)
Crunching:
(length (incr_bin IH) = S (length IH) ->
 length (incr_bin (n :: IH)) = S (length (n :: IH)))
Tactic call ran for 0.016 secs (0.016u,0.s) (success)
Crunching:
(length (incr_bin IH) = S (length IH) ->
 length (incr_bin (n :: IH)) = S (length (n :: IH)))
Crunching:
(length (incr_bin IH) = S (length IH) ->
 length (incr_bin (n :: IH)) = S (length (n :: IH)))
(ret [[0.33333333333332099; 0.33333333333334692]])
(ret [[0.39052428152232477; 0.3905243021208048]])
(ret [[0.39051452913860984; 0.39053541828418686]])
(ret [[0.40546510799655183; 0.40546510821793463]])
(ret [[0.40546510810804604; 0.40546510810828312]])
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (length (incr_bin f) = length f)
Crunching:
(Exists (fun b : bool => b <> true) f -> length (incr_bin f) = length f)
Tactic call ran for 0.016 secs (0.016u,0.s) (success)
Crunching:
(sum_over_list (map Cmod2 (vec_to_list n)) =
 big_sum (fun i : nat => (Cmod (n i 0%nat) * (Cmod (n i 0%nat) * 1))%R) y)
Crunching: (length (incr_bin f) = length f)
Crunching: (length (incr_bin f) = length f)
Crunching: (length (incr_bin f) = length f)
Crunching:
(Exists (fun b : bool => b <> true) f -> length (incr_bin f) = length f)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching:
(WF_Unitary n ->
 Forall (fun x : R => 0 <= x) (apply_u n) /\ sum_over_list (apply_u n) = 1)
Crunching: (length (incr_bin f) = length f)
Crunching:
(pad_u l m HP × pad_ctrl l q H' HQ = pad_ctrl l q H' HQ × pad_u l m HP)
Crunching: (length (incr_bin f) = length f)
Crunching:
(Exists (fun b : bool => b <> true) f -> length (incr_bin f) = length f)
Crunching:
(Exists (fun b : bool => b <> true) f -> length (incr_bin f) = length f)
Crunching: (length (incr_bin f) = length f)
Crunching: (length (incr_bin f) = length f)
Crunching: (length (incr_bin f) = length f)
Crunching: (length (incr_bin f) = length f)
Crunching:
(Exists (fun b : bool => b <> true) f -> length (incr_bin f) = length f)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (∣1⟩ = basis_vector 2 1)
(ret [[0.33333333333332099; 0.33333333333334692]])
(ret [[0.39052428152232477; 0.3905243021208048]])
(ret [[0.39051452913860984; 0.39053541828418686]])
(ret [[0.40546510799655183; 0.40546510821793463]])
(ret [[0.40546510810804604; 0.40546510810828312]])
Crunching: (Nat.testbit (length (incr_bin k)) m = Nat.testbit (length k) m)
Crunching:
(WF_Unitary n ->
 Forall (fun x : R => 0 <= x) (apply_u n) /\ sum_over_list (apply_u n) = 1)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching:
(exp_in 0 (exp 0) ->
 length (if x then false :: incr_bin [] else [true]) = S (length []))
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching:
(pad_u l Hn A × pad_ctrl l n o B = pad_ctrl l n o B × pad_u l Hn A)
Crunching: (x - n <= Hxnonneg -> x - Hxnonneg <= n)
Crunching: (length (apply_u u) = (2 ^ 0)%nat)
Crunching: (length (apply_u H) = (2 ^ Hbeq)%nat)
Crunching: (length (apply_u n) = (2 ^ l)%nat)
Crunching: (length (apply_u CDML) = (2 ^ S l)%nat)
Crunching: (length (apply_u H) = (2 ^ w2)%nat)
Crunching: (length (apply_u H) = (2 ^ Hbeq)%nat)
Crunching: (length (apply_u u) = (2 ^ Hneq)%nat)
Crunching: (length (apply_u u) = (2 ^ Hneq)%nat)
Crunching: (length (apply_u n) = (2 ^ l)%nat)
Crunching: (length (apply_u CDML) = (2 ^ S l)%nat)
Crunching: (length (apply_u H) = (2 ^ w2)%nat)
Crunching: (n = o)
Crunching:
(nth x (apply_u dyz) 0 =
 (Cmod ⟨ basis_vector (2 ^ y) x, dyz × basis_vector (2 ^ y) 0 ⟩ *
  (Cmod ⟨ basis_vector (2 ^ y) x, dyz × basis_vector (2 ^ y) 0 ⟩ * 1))%R)
Crunching:
(forall x : nat,
 (x < 2 ^ 0)%nat ->
 WF_Matrix l ->
 nth x (apply_u l) (- 0)%R =
 probability_of_outcome (basis_vector (2 ^ 0) x) (l × basis_vector (2 ^ 0) 0))
Crunching:
((H < 2 ^ n)%nat ->
 WF_Matrix a ->
 nth H (apply_u a) (- 0)%R =
 probability_of_outcome (basis_vector (2 ^ n) H) (a × basis_vector (2 ^ n) 0))
Crunching: (f < 2 ^ E -> length (nat_to_binlist' f) <= E)
     = @^~ 8
     : M nat
     = tt
     : [the monad of idfun] unit
     = @^~ None
     : [the contMonad of ContMonad.acto bool] (option nat)
     = @^~ (Some 3)
     : [the contMonad of ContMonad.acto bool] (option nat)
Crunching:
(nth s1 (apply_u c_encad) 0 =
 probability_of_outcome (basis_vector (2 ^ c) s1)
   (c_encad × basis_vector (2 ^ c) 0))
Crunching: False
Crunching:
(nth s1 (apply_u c_encad) 0 =
 probability_of_outcome (basis_vector (2 ^ c) s1)
   (c_encad × basis_vector (2 ^ c) 0))
Crunching:
(nth s1 (apply_u c_encad) 0 =
 probability_of_outcome (basis_vector (2 ^ c) s1)
   (c_encad × basis_vector (2 ^ c) 0))
Crunching:
(nth s1 (apply_u c_encad) 0 =
 probability_of_outcome (basis_vector (2 ^ c) s1)
   (c_encad × basis_vector (2 ^ c) 0))
Crunching:
((0 < false)%R /\
 (forall x : Base R_met,
  D_x no_cond 1 x /\ (dist R_met x 1 < false)%R ->
  (dist R_met (atan x) (atan 1) < LE)%R))
Crunching:
((false > 0)%R /\
 (forall x : Base R_met,
  D_x no_cond 1 x /\ (dist R_met x 1 < false)%R ->
  (dist R_met (atan x) (atan 1) < LE)%R))
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching:
((eq > √ 0)%R ->
 exists alp : R,
   (alp > √ 0)%R /\
   (forall x : R,
    D_x no_cond 1 x /\ (R_dist x 1 < alp)%R ->
    (R_dist (atan x) (atan 1) < eq)%R))
Crunching:
((eq > √ 0)%R ->
 exists alp : R,
   (alp > √ 0)%R /\
   (forall x : R,
    D_x no_cond 1 x /\ (R_dist x 1 < alp)%R ->
    (R_dist (atan x) (atan 1) < eq)%R))
Crunching:
((0 < eq)%R ->
 exists alp : R,
   (0 < alp)%R /\
   (forall x : Base R_met,
    D_x no_cond 1 x /\ (dist R_met x 1 < alp)%R ->
    (dist R_met (atan x) (atan 1) < eq)%R))
Crunching: (Forall (fun x : R => 0 <= x) (repeat x H))
Crunching: (length (nat_to_binlist o eps) = o)
Crunching: (length (nat_to_binlist o eps) = o)
Crunching: (Forall (fun x : R => 0 <= x) (repeat x H))
Crunching: (Forall (fun x : R => 0 <= x) (repeat x H))
Crunching: (Forall (fun x : R => 0 <= x) (repeat m 0))
Crunching:
(forall eps : R,
 (eps > 0)%R ->
 exists alp : R,
   (alp > 0)%R /\
   (forall x : Base R_met,
    D_x no_cond 1 x /\
    ((let (Base, dist, _, _, _, _) as m return (Base m -> Base m -> R) :=
        R_met in
      dist) x 1 < alp)%R ->
    ((let (Base, dist, _, _, _, _) as m return (Base m -> Base m -> R) :=
        R_met in
      dist) (atan x) (atan 1) < eps)%R))
Crunching:
((true > 0)%R /\
 (forall x : R,
  D_x no_cond 1 x /\ (R_dist x 1 < true)%R ->
  (R_dist (atan x) (atan 1) < a)%R))
Crunching: (Forall (fun x : R => 0 <= x) (repeat x H))
Crunching:
((0 < false)%R /\
 (forall x : Base R_met,
  D_x no_cond 1 x /\ (dist R_met x 1 < false)%R ->
  (dist R_met (atan x) (atan 1) < LE)%R))
Crunching:
((false > 0)%R /\
 (forall x : Base R_met,
  D_x no_cond 1 x /\ (dist R_met x 1 < false)%R ->
  (dist R_met (atan x) (atan 1) < LE)%R))
Crunching: (Forall (fun x : R => 0 <= x) (repeat m 0))
Crunching: (Forall (fun x : R => 0 <= x) (repeat x H))
Crunching:
((eq > √ 0)%R ->
 exists alp : R,
   (alp > √ 0)%R /\
   (forall x : R,
    D_x no_cond 1 x /\ (R_dist x 1 < alp)%R ->
    (R_dist (atan x) (atan 1) < eq)%R))
Crunching:
((eq > √ 0)%R ->
 exists alp : R,
   (alp > √ 0)%R /\
   (forall x : R,
    D_x no_cond 1 x /\ (R_dist x 1 < alp)%R ->
    (R_dist (atan x) (atan 1) < eq)%R))
Crunching: (Forall (fun x : R => 0 <= x) (repeat a H))
Crunching: (0 <= x -> Forall (fun x : R => 0 <= x) (repeat x H))
Crunching: (forall n : nat, (n >= ?N)%nat -> R_dist (PI_2_3_7_tg n) R0 < a)
Crunching:
(exists N : nat, forall n : nat, (n >= N)%nat -> R_dist (PI_2_3_7_tg n) 0 < a)
Crunching:
((0 < eq)%R ->
 exists alp : R,
   (0 < alp)%R /\
   (forall x : Base R_met,
    D_x no_cond 1 x /\ (dist R_met x 1 < alp)%R ->
    (dist R_met (atan x) (atan 1) < eq)%R))
Crunching: (Forall (fun x : R => 0 <= x) (repeat r 0))
Crunching:
(forall (m : nat) (x : R), sum_over_list (repeat x m) = (INR m * x)%R)
Crunching:
(forall (m : nat) (x : R), sum_over_list (repeat x m) = (INR m * x)%R)
     = ret 2.8754776337791554e-14%float
     : E FF
     = ret 1.1539903023827236e-05%float
     : E FF
     = ret
         {|
           approx.pol :=
             [[[109.9761759193364; 109.9761759193364]];
             [[91.024979933356605; 91.024979933356605]];
             [[-0.013094741799676513; -0.013094741799676513]];
             [[0.0068657782589525594; 0.0068657782589525594]];
             [[-0.0036010109553458848; -0.0036010109553458848]];
             [[0.0018905493185753925; 0.0018905493185753925]];
             [[-0.00099590478953359707; -0.00099590478953359707]];
             [[0.00053090310183563356; 0.00053090310183563356]];
             [[-0.00029486341253459614; -0.00029486341253459614]];
             [[0.011210177712916903; 0.011210177712916903]];
             [[0.026815037081536274; 0.026815037081536274]]];
           approx.rem := [[-0.074844644956674256; 0.074844644956674242]];
           approx.cont := true
         |}
     : Static.sval (chebyshev_model_ops (fromZ 18) (fromZ 200)) FUN
     = ret (Specific_ops.Float 5567862537815687%Z (-58)%Z)
     : E FF
Finished transaction in 0.867 secs (0.823u,0.042s) (successful)
     = ret (Specific_ops.Float 5567862537815687%Z (-57)%Z)
     : E FF
Finished transaction in 0.79 secs (0.786u,0.002s) (successful)
     = ret
         {|
           approx.pol :=
             [[[Specific_ops.Float 720357451616277761%Z (-58)%Z;
              Specific_ops.Float 720357451616277761%Z (-58)%Z]];
             [[Specific_ops.Float 1094558786233859380%Z (-58)%Z;
             Specific_ops.Float 1094558786233859380%Z (-58)%Z]];
             [[Specific_ops.Float 977308976456680341%Z (-59)%Z;
             Specific_ops.Float 977308976456680341%Z (-59)%Z]];
             [[Specific_ops.Float 911430244636437681%Z (-61)%Z;
             Specific_ops.Float 911430244636437681%Z (-61)%Z]];
             [[Specific_ops.Float (-875073714472971280)%Z (-63)%Z;
             Specific_ops.Float (-875073714472971280)%Z (-63)%Z]];
             [[Specific_ops.Float (-749224186984049261)%Z (-62)%Z;
             Specific_ops.Float (-749224186984049261)%Z (-62)%Z]];
             [[Specific_ops.Float (-922337203685477604)%Z (-63)%Z;
             Specific_ops.Float (-922337203685477604)%Z (-63)%Z]];
             [[Specific_ops.Float (-692452066805713429)%Z (-64)%Z;
             Specific_ops.Float (-692452066805713429)%Z (-64)%Z]];
             [[Specific_ops.Float (-756215827400101205)%Z (-67)%Z;
             Specific_ops.Float (-756215827400101205)%Z (-67)%Z]];
             [[Specific_ops.Float 698045379138553685%Z (-67)%Z;
             Specific_ops.Float 698045379138553685%Z (-67)%Z]];
             [[Specific_ops.Float 684621429539735211%Z (-67)%Z;
             Specific_ops.Float 684621429539735211%Z (-67)%Z]];
             [[Specific_ops.Float 733842578068733952%Z (-68)%Z;
             Specific_ops.Float 733842578068733952%Z (-68)%Z]];
             [[Specific_ops.Float 894929973254551552%Z (-69)%Z;
             Specific_ops.Float 894929973254551552%Z (-69)%Z]]];
           approx.rem :=
             [[Specific_ops.Float (-929534692799689239)%Z (-69)%Z;
             Specific_ops.Float 929534692799689239%Z (-69)%Z]];
           approx.cont := true
         |}
     : Static.sval chebyshev11_model_ops FUN
Finished transaction in 1.042 secs (1.035u,0.003s) (successful)
     = ret
         {|
           approx.pol :=
             [[[Specific_ops.Float 720357451616277761%Z (-57)%Z;
              Specific_ops.Float 720357451616277761%Z (-57)%Z]];
             [[Specific_ops.Float 1094558786233859380%Z (-57)%Z;
             Specific_ops.Float 1094558786233859380%Z (-57)%Z]];
             [[Specific_ops.Float 977308976456680341%Z (-58)%Z;
             Specific_ops.Float 977308976456680341%Z (-58)%Z]];
             [[Specific_ops.Float 911430244636437681%Z (-60)%Z;
             Specific_ops.Float 911430244636437681%Z (-60)%Z]];
             [[Specific_ops.Float (-875073714472971280)%Z (-62)%Z;
             Specific_ops.Float (-875073714472971280)%Z (-62)%Z]];
             [[Specific_ops.Float (-749224186984049261)%Z (-61)%Z;
             Specific_ops.Float (-749224186984049261)%Z (-61)%Z]];
             [[Specific_ops.Float (-922337203685477604)%Z (-62)%Z;
             Specific_ops.Float (-922337203685477604)%Z (-62)%Z]];
             [[Specific_ops.Float (-692452066805713429)%Z (-63)%Z;
             Specific_ops.Float (-692452066805713429)%Z (-63)%Z]];
             [[Specific_ops.Float (-756215827400101205)%Z (-66)%Z;
             Specific_ops.Float (-756215827400101205)%Z (-66)%Z]];
             [[Specific_ops.Float 698045379138553685%Z (-66)%Z;
             Specific_ops.Float 698045379138553685%Z (-66)%Z]];
             [[Specific_ops.Float 684621429539735211%Z (-66)%Z;
             Specific_ops.Float 684621429539735211%Z (-66)%Z]];
             [[Specific_ops.Float 733842578068733952%Z (-67)%Z;
             Specific_ops.Float 733842578068733952%Z (-67)%Z]];
             [[Specific_ops.Float 894929973254551552%Z (-68)%Z;
             Specific_ops.Float 894929973254551552%Z (-68)%Z]]];
           approx.rem :=
             [[Specific_ops.Float (-929534692799689239)%Z (-68)%Z;
             Specific_ops.Float 929534692799689239%Z (-68)%Z]];
           approx.cont := true
         |}
     : Static.sval chebyshev11_model_ops FUN
Finished transaction in 1.047 secs (1.045u,0.s) (successful)
Crunching: (funbool_to_list b a = funbool_to_list b (update a psi_un n))
Crunching: (funbool_to_list b (update a psi_un n) = funbool_to_list b a)
Crunching: (b <= m -> funbool_to_list b (update a m n) = funbool_to_list b a)
Crunching:
(forall (m : nat) (x : R), sum_over_list (repeat x m) = (INR m * x)%R)
Crunching: False
Crunching: (sum_over_list (repeat x m) = (INR m * x)%R)
Crunching: (~ 1 < 1)
Crunching: (sum_over_list (repeat x 0) = (INR 0 * x)%R)
Crunching: (funbool_to_list b a = funbool_to_list b (update a psi_un n))
Crunching: (funbool_to_list b (update a psi_un n) = funbool_to_list b a)
Crunching: (hyp_r <= sample (uniform hyp_r n) m < n)%nat
Crunching: (funbool_to_list b a = funbool_to_list b (update a psi_un n))
Crunching: (funbool_to_list b (update a psi_un n) = funbool_to_list b a)
Crunching: (length l = g -> funbool_to_list g (list_to_funbool g l) = l)
Crunching: (length Hb = n -> funbool_to_list n (list_to_funbool n Hb) = Hb)
Crunching: (length l = g -> funbool_to_list g (list_to_funbool g l) = l)
Crunching: (length l = g -> funbool_to_list g (list_to_funbool g l) = l)
Crunching: (funbool_to_list (length b) (list_to_funbool (length b) b) = b)
Crunching: (funbool_to_list (length b) (list_to_funbool (length b) b) = b)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (length Hb = n -> funbool_to_list n (list_to_funbool n Hb) = Hb)
Crunching: (length l = g -> funbool_to_list g (list_to_funbool g l) = l)
Crunching: (length l = g -> funbool_to_list g (list_to_funbool g l) = l)
Crunching: (length l = g -> funbool_to_list g (list_to_funbool g l) = l)
Crunching: (length [] = n -> funbool_to_list n (list_to_funbool n []) = [])
Crunching: (funbool_to_list (length b) (list_to_funbool (length b) b) = b)
Crunching: (funbool_to_list (length b) (list_to_funbool (length b) b) = b)
Crunching: (funbool_to_list (length b) (list_to_funbool (length b) b) = b)
Crunching: (funbool_to_list (length b) (list_to_funbool (length b) b) = b)
Crunching: (funbool_to_list x (list_to_funbool x z1) = z1)
Crunching: (hyp_r <= sample (uniform hyp_r n) m < n)%nat
Crunching: (hyp_r <= sample (uniform hyp_r n) m < n)%nat
Crunching: (hyp_r <= sample (uniform hyp_r n) m < n)%nat
Crunching: (hyp_r <= sample (uniform hyp_r n) m < n)%nat
Crunching: (length Hb = n -> funbool_to_list n (list_to_funbool n Hb) = Hb)
Tactic call ran for 0.006 secs (0.006u,0.s) (success)
Crunching: (length l = g -> funbool_to_list g (list_to_funbool g l) = l)
Crunching: (distribution (uniform l (S l)))
Crunching: (distribution (uniform l (S l)))
Crunching: (length l = g -> funbool_to_list g (list_to_funbool g l) = l)
Crunching: (length l = g -> funbool_to_list g (list_to_funbool g l) = l)
Crunching: (length l = g -> funbool_to_list g (list_to_funbool g l) = l)
Crunching: (distribution (uniform n r))
Crunching: (distribution (uniform n r))
Crunching: (distribution (uniform n r))
Crunching: (lb <= (x + y) * / 2)
Crunching: (lb <= (x + y) * / 2)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (distribution (uniform l (S l)))
Crunching: (distribution (uniform l (S l)))
Tactic call ran for 0.006 secs (0.006u,0.s) (success)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (distribution (uniform l (S l)))
Crunching: (distribution (uniform l (S l)))
Crunching: (∣0⟩ = basis_vector 2 0)
Tactic call ran for 0.005 secs (0.005u,0.s) (success)
Crunching: (funbool_to_nat len (nat_to_funbool len H0) = H0)
Crunching: (distribution (uniform l (S l)))
Crunching: (distribution (uniform l (S l)))
Crunching: (∣0⟩ = basis_vector 2 0)
Tactic call ran for 0.005 secs (0.005u,0.s) (success)
Crunching: (distribution (uniform l (S l)))
Crunching: (distribution (uniform l (S l)))
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (distribution (uniform l (S l)))
Crunching: (distribution (uniform l (S l)))
Crunching: (funbool_to_nat len (nat_to_funbool len n) = n)
Crunching: (distribution (uniform l (S l)))
Crunching: (distribution (uniform l (S l)))
Crunching: (distribution (uniform l (S l)))
out of reach
Tactic call ran for 0.003 secs (0.002u,0.001s) (failure)
Crunching: (distribution (uniform 0 1))
Crunching: (distribution (uniform 0 Hn))
Crunching: (distribution (uniform 0 Hn))
out of reach
Tactic call ran for 0.005 secs (0.005u,0.s) (failure)
Crunching: (H8 = m)
Crunching: (distribution (uniform 0 r))
Crunching: (distribution (uniform 0 a))
Crunching: (distribution (uniform n r))
     = err "msqrt: missed mu0<1"
     : E FF
     = ret 0.019054260631166435%float
     : E FF
     = ret 0.0027158307793357069%float
     : E FF
     = ret 0.00062770722533873587%float
     : E FF
     = ret 0.00016685132944658826%float
     : E FF
     = ret 4.7498455945126596e-05%float
     : E FF
Crunching: (distribution (uniform n r))
     = ret 1.4097830869872009e-05%float
     : E FF
Crunching: (distribution (uniform n r))
     = ret 4.306735966350321e-06%float
     : E FF
     = ret 1.3443005331964648e-06%float
     : E FF
     = ret 4.2675434309288284e-07%float
     : E FF
     = ret 6.3857338167259186e-13%float
     : E FF
     = err "msqrt: missed mu0<1"
     : E FF
     = err "msqrt: missed mu0<1"
     : E FF
     = err "msqrt: missed mu0<1"
     : E FF
     = ret 0.020043240427919461%float
     : E FF
     = err "msqrt: missed mu0<1"
     : E FF
     = err "msqrt: missed 0<delta"
     : E FF
     = ret 0.01016690008922291%float
     : E FF
     = ret 0.0037377455251410823%float
     : E FF
     = ret 0.0019091978629927784%float
     : E FF
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
     = ret 0.0010782160772482797%float
     : E FF
     = ret 0.00064239238802731046%float
     : E FF
     = ret 9.7192075699687093e-05%float
     : E FF
     = err "msqrt: missed mu0<1"
     : E FF
     = ret 0.0033595091724205831%float
     : E FF
     = ret 1.2479890519241319e-06%float
     : E FF
Crunching: (∣0⟩ = basis_vector 2 0)
     = ret 6.8778214963336185e-10%float
     : E FF
Crunching: (∣0⟩ = basis_vector 2 0)
     = err "msqrt: missed mu0<1"
     : E FF
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching: (funbool_to_nat len (nat_to_funbool len H0) = H0)
Crunching: (forall l r : nat, (l <= r)%nat -> length (uniform l r) = r)
Crunching: (funbool_to_nat len (nat_to_funbool len H0) = H0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (INR (S n - 1) = INR n)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching: (INR (S n - 1) = INR n)
Crunching: (INR (S n - 1) = INR n)
Crunching: (length (uniform a' Ha') = Ha')
Crunching: (forall l r : nat, (l <= r)%nat -> length (uniform l r) = r)
Crunching: (INR (S n - 1) = INR n)
     = err "msqrt: missed mu0<1"
     : E FF
     = ret 6.9214269464063779e-05%float
     : E FF
     = ret 1.3524254710726107e-07%float
     : E FF
Finished transaction in 0.005 secs (0.004u,0.s) (successful)
     = ret 1.3524254710726107e-07%float
     : E FF
Finished transaction in 0.004 secs (0.003u,0.s) (successful)
     = ret 4.3520742565301479e-14%float
     : E FF
Finished transaction in 0.013 secs (0.012u,0.s) (successful)
     = ret 2.64233079860787e-14%float
     : E FF
Finished transaction in 0.027 secs (0.026u,0.s) (successful)
     = ret 2.8865798640254057e-14%float
     : E FF
Finished transaction in 0.047 secs (0.047u,0.s) (successful)
     = ret 3.264055692397959e-14%float
     : E FF
Finished transaction in 0.075 secs (0.075u,0.s) (successful)
     = ret 4.8405723873656749e-14%float
     : E FF
Finished transaction in 0.11 secs (0.11u,0.s) (successful)
     = ret 4.7961634663806674e-14%float
     : E FF
Finished transaction in 0.154 secs (0.154u,0.s) (successful)
Finished transaction in 0.018 secs (0.017u,0.001s) (successful)
Finished transaction in 0.017 secs (0.017u,0.s) (successful)
Finished transaction in 0.052 secs (0.052u,0.s) (successful)
Finished transaction in 0.167 secs (0.166u,0.s) (successful)
Finished transaction in 0.464 secs (0.457u,0.005s) (successful)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Finished transaction in 1.02 secs (1.019u,0.s) (successful)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Finished transaction in 1.992 secs (1.986u,0.003s) (successful)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Finished transaction in 3.56 secs (3.55u,0.004s) (successful)
Finished transaction in 0. secs (0.u,0.s) (successful)
Finished transaction in 0. secs (0.u,0.s) (successful)
Finished transaction in 0. secs (0.u,0.s) (successful)
Finished transaction in 0. secs (0.u,0.s) (successful)
Finished transaction in 0. secs (0.u,0.s) (successful)
Finished transaction in 0. secs (0.u,0.s) (successful)
Finished transaction in 0. secs (0.u,0.s) (successful)
Finished transaction in 0. secs (0.u,0.s) (successful)
     = ret 0.15148746656688988%float
     : E FF
     = ret 0.15139658307288195%float
     : E FF
     = ret 0.15139657739821419%float
     : E FF
     = ret 0.061446269198929239%float
     : E FF
Crunching: (∣0⟩ = basis_vector 2 0)
     = ret 0.055199058172036616%float
     : E FF
     = ret 0.055198568077180994%float
     : E FF
     = err "msqrt: missed mu0<1"
     : E FF
     = ret 0.018492804666128928%float
     : E FF
     = ret 0.018483580455310147%float
     : E FF
     = err "msqrt: missed 0<delta"
     : E FF
Crunching: (∣0⟩ = basis_vector 2 0)
     = ret 0.0019586963778410399%float
     : E FF
     = ret 0.0019558414535714858%float
     : E FF
Crunching: (forall r : nat, (b <= r)%nat -> length (uniform b r) = r)
Crunching: (length (uniform x (S (Init.Nat.pred n))) = S (Init.Nat.pred n))
Crunching: (length (uniform x (S (Init.Nat.pred n))) = S (Init.Nat.pred n))
Crunching: (length (uniform x (S (Init.Nat.pred n))) = S (Init.Nat.pred n))
Crunching: (length (uniform x (S (Init.Nat.pred n))) = S (Init.Nat.pred n))
Crunching: (length (uniform x (S (Init.Nat.pred n))) = S (Init.Nat.pred n))
Crunching: (length (uniform x (S (Init.Nat.pred n))) = S (Init.Nat.pred n))
Crunching: (nat_to_binlist' (2 * 0 + 1) = [true])
Crunching: (nat_to_binlist' (2 * 0 + 1) = [true])
Crunching: (nat_to_binlist' (2 * H + 1) = true :: nat_to_binlist' H)
clear  H0a'  :  (False -> cmpA a a' <> Lt)
Crunching: (nat_to_binlist' (2 * 0 + 1) = [true])
Crunching: (nat_to_binlist' (2 * H + 1) = true :: nat_to_binlist' H)
Crunching: (nat_to_binlist' (2 * H + 1) = true :: nat_to_binlist' H)
Crunching: (nat_to_binlist' (2 * H + 1) = true :: nat_to_binlist' H)
Crunching:
(list_to_funbool n (nat_to_binlist' (binlist_to_nat a)) i =
 list_to_funbool n a i)
Crunching:
((forall r1 r2 r3 : R, r1 < r2 -> r2 < r3 -> r1 < r3) ->
 (forall r1 r2 r3 r4 : R, r1 = r2 -> r2 < r4 -> r4 = r3 -> r1 < r3) ->
 forall x : nat, fst pol (2 ^ pol + x) = S (fst pol x))
Crunching:
(list_to_funbool n (nat_to_binlist' (binlist_to_nat a)) i =
 list_to_funbool n a i)
Crunching:
(list_to_funbool n (nat_to_binlist' (binlist_to_nat a)) i =
 list_to_funbool n a i)
Crunching:
(forall i : nat,
 list_to_funbool n (nat_to_binlist' (binlist_to_nat a)) i =
 list_to_funbool n a i)
rewrite if_dtt
if (proj1_sig k1 + proj1_sig k2 <? n)
then
(fun E : (proj1_sig k1 + proj1_sig k2 <? n) = true =>
 ltN_of_nat (proj1_sig k1 + proj1_sig k2) n E)
else
(fun E : (proj1_sig k1 + proj1_sig k2 <? n) = false =>
 ltN_of_nat (proj1_sig k1 + proj1_sig k2 - n) n (ltN_plus_mod_lemma1 k1 k2 E))
Crunching: (nat_to_binlist' (binlist_to_nat H4) = H4)
Crunching: (nat_to_binlist' (binlist_to_nat a) = a)
Crunching:
(list_to_funbool n (nat_to_binlist' (binlist_to_nat a)) i =
 list_to_funbool n a i)
Crunching:
(list_to_funbool n (nat_to_binlist' (binlist_to_nat a)) i =
 list_to_funbool n a i)
Crunching: (fst pol (2 ^ pol + 0) = S (fst pol 0))
Crunching: (fst pol (2 ^ pol + i) = S (fst pol i))
Crunching: (forall x : nat, fst pol (2 ^ pol + x) = S (fst pol x))
Crunching:
(list_to_funbool n (nat_to_binlist' (binlist_to_nat a)) i =
 list_to_funbool n a i)
Crunching:
(list_to_funbool n (nat_to_binlist' (binlist_to_nat a)) i =
 list_to_funbool n a i)
Crunching:
(forall i : nat,
 list_to_funbool n (nat_to_binlist' (binlist_to_nat a)) i =
 list_to_funbool n a i)
Crunching:
(list_to_funbool n (nat_to_binlist' (binlist_to_nat a)) i =
 list_to_funbool n a i)
out of reach
Tactic call ran for 0.006 secs (0.006u,0.s) (failure)
Crunching:
((forall r1 r2 r3 : R, r1 < r2 -> r2 < r3 -> r1 < r3) ->
 (forall r1 r2 r3 r4 : R, r1 = r2 -> r2 < r4 -> r4 = r3 -> r1 < r3) ->
 forall x : nat, fst pol (2 ^ pol + x) = S (fst pol x))
Crunching:
(list_to_funbool n (nat_to_binlist' (binlist_to_nat a)) i =
 list_to_funbool n a i)
Crunching:
(forall i : nat,
 list_to_funbool n (nat_to_binlist' (binlist_to_nat a)) i =
 list_to_funbool n a i)
Crunching: (Is_true (eqb (list_to_funbool n l m) true))
out of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
Crunching: (fst b Hb = 0%nat)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching: (list_to_funbool m (repeat false m) Hm = false)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching:
(match
   (fix Ffix (x x0 : nat) {struct x0} : nat :=
      match x0 with
      | 0%nat => 1%nat
      | S x1 =>
          (fix Ffix0 (x2 x3 : nat) {struct x2} : nat :=
             match x2 with
             | 0%nat => 0%nat
             | S x4 =>
                 (fix Ffix1 (x5 x6 : nat) {struct x5} : nat :=
                    match x5 with
                    | 0%nat => x6
                    | S x7 => S (Ffix1 x7 x6)
                    end) x3 (Ffix0 x4 x3)
             end) x (Ffix x x1)
      end) 2%nat pol
 with
 | 0%nat =>
     (fix Ffix (x x0 : nat) {struct x0} : nat :=
        match x0 with
        | 0%nat => 1%nat
        | S x1 =>
            (fix Ffix0 (x2 x3 : nat) {struct x2} : nat :=
               match x2 with
               | 0%nat => 0%nat
               | S x4 =>
                   (fix Ffix1 (x5 x6 : nat) {struct x5} : nat :=
                      match x5 with
                      | 0%nat => x6
                      | S x7 => S (Ffix1 x7 x6)
                      end) x3 (Ffix0 x4 x3)
               end) x (Ffix x x1)
        end) 2%nat pol
 | S x =>
     let (H, _) :=
       (fix Ffix (x0 x1 x2 x3 : nat) {struct x0} : nat * nat :=
          match x0 with
          | 0%nat => (x2, x3)
          | S x4 =>
              match x3 with
              | 0%nat => Ffix x4 x1 (S x2) x1
              | S x5 => Ffix x4 x1 x2 x5
              end
          end) P x 0%nat x in
     H
 end = 0%nat)
Crunching: (fst 0 Hb = 0%nat)
Crunching: (fst b Hb = 0%nat)
Crunching: (list_to_funbool m (repeat false m) Hm = false)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
Crunching: (false = true)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching: (false = true)
Crunching: (false = true)
Crunching: (fst a b = 0%nat)
Crunching: Type
Crunching: (list_to_funbool m (repeat false m) Hm = false)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching:
(match
   (fix Ffix (x x0 : nat) {struct x0} : nat :=
      match x0 with
      | 0%nat => 1%nat
      | S x1 =>
          (fix Ffix0 (x2 x3 : nat) {struct x2} : nat :=
             match x2 with
             | 0%nat => 0%nat
             | S x4 =>
                 (fix Ffix1 (x5 x6 : nat) {struct x5} : nat :=
                    match x5 with
                    | 0%nat => x6
                    | S x7 => S (Ffix1 x7 x6)
                    end) x3 (Ffix0 x4 x3)
             end) x (Ffix x x1)
      end) 2%nat pol
 with
 | 0%nat =>
     (fix Ffix (x x0 : nat) {struct x0} : nat :=
        match x0 with
        | 0%nat => 1%nat
        | S x1 =>
            (fix Ffix0 (x2 x3 : nat) {struct x2} : nat :=
               match x2 with
               | 0%nat => 0%nat
               | S x4 =>
                   (fix Ffix1 (x5 x6 : nat) {struct x5} : nat :=
                      match x5 with
                      | 0%nat => x6
                      | S x7 => S (Ffix1 x7 x6)
                      end) x3 (Ffix0 x4 x3)
               end) x (Ffix x x1)
        end) 2%nat pol
 | S x =>
     let (H, _) :=
       (fix Ffix (x0 x1 x2 x3 : nat) {struct x0} : nat * nat :=
          match x0 with
          | 0%nat => (x2, x3)
          | S x4 =>
              match x3 with
              | 0%nat => Ffix x4 x1 (S x2) x1
              | S x5 => Ffix x4 x1 x2 x5
              end
          end) P x 0%nat x in
     H
 end = 0%nat)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (fst 0 Hb = 0%nat)
Crunching: (fst b Hb = 0%nat)
Crunching:
((forall n : nat,
  S n =
  (fix add (n0 m : nat) {struct n0} : nat :=
     match n0 with
     | 0 => m
     | S p => S (add p m)
     end) n 1) ->
 (fix list_to_funbool (len : nat) (l : list bool) {struct l} : nat -> bool :=
    match l with
    | [] => fun _ : nat => false
    | h :: t =>
        fun j : nat =>
        if
         (fix eqb (n m : nat) {struct n} : bool :=
            match n with
            | 0 => match m with
                   | 0 => true
                   | S _ => false
                   end
            | S n' => match m with
                      | 0 => false
                      | S m' => eqb n' m'
                      end
            end) j
           ((fix sub (n m : nat) {struct n} : nat :=
               match n with
               | 0 => n
               | S k => match m with
                        | 0 => n
                        | S l0 => sub k l0
                        end
               end) len 1)
        then h
        else
         list_to_funbool
           ((fix sub (n m : nat) {struct n} : nat :=
               match n with
               | 0 => n
               | S k => match m with
                        | 0 => n
                        | S l0 => sub k l0
                        end
               end) len 1) t j
    end) x
   ((fix repeat (x : bool) (n : nat) {struct n} : list bool :=
       match n with
       | 0 => []
       | S k => x :: repeat x k
       end) false x) He = false)
Crunching: (list_to_funbool p (repeat false p) 0 = false)
Crunching: (false = true)
Crunching: (fst s x = 0%nat)
Crunching: (fst s x = 0%nat)
Crunching: (false = true)
Crunching: (false = true)
Crunching: (false = true)
Crunching: (false = true)
Crunching: (false = true)
Crunching: (false = true)
Crunching: (fst m Hcase = 0%nat)
Crunching: (fst m Hcase = 0%nat)
Crunching: (fst m Hcase = 0%nat)
Crunching: (false = true)
Crunching: (false = true)
Crunching: (false = true)
Crunching: Type
Crunching: (list_to_funbool m (repeat false m) Hm = false)
Crunching: (snd H 0 = 0%nat)
Crunching:
((0 + 1)%R = 1 ->
 (0 + 1)%R = 1 -> Rabs Hincl < Rabs HF -> HF > 0 -> Hincl < HF)
Crunching:
((1 + 0)%R = 1 ->
 (0 + 1)%R = 1 -> Rabs Hincl < Rabs HF -> HF > 0 -> Hincl < HF)
Crunching: (snd H 0 = 0%nat)
Crunching: (q < n -> f q = false)
Crunching: (q i = false)
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 n (ltN_pred_lemma0 k k0 E)))
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 n (ltN_pred_lemma0 k k0 E)))
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 n (ltN_pred_lemma0 k k0 E)))
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 n (ltN_pred_lemma0 k k0 E)))
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 n (ltN_pred_lemma0 k k0 E)))
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 n (ltN_pred_lemma0 k k0 E)))
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 n (ltN_pred_lemma0 k k0 E)))
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 n (ltN_pred_lemma0 k k0 E)))
Crunching: (v < S p -> nat_to_funbool (S p) (funbool_to_nat (S p) c) v = c v)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (snd pol X = X)
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 n (ltN_pred_lemma0 k k0 E)))
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 n (ltN_pred_lemma0 k k0 E)))
Crunching:
((fun i j : nat => if (i =? n) && (j =? 0) then C1 else 0%R) =
 f_to_vec len (nat_to_funbool len n))
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 n (ltN_pred_lemma0 k k0 E)))
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 n (ltN_pred_lemma0 k k0 E)))
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 n (ltN_pred_lemma0 k k0 E)))
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 n (ltN_pred_lemma0 k k0 E)))
Crunching:
(IHP' < 2 ^ p ->
 basis_vector (2 ^ p) IHP' = f_to_vec p (nat_to_funbool p IHP'))
Crunching:
((if (x =? n) && (y =? 0) then C1 else 0%R) =
 f_to_vec len (list_to_funbool len (nat_to_binlist len n)) x y)
Crunching:
((fun i j : nat => if (i =? n) && (j =? 0) then C1 else 0%R) =
 f_to_vec len (nat_to_funbool len n))
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 n (ltN_pred_lemma0 k k0 E)))
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 n (ltN_pred_lemma0 k k0 E)))
Crunching: (forall x y z : nat, x - y <= z -> x - z <= y)
Debug:
In environment
n : int
r_ge0 : 2%:~R <= n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: ba_casoratian n; n%:~R]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          (add
             match match l with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end with
             | [::] => zero
             | x :: _ => x
             end one) zero))" (cannot unify "false" and 
"true").
Debug:
In environment
n : int
r_ge0 : 2%:~R <= n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: ba_casoratian n; n%:~R]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          (add
             match match l with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end with
             | [::] => zero
             | x :: _ => x
             end one) zero))" (cannot unify "false" and 
"true").
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Debug:
In environment
n : int
r_ge0 : 2%:~R <= n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: ba_casoratian n; n%:~R]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          (add
             match match l with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end with
             | [::] => zero
             | x :: _ => x
             end one) zero))" (cannot unify "false" and 
"true").
Crunching: False
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching: False
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching:
(IHP' < 2 ^ p ->
 basis_vector (2 ^ p) IHP' = f_to_vec p (nat_to_funbool p IHP'))
Crunching:
(exists alp : R,
   alp > 0 /\
   (forall x : R,
    D_x no_cond 1 x /\ R_dist x 1 < alp -> R_dist (atan x) (atan 1) < eps))
Crunching: False
Crunching: False
Crunching:
(basis_vector (S (1 - 0) ^ len) n = f_to_vec len (nat_to_funbool len n))
Crunching: (forall x y : nat, (y < 2 ^ n)%nat -> fst n (x * 2 ^ n + y) = x)
Crunching: (forall x y : nat, (y < 2 ^ n)%nat -> fst n (x * 2 ^ n + y) = x)
Crunching: ((E0 < 2 ^ Ha)%nat -> fst Ha (h * 2 ^ Ha + E0) = h)
Crunching:
(WF_Matrix WF ->
 (forall f : nat -> bool, q' × f_to_vec q f = WF × f_to_vec q f) -> q' = WF)
Crunching: (b * a + a * b <= a * a + b * b)
Crunching: ((c < 2 ^ n)%nat -> fst n (a * 2 ^ n + c) = a)
Crunching:
(WF_Matrix WF ->
 (forall f : nat -> bool, q' × f_to_vec q f = WF × f_to_vec q f) -> q' = WF)
Crunching: (snd 0 (x * 2 ^ 0 + y) = y)
Crunching: (b * a + a * b <= a * a + b * b)
Crunching: (snd 0 (x * 2 ^ 0 + y) = y)
Crunching: (b * a + a * b <= a * a + b * b)
Crunching: (snd 0 (x * 2 ^ 0 + y) = y)
Crunching: (snd 0 (x * 2 ^ 0 + y) = y)
Crunching: (b * a + a * b <= a * a + b * b)
Crunching: (snd h (i * S l + l) = l)
zeta_3_irrational : ~ (exists r : rat, (z3 == r%:CR)%CR)

zeta_3_irrational is not universe polymorphic
zeta_3_irrational is opaque
Expands to: Constant mathcomp.apery.z3irrational.zeta_3_irrational
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building ident_interp...
Building base_eq_dec...
Building base_beq_and_reflect...
Building base_beq...
Building reflect_base_beq...
Building baseHasNatAndCorrect...
Building baseHasNat...
Building baseHasNatCorrect...
Building base_interp_beq...
Building reflect_base_interp_beq...
Building try_make_base_transport_cps...
Building try_make_base_transport_cps_correct...
Building all_idents...
Building all_ident_and_interp...
Building buildEagerIdentAndInterpCorrect...
Building buildEagerIdent...
Building buildInterpEagerIdentCorrect...
Building toRestrictedIdentAndCorrect...
Building toRestrictedIdent...
Building toFromRestrictedIdent...
Building buildIdentAndInterpCorrect...
Building buildIdent...
Building buildInterpIdentCorrect...
Building ident_is_var_like...
Building eqv_Reflexive_Proper...
Crunching: (snd 0 (x * 2 ^ 0 + y) = y)
Building ident_interp_Proper...
Building invertIdent...
Building buildInvertIdentCorrect...
Building base_default...
Building package...
Building all_base...
Building all_idents...
Building ident_index...
Building eta_ident_cps_gen...
Building eta_ident_cps_gen_expand_literal...
Building eta_ident_cps...
Building simple_idents...
Building all_raw_idents...
Building raw_ident_index...
Building raw_ident_index_idempotent...
Building eta_raw_ident_cps_gen...
Building raw_ident_to_ident...
Building raw_ident_infos_of...
Building split_raw_ident_gen...
Crunching: (snd n (x * 2 ^ n + y) = y)
Building invert_bind_args...
Crunching: (∣0⟩ = basis_vector 2 0)
Building invert_bind_args_unknown...
Building all_pattern_idents...
Building eta_pattern_ident_cps_gen...
Building eta_pattern_ident_cps_gen_expand_literal...
Building split_types...
Crunching: (snd 0 (x * 2 ^ 0 + y) = y)
Building add_types_from_raw_sig...
Crunching: (snd 0 (x * 2 ^ 0 + y) = y)
Building to_type_split_types_subst_default_eq...
Building projT1_add_types_from_raw_sig_eq...
Crunching: (snd 0 (x * 2 ^ 0 + y) = y)
Crunching: (snd 0 (x * 2 ^ 0 + y) = y)
Crunching: (snd 0 (x * 2 ^ 0 + y) = y)
Building arg_types_unfolded...
Crunching: (snd 0 (x * 2 ^ 0 + y) = y)
Building type_of_list_arg_types_beq_unfolded...
Building to_typed_unfolded...
Building of_typed_ident_unfolded...
Building arg_types_of_typed_ident_unfolded...
Crunching: (snd 0 (x * 2 ^ 0 + y) = y)
Building unify...
Building unify_unknown...
Crunching: (snd 0 (x * 2 ^ 0 + y) = y)
Building final ident package...
Proving is_simple_correct0...
Tactic call ran for 0.605 secs (0.594u,0.009s) (success)
Proving invert_bind_args_raw_to_typed...
Tactic call ran for 0.386 secs (0.376u,0.01s) (success)
Proving fold_invert_bind_args...
Tactic call ran for 0.029 secs (0.029u,0.s) (success)
Proving split_ident_to_ident...
Tactic call ran for 0.023 secs (0.023u,0.s) (success)
Proving eq_indep_types_of_eq_types...
Tactic call ran for 1.16 secs (1.135u,0.023s) (success)
Proving fold_eta_ident_cps...
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving fold_unify...
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving to_typed_of_typed_ident...
Tactic call ran for 1.514 secs (1.496u,0.018s) (success)
Proving eq_invert_bind_args_unknown...
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving eq_unify_unknown...
Tactic call ran for 0. secs (0.u,0.s) (success)
Reifying...
Debug:
In environment
i, j : nat
sRfD : (1 < j)%N
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: b_over_a_seq (i - j + j)%N; b_over_a_seq j;
         \sum_(j <= k < i - j + j)
            6%:~R / (k%:~R + 1) ^ 3 / (a (int.shift 1 k) * a k)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
i, j : nat
sRfD : (1 < j)%N
valq : int * int
i0 : (0 < valq.2) && coprime `|valq.1| `|valq.2|
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: b_over_a_seq (i - j + j)%N; b_over_a_seq j;
         \sum_(j <= k < i - j + j)
            6%:~R / (k%:~R + 1) ^ 3 / (a (int.shift 1 k) * a k)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Closed under the global context
Compiling decision tree...
Splitting rewrite rules...
Assembling rewrite_head...
Reducing rewrite_head...
Tactic call ran for 0.163 secs (0.16u,0.003s) (success)
Tactic call ran for 0.12 secs (0.116u,0.003s) (success)
Tactic call ran for 0.114 secs (0.113u,0.001s) (success)
Crunching: (snd a (b * S c + c) = c)
Assembling rewrite_head_no_dtree...
Reducing rewrite_head_no_dtree...
Crunching: (snd h (i * S l + l) = l)
Proving Rewriter_Wf...
Tactic call ran for 0.089 secs (0.082u,0.007s) (success)
Tactic call ran for 1.016 secs (0.985u,0.03s) (success)
Proving Rewriter_Interp...
Crunching: (snd h l = l)
Tactic call ran for 0.848 secs (0.837u,0.011s) (success)
Crunching: (snd h (i * S l + l) = l)
Tactic call ran for 0.658 secs (0.616u,0.041s) (success)
Assembling verified rewriter...
Refining with verified rewriter...
Finished transaction in 27.114 secs (26.511u,0.57s) (successful)
Debug:
In environment
i, j : nat
S_E : (1 < j)%N
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: b_over_a_seq (i - j + j)%N; b_over_a_seq j;
         \sum_(j <= k < i - j + j)
            6%:~R / (k%:~R + 1) ^ 3 / (a (int.shift 1 k) * a k)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
i, j : nat
S_E : (1 < j)%N
valq : int * int
i0 : (0 < valq.2) && coprime `|valq.1| `|valq.2|
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: b_over_a_seq (i - j + j)%N; b_over_a_seq j;
         \sum_(j <= k < i - j + j)
            6%:~R / (k%:~R + 1) ^ 3 / (a (int.shift 1 k) * a k)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
i, j : nat
sRfD : (1 < j)%N
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: b_over_a_seq (i - j + j)%N; b_over_a_seq j;
         \sum_(j <= k < i - j + j)
            6%:~R / (k%:~R + 1) ^ 3 / (a (int.shift 1 k) * a k)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching:
((cos x)² = (1 - (sin x)²)%R ->
 sum_over_list (scale x l) = (x * sum_over_list l)%R)
Crunching:
((cos x)² = (1 - (sin x)²)%R ->
 sum_over_list (scale x l) = (x * sum_over_list l)%R)
Crunching: (f_to_vec z (shift (update f i b) j) = f_to_vec z (shift f j))
Crunching:
((cos x)² = (1 - (sin x)²)%R ->
 sum_over_list (scale x l) = (x * sum_over_list l)%R)
Debug:
In environment
i, j : nat
p : (1 < j)%N
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: b_over_a_seq (i - j + j)%N; b_over_a_seq j;
         \sum_(j <= k < i - j + j)
            6%:~R / (k%:~R + 1) ^ 3 / (a (int.shift 1 k) * a k)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
i, j : nat
p : (1 < j)%N
valq : int * int
i0 : (0 < valq.2) && coprime `|valq.1| `|valq.2|
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: b_over_a_seq (i - j + j)%N; b_over_a_seq j;
         \sum_(j <= k < i - j + j)
            6%:~R / (k%:~R + 1) ^ 3 / (a (int.shift 1 k) * a k)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching:
(forall (j : nat) (b : bool),
 j + z <= H1 \/ H1 < j ->
 f_to_vec z (shift (update N H1 b) j) = f_to_vec z (shift N j))
out of reach
Tactic call ran for 0.008 secs (0.008u,0.s) (failure)
Crunching: positive
Crunching: positive
Crunching: positive
Debug:
In environment
i, j : nat
S_E : (1 < j)%N
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: b_over_a_seq (i - j + j)%N; b_over_a_seq j;
         \sum_(j <= k < i - j + j)
            6%:~R / (k%:~R + 1) ^ 3 / (a (int.shift 1 k) * a k)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
out of reach
Tactic call ran for 0.006 secs (0.006u,0.s) (failure)
Debug:
In environment
i, j : nat
sRfD : (1 < j)%N
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: b_over_a_seq (i - j + j)%N; b_over_a_seq j;
         \sum_(j <= k < i - j + j)
            6%:~R / (k%:~R + 1) ^ 3 / (a (int.shift 1 k) * a k)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
i, j : nat
sRfD : (1 < j)%N
valq : int * int
i0 : (0 < valq.2) && coprime `|valq.1| `|valq.2|
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: b_over_a_seq (i - j + j)%N; b_over_a_seq j;
         \sum_(j <= k < i - j + j)
            6%:~R / (k%:~R + 1) ^ 3 / (a (int.shift 1 k) * a k)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
out of reach
Tactic call ran for 0.006 secs (0.006u,0.s) (failure)
out of reach
Tactic call ran for 0.006 secs (0.006u,0.s) (failure)
out of reach
Tactic call ran for 0.006 secs (0.006u,0.s) (failure)
Crunching: (f_to_vec z (shift (update f i b) j) = f_to_vec z (shift f j))
Debug:
In environment
i, j : nat
pn : (1 < j)%N
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: b_over_a_seq (i - j + j)%N; b_over_a_seq j;
         \sum_(j <= k < i - j + j)
            6%:~R / (k%:~R + 1) ^ 3 / (a (int.shift 1 k) * a k)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Debug:
In environment
i, j : nat
pn : (1 < j)%N
valq : int * int
i0 : (0 < valq.2) && coprime `|valq.1| `|valq.2|
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: b_over_a_seq (i - j + j)%N; b_over_a_seq j;
         \sum_(j <= k < i - j + j)
            6%:~R / (k%:~R + 1) ^ 3 / (a (int.shift 1 k) * a k)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching:
(forall (j : nat) (b : bool),
 j + z <= H1 \/ H1 < j ->
 f_to_vec z (shift (update N H1 b) j) = f_to_vec z (shift N j))
Crunching:
((cos x)² = (1 - (sin x)²)%R ->
 sum_over_list (scale x l) = (x * sum_over_list l)%R)
out of reach
Tactic call ran for 0.006 secs (0.006u,0.s) (failure)
out of reach
Tactic call ran for 0.006 secs (0.006u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching:
((cos x)² = (1 - (sin x)²)%R ->
 sum_over_list (scale x l) = (x * sum_over_list l)%R)
Crunching: positive
Crunching:
(f_to_vec x (shift (fun j : nat => if j =? H then a0 else y j) H0) =
 f_to_vec x (shift y H0))
out of reach
Tactic call ran for 0.007 secs (0.006u,0.s) (failure)
Crunching: positive
Crunching:
(f_to_vec x (shift (fun j : nat => if j =? H then a0 else y j) H0) =
 f_to_vec x (shift y H0))
Crunching: positive
Crunching:
(f_to_vec x (shift (fun j : nat => if j =? H then a0 else y j) H0) =
 f_to_vec x (shift y H0))
out of reach
Tactic call ran for 0.007 secs (0.007u,0.s) (failure)
Crunching: positive
out of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
Crunching: positive
Crunching: positive
Crunching: positive
Crunching: positive
Crunching: positive
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching: positive
out of reach
Tactic call ran for 0.006 secs (0.006u,0.s) (failure)
Crunching: positive
Crunching: (∣0⟩ = basis_vector 2 0)
out of reach
Tactic call ran for 0.003 secs (0.002u,0.001s) (failure)
Crunching:
(f_to_vec x (shift (fun j : nat => if j =? H then x0 else y j) H0) =
 f_to_vec x (shift y H0))
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching:
((n' < length Hn')%nat ->
 sum_over_list (firstn (S n') Hn') =
 (sum_over_list (firstn n' Hn') + nth n' Hn' 0)%R)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching:
(sum_over_list (firstn (S a0) a') =
 (sum_over_list (firstn a0 a') + nth a0 a' 0)%R)
Crunching:
(sum_over_list (firstn (S a0) a') =
 (sum_over_list (firstn a0 a') + nth a0 a' 0)%R)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching:
(f_to_vec x (shift (fun j : nat => if j =? H then x0 else y j) H0) =
 f_to_vec x (shift y H0))
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching:
((n' < length Hn')%nat ->
 sum_over_list (firstn (S n') Hn') =
 (sum_over_list (firstn n' Hn') + nth n' Hn' 0)%R)
Crunching:
((n' < length Hn')%nat ->
 sum_over_list match Hn' with
               | [] => []
               | a :: l => a :: firstn n' l
               end = (sum_over_list (firstn n' Hn') + nth n' Hn' 0)%R)
Crunching:
(sum_over_list (firstn (S M) l) = (sum_over_list (firstn M l) + nth M l 0)%R)
Crunching: False
Crunching:
(sum_over_list (firstn (S M) l) = (sum_over_list (firstn M l) + nth M l 0)%R)
Crunching:
(sum_over_list (firstn (S a0) a') =
 (sum_over_list (firstn a0 a') + nth a0 a' 0)%R)
Crunching:
(sum_over_list (firstn (S a0) a') =
 (sum_over_list (firstn a0 a') + nth a0 a' 0)%R)
Crunching:
(sum_over_list (firstn (S a0) a') =
 (sum_over_list (firstn a0 a') + nth a0 a' 0)%R)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (Forall (fun x : R => 0 <= x) (scale a []))
Crunching: (Forall (fun x : R => 0 - 0 <= x) (scale a []))
Crunching: (Forall (fun x : R => 0 <= x) (scale a []))
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (Forall (fun x : R => 0 - 0 <= x) (scale a []))
Crunching: (Forall (fun x : R => 0 <= x) (scale a []))
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching:
(forall m n : nat,
 f_to_vec m H4 ⊗ f_to_vec n res =
 f_to_vec (m + n) (fun x : nat => if x <? m then H4 x else res (x - m)))
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching:
(forall n0 : nat,
 (forall m0 : nat,
  m0 < n0 ->
  forall n1 : nat,
  f_to_vec m p ⊗ f_to_vec n1 n =
  f_to_vec (m + n1) (fun x : nat => if x <? m then p x else n (x - m))) ->
 forall n1 : nat,
 f_to_vec m p ⊗ f_to_vec n1 n =
 f_to_vec (m + n1) (fun x : nat => if x <? m then p x else n (x - m)))
Crunching: (Forall (fun x : R => 0 - 0 <= x) (scale a []))
Crunching: (Forall (fun x : R => 0 - 0 <= x) (scale a []))
Crunching: (Forall (fun x : R => 0 <= x) (scale a []))
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching:
(forall m n : nat,
 f_to_vec m H4 ⊗ f_to_vec n res =
 f_to_vec (m + n) (fun x : nat => if x <? m then H4 x else res (x - m)))
Crunching:
(forall m n : nat,
 f_to_vec m H4 ⊗ f_to_vec n res =
 f_to_vec (m + n)
   (fun x : nat =>
    if match m with
       | 0 => false
       | S m' => x <=? m'
       end
    then H4 x
    else res (x - m)))
Crunching:
((f_to_vec x H4 (x0 / 2 ^ l)%nat (y / 1)%nat *
  f_to_vec l e2 (x0 mod 2 ^ l) (y mod 1))%C =
 f_to_vec (x + l) (fun x0 : nat => if x0 <? x then H4 x0 else e2 (x0 - x)) x0
   y)
Crunching: False
Crunching: (∣1⟩ = basis_vector 2 1)
Debug:
In environment
n : int
P1 : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: b' (int.shift 2 n); annotated_recs_c.P_cf0 n; 
        b' n; annotated_recs_c.P_cf1 n; b' (int.shift 1 n);
         annotated_recs_c.P_cf2 n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Debug:
In environment
n : int
hmn : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: b' (int.shift 2 n); annotated_recs_c.P_cf0 n; 
        b' n; annotated_recs_c.P_cf1 n; b' (int.shift 1 n);
         annotated_recs_c.P_cf2 n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Debug:
In environment
n : int
sAD : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: b' (int.shift 2 n); annotated_recs_c.P_cf0 n; 
        b' n; annotated_recs_c.P_cf1 n; b' (int.shift 1 n);
         annotated_recs_c.P_cf2 n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Debug:
In environment
n : int
P1 : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: b' (int.shift 2 n); annotated_recs_c.P_cf0 n; 
        b' n; annotated_recs_c.P_cf1 n; b' (int.shift 1 n);
         annotated_recs_c.P_cf2 n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Debug:
In environment
n : int
hmn : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: b' (int.shift 2 n); annotated_recs_c.P_cf0 n; 
        b' n; annotated_recs_c.P_cf1 n; b' (int.shift 1 n);
         annotated_recs_c.P_cf2 n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Debug:
In environment
n : int
sAD : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: b' (int.shift 2 n); annotated_recs_c.P_cf0 n; 
        b' n; annotated_recs_c.P_cf1 n; b' (int.shift 1 n);
         annotated_recs_c.P_cf2 n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Debug:
In environment
n : int
P1 : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: b' (int.shift 2 n); annotated_recs_c.P_cf0 n; 
        b' n; annotated_recs_c.P_cf1 n; b' (int.shift 1 n);
         annotated_recs_c.P_cf2 n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Debug:
In environment
n : int
Hb : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: b' (int.shift 2 n); annotated_recs_c.P_cf0 n; 
        b' n; annotated_recs_c.P_cf1 n; b' (int.shift 1 n);
         annotated_recs_c.P_cf2 n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Debug:
In environment
n : int
hmn : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: b' (int.shift 2 n); annotated_recs_c.P_cf0 n; 
        b' n; annotated_recs_c.P_cf1 n; b' (int.shift 1 n);
         annotated_recs_c.P_cf2 n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Debug:
In environment
n : int
sAD : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: b' (int.shift 2 n); annotated_recs_c.P_cf0 n; 
        b' n; annotated_recs_c.P_cf1 n; b' (int.shift 1 n);
         annotated_recs_c.P_cf2 n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Debug:
In environment
n : int
i : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: b' (int.shift 2 n); annotated_recs_c.P_cf0 n; 
        b' n; annotated_recs_c.P_cf1 n; b' (int.shift 1 n);
         annotated_recs_c.P_cf2 n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Debug:
In environment
n : int
P1 : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: b' (int.shift 2 n); annotated_recs_c.P_cf0 n; 
        b' n; annotated_recs_c.P_cf1 n; b' (int.shift 1 n);
         annotated_recs_c.P_cf2 n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Debug:
In environment
n : int
p : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: b' (int.shift 2 n); annotated_recs_c.P_cf0 n; 
        b' n; annotated_recs_c.P_cf1 n; b' (int.shift 1 n);
         annotated_recs_c.P_cf2 n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Debug:
In environment
n : int
Hb : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: b' (int.shift 2 n); annotated_recs_c.P_cf0 n; 
        b' n; annotated_recs_c.P_cf1 n; b' (int.shift 1 n);
         annotated_recs_c.P_cf2 n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Debug:
In environment
n : int
hmn : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: b' (int.shift 2 n); annotated_recs_c.P_cf0 n; 
        b' n; annotated_recs_c.P_cf1 n; b' (int.shift 1 n);
         annotated_recs_c.P_cf2 n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Crunching:
(Forall (fun x : R => R0 < x \/ R0 = x)
   ((fix join' (l1 : list R) (l2 : nat -> list R) (n : nat) {struct n} :
         list R :=
       match n with
       | 0%nat => []
       | S n' =>
           (fix app (l m : list R) {struct l} : list R :=
              match l with
              | [] => m
              | a :: l3 => a :: app l3 m
              end) (join' l1 l2 n')
             ((fix scale (r : R) (l : list R) {struct l} : list R :=
                 match l with
                 | [] => []
                 | h :: t => (r * h)%R :: scale r t
                 end)
                ((fix nth (n0 : nat) (l : list R) (default : R) {struct l} :
                      R :=
                    match n0 with
                    | 0%nat => match l with
                               | [] => default
                               | x :: _ => x
                               end
                    | S m =>
                        match l with
                        | [] => default
                        | _ :: t => nth m t default
                        end
                    end) n' l1 R0) (l2 n'))
       end) H'2 l2
      ((fix length (l : list R) : nat :=
          match l with
          | [] => 0%nat
          | _ :: l' => S (length l')
          end) H'2)))
Debug:
In environment
n : int
sAD : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: b' (int.shift 2 n); annotated_recs_c.P_cf0 n; 
        b' n; annotated_recs_c.P_cf1 n; b' (int.shift 1 n);
         annotated_recs_c.P_cf2 n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Crunching:
(forall m n : nat,
 f_to_vec m H4 ⊗ f_to_vec n res =
 f_to_vec (m + n) (fun x : nat => if x <? m then H4 x else res (x - m)))
Debug:
In environment
n : int
i : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: b' (int.shift 2 n); annotated_recs_c.P_cf0 n; 
        b' n; annotated_recs_c.P_cf1 n; b' (int.shift 1 n);
         annotated_recs_c.P_cf2 n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Crunching:
(Forall (fun x : R => R0 < x \/ R0 = x)
   ((fix join' (l1 : list R) (l2 : nat -> list R) (n : nat) {struct n} :
         list R :=
       match n with
       | 0%nat => []
       | S n' =>
           (fix app (l m : list R) {struct l} : list R :=
              match l with
              | [] => m
              | a :: l3 => a :: app l3 m
              end) (join' l1 l2 n')
             ((fix scale (r : R) (l : list R) {struct l} : list R :=
                 match l with
                 | [] => []
                 | h :: t => (r * h)%R :: scale r t
                 end)
                ((fix nth (n0 : nat) (l : list R) (default : R) {struct l} :
                      R :=
                    match n0 with
                    | 0%nat => match l with
                               | [] => default
                               | x :: _ => x
                               end
                    | S m =>
                        match l with
                        | [] => default
                        | _ :: t => nth m t default
                        end
                    end) n' l1 R0) (l2 n'))
       end) H'2 l2
      ((fix length (l : list R) : nat :=
          match l with
          | [] => 0%nat
          | _ :: l' => S (length l')
          end) H'2)))
Crunching: (Forall (fun x : R => 0 <= x) (join H'2 H1))
Debug:
In environment
n : int
P1 : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: b' (int.shift 2 n); annotated_recs_c.P_cf0 n; 
        b' n; annotated_recs_c.P_cf1 n; b' (int.shift 1 n);
         annotated_recs_c.P_cf2 n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Crunching: (Forall (fun x : R => 0 <= x) (join x H))
Crunching: (Forall (fun x : R => 0 <= x) (join x H))
Debug:
In environment
n : int
p : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: b' (int.shift 2 n); annotated_recs_c.P_cf0 n; 
        b' n; annotated_recs_c.P_cf1 n; b' (int.shift 1 n);
         annotated_recs_c.P_cf2 n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Debug:
In environment
n : int
Hb : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: b' (int.shift 2 n); annotated_recs_c.P_cf0 n; 
        b' n; annotated_recs_c.P_cf1 n; b' (int.shift 1 n);
         annotated_recs_c.P_cf2 n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Debug:
In environment
n : int
hmn : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: b' (int.shift 2 n); annotated_recs_c.P_cf0 n; 
        b' n; annotated_recs_c.P_cf1 n; b' (int.shift 1 n);
         annotated_recs_c.P_cf2 n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Crunching: (Forall (fun x : R => 0 <= x) (join x H))
Crunching: (∣0⟩ = basis_vector 2 0)
Debug:
In environment
n : int
sAD : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: b' (int.shift 2 n); annotated_recs_c.P_cf0 n; 
        b' n; annotated_recs_c.P_cf1 n; b' (int.shift 1 n);
         annotated_recs_c.P_cf2 n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Crunching:
(Forall (fun x : R => R0 < x \/ R0 = x)
   ((fix join' (l1 : list R) (l2 : nat -> list R) (n : nat) {struct n} :
         list R :=
       match n with
       | 0%nat => []
       | S n' =>
           (fix app (l m : list R) {struct l} : list R :=
              match l with
              | [] => m
              | a :: l3 => a :: app l3 m
              end) (join' l1 l2 n')
             ((fix scale (r : R) (l : list R) {struct l} : list R :=
                 match l with
                 | [] => []
                 | h :: t => (r * h)%R :: scale r t
                 end)
                ((fix nth (n0 : nat) (l : list R) (default : R) {struct l} :
                      R :=
                    match n0 with
                    | 0%nat => match l with
                               | [] => default
                               | x :: _ => x
                               end
                    | S m =>
                        match l with
                        | [] => default
                        | _ :: t => nth m t default
                        end
                    end) n' l1 R0) (l2 n'))
       end) H'2 l2
      ((fix length (l : list R) : nat :=
          match l with
          | [] => 0%nat
          | _ :: l' => S (length l')
          end) H'2)))
Crunching:
(Forall (fun x : R => R0 < x \/ R0 = x)
   ((fix join' (l1 : list R) (l2 : nat -> list R) (n : nat) {struct n} :
         list R :=
       match n with
       | 0%nat => []
       | S n' =>
           (fix app (l m : list R) {struct l} : list R :=
              match l with
              | [] => m
              | a :: l3 => a :: app l3 m
              end) (join' l1 l2 n')
             ((fix scale (r : R) (l : list R) {struct l} : list R :=
                 match l with
                 | [] => []
                 | h :: t => (r * h)%R :: scale r t
                 end)
                ((fix nth (n0 : nat) (l : list R) (default : R) {struct l} :
                      R :=
                    match n0 with
                    | 0%nat => match l with
                               | [] => default
                               | x :: _ => x
                               end
                    | S m =>
                        match l with
                        | [] => default
                        | _ :: t => nth m t default
                        end
                    end) n' l1 R0) (l2 n'))
       end) H'2 l2
      ((fix length (l : list R) : nat :=
          match l with
          | [] => 0%nat
          | _ :: l' => S (length l')
          end) H'2)))
Debug:
In environment
n : int
i : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: b' (int.shift 2 n); annotated_recs_c.P_cf0 n; 
        b' n; annotated_recs_c.P_cf1 n; b' (int.shift 1 n);
         annotated_recs_c.P_cf2 n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Crunching: (exp 1 <> 0)
Debug:
In environment
n : int
P1 : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: b' (int.shift 2 n); annotated_recs_c.P_cf0 n; 
        b' n; annotated_recs_c.P_cf1 n; b' (int.shift 1 n);
         annotated_recs_c.P_cf2 n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Debug:
In environment
n : int
p : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: b' (int.shift 2 n); annotated_recs_c.P_cf0 n; 
        b' n; annotated_recs_c.P_cf1 n; b' (int.shift 1 n);
         annotated_recs_c.P_cf2 n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Debug:
In environment
n : int
Hb : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: b' (int.shift 2 n); annotated_recs_c.P_cf0 n; 
        b' n; annotated_recs_c.P_cf1 n; b' (int.shift 1 n);
         annotated_recs_c.P_cf2 n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Debug:
In environment
n : int
hmn : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: b' (int.shift 2 n); annotated_recs_c.P_cf0 n; 
        b' n; annotated_recs_c.P_cf1 n; b' (int.shift 1 n);
         annotated_recs_c.P_cf2 n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Crunching:
(Forall (fun x : R => 0 <= x) H'2 ->
 (forall i : nat, (i < length H'2)%nat -> Forall (fun x : R => 0 <= x) (WF i)) ->
 Forall (fun x : R => 0 <= x) (join H'2 WF))
Debug:
In environment
n : int
pAI : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: b' (int.shift 2 n); annotated_recs_c.P_cf0 n; 
        b' n; annotated_recs_c.P_cf1 n; b' (int.shift 1 n);
         annotated_recs_c.P_cf2 n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Debug:
In environment
n : int
sAD : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: b' (int.shift 2 n); annotated_recs_c.P_cf0 n; 
        b' n; annotated_recs_c.P_cf1 n; b' (int.shift 1 n);
         annotated_recs_c.P_cf2 n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Crunching: (Forall (fun x : R => 0 <= x) (join H'2 Hr1))
Crunching: (Forall (fun x : R => 0 <= x) (join H'2 Hr1))
Crunching:
(Forall (fun x : R => R0 < x \/ R0 = x)
   ((fix join' (l1 : list R) (l2 : nat -> list R) (n : nat) {struct n} :
         list R :=
       match n with
       | 0%nat => []
       | S n' =>
           (fix app (l m : list R) {struct l} : list R :=
              match l with
              | [] => m
              | a :: l3 => a :: app l3 m
              end) (join' l1 l2 n')
             ((fix scale (r : R) (l : list R) {struct l} : list R :=
                 match l with
                 | [] => []
                 | h :: t => (r * h)%R :: scale r t
                 end)
                ((fix nth (n0 : nat) (l : list R) (default : R) {struct l} :
                      R :=
                    match n0 with
                    | 0%nat => match l with
                               | [] => default
                               | x :: _ => x
                               end
                    | S m =>
                        match l with
                        | [] => default
                        | _ :: t => nth m t default
                        end
                    end) n' l1 R0) (l2 n'))
       end) H'2 l2
      ((fix length (l : list R) : nat :=
          match l with
          | [] => 0%nat
          | _ :: l' => S (length l')
          end) H'2)))
Crunching:
(Forall (fun x : R => R0 < x \/ R0 = x)
   ((fix join' (l1 : list R) (l2 : nat -> list R) (n : nat) {struct n} :
         list R :=
       match n with
       | 0%nat => []
       | S n' =>
           (fix app (l m : list R) {struct l} : list R :=
              match l with
              | [] => m
              | a :: l3 => a :: app l3 m
              end) (join' l1 l2 n')
             ((fix scale (r : R) (l : list R) {struct l} : list R :=
                 match l with
                 | [] => []
                 | h :: t => (r * h)%R :: scale r t
                 end)
                ((fix nth (n0 : nat) (l : list R) (default : R) {struct l} :
                      R :=
                    match n0 with
                    | 0%nat => match l with
                               | [] => default
                               | x :: _ => x
                               end
                    | S m =>
                        match l with
                        | [] => default
                        | _ :: t => nth m t default
                        end
                    end) n' l1 R0) (l2 n'))
       end) H'2 l2
      ((fix length (l : list R) : nat :=
          match l with
          | [] => 0%nat
          | _ :: l' => S (length l')
          end) H'2)))
Debug:
In environment
n : int
i : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: b' (int.shift 2 n); annotated_recs_c.P_cf0 n; 
        b' n; annotated_recs_c.P_cf1 n; b' (int.shift 1 n);
         annotated_recs_c.P_cf2 n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Crunching: (Forall (fun x : R => 0 <= x) (join H'2 H1))
Crunching: (Forall (fun x : R => 0 <= x) (join x H))
Crunching: (pad_u n i σx × f_to_vec n f = f_to_vec n (update f i (¬ f i)))
Debug:
In environment
n : int
P1 : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: b' (int.shift 2 n); annotated_recs_c.P_cf0 n; 
        b' n; annotated_recs_c.P_cf1 n; b' (int.shift 1 n);
         annotated_recs_c.P_cf2 n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Finished transaction in 89.447 secs (88.901u,0.48s) (successful)
Crunching: (Forall (fun x : R => 0 <= x) (join x H))
Debug:
In environment
n : int
p : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: b' (int.shift 2 n); annotated_recs_c.P_cf0 n; 
        b' n; annotated_recs_c.P_cf1 n; b' (int.shift 1 n);
         annotated_recs_c.P_cf2 n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Debug:
In environment
n : int
Hb : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: b' (int.shift 2 n); annotated_recs_c.P_cf0 n; 
        b' n; annotated_recs_c.P_cf1 n; b' (int.shift 1 n);
         annotated_recs_c.P_cf2 n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Crunching: (Forall (fun x : R => 0 <= x) (join x H))
Debug:
In environment
n : int
hmn : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: b' (int.shift 2 n); annotated_recs_c.P_cf0 n; 
        b' n; annotated_recs_c.P_cf1 n; b' (int.shift 1 n);
         annotated_recs_c.P_cf2 n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Crunching: (Forall (fun x : R => 0 <= x) (join x H))
Crunching:
(pad_u (S x) x σx × f_to_vec (S x) H = f_to_vec (S x) (update H x (¬ H x)))
Debug:
In environment
n : int
pAI : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: b' (int.shift 2 n); annotated_recs_c.P_cf0 n; 
        b' n; annotated_recs_c.P_cf1 n; b' (int.shift 1 n);
         annotated_recs_c.P_cf2 n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Debug:
In environment
n : int
sAD : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: b' (int.shift 2 n); annotated_recs_c.P_cf0 n; 
        b' n; annotated_recs_c.P_cf1 n; b' (int.shift 1 n);
         annotated_recs_c.P_cf2 n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Crunching:
(Forall (fun x : R => 0 <= x) H ->
 (forall i : nat, (i < length H)%nat -> Forall (fun x : R => 0 <= x) (xxh i)) ->
 Forall (fun x : R => 0 <= x) (join H xxh))
Crunching: (pad_u l x σx × f_to_vec l f = f_to_vec l (update f x (¬ f x)))
Crunching: (∣0⟩ = basis_vector 2 0)
Debug:
In environment
n : int
i : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: b' (int.shift 2 n); annotated_recs_c.P_cf0 n; 
        b' n; annotated_recs_c.P_cf1 n; b' (int.shift 1 n);
         annotated_recs_c.P_cf2 n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Crunching:
(pad_u l x σx × f_to_vec l H13 = f_to_vec l (update H13 x (¬ H13 x)))
Crunching:
(pad_u l x σx × f_to_vec l H13 = f_to_vec l (update H13 x (¬ H13 x)))
Debug:
In environment
n : int
P1 : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: b' (int.shift 2 n); annotated_recs_c.P_cf0 n; 
        b' n; annotated_recs_c.P_cf1 n; b' (int.shift 1 n);
         annotated_recs_c.P_cf2 n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Crunching:
(Forall (fun x : R => R0 < x \/ R0 = x)
   ((fix join' (l1 : list R) (l2 : nat -> list R) (n : nat) {struct n} :
         list R :=
       match n with
       | 0%nat => []
       | S n' =>
           (fix app (l m : list R) {struct l} : list R :=
              match l with
              | [] => m
              | a :: l3 => a :: app l3 m
              end) (join' l1 l2 n')
             ((fix scale (r : R) (l : list R) {struct l} : list R :=
                 match l with
                 | [] => []
                 | h :: t => (r * h)%R :: scale r t
                 end)
                ((fix nth (n0 : nat) (l : list R) (default : R) {struct l} :
                      R :=
                    match n0 with
                    | 0%nat => match l with
                               | [] => default
                               | x :: _ => x
                               end
                    | S m =>
                        match l with
                        | [] => default
                        | _ :: t => nth m t default
                        end
                    end) n' l1 R0) (l2 n'))
       end) H'2 l2
      ((fix length (l : list R) : nat :=
          match l with
          | [] => 0%nat
          | _ :: l' => S (length l')
          end) H'2)))
Crunching:
(Forall (fun x : R => R0 < x \/ R0 = x)
   ((fix join' (l1 : list R) (l2 : nat -> list R) (n : nat) {struct n} :
         list R :=
       match n with
       | 0%nat => []
       | S n' =>
           (fix app (l m : list R) {struct l} : list R :=
              match l with
              | [] => m
              | a :: l3 => a :: app l3 m
              end) (join' l1 l2 n')
             ((fix scale (r : R) (l : list R) {struct l} : list R :=
                 match l with
                 | [] => []
                 | h :: t => (r * h)%R :: scale r t
                 end)
                ((fix nth (n0 : nat) (l : list R) (default : R) {struct l} :
                      R :=
                    match n0 with
                    | 0%nat => match l with
                               | [] => default
                               | x :: _ => x
                               end
                    | S m =>
                        match l with
                        | [] => default
                        | _ :: t => nth m t default
                        end
                    end) n' l1 R0) (l2 n'))
       end) H'2 l2
      ((fix length (l : list R) : nat :=
          match l with
          | [] => 0%nat
          | _ :: l' => S (length l')
          end) H'2)))
Crunching:
(Forall (fun x : R => R0 < x \/ R0 = x)
   ((fix join' (l1 : list R) (l2 : nat -> list R) (n : nat) {struct n} :
         list R :=
       match n with
       | 0%nat => []
       | S n' =>
           (fix app (l m : list R) {struct l} : list R :=
              match l with
              | [] => m
              | a :: l3 => a :: app l3 m
              end) (join' l1 l2 n')
             ((fix scale (r : R) (l : list R) {struct l} : list R :=
                 match l with
                 | [] => []
                 | h :: t => (r * h)%R :: scale r t
                 end)
                ((fix nth (n0 : nat) (l : list R) (default : R) {struct l} :
                      R :=
                    match n0 with
                    | 0%nat => match l with
                               | [] => default
                               | x :: _ => x
                               end
                    | S m =>
                        match l with
                        | [] => default
                        | _ :: t => nth m t default
                        end
                    end) n' l1 R0) (l2 n'))
       end) H'2 l2
      ((fix length (l : list R) : nat :=
          match l with
          | [] => 0%nat
          | _ :: l' => S (length l')
          end) H'2)))
Crunching: (pad_u n i σx × f_to_vec n f = f_to_vec n (update f i (¬ f i)))
Debug:
In environment
n : int
p : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: b' (int.shift 2 n); annotated_recs_c.P_cf0 n; 
        b' n; annotated_recs_c.P_cf1 n; b' (int.shift 1 n);
         annotated_recs_c.P_cf2 n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Crunching: (pad_u n i σx × f_to_vec n f = f_to_vec n (update f i (¬ f i)))
Debug:
In environment
n : int
Hb : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: b' (int.shift 2 n); annotated_recs_c.P_cf0 n; 
        b' n; annotated_recs_c.P_cf1 n; b' (int.shift 1 n);
         annotated_recs_c.P_cf2 n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Crunching: (exp 1 <> 0)
Debug:
In environment
n : int
hmn : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: b' (int.shift 2 n); annotated_recs_c.P_cf0 n; 
        b' n; annotated_recs_c.P_cf1 n; b' (int.shift 1 n);
         annotated_recs_c.P_cf2 n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Crunching: False
Crunching: False
Crunching: False
Finished transaction in 20.769 secs (20.412u,0.342s) (successful)
Crunching:
(Forall (fun x : R => 0 <= x) H'2 ->
 (forall i : nat, (i < length H'2)%nat -> Forall (fun x : R => 0 <= x) (WF i)) ->
 Forall (fun x : R => 0 <= x) (join H'2 WF))
Crunching: (distribution (join n f))
Crunching: (distribution (join n f))
Crunching: (distribution (join n f))
Crunching: (distribution (join n f))
Crunching: (distribution (join n f))
Crunching: (distribution (join n f))
Crunching:
(Forall (fun x : R => R0 < x \/ R0 = x)
   ((fix join' (l1 : list R) (l2 : nat -> list R) (n : nat) {struct n} :
         list R :=
       match n with
       | 0%nat => []
       | S n' =>
           (fix app (l m : list R) {struct l} : list R :=
              match l with
              | [] => m
              | a :: l3 => a :: app l3 m
              end) (join' l1 l2 n')
             ((fix scale (r : R) (l : list R) {struct l} : list R :=
                 match l with
                 | [] => []
                 | h :: t => (r * h)%R :: scale r t
                 end)
                ((fix nth (n0 : nat) (l : list R) (default : R) {struct l} :
                      R :=
                    match n0 with
                    | 0%nat => match l with
                               | [] => default
                               | x :: _ => x
                               end
                    | S m =>
                        match l with
                        | [] => default
                        | _ :: t => nth m t default
                        end
                    end) n' l1 R0) (l2 n'))
       end) x y
      ((fix length (l : list R) : nat :=
          match l with
          | [] => 0%nat
          | _ :: l' => S (length l')
          end) x)) /\
 (fix big_sum (G : Type) (H : Monoid G) (f : nat -> G) (n : nat) {struct n} :
      G :=
    match n with
    | 0%nat => let (Gzero, Gplus, _, _, _) := H in Gzero
    | S n' =>
        (let (Gzero, Gplus, _, _, _) := H in Gplus) (big_sum G H f n') (f n')
    end) R
   {|
     Gzero := R0;
     Gplus := Rplus;
     Gplus_0_l :=
       fun g : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEc (RMicromega.CZ 0)) (EnvRing.PEX 1);
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs := EnvRing.PEX 1
            |} ()) [] eq_refl (fun _ : positive => g);
     Gplus_0_r :=
       fun g : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEc (RMicromega.CZ 0));
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs := EnvRing.PEX 1
            |} ()) [] eq_refl (fun _ : positive => g);
     Gplus_assoc :=
       fun g h i : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEX 1)
                  (EnvRing.PEadd (EnvRing.PEX 2) (EnvRing.PEX 3));
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs :=
                EnvRing.PEadd (EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEX 2))
                  (EnvRing.PEX 3)
            |} ()) [] eq_refl
         (fun p : positive =>
          match p with
          | (_~1)%positive => i
          | (_~0)%positive => h
          | 1%positive => g
          end)
   |}
   (fun i : nat =>
    (fix nth (n : nat) (l : list R) (default : R) {struct l} : R :=
       match n with
       | 0%nat => match l with
                  | [] => default
                  | x :: _ => x
                  end
       | S m => match l with
                | [] => default
                | _ :: t => nth m t default
                end
       end) i
      ((fix join' (l1 : list R) (l2 : nat -> list R) (n : nat) {struct n} :
            list R :=
          match n with
          | 0%nat => []
          | S n' =>
              (fix app (l m : list R) {struct l} : list R :=
                 match l with
                 | [] => m
                 | a :: l3 => a :: app l3 m
                 end) (join' l1 l2 n')
                ((fix scale (r : R) (l : list R) {struct l} : list R :=
                    match l with
                    | [] => []
                    | h :: t => (r * h)%R :: scale r t
                    end)
                   ((fix nth
                       (n0 : nat) (l : list R) (default : R) {struct l} :
                         R :=
                       match n0 with
                       | 0%nat =>
                           match l with
                           | [] => default
                           | x :: _ => x
                           end
                       | S m =>
                           match l with
                           | [] => default
                           | _ :: t => nth m t default
                           end
                       end) n' l1 R0) (l2 n'))
          end) x y
         ((fix length (l : list R) : nat :=
             match l with
             | [] => 0%nat
             | _ :: l' => S (length l')
             end) x)) R0)
   ((fix length (l : list R) : nat :=
       match l with
       | [] => 0%nat
       | _ :: l' => S (length l')
       end)
      ((fix join' (l1 : list R) (l2 : nat -> list R) (n : nat) {struct n} :
            list R :=
          match n with
          | 0%nat => []
          | S n' =>
              (fix app (l m : list R) {struct l} : list R :=
                 match l with
                 | [] => m
                 | a :: l3 => a :: app l3 m
                 end) (join' l1 l2 n')
                ((fix scale (r : R) (l : list R) {struct l} : list R :=
                    match l with
                    | [] => []
                    | h :: t => (r * h)%R :: scale r t
                    end)
                   ((fix nth
                       (n0 : nat) (l : list R) (default : R) {struct l} :
                         R :=
                       match n0 with
                       | 0%nat =>
                           match l with
                           | [] => default
                           | x :: _ => x
                           end
                       | S m =>
                           match l with
                           | [] => default
                           | _ :: t => nth m t default
                           end
                       end) n' l1 R0) (l2 n'))
          end) x y
         ((fix length (l : list R) : nat :=
             match l with
             | [] => 0%nat
             | _ :: l' => S (length l')
             end) x))) = R1)
Crunching:
(pad_ctrl n i j σx × f_to_vec n f = f_to_vec n (update f j (f j ⊕ f i)))
Crunching:
(pad_ctrl n i j σx × f_to_vec n f = f_to_vec n (update f j (f j ⊕ f i)))
Crunching:
(1 > 0 /\
 (forall x : Base R_met,
  D_x no_cond n x /\ dist R_met x n < 1 -> dist R_met (id x) (id n) < m))
Crunching: (distribution (join n f))
Crunching: (distribution (join n f))
Crunching: (distribution (join n f))
Crunching: (distribution (join n f))
Crunching: (distribution (join n f))
Crunching:
(Forall (fun x : R => 0 <= x) (join [] x) /\ sum_over_list (join [] x) = 1)
Crunching:
(Forall (fun x : R => 0 <= x) (join [] x) /\ sum_over_list (join [] x) = 1)
Crunching:
(pad_ctrl H3 i j σx × f_to_vec H3 f = f_to_vec H3 (update f j (f j ⊕ f i)))
Crunching:
(pad_ctrl H3 i j σx × f_to_vec H3 f = f_to_vec H3 (update f j (f j ⊕ f i)))
Crunching:
(Az < env ->
 k <> Az ->
 pad_ctrl env k Az σx × f_to_vec env RS =
 f_to_vec env (update RS Az (RS Az ⊕ RS k)))
Crunching:
(a < env ->
 k <> a ->
 pad_ctrl env k a σx × f_to_vec env b = f_to_vec env (update b a (b a ⊕ b k)))
Crunching:
(pad_ctrl n m Hm σx × f_to_vec n H = f_to_vec n (update H Hm (H Hm ⊕ H m)))
Crunching:
(pad_ctrl 0 m Hm σx × f_to_vec 0 H = f_to_vec 0 (update H Hm (H Hm ⊕ H m)))
Crunching:
(pad_ctrl n m Hm σx × f_to_vec n H = f_to_vec n (update H Hm (H Hm ⊕ H m)))
Crunching:
(forall (l1 : list R) (l2 : nat -> list R),
 join (m :: l1) l2 = scale m (l2 0%nat) ++ join l1 (shift l2 1))
Crunching: (join [x] l2 = scale x (l2 0%nat) ++ join [] (shift l2 1))
Crunching:
(pad_ctrl n m Hm σx × f_to_vec n H = f_to_vec n (update H Hm (H Hm ⊕ H m)))
Crunching:
(pad_ctrl 0 m Hm σx × f_to_vec 0 H = f_to_vec 0 (update H Hm (H Hm ⊕ H m)))
Crunching: (join [x] l2 = scale x (l2 0%nat) ++ join [] (shift l2 1))
Crunching:
(forall l2 : nat -> list R,
 join (n :: H4) l2 = scale n (l2 0%nat) ++ join H4 (shift l2 1))
Crunching:
(forall (l1 : list R) (l2 : nat -> list R),
 join (m :: l1) l2 = scale m (l2 0%nat) ++ join l1 (shift l2 1))
Crunching: (join [x] l2 = scale x (l2 0%nat) ++ join [] (shift l2 1))
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (pad_swap n i j × f_to_vec n f = f_to_vec n (fswap f i j))
Crunching:
(Forall (fun x : R => 0 <= x) l ->
 (forall k : nat, length (f k) = (2 ^ HlHr)%nat) ->
 (forall k : nat, (k < length l)%nat -> distribution (f k)) ->
 fst HlHr (sample (join l f) r) = sample l r)
rewrite if_dtt
if (proj1_sig y <? proj1_sig x)
then
(fun E1 : (proj1_sig y <? proj1_sig x) = true =>
 ltN_of_nat (proj1_sig y) (S n) (ltN_intro_lemma1 n x y E1))
else
(fun E1 : (proj1_sig y <? proj1_sig x) = false =>
 ltN_of_nat (S (proj1_sig y)) (S n) (ltN_intro_lemma2 n x y E1))
Crunching:
(forall (n i : nat) (θ : R) (f : nat -> bool),
 i < n ->
 pad_u n i (phase_shift θ) × f_to_vec n f = Cexp (f i * θ) .* f_to_vec n f)
Crunching:
(pad_u n i (phase_shift θ) × f_to_vec n f = Cexp (f i * θ) .* f_to_vec n f)
rewrite if_dtt
if (proj1_sig y <? proj1_sig x)
then
(fun E1 : (proj1_sig y <? proj1_sig x) = true =>
 ltN_of_nat (proj1_sig y) (S n) (ltN_intro_lemma1 n x y E1))
else
(fun E1 : (proj1_sig y <? proj1_sig x) = false =>
 ltN_of_nat (S (proj1_sig y)) (S n) (ltN_intro_lemma2 n x y E1))
Crunching:
(pad_u n Eqf (phase_shift Lef) × f_to_vec n x =
 Cexp (x Eqf * Lef) .* f_to_vec n x)
Crunching:
(pad_u n m (phase_shift H) × f_to_vec n f = Cexp (f m * H) .* f_to_vec n f)
Crunching:
(pad_u P l (phase_shift θ) × f_to_vec P f = Cexp (f l * θ) .* f_to_vec P f)
rewrite if_dtt
if (proj1_sig y <? proj1_sig x)
then
(fun E1 : (proj1_sig y <? proj1_sig x) = true =>
 ltN_of_nat (proj1_sig y) (S n) (ltN_intro_lemma1 n x y E1))
else
(fun E1 : (proj1_sig y <? proj1_sig x) = false =>
 ltN_of_nat (S (proj1_sig y)) (S n) (ltN_intro_lemma2 n x y E1))
Crunching:
(pad_u P l (phase_shift p0) × f_to_vec P f = Cexp (f l * p0) .* f_to_vec P f)
rewrite if_dtt
if (proj1_sig y <? proj1_sig x)
then
(fun E1 : (proj1_sig y <? proj1_sig x) = true =>
 ltN_of_nat (proj1_sig y) (S n) (ltN_intro_lemma1 n x y E1))
else
(fun E1 : (proj1_sig y <? proj1_sig x) = false =>
 ltN_of_nat (S (proj1_sig y)) (S n) (ltN_intro_lemma2 n x y E1))
Crunching:
(pad_u n IH (phase_shift θ) × f_to_vec n f = Cexp (f IH * θ) .* f_to_vec n f)
Crunching:
(forall f : nat -> bool,
 IH < 0 ->
 pad_u 0 IH (phase_shift Eq0) × f_to_vec 0 f =
 Cexp (f IH * Eq0) .* f_to_vec 0 f)
Crunching:
(pad_u n IH (phase_shift m) × f_to_vec n H1 =
 Cexp (H1 IH * m) .* f_to_vec n H1)
Crunching:
(forall rnd : R,
 a > 0 ->
 (if Rlt_le_dec rnd (a * a0)
  then 0%nat
  else S (sample (scale a l) (rnd - a * a0))) =
 (if Rlt_le_dec (rnd / a) a0 then 0%nat else S (sample l (rnd / a - a0))))
Crunching:
(forall (n i : nat) (θ : R) (f : nat -> bool),
 i < n ->
 pad_u n i (phase_shift θ) × f_to_vec n f = Cexp (f i * θ) .* f_to_vec n f)
Crunching:
(pad_u n i (phase_shift θ) × f_to_vec n f = Cexp (f i * θ) .* f_to_vec n f)
Debug:
In environment
n : int
sHG : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_v.P_horner b' n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
sHG : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_v.P_horner b' n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching:
(forall rnd : R, a > 0 -> sample (scale a l) rnd = sample l (rnd * / a))
Debug:
In environment
n : int
sHG : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_v.P_horner b' n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
sHG : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_v.P_horner b' n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching:
(Σ (fun y0 : nat => (pad_u n i (phase_shift θ) x y0 * f_to_vec n f y0 y)%C)
   (2 ^ n) = (Cexp (f i * θ) * f_to_vec n f x y)%C)
Crunching:
(Σ (fun y0 : nat => (pad_u n i (phase_shift θ) x y0 * f_to_vec n f y0 y)%C)
   (2 ^ n) = (Cexp (f i * θ) * f_to_vec n f x y)%C)
rewrite if_dtt
if (proj1_sig y <? proj1_sig x)
then
(fun E1 : (proj1_sig y <? proj1_sig x) = true =>
 ltN_of_nat (proj1_sig y) (S n) (ltN_intro_lemma1 n x y E1))
else
(fun E1 : (proj1_sig y <? proj1_sig x) = false =>
 ltN_of_nat (S (proj1_sig y)) (S n) (ltN_intro_lemma2 n x y E1))
Debug:
In environment
n : int
Hq1 : is_true ((0 <= n) == true)
valq : int * int
i : is_true ((0 < valq.2) && coprime `|valq.1| `|valq.2|)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_v.P_horner b' n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
i : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_v.P_horner b' n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching:
(a > 0 ->
 (if Rlt_le_dec H (a * a0)
  then 0%nat
  else S (sample (scale a l) (H - a * a0))) =
 (if Rlt_le_dec (H / a) a0 then 0%nat else S (sample l (H / a - a0))))
Crunching:
(forall rnd : R,
 a > 0 ->
 (if Rlt_le_dec rnd (a * a0)
  then 0%nat
  else S (sample (scale a l) (rnd - a * a0))) =
 (if Rlt_le_dec (rnd / a) a0 then 0%nat else S (sample l (rnd / a - a0))))
Crunching:
(n = 0 \/ 0 < n ->
 Σ
   (fun y0 : nat =>
    (pad_u (S i) i (phase_shift θ) x y0 * f_to_vec (S i) f y0 y)%C) 
   (2 ^ S i) = (Cexp (f i * θ) * f_to_vec (S i) f x y)%C)
Debug:
In environment
n : int
sHG : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_v.P_horner b' n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Tactic call ran for 0.005 secs (0.004u,0.001s) (success)
Debug:
In environment
n : int
Hq1 : is_true ((0 <= n) == true)
valq : int * int
i : is_true ((0 < valq.2) && coprime `|valq.1| `|valq.2|)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_v.P_horner b' n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching:
(pad_u n Eqf (phase_shift Lef) × f_to_vec n x =
 Cexp (x Eqf * Lef) .* f_to_vec n x)
Debug:
In environment
n : int
i : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_v.P_horner b' n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
sHG : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_v.P_horner b' n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching:
((if a + 1 <=? n
  then I (2 ^ a) ⊗ phase_shift b ⊗ I (2 ^ (n - (a + 1)))
  else Zero) × f_to_vec n Hb = Cexp (Hb a * b) .* f_to_vec n Hb)
Crunching:
(pad_u n a (phase_shift b) × f_to_vec n Hb = Cexp (Hb a * b) .* f_to_vec n Hb)
Crunching:
(pad_u n P (phase_shift notall) × f_to_vec n HE =
 Cexp (HE P * notall) .* f_to_vec n HE)
Debug:
In environment
n : int
Hq1 : is_true ((0 <= n) == true)
valq : int * int
i : is_true ((0 < valq.2) && coprime `|valq.1| `|valq.2|)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_v.P_horner b' n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching:
(pad_u n P (phase_shift notall) × f_to_vec n HE =
 Cexp (HE P * notall) .* f_to_vec n HE)
Crunching: (a > 0 -> sample (scale a l) H1 = sample l (H1 / a))
Crunching:
(pad_u n P (phase_shift notall) × f_to_vec n f =
 Cexp (f P * notall) .* f_to_vec n f)
Crunching:
(pad_u n P (phase_shift notall) × f_to_vec n f =
 Cexp (f P * notall) .* f_to_vec n f)
Crunching:
(pad_u n m (phase_shift H) × f_to_vec n f = Cexp (f m * H) .* f_to_vec n f)
Crunching:
(forall rnd : R, a > 0 -> sample (scale a l) rnd = sample l (rnd * / a))
Debug:
In environment
n : int
i : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_v.P_horner b' n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
sHG : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_v.P_horner b' n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
rewrite if_dtt
if (proj1_sig y <? proj1_sig x)
then
(fun E1 : (proj1_sig y <? proj1_sig x) = true =>
 ltN_of_nat (proj1_sig y) (S n) (ltN_intro_lemma1 n x y E1))
else
(fun E1 : (proj1_sig y <? proj1_sig x) = false =>
 ltN_of_nat (S (proj1_sig y)) (S n) (ltN_intro_lemma2 n x y E1))
Crunching:
((fun n0 : nat =>
  forall f : nat -> bool,
  0 < n ->
  pad_u n 0 (phase_shift H) × f_to_vec n f = Cexp (f 0 * H) .* f_to_vec n f)
   1)
Crunching: (0%nat = 0%nat)
Crunching: (0%nat = 0%nat)
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: rho 2]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching:
(forall f : nat -> bool,
 (i < H1)%nat ->
 pad_u H1 i hadamard × f_to_vec H1 f =
 / √ 2
 .* (f_to_vec H1 (update f i false)
     .+ Cexp (f i * PI) .* f_to_vec H1 (update f i true)))
Crunching:
(forall f : nat -> bool,
 (A < H1)%nat ->
 pad_u H1 A hadamard × f_to_vec H1 f =
 / √ 2
 .* (f_to_vec H1 (update f A false)
     .+ Cexp (f A * PI) .* f_to_vec H1 (update f A true)))
Crunching:
(forall f : nat -> bool,
 (i < H1)%nat ->
 pad_u H1 i hadamard × f_to_vec H1 f =
 / √ 2
 .* (f_to_vec H1 (update f i false)
     .+ Cexp (f i * PI) .* f_to_vec H1 (update f i true)))
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: rho 2]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching:
(a > 0 ->
 (if Rlt_le_dec H (a * a0)
  then 0%nat
  else S (sample (scale a l) (H - a * a0))) =
 (if Rlt_le_dec (H / a) a0 then 0%nat else S (sample l (H / a - a0))))
Crunching:
(forall rnd : R,
 a > 0 ->
 (if Rlt_le_dec rnd (a * a0)
  then 0%nat
  else S (sample (scale a l) (rnd - a * a0))) =
 (if Rlt_le_dec (rnd / a) a0 then 0%nat else S (sample l (rnd / a - a0))))
Crunching:
(pad_u (S i) i hadamard × f_to_vec (S i) f =
 / √ IZR (Z.succ (Z.succ 0))
 .* (f_to_vec (S i) (update f i false)
     .+ Cexp (f i * PI) .* f_to_vec (S i) (update f i true)))
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: rho 2]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching:
(forall f : nat -> bool,
 (i < H1)%nat ->
 pad_u H1 i hadamard × f_to_vec H1 f =
 / √ 2
 .* (f_to_vec H1 (update f i false)
     .+ Cexp (f i * PI) .* f_to_vec H1 (update f i true)))
Crunching:
(forall f : nat -> bool,
 (A < H1)%nat ->
 pad_u H1 A hadamard × f_to_vec H1 f =
 / √ 2
 .* (f_to_vec H1 (update f A false)
     .+ Cexp (f A * PI) .* f_to_vec H1 (update f A true)))
Crunching:
(forall f : nat -> bool,
 (i < H1)%nat ->
 pad_u H1 i hadamard × f_to_vec H1 f =
 / √ 2
 .* (f_to_vec H1 (update f i false)
     .+ Cexp (f i * PI) .* f_to_vec H1 (update f i true)))
Crunching:
(pad_u H1 a hadamard × f_to_vec H1 f =
 / √ 2
 .* (f_to_vec H1 (update f a false)
     .+ Cexp (f a * PI) .* f_to_vec H1 (update f a true)))
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: rho 2]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching:
(pad_u H1 a hadamard × f_to_vec H1 n =
 / √ 2
 .* (f_to_vec H1 (update n a false)
     .+ Cexp (n a * PI) .* f_to_vec H1 (update n a true)))
Crunching:
(pad_u H1 a hadamard × f_to_vec H1 n =
 / √ 2
 .* (f_to_vec H1 (update n a false)
     .+ Cexp (n a * PI) .* f_to_vec H1 (update n a true)))
Crunching:
(pad_u H1 a hadamard × f_to_vec H1 n =
 / √ 2
 .* (f_to_vec H1 (update n a false)
     .+ Cexp (n a * PI) .* f_to_vec H1 (update n a true)))
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: rho 2]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching:
(Forall (fun x : R => 0 <= x) a ->
 (forall k : nat, length (Ha k) = (2 ^ ln1)%nat) ->
 (forall k : nat, (k < length a)%nat -> distribution (Ha k)) ->
 let o := sample a l in
 let rnd' := compute_new_rnd l a o in
 snd ln1 (sample (join a Ha) l) = sample (Ha o) rnd')
Crunching:
(Forall (fun x : R => 0 <= x) a ->
 (forall k : nat, length (Ha k) = (2 ^ ln1)%nat) ->
 (forall k : nat, (k < length a)%nat -> distribution (Ha k)) ->
 let o := sample a l in
 let rnd' := compute_new_rnd l a o in
 snd ln1 (sample (join a Ha) l) = sample (Ha o) rnd')
Crunching: (A = big_sum (fun i : nat => A i 0 .* basis_vector n i) n)
Crunching:
(WF_Matrix Hm ->
 Hm = big_sum (fun i x y : nat => (Hm i 0 * basis_vector m i x y)%C) m)
Crunching:
(Forall (fun x : R => 0 <= x) a ->
 (forall k : nat, length (Ha k) = (2 ^ t)%nat) ->
 (forall k : nat, (k < length a)%nat -> distribution (Ha k)) ->
 snd t (sample (join a Ha) z) =
 sample (Ha (sample a z)) (compute_new_rnd z a (sample a z)))
Crunching:
(Forall (fun x : R => 0 <= x) a ->
 (forall k : nat, length (Ha k) = (2 ^ t)%nat) ->
 (forall k : nat, (k < length a)%nat -> distribution (Ha k)) ->
 snd t (sample (join a Ha) z) =
 sample (Ha (sample a z)) (compute_new_rnd z a (sample a z)))
Crunching: (snd 0 (sample (join l1 l2) rnd) = sample (l2 o) rnd')
Crunching:
((forall k : nat, (k < length l1)%nat -> distribution (g k)) ->
 snd m (sample (join l1 g) rnd) =
 sample (g (sample l1 rnd)) (compute_new_rnd rnd l1 (sample l1 rnd)))
Crunching:
(forall ψ : Vector H2,
 WF_Matrix ψ -> ψ = big_sum (fun i : nat => ψ i 0 .* basis_vector H2 i) H2)
Crunching: (A = big_sum (fun i : nat => A i 0 .* basis_vector n i) n)
Crunching:
((forall k : nat, (k < length l1)%nat -> distribution (j k)) ->
 snd m (sample (join l1 j) Hxy) =
 sample (j (sample l1 Hxy)) (compute_new_rnd Hxy l1 (sample l1 Hxy)))
Crunching:
((forall k : nat, (k < length l1)%nat -> distribution (g k)) ->
 snd m (sample (join l1 g) rnd) =
 sample (g (sample l1 rnd)) (compute_new_rnd rnd l1 (sample l1 rnd)))
Debug:
In environment
LT, LT' : nat
p : LT' != LT + 1
H : LT != -1
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: c (int.shift 1 LT) LT'; annotated_recs_c.Sn_cf0_0 LT LT'; c LT LT']
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching:
(WF_Matrix Hm ->
 Hm = big_sum (fun i x y : nat => (Hm i 0 * basis_vector m i x y)%C) m)
Debug:
In environment
LT, LT' : nat
p : LT' != LT + 1
H : LT != -1
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: c (int.shift 1 LT) LT'; annotated_recs_c.Sn_cf0_0 LT LT'; c LT LT']
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching: (pr_outcome_sum (scale l i) E0 = (l * pr_outcome_sum i E0)%R)
Crunching:
((0 < 1)%nat ->
 forall (a : R) (l : list R) (f : nat -> bool),
 pr_outcome_sum (scale a l) f = (a * pr_outcome_sum l f)%R)
clear  Hb  :  (False -> None = Some ?a0@{n:=0})
clear  b  :  (False -> False)
Crunching:
(pr_outcome_sum (scale hyp_r []) rnd = (hyp_r * pr_outcome_sum [] rnd)%R)
Crunching: (pr_outcome_sum (scale l i) E0 = (l * pr_outcome_sum i E0)%R)
Debug:
In environment
g : nat
fK : int
gK : annotated_recs_c.precond.Sk g fK
maxn3 : forall n1 n2 n3 : nat,
        {m : nat | [/\ (n1 <= m)%N, (n2 <= m)%N & (n3 <= m)%N]}
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: c g (int.shift 1 fK); annotated_recs_c.Sk_cf0_0 g fK; c g fK]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n, le_mn2 : int
x := (n, d) : int * (int -> int -> int -> rat)
H : annotated_recs_c.precond.Sk n le_mn2
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: c n (int.shift 1 le_mn2); annotated_recs_c.Sk_cf0_0 n le_mn2;
         c n le_mn2]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching: (pr_outcome_sum (scale a l) f = (a * pr_outcome_sum l f)%R)
Crunching:
((0 < 1)%nat ->
 forall (a : R) (l : list R) (f : nat -> bool),
 pr_outcome_sum (scale a l) f = (a * pr_outcome_sum l f)%R)
Debug:
In environment
g : nat
fK : int
gK : annotated_recs_c.precond.Sk g fK
maxn3 : forall n1 n2 n3 : nat,
        {m : nat | [/\ (n1 <= m)%N, (n2 <= m)%N & (n3 <= m)%N]}
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: c g (int.shift 1 fK); annotated_recs_c.Sk_cf0_0 g fK; c g fK]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching:
(forall f : nat -> Vector n,
 big_sum f (2 * c) =
 big_sum (fun i : nat => f (2 * i)) c
 .+ big_sum (fun i : nat => f (2 * i + 1)) c)
Crunching: ((/ √ 2)%R <> 0 -> pr_P ?P (pr_outcome_sum (scale n f) f0))
Crunching: False
Debug:
In environment
n, le_mn2 : int
x := (n, d) : int * (int -> int -> int -> rat)
H : annotated_recs_c.precond.Sk n le_mn2
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: c n (int.shift 1 le_mn2); annotated_recs_c.Sk_cf0_0 n le_mn2;
         c n le_mn2]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n, le_mn2 : int
x := (n, d) : int * (int -> int -> int -> rat)
pG : annotated_recs_c.precond.Sk n le_mn2
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: c n (int.shift 1 le_mn2); annotated_recs_c.Sk_cf0_0 n le_mn2;
         c n le_mn2]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching:
(forall (x : nat) (l1 : list R) (l2 : nat -> list R) (m : nat),
 (forall k : nat, (k < x)%nat -> length (l2 k) = m) ->
 length (join' l1 l2 x) = (x * m)%nat)
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building ident_interp...
Building base_eq_dec...
Building base_beq_and_reflect...
Building base_beq...
Building reflect_base_beq...
Building baseHasNatAndCorrect...
Building baseHasNat...
Building baseHasNatCorrect...
Building base_interp_beq...
Building reflect_base_interp_beq...
Building try_make_base_transport_cps...
Building try_make_base_transport_cps_correct...
Building all_idents...
Building all_ident_and_interp...
Building buildEagerIdentAndInterpCorrect...
Building buildEagerIdent...
Building buildInterpEagerIdentCorrect...
Building toRestrictedIdentAndCorrect...
Building toRestrictedIdent...
Building toFromRestrictedIdent...
Building buildIdentAndInterpCorrect...
Building buildIdent...
Building buildInterpIdentCorrect...
Building ident_is_var_like...
Building eqv_Reflexive_Proper...
Building ident_interp_Proper...
Building invertIdent...
Building buildInvertIdentCorrect...
Building base_default...
Building package...
Debug:
In environment
g : nat
fK : int
gK : annotated_recs_c.precond.Sk g fK
maxn3 : forall n1 n2 n3 : nat,
        {m : nat | [/\ (n1 <= m)%N, (n2 <= m)%N & (n3 <= m)%N]}
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: c g (int.shift 1 fK); annotated_recs_c.Sk_cf0_0 g fK; c g fK]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Building all_base...
Building all_idents...
Crunching:
(forall (n : nat) (f : nat -> Vector len1),
 big_sum f (2 * n) =
 big_sum (fun i : nat => f (2 * i)) n
 .+ big_sum (fun i : nat => f (2 * i + 1)) n)
Building ident_index...
Building eta_ident_cps_gen...
Building eta_ident_cps_gen_expand_literal...
Building eta_ident_cps...
Building simple_idents...
Building all_raw_idents...
Building raw_ident_index...
Building raw_ident_index_idempotent...
Building eta_raw_ident_cps_gen...
Building raw_ident_to_ident...
Building raw_ident_infos_of...
Building split_raw_ident_gen...
Crunching:
(forall f : nat -> Vector n,
 big_sum f (2 * c) =
 big_sum (fun i : nat => f (2 * i)) c
 .+ big_sum (fun i : nat => f (2 * i + 1)) c)
Building invert_bind_args...
Building invert_bind_args_unknown...
Building all_pattern_idents...
Building eta_pattern_ident_cps_gen...
Building eta_pattern_ident_cps_gen_expand_literal...
Building split_types...
Building add_types_from_raw_sig...
Building to_type_split_types_subst_default_eq...
Crunching:
(forall (x : nat) (l1 : list R) (l2 : nat -> list R) (m : nat),
 (forall k : nat, (k < x)%nat -> length (l2 k) = m) ->
 length (join' l1 l2 x) = (x * m)%nat)
Building projT1_add_types_from_raw_sig_eq...
Building arg_types_unfolded...
Building type_of_list_arg_types_beq_unfolded...
Building to_typed_unfolded...
Building of_typed_ident_unfolded...
Building arg_types_of_typed_ident_unfolded...
Building unify...
Building unify_unknown...
Building final ident package...
Proving is_simple_correct0...
Debug:
In environment
n : nat
p : 2 <= n.+1
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner a n.+1]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Tactic call ran for 1.034 secs (1.002u,0.029s) (success)
Proving invert_bind_args_raw_to_typed...
Crunching:
(m < n \/ m = n ->
 m < n \/ m = n ->
 big_sum Hn (S n) =
 big_sum Hn m .+ Hn m .+ big_sum (shift Hn (m + 1)) (S n - 1 - m))
Tactic call ran for 0.596 secs (0.574u,0.015s) (success)
Proving fold_invert_bind_args...
Tactic call ran for 0.124 secs (0.119u,0.004s) (success)
Proving split_ident_to_ident...
Tactic call ran for 0.035 secs (0.034u,0.s) (success)
Proving eq_indep_types_of_eq_types...
Tactic call ran for 1.82 secs (1.72u,0.096s) (success)
Proving fold_eta_ident_cps...
Tactic call ran for 0.023 secs (0.019u,0.003s) (success)
Proving fold_unify...
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving to_typed_of_typed_ident...
Crunching: ((2 * S (S n))%nat = S (S (2 * S n)) -> P (S n))
Tactic call ran for 3.22 secs (3.189u,0.024s) (success)
Proving eq_invert_bind_args_unknown...
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving eq_unify_unknown...
Tactic call ran for 0. secs (0.u,0.s) (success)
Debug:
In environment
n : nat
lt_n_m : 2 <= n.+1
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner a n.+1]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : nat
p : 2 <= n.+1
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner a n.+1]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching:
(big_sum alp_f1d a =
 big_sum alp_f1d i .+ alp_f1d i
 .+ big_sum (shift alp_f1d (i + 1)) (a - 1 - i))
Reifying...
"paths has been translated as pathsᵗ"
"idpath has been translated as idpathᵗ"
Crunching: (WF_Matrix (big_sum v n))
Crunching: (WF_Matrix (big_sum v n))
Crunching: (WF_Matrix (big_sum v n))
Debug:
In environment
n : nat
lt_n_m : 2 <= n.+1
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner a n.+1]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : nat
H : 2 <= n.+1
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner a n.+1]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : nat
p : 2 <= n.+1
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner a n.+1]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
"paths_ind has been translated as paths_indᵗ"
Compiling decision tree...
Splitting rewrite rules...
Crunching: (WF_Matrix (big_sum v n))
"transport has been translated as transportᵗ"
"sigT has been translated as sigTᵗ"
Crunching:
((0 < length [])%nat ->
 pr_outcome_sum (firstn 1 []) HB =
 ((if HB 0%nat then nth 0 [] 0 else 0) + pr_outcome_sum (firstn 0 []) HB)%R)
Crunching: (WF_Matrix (big_sum v n))
Assembling rewrite_head...
Crunching:
(forall (i : nat) (v : nat -> Matrix H1 (1 - 0)),
 i < S n ->
 big_sum v (S n) =
 big_sum v i .+ v i .+ big_sum (shift v (i + (1 - 0))) (S n - (1 - 0) - i))
Reducing rewrite_head...
Tactic call ran for 0.654 secs (0.641u,0.012s) (success)
"projT1 has been translated as projT1ᵗ"
"projT2 has been translated as projT2ᵗ"
Tactic call ran for 5.758 secs (5.541u,0.208s) (success)
Tactic call ran for 0.336 secs (0.331u,0.003s) (success)
Assembling rewrite_head_no_dtree...
Reducing rewrite_head_no_dtree...
Proving Rewriter_Wf...
Tactic call ran for 0.605 secs (0.601u,0.003s) (success)
Tactic call ran for 3.02 secs (2.979u,0.032s) (success)
Proving Rewriter_Interp...
rewrite if_dtt
if
(proj1_sig (exist (fun k : nat => (k <? 0) = true) x0 e0) <?
 proj1_sig (exist (fun k : nat => (k <? 1) = true) x e))
then
(fun
   E1 : (proj1_sig (exist (fun k : nat => (k <? 0) = true) x0 e0) <?
         proj1_sig (exist (fun k : nat => (k <? 1) = true) x e)) = true =>
 ltN_of_nat (proj1_sig (exist (fun k : nat => (k <? 0) = true) x0 e0)) 1
   (ltN_intro_lemma1 0 (exist (fun k : nat => (k <? 1) = true) x e)
      (exist (fun k : nat => (k <? 0) = true) x0 e0) E1))
else
(fun
   E1 : (proj1_sig (exist (fun k : nat => (k <? 0) = true) x0 e0) <?
         proj1_sig (exist (fun k : nat => (k <? 1) = true) x e)) = false =>
 ltN_of_nat (S (proj1_sig (exist (fun k : nat => (k <? 0) = true) x0 e0))) 1
   (ltN_intro_lemma2 0 (exist (fun k : nat => (k <? 1) = true) x e)
      (exist (fun k : nat => (k <? 0) = true) x0 e0) E1))
Tactic call ran for 4.406 secs (4.308u,0.091s) (success)
Tactic call ran for 1.983 secs (1.964u,0.016s) (success)
rewrite if_dtt
if
(proj1_sig (exist (fun k : nat => (k <? 0) = true) x0 e0) <?
 proj1_sig (exist (fun k : nat => (k <? 1) = true) x e))
then
(fun
   E1 : (proj1_sig (exist (fun k : nat => (k <? 0) = true) x0 e0) <?
         proj1_sig (exist (fun k : nat => (k <? 1) = true) x e)) = true =>
 ltN_of_nat (proj1_sig (exist (fun k : nat => (k <? 0) = true) x0 e0)) 1
   (ltN_intro_lemma1 0 (exist (fun k : nat => (k <? 1) = true) x e)
      (exist (fun k : nat => (k <? 0) = true) x0 e0) E1))
else
(fun
   E1 : (proj1_sig (exist (fun k : nat => (k <? 0) = true) x0 e0) <?
         proj1_sig (exist (fun k : nat => (k <? 1) = true) x e)) = false =>
 ltN_of_nat (S (proj1_sig (exist (fun k : nat => (k <? 0) = true) x0 e0))) 1
   (ltN_intro_lemma2 0 (exist (fun k : nat => (k <? 1) = true) x e)
      (exist (fun k : nat => (k <? 0) = true) x0 e0) E1))
Assembling verified rewriter...
Refining with verified rewriter...
Finished transaction in 75.839 secs (73.931u,1.743s) (successful)
Crunching:
(pr_outcome_sum (join l1 n)
   (fun z : nat => y (fst n0 z) && nN (fst n0 z) (snd n0 z)) >= 
 dy * r2)
Finished transaction in 3.488 secs (3.423u,0.06s) (successful)
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building ident_interp...
Building base_eq_dec...
Building base_beq_and_reflect...
Building base_beq...
Building reflect_base_beq...
Building baseHasNatAndCorrect...
Building baseHasNat...
Building baseHasNatCorrect...
Building base_interp_beq...
Building reflect_base_interp_beq...
Building try_make_base_transport_cps...
Building try_make_base_transport_cps_correct...
Building all_idents...
Building all_ident_and_interp...
Building buildEagerIdentAndInterpCorrect...
Finished transaction in 3.754 secs (3.667u,0.081s) (successful)
Building buildEagerIdent...
Building buildInterpEagerIdentCorrect...
Building toRestrictedIdentAndCorrect...
Building toRestrictedIdent...
Building toFromRestrictedIdent...
Building buildIdentAndInterpCorrect...
Building buildIdent...
Building buildInterpIdentCorrect...
Building ident_is_var_like...
Building eqv_Reflexive_Proper...
Debug:
In environment
n : int
nge2 : is_true ((Posz 2 : int) <= (n : int))
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Building ident_interp_Proper...
Building invertIdent...
Building buildInvertIdentCorrect...
Building base_default...
Building package...
Building all_base...
Building all_idents...
Building ident_index...
Building eta_ident_cps_gen...
Building eta_ident_cps_gen_expand_literal...
Building eta_ident_cps...
Building simple_idents...
Building all_raw_idents...
Building raw_ident_index...
Building raw_ident_index_idempotent...
Building eta_raw_ident_cps_gen...
Building raw_ident_to_ident...
Building raw_ident_infos_of...
Debug:
In environment
Az, RS : int
b : int * int
hf : (0 < b.2) && coprime `|b.1| `|b.2|
v : int
RS' : annotated_recs_d.precond.Sn Az RS v
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: d (int.shift 1 Az) RS v; annotated_recs_d.Sn_cf0_0_0 Az RS v;
         d Az RS v]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Building split_raw_ident_gen...
Debug:
In environment
n : int
prim_z : is_true ((Posz 2 : int) <= (n : int))
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Building invert_bind_args...
Building invert_bind_args_unknown...
Building all_pattern_idents...
rewrite if_dtt
if
(proj1_sig (exist (fun k : nat => (k <? 0) = true) x0 e0) <?
 proj1_sig (exist (fun k : nat => (k <? 1) = true) x e))
then
(fun
   E1 : (proj1_sig (exist (fun k : nat => (k <? 0) = true) x0 e0) <?
         proj1_sig (exist (fun k : nat => (k <? 1) = true) x e)) = true =>
 ltN_of_nat (proj1_sig (exist (fun k : nat => (k <? 0) = true) x0 e0)) 1
   (ltN_intro_lemma1 0 (exist (fun k : nat => (k <? 1) = true) x e)
      (exist (fun k : nat => (k <? 0) = true) x0 e0) E1))
else
(fun
   E1 : (proj1_sig (exist (fun k : nat => (k <? 0) = true) x0 e0) <?
         proj1_sig (exist (fun k : nat => (k <? 1) = true) x e)) = false =>
 ltN_of_nat (S (proj1_sig (exist (fun k : nat => (k <? 0) = true) x0 e0))) 1
   (ltN_intro_lemma2 0 (exist (fun k : nat => (k <? 1) = true) x e)
      (exist (fun k : nat => (k <? 0) = true) x0 e0) E1))
Building eta_pattern_ident_cps_gen...
Building eta_pattern_ident_cps_gen_expand_literal...
Building split_types...
Building add_types_from_raw_sig...
Building to_type_split_types_subst_default_eq...
Building projT1_add_types_from_raw_sig_eq...
Building arg_types_unfolded...
Building type_of_list_arg_types_beq_unfolded...
Building to_typed_unfolded...
Building of_typed_ident_unfolded...
Building arg_types_of_typed_ident_unfolded...
Building unify...
Building unify_unknown...
Building final ident package...
Proving is_simple_correct0...
Tactic call ran for 0.515 secs (0.512u,0.001s) (success)
Proving invert_bind_args_raw_to_typed...
"existT has been translated as existTᵗ"
Tactic call ran for 0.368 secs (0.357u,0.01s) (success)
Proving fold_invert_bind_args...
Tactic call ran for 0.024 secs (0.024u,0.s) (success)
Proving split_ident_to_ident...
Tactic call ran for 0.02 secs (0.02u,0.s) (success)
Proving eq_indep_types_of_eq_types...
Tactic call ran for 1.194 secs (1.167u,0.016s) (success)
Proving fold_eta_ident_cps...
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving fold_unify...
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving to_typed_of_typed_ident...
Tactic call ran for 2.484 secs (2.443u,0.025s) (success)
Proving eq_invert_bind_args_unknown...
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving eq_unify_unknown...
Tactic call ran for 0. secs (0.u,0.s) (success)
Crunching: (WF_Matrix (vkron n f))
Reifying...
Compiling decision tree...
Crunching: (vkron z z0 y H13 = 0%R)
Splitting rewrite rules...
Assembling rewrite_head...
Reducing rewrite_head...
Tactic call ran for 0.011 secs (0.011u,0.s) (success)
Tactic call ran for 0.001 secs (0.001u,0.s) (success)
Tactic call ran for 0.049 secs (0.043u,0.005s) (success)
Assembling rewrite_head_no_dtree...
Reducing rewrite_head_no_dtree...
Proving Rewriter_Wf...
Tactic call ran for 0.009 secs (0.009u,0.s) (success)
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving Rewriter_Interp...
Tactic call ran for 0.114 secs (0.112u,0.001s) (success)
Tactic call ran for 0. secs (0.u,0.s) (success)
Assembling verified rewriter...
Refining with verified rewriter...
Finished transaction in 18.553 secs (18.322u,0.15s) (successful)
Crunching: (WF_Matrix (vkron n f))
Debug:
In environment
f0 := fun t t0 : zmodType => (0, 0)
 : forall t t0 : zmodType, GRing.Zmodule.sort t * GRing.Zmodule.sort t0
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_horner
           (fun n : int =>
            reducebig 0 (bigopz.index_iotaz 0 (n + 1))
              (fun k : int =>
               BigBody k +%R true
                 (match n with
                  | Posz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 true true
                      | Negz m1 => binomial_rec n1 m1 true false
                      end
                  | Negz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 false true
                      | Negz m1 => binomial_rec n1 m1 false false
                      end
                  end%:~R ^ Posz 2 *
                  match n + k with
                  | Posz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 true true
                      | Negz m1 => binomial_rec n1 m1 true false
                      end
                  | Negz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 false true
                      | Negz m1 => binomial_rec n1 m1 false false
                      end
                  end%:~R ^ Posz 2 *
                  (reducebig 0 (bigopz.index_iotaz 1 (n + 1))
                     (fun k0 : int =>
                      BigBody k0 +%R true (k0%:~R ^ Posz 3)^-1) +
                   reducebig 0 (bigopz.index_iotaz 1 (k + 1))
                     (fun m : int =>
                      BigBody m +%R true
                        ((-1) ^ (m + 1) /
                         ((Posz 2)%:~R * m%:~R ^ Posz 3 *
                          match n with
                          | Posz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 true true
                              | Negz m1 => binomial_rec n1 m1 true false
                              end
                          | Negz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 false true
                              | Negz m1 => binomial_rec n1 m1 false false
                              end
                          end%:~R *
                          match n + m with
                          | Posz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 true true
                              | Negz m1 => binomial_rec n1 m1 true false
                              end
                          | Negz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 false true
                              | Negz m1 => binomial_rec n1 m1 false false
                              end
                          end%:~R))))))) 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching: (vkron z z0 y H13 = (R0, R0))
Crunching: (vkron z z0 y H13 = 0%R)
Crunching: (vkron z z0 y H13 = 0%R)
Crunching: (r >= 2 ^ z \/ y >= 1 -> vkron z z0 r y = z0 ?Goal0 ?Goal2 ?Goal3)
Crunching: (forall x y : nat, x >= 2 ^ z \/ y >= 1 -> vkron z z0 x y = 0%R)
Debug:
In environment
f0 := fun t t0 : zmodType => (0, 0)
 : forall t t0 : zmodType, GRing.Zmodule.sort t * GRing.Zmodule.sort t0
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_horner
           (fun n : int =>
            reducebig 0 (bigopz.index_iotaz 0 (n + 1))
              (fun k : int =>
               BigBody k +%R true
                 (match n with
                  | Posz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 true true
                      | Negz m1 => binomial_rec n1 m1 true false
                      end
                  | Negz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 false true
                      | Negz m1 => binomial_rec n1 m1 false false
                      end
                  end%:~R ^ Posz 2 *
                  match n + k with
                  | Posz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 true true
                      | Negz m1 => binomial_rec n1 m1 true false
                      end
                  | Negz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 false true
                      | Negz m1 => binomial_rec n1 m1 false false
                      end
                  end%:~R ^ Posz 2 *
                  (reducebig 0 (bigopz.index_iotaz 1 (n + 1))
                     (fun k0 : int =>
                      BigBody k0 +%R true (k0%:~R ^ Posz 3)^-1) +
                   reducebig 0 (bigopz.index_iotaz 1 (k + 1))
                     (fun m : int =>
                      BigBody m +%R true
                        ((-1) ^ (m + 1) /
                         ((Posz 2)%:~R * m%:~R ^ Posz 3 *
                          match n with
                          | Posz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 true true
                              | Negz m1 => binomial_rec n1 m1 true false
                              end
                          | Negz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 false true
                              | Negz m1 => binomial_rec n1 m1 false false
                              end
                          end%:~R *
                          match n + m with
                          | Posz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 true true
                              | Negz m1 => binomial_rec n1 m1 true false
                              end
                          | Negz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 false true
                              | Negz m1 => binomial_rec n1 m1 false false
                              end
                          end%:~R))))))) 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
f0 := fun t t0 : zmodType => (0, 0)
 : forall t t0 : zmodType, GRing.Zmodule.sort t * GRing.Zmodule.sort t0
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_horner
           (fun n : int =>
            reducebig 0 (bigopz.index_iotaz 0 (n + 1))
              (fun k : int =>
               BigBody k +%R true
                 (match n with
                  | Posz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 true true
                      | Negz m1 => binomial_rec n1 m1 true false
                      end
                  | Negz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 false true
                      | Negz m1 => binomial_rec n1 m1 false false
                      end
                  end%:~R ^ Posz 2 *
                  match n + k with
                  | Posz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 true true
                      | Negz m1 => binomial_rec n1 m1 true false
                      end
                  | Negz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 false true
                      | Negz m1 => binomial_rec n1 m1 false false
                      end
                  end%:~R ^ Posz 2 *
                  (reducebig 0 (bigopz.index_iotaz 1 (n + 1))
                     (fun k0 : int =>
                      BigBody k0 +%R true (k0%:~R ^ Posz 3)^-1) +
                   reducebig 0 (bigopz.index_iotaz 1 (k + 1))
                     (fun m : int =>
                      BigBody m +%R true
                        ((-1) ^ (m + 1) /
                         ((Posz 2)%:~R * m%:~R ^ Posz 3 *
                          match n with
                          | Posz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 true true
                              | Negz m1 => binomial_rec n1 m1 true false
                              end
                          | Negz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 false true
                              | Negz m1 => binomial_rec n1 m1 false false
                              end
                          end%:~R *
                          match n + m with
                          | Posz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 true true
                              | Negz m1 => binomial_rec n1 m1 true false
                              end
                          | Negz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 false true
                              | Negz m1 => binomial_rec n1 m1 false false
                              end
                          end%:~R))))))) 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner b 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
f0 := fun t t0 : zmodType => (0, 0)
 : forall t t0 : zmodType, GRing.Zmodule.sort t * GRing.Zmodule.sort t0
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_horner
           (fun n : int =>
            reducebig 0 (bigopz.index_iotaz 0 (n + 1))
              (fun k : int =>
               BigBody k +%R true
                 (match n with
                  | Posz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 true true
                      | Negz m1 => binomial_rec n1 m1 true false
                      end
                  | Negz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 false true
                      | Negz m1 => binomial_rec n1 m1 false false
                      end
                  end%:~R ^ Posz 2 *
                  match n + k with
                  | Posz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 true true
                      | Negz m1 => binomial_rec n1 m1 true false
                      end
                  | Negz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 false true
                      | Negz m1 => binomial_rec n1 m1 false false
                      end
                  end%:~R ^ Posz 2 *
                  (reducebig 0 (bigopz.index_iotaz 1 (n + 1))
                     (fun k0 : int =>
                      BigBody k0 +%R true (k0%:~R ^ Posz 3)^-1) +
                   reducebig 0 (bigopz.index_iotaz 1 (k + 1))
                     (fun m : int =>
                      BigBody m +%R true
                        ((-1) ^ (m + 1) /
                         ((Posz 2)%:~R * m%:~R ^ Posz 3 *
                          match n with
                          | Posz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 true true
                              | Negz m1 => binomial_rec n1 m1 true false
                              end
                          | Negz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 false true
                              | Negz m1 => binomial_rec n1 m1 false false
                              end
                          end%:~R *
                          match n + m with
                          | Posz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 true true
                              | Negz m1 => binomial_rec n1 m1 true false
                              end
                          | Negz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 false true
                              | Negz m1 => binomial_rec n1 m1 false false
                              end
                          end%:~R))))))) 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner b 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
f0 := fun t t0 : zmodType => (0, 0)
 : forall t t0 : zmodType, GRing.Zmodule.sort t * GRing.Zmodule.sort t0
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_horner
           (fun n : int =>
            reducebig 0 (bigopz.index_iotaz 0 (n + 1))
              (fun k : int =>
               BigBody k +%R true
                 (match n with
                  | Posz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 true true
                      | Negz m1 => binomial_rec n1 m1 true false
                      end
                  | Negz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 false true
                      | Negz m1 => binomial_rec n1 m1 false false
                      end
                  end%:~R ^ Posz 2 *
                  match n + k with
                  | Posz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 true true
                      | Negz m1 => binomial_rec n1 m1 true false
                      end
                  | Negz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 false true
                      | Negz m1 => binomial_rec n1 m1 false false
                      end
                  end%:~R ^ Posz 2 *
                  (reducebig 0 (bigopz.index_iotaz 1 (n + 1))
                     (fun k0 : int =>
                      BigBody k0 +%R true (k0%:~R ^ Posz 3)^-1) +
                   reducebig 0 (bigopz.index_iotaz 1 (k + 1))
                     (fun m : int =>
                      BigBody m +%R true
                        ((-1) ^ (m + 1) /
                         ((Posz 2)%:~R * m%:~R ^ Posz 3 *
                          match n with
                          | Posz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 true true
                              | Negz m1 => binomial_rec n1 m1 true false
                              end
                          | Negz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 false true
                              | Negz m1 => binomial_rec n1 m1 false false
                              end
                          end%:~R *
                          match n + m with
                          | Posz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 true true
                              | Negz m1 => binomial_rec n1 m1 true false
                              end
                          | Negz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 false true
                              | Negz m1 => binomial_rec n1 m1 false false
                              end
                          end%:~R))))))) 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
f0 := fun t t0 : zmodType => (0, 0)
 : forall t t0 : zmodType, GRing.Zmodule.sort t * GRing.Zmodule.sort t0
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: (((((0%Q + rat_of_Z 2)%Q *
             ((0%Q + rat_of_Z 2)%Q * (0%Q + rat_of_Z 2)%Q)%Q)%Q * 
            b (Posz 2))%Q +
           ((((- rat_of_Z 1)%Q *
              (((rat_of_Z 17 * (0%Q * 0%Q)%Q)%Q + (rat_of_Z 51 * 0%Q)%Q)%Q +
               rat_of_Z 39)%Q)%Q * ((rat_of_Z 2 * 0%Q)%Q + rat_of_Z 3)%Q)%Q *
            b (Posz 1))%Q)%Q +
          (((0%Q + rat_of_Z 1)%Q *
            ((0%Q + rat_of_Z 1)%Q * (0%Q + rat_of_Z 1)%Q)%Q)%Q * 
           b (Posz 0))%Q)%Q; 0%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
HP, HIS, z_ne_0 : int
LT : annotated_recs_d.precond.Sk HP HIS z_ne_0
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: (match intZmod.addz z_ne_0 1 with
          | Posz n => iterop n mulq (- 1%Q) 1
          | Negz n =>
              (match n with
               | 0 => (- 1%Q)%Q
               | _.+1 =>
                   ((- 1%Q)%Q *
                    (fix loop (m : nat) : rat :=
                       match m with
                       | 0 => 1
                       | 1 => - 1%Q
                       | (_.+1 as i).+1 => (- 1%Q)%Q * loop i
                       end) n)%Q
               end^-1)%Q
          end *
          (((((1%Q + 1%Q)%Q *
              (match z_ne_0 with
               | Posz n => iterop n addq 1 0
               | Negz n =>
                   (-
                    match n with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 => 1%Q + loop i
                            end) n)%Q
                    end)%Q
               end *
               (match z_ne_0 with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 => 1%Q + loop i
                             end) n)%Q
                     end)%Q
                end *
                match z_ne_0 with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 => 1%Q + loop i
                             end) n)%Q
                     end)%Q
                end)%Q)%Q)%Q *
             match binomialz HP z_ne_0 with
             | Posz n => iterop n addq 1 0
             | Negz n =>
                 (-
                  match n with
                  | 0 => 1%Q
                  | _.+1 =>
                      (1%Q +
                       (fix loop (m : nat) : rat :=
                          match m with
                          | 0 => 0
                          | 1 => 1
                          | (_.+1 as i).+1 => 1%Q + loop i
                          end) n)%Q
                  end)%Q
             end)%Q *
            match binomialz (intZmod.addz HP z_ne_0) z_ne_0 with
            | Posz n => iterop n addq 1 0
            | Negz n =>
                (-
                 match n with
                 | 0 => 1%Q
                 | _.+1 =>
                     (1%Q +
                      (fix loop (m : nat) : rat :=
                         match m with
                         | 0 => 0
                         | 1 => 1
                         | (_.+1 as i).+1 => 1%Q + loop i
                         end) n)%Q
                 end)%Q
            end)%Q^-1)%Q)%Q;
         (annotated_recs_d.Sk_cf0_0_0 HP HIS z_ne_0 *
          (match intZmod.addz z_ne_0 1 with
           | Posz n => iterop n mulq (- 1%Q) 1
           | Negz n =>
               (match n with
                | 0 => (- 1%Q)%Q
                | _.+1 =>
                    ((- 1%Q)%Q *
                     (fix loop (m : nat) : rat :=
                        match m with
                        | 0 => 1
                        | 1 => - 1%Q
                        | (_.+1 as i).+1 => (- 1%Q)%Q * loop i
                        end) n)%Q
                end^-1)%Q
           end *
           (((((1%Q + 1%Q)%Q *
               (match z_ne_0 with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 => 1%Q + loop i
                             end) n)%Q
                     end)%Q
                end *
                (match z_ne_0 with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end *
                 match z_ne_0 with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end)%Q)%Q)%Q *
              match binomialz HP z_ne_0 with
              | Posz n => iterop n addq 1 0
              | Negz n =>
                  (-
                   match n with
                   | 0 => 1%Q
                   | _.+1 =>
                       (1%Q +
                        (fix loop (m : nat) : rat :=
                           match m with
                           | 0 => 0
                           | 1 => 1
                           | (_.+1 as i).+1 => 1%Q + loop i
                           end) n)%Q
                   end)%Q
              end)%Q *
             match binomialz (intZmod.addz HP z_ne_0) z_ne_0 with
             | Posz n => iterop n addq 1 0
             | Negz n =>
                 (-
                  match n with
                  | 0 => 1%Q
                  | _.+1 =>
                      (1%Q +
                       (fix loop (m : nat) : rat :=
                          match m with
                          | 0 => 0
                          | 1 => 1
                          | (_.+1 as i).+1 => 1%Q + loop i
                          end) n)%Q
                  end)%Q
             end)%Q^-1)%Q)%Q)%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner b 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
f0 := fun t t0 : zmodType => (0, 0)
 : forall t t0 : zmodType, GRing.Zmodule.sort t * GRing.Zmodule.sort t0
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_horner
           (fun n : int =>
            reducebig 0 (bigopz.index_iotaz 0 (n + 1))
              (fun k : int =>
               BigBody k +%R true
                 (match n with
                  | Posz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 true true
                      | Negz m1 => binomial_rec n1 m1 true false
                      end
                  | Negz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 false true
                      | Negz m1 => binomial_rec n1 m1 false false
                      end
                  end%:~R ^ Posz 2 *
                  match n + k with
                  | Posz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 true true
                      | Negz m1 => binomial_rec n1 m1 true false
                      end
                  | Negz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 false true
                      | Negz m1 => binomial_rec n1 m1 false false
                      end
                  end%:~R ^ Posz 2 *
                  (reducebig 0 (bigopz.index_iotaz 1 (n + 1))
                     (fun k0 : int =>
                      BigBody k0 +%R true (k0%:~R ^ Posz 3)^-1) +
                   reducebig 0 (bigopz.index_iotaz 1 (k + 1))
                     (fun m : int =>
                      BigBody m +%R true
                        ((-1) ^ (m + 1) /
                         ((Posz 2)%:~R * m%:~R ^ Posz 3 *
                          match n with
                          | Posz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 true true
                              | Negz m1 => binomial_rec n1 m1 true false
                              end
                          | Negz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 false true
                              | Negz m1 => binomial_rec n1 m1 false false
                              end
                          end%:~R *
                          match n + m with
                          | Posz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 true true
                              | Negz m1 => binomial_rec n1 m1 true false
                              end
                          | Negz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 false true
                              | Negz m1 => binomial_rec n1 m1 false false
                              end
                          end%:~R))))))) 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
f0 := fun t t0 : zmodType => (0, 0)
 : forall t t0 : zmodType, GRing.Zmodule.sort t * GRing.Zmodule.sort t0
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_horner
           (fun n : int =>
            reducebig 0 (bigopz.index_iotaz 0 (n + 1))
              (fun k : int =>
               BigBody k +%R true
                 (match n with
                  | Posz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 true true
                      | Negz m1 => binomial_rec n1 m1 true false
                      end
                  | Negz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 false true
                      | Negz m1 => binomial_rec n1 m1 false false
                      end
                  end%:~R ^ Posz 2 *
                  match n + k with
                  | Posz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 true true
                      | Negz m1 => binomial_rec n1 m1 true false
                      end
                  | Negz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 false true
                      | Negz m1 => binomial_rec n1 m1 false false
                      end
                  end%:~R ^ Posz 2 *
                  (reducebig 0 (bigopz.index_iotaz 1 (n + 1))
                     (fun k0 : int =>
                      BigBody k0 +%R true (k0%:~R ^ Posz 3)^-1) +
                   reducebig 0 (bigopz.index_iotaz 1 (k + 1))
                     (fun m : int =>
                      BigBody m +%R true
                        ((-1) ^ (m + 1) /
                         ((Posz 2)%:~R * m%:~R ^ Posz 3 *
                          match n with
                          | Posz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 true true
                              | Negz m1 => binomial_rec n1 m1 true false
                              end
                          | Negz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 false true
                              | Negz m1 => binomial_rec n1 m1 false false
                              end
                          end%:~R *
                          match n + m with
                          | Posz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 true true
                              | Negz m1 => binomial_rec n1 m1 true false
                              end
                          | Negz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 false true
                              | Negz m1 => binomial_rec n1 m1 false false
                              end
                          end%:~R))))))) 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
f0 := fun t t0 : zmodType => (0, 0)
 : forall t t0 : zmodType, GRing.Zmodule.sort t * GRing.Zmodule.sort t0
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: (((((0%Q + rat_of_Z 2)%Q *
             ((0%Q + rat_of_Z 2)%Q * (0%Q + rat_of_Z 2)%Q)%Q)%Q * 
            b (Posz 2))%Q +
           ((((- rat_of_Z 1)%Q *
              (((rat_of_Z 17 * (0%Q * 0%Q)%Q)%Q + (rat_of_Z 51 * 0%Q)%Q)%Q +
               rat_of_Z 39)%Q)%Q * ((rat_of_Z 2 * 0%Q)%Q + rat_of_Z 3)%Q)%Q *
            b (Posz 1))%Q)%Q +
          (((0%Q + rat_of_Z 1)%Q *
            ((0%Q + rat_of_Z 1)%Q * (0%Q + rat_of_Z 1)%Q)%Q)%Q * 
           b (Posz 0))%Q)%Q; 0%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching: (f 0 ⊗ vkron n (fun i : nat => f (i + 1)) = vkron (S n) f)
Crunching: (f 0 ⊗ vkron n (fun i : nat => f (i + 1)) = vkron (S n) f)
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building ident_interp...
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner b 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
"isequiv has been translated as isequivᵗ"
Building base_eq_dec...
Building base_beq_and_reflect...
Building base_beq...
Building reflect_base_beq...
Building baseHasNatAndCorrect...
Debug:
In environment
f0 := fun t t0 : zmodType => (0, 0)
 : forall t t0 : zmodType, GRing.Zmodule.sort t * GRing.Zmodule.sort t0
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_horner
           (fun n : int =>
            reducebig 0 (bigopz.index_iotaz 0 (n + 1))
              (fun k : int =>
               BigBody k +%R true
                 (match n with
                  | Posz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 true true
                      | Negz m1 => binomial_rec n1 m1 true false
                      end
                  | Negz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 false true
                      | Negz m1 => binomial_rec n1 m1 false false
                      end
                  end%:~R ^ Posz 2 *
                  match n + k with
                  | Posz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 true true
                      | Negz m1 => binomial_rec n1 m1 true false
                      end
                  | Negz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 false true
                      | Negz m1 => binomial_rec n1 m1 false false
                      end
                  end%:~R ^ Posz 2 *
                  (reducebig 0 (bigopz.index_iotaz 1 (n + 1))
                     (fun k0 : int =>
                      BigBody k0 +%R true (k0%:~R ^ Posz 3)^-1) +
                   reducebig 0 (bigopz.index_iotaz 1 (k + 1))
                     (fun m : int =>
                      BigBody m +%R true
                        ((-1) ^ (m + 1) /
                         ((Posz 2)%:~R * m%:~R ^ Posz 3 *
                          match n with
                          | Posz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 true true
                              | Negz m1 => binomial_rec n1 m1 true false
                              end
                          | Negz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 false true
                              | Negz m1 => binomial_rec n1 m1 false false
                              end
                          end%:~R *
                          match n + m with
                          | Posz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 true true
                              | Negz m1 => binomial_rec n1 m1 true false
                              end
                          | Negz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 false true
                              | Negz m1 => binomial_rec n1 m1 false false
                              end
                          end%:~R))))))) 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Building baseHasNat...
"equiv has been translated as equivᵗ"
Building baseHasNatCorrect...
Building base_interp_beq...
Building reflect_base_interp_beq...
Building try_make_base_transport_cps...
Building try_make_base_transport_cps_correct...
Building all_idents...
Building all_ident_and_interp...
Building buildEagerIdentAndInterpCorrect...
Building buildEagerIdent...
Building buildInterpEagerIdentCorrect...
"eq has been translated as eqᵗ"
Building toRestrictedIdentAndCorrect...
Debug:
In environment
EQ, n, m : int
H : 0 < EQ
H0 : 0 < m /\ m < EQ
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: d EQ n (int.shift 1 m); annotated_recs_d.Sm_cf0_0_0 EQ n m; d EQ n m]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Building toRestrictedIdent...
Building toFromRestrictedIdent...
Building buildIdentAndInterpCorrect...
Debug:
In environment
f0 := fun t t0 : zmodType => (0, 0)
 : forall t t0 : zmodType, GRing.Zmodule.sort t * GRing.Zmodule.sort t0
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_horner
           (fun n : int =>
            reducebig 0 (bigopz.index_iotaz 0 (n + 1))
              (fun k : int =>
               BigBody k +%R true
                 (match n with
                  | Posz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 true true
                      | Negz m1 => binomial_rec n1 m1 true false
                      end
                  | Negz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 false true
                      | Negz m1 => binomial_rec n1 m1 false false
                      end
                  end%:~R ^ Posz 2 *
                  match n + k with
                  | Posz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 true true
                      | Negz m1 => binomial_rec n1 m1 true false
                      end
                  | Negz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 false true
                      | Negz m1 => binomial_rec n1 m1 false false
                      end
                  end%:~R ^ Posz 2 *
                  (reducebig 0 (bigopz.index_iotaz 1 (n + 1))
                     (fun k0 : int =>
                      BigBody k0 +%R true (k0%:~R ^ Posz 3)^-1) +
                   reducebig 0 (bigopz.index_iotaz 1 (k + 1))
                     (fun m : int =>
                      BigBody m +%R true
                        ((-1) ^ (m + 1) /
                         ((Posz 2)%:~R * m%:~R ^ Posz 3 *
                          match n with
                          | Posz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 true true
                              | Negz m1 => binomial_rec n1 m1 true false
                              end
                          | Negz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 false true
                              | Negz m1 => binomial_rec n1 m1 false false
                              end
                          end%:~R *
                          match n + m with
                          | Posz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 true true
                              | Negz m1 => binomial_rec n1 m1 true false
                              end
                          | Negz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 false true
                              | Negz m1 => binomial_rec n1 m1 false false
                              end
                          end%:~R))))))) 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Building buildIdent...
"inverse has been translated as inverseᵗ"
Building buildInterpIdentCorrect...
Building ident_is_var_like...
Building eqv_Reflexive_Proper...
"contr has been translated as contrᵗ"
Building ident_interp_Proper...
Building invertIdent...
"weakFunext has been translated as weakFunextᵗ"
Building buildInvertIdentCorrect...
Building base_default...
Building package...
Building all_base...
Building all_idents...
Building ident_index...
Debug:
In environment
f0 := fun t t0 : zmodType => (0, 0)
 : forall t t0 : zmodType, GRing.Zmodule.sort t * GRing.Zmodule.sort t0
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: (((((0%Q + rat_of_Z 2)%Q *
             ((0%Q + rat_of_Z 2)%Q * (0%Q + rat_of_Z 2)%Q)%Q)%Q * 
            b (Posz 2))%Q +
           ((((- rat_of_Z 1)%Q *
              (((rat_of_Z 17 * (0%Q * 0%Q)%Q)%Q + (rat_of_Z 51 * 0%Q)%Q)%Q +
               rat_of_Z 39)%Q)%Q * ((rat_of_Z 2 * 0%Q)%Q + rat_of_Z 3)%Q)%Q *
            b (Posz 1))%Q)%Q +
          (((0%Q + rat_of_Z 1)%Q *
            ((0%Q + rat_of_Z 1)%Q * (0%Q + rat_of_Z 1)%Q)%Q)%Q * 
           b (Posz 0))%Q)%Q; 0%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
f0 := fun t t0 : zmodType => (0, 0)
 : forall t t0 : zmodType, GRing.Zmodule.sort t * GRing.Zmodule.sort t0
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: (((((0%Q + rat_of_Z 2)%Q *
             ((0%Q + rat_of_Z 2)%Q * (0%Q + rat_of_Z 2)%Q)%Q)%Q * 
            b (Posz 2))%Q +
           ((((- rat_of_Z 1)%Q *
              (((rat_of_Z 17 * (0%Q * 0%Q)%Q)%Q + (rat_of_Z 51 * 0%Q)%Q)%Q +
               rat_of_Z 39)%Q)%Q * ((rat_of_Z 2 * 0%Q)%Q + rat_of_Z 3)%Q)%Q *
            b (Posz 1))%Q)%Q +
          (((0%Q + rat_of_Z 1)%Q *
            ((0%Q + rat_of_Z 1)%Q * (0%Q + rat_of_Z 1)%Q)%Q)%Q * 
           b (Posz 0))%Q)%Q; 0%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Building eta_ident_cps_gen...
Building eta_ident_cps_gen_expand_literal...
Building eta_ident_cps...
Building simple_idents...
Building all_raw_idents...
Building raw_ident_index...
Building raw_ident_index_idempotent...
Building eta_raw_ident_cps_gen...
Building raw_ident_to_ident...
Building raw_ident_infos_of...
Building split_raw_ident_gen...
Building invert_bind_args...
Building invert_bind_args_unknown...
Building all_pattern_idents...
Building eta_pattern_ident_cps_gen...
Building eta_pattern_ident_cps_gen_expand_literal...
Building split_types...
Building add_types_from_raw_sig...
Crunching: (f 0 ⊗ vkron n (fun i : nat => f (i + 1)) = vkron (S n) f)
Building to_type_split_types_subst_default_eq...
Building projT1_add_types_from_raw_sig_eq...
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner b 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Building arg_types_unfolded...
Building type_of_list_arg_types_beq_unfolded...
Building to_typed_unfolded...
Debug:
In environment
f0 := fun t t0 : zmodType => (0, 0)
 : forall t t0 : zmodType, GRing.Zmodule.sort t * GRing.Zmodule.sort t0
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_horner
           (fun n : int =>
            reducebig 0 (bigopz.index_iotaz 0 (n + 1))
              (fun k : int =>
               BigBody k +%R true
                 (match n with
                  | Posz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 true true
                      | Negz m1 => binomial_rec n1 m1 true false
                      end
                  | Negz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 false true
                      | Negz m1 => binomial_rec n1 m1 false false
                      end
                  end%:~R ^ Posz 2 *
                  match n + k with
                  | Posz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 true true
                      | Negz m1 => binomial_rec n1 m1 true false
                      end
                  | Negz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 false true
                      | Negz m1 => binomial_rec n1 m1 false false
                      end
                  end%:~R ^ Posz 2 *
                  (reducebig 0 (bigopz.index_iotaz 1 (n + 1))
                     (fun k0 : int =>
                      BigBody k0 +%R true (k0%:~R ^ Posz 3)^-1) +
                   reducebig 0 (bigopz.index_iotaz 1 (k + 1))
                     (fun m : int =>
                      BigBody m +%R true
                        ((-1) ^ (m + 1) /
                         ((Posz 2)%:~R * m%:~R ^ Posz 3 *
                          match n with
                          | Posz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 true true
                              | Negz m1 => binomial_rec n1 m1 true false
                              end
                          | Negz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 false true
                              | Negz m1 => binomial_rec n1 m1 false false
                              end
                          end%:~R *
                          match n + m with
                          | Posz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 true true
                              | Negz m1 => binomial_rec n1 m1 true false
                              end
                          | Negz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 false true
                              | Negz m1 => binomial_rec n1 m1 false false
                              end
                          end%:~R))))))) 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Building of_typed_ident_unfolded...
Building arg_types_of_typed_ident_unfolded...
Debug:
In environment
f0 := fun t t0 : zmodType => (0, 0)
 : forall t t0 : zmodType, GRing.Zmodule.sort t * GRing.Zmodule.sort t0
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_horner
           (fun n : int =>
            reducebig 0 (bigopz.index_iotaz 0 (n + 1))
              (fun k : int =>
               BigBody k +%R true
                 (match n with
                  | Posz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 true true
                      | Negz m1 => binomial_rec n1 m1 true false
                      end
                  | Negz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 false true
                      | Negz m1 => binomial_rec n1 m1 false false
                      end
                  end%:~R ^ Posz 2 *
                  match n + k with
                  | Posz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 true true
                      | Negz m1 => binomial_rec n1 m1 true false
                      end
                  | Negz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 false true
                      | Negz m1 => binomial_rec n1 m1 false false
                      end
                  end%:~R ^ Posz 2 *
                  (reducebig 0 (bigopz.index_iotaz 1 (n + 1))
                     (fun k0 : int =>
                      BigBody k0 +%R true (k0%:~R ^ Posz 3)^-1) +
                   reducebig 0 (bigopz.index_iotaz 1 (k + 1))
                     (fun m : int =>
                      BigBody m +%R true
                        ((-1) ^ (m + 1) /
                         ((Posz 2)%:~R * m%:~R ^ Posz 3 *
                          match n with
                          | Posz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 true true
                              | Negz m1 => binomial_rec n1 m1 true false
                              end
                          | Negz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 false true
                              | Negz m1 => binomial_rec n1 m1 false false
                              end
                          end%:~R *
                          match n + m with
                          | Posz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 true true
                              | Negz m1 => binomial_rec n1 m1 true false
                              end
                          | Negz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 false true
                              | Negz m1 => binomial_rec n1 m1 false false
                              end
                          end%:~R))))))) 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Building unify...
Building unify_unknown...
Debug:
In environment
f0 := fun t t0 : zmodType => (0, 0)
 : forall t t0 : zmodType, GRing.Zmodule.sort t * GRing.Zmodule.sort t0
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_horner
           (fun n : int =>
            reducebig 0 (bigopz.index_iotaz 0 (n + 1))
              (fun k : int =>
               BigBody k +%R true
                 (match n with
                  | Posz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 true true
                      | Negz m1 => binomial_rec n1 m1 true false
                      end
                  | Negz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 false true
                      | Negz m1 => binomial_rec n1 m1 false false
                      end
                  end%:~R ^ Posz 2 *
                  match n + k with
                  | Posz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 true true
                      | Negz m1 => binomial_rec n1 m1 true false
                      end
                  | Negz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 false true
                      | Negz m1 => binomial_rec n1 m1 false false
                      end
                  end%:~R ^ Posz 2 *
                  (reducebig 0 (bigopz.index_iotaz 1 (n + 1))
                     (fun k0 : int =>
                      BigBody k0 +%R true (k0%:~R ^ Posz 3)^-1) +
                   reducebig 0 (bigopz.index_iotaz 1 (k + 1))
                     (fun m : int =>
                      BigBody m +%R true
                        ((-1) ^ (m + 1) /
                         ((Posz 2)%:~R * m%:~R ^ Posz 3 *
                          match n with
                          | Posz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 true true
                              | Negz m1 => binomial_rec n1 m1 true false
                              end
                          | Negz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 false true
                              | Negz m1 => binomial_rec n1 m1 false false
                              end
                          end%:~R *
                          match n + m with
                          | Posz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 true true
                              | Negz m1 => binomial_rec n1 m1 true false
                              end
                          | Negz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 false true
                              | Negz m1 => binomial_rec n1 m1 false false
                              end
                          end%:~R))))))) 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Building final ident package...
Proving is_simple_correct0...
Tactic call ran for 0.453 secs (0.444u,0.005s) (success)
Proving invert_bind_args_raw_to_typed...
Tactic call ran for 0.286 secs (0.272u,0.013s) (success)
Proving fold_invert_bind_args...
Tactic call ran for 0.032 secs (0.032u,0.s) (success)
Proving split_ident_to_ident...
Tactic call ran for 0.015 secs (0.015u,0.s) (success)
Proving eq_indep_types_of_eq_types...
Debug:
In environment
f0 := fun t t0 : zmodType => (0, 0)
 : forall t t0 : zmodType, GRing.Zmodule.sort t * GRing.Zmodule.sort t0
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: (((((0%Q + rat_of_Z 2)%Q *
             ((0%Q + rat_of_Z 2)%Q * (0%Q + rat_of_Z 2)%Q)%Q)%Q * 
            b (Posz 2))%Q +
           ((((- rat_of_Z 1)%Q *
              (((rat_of_Z 17 * (0%Q * 0%Q)%Q)%Q + (rat_of_Z 51 * 0%Q)%Q)%Q +
               rat_of_Z 39)%Q)%Q * ((rat_of_Z 2 * 0%Q)%Q + rat_of_Z 3)%Q)%Q *
            b (Posz 1))%Q)%Q +
          (((0%Q + rat_of_Z 1)%Q *
            ((0%Q + rat_of_Z 1)%Q * (0%Q + rat_of_Z 1)%Q)%Q)%Q * 
           b (Posz 0))%Q)%Q; 0%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
f0 := fun t t0 : zmodType => (0, 0)
 : forall t t0 : zmodType, GRing.Zmodule.sort t * GRing.Zmodule.sort t0
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: (((((0%Q + rat_of_Z 2)%Q *
             ((0%Q + rat_of_Z 2)%Q * (0%Q + rat_of_Z 2)%Q)%Q)%Q * 
            b (Posz 2))%Q +
           ((((- rat_of_Z 1)%Q *
              (((rat_of_Z 17 * (0%Q * 0%Q)%Q)%Q + (rat_of_Z 51 * 0%Q)%Q)%Q +
               rat_of_Z 39)%Q)%Q * ((rat_of_Z 2 * 0%Q)%Q + rat_of_Z 3)%Q)%Q *
            b (Posz 1))%Q)%Q +
          (((0%Q + rat_of_Z 1)%Q *
            ((0%Q + rat_of_Z 1)%Q * (0%Q + rat_of_Z 1)%Q)%Q)%Q * 
           b (Posz 0))%Q)%Q; 0%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Tactic call ran for 1.252 secs (1.226u,0.019s) (success)
Proving fold_eta_ident_cps...
Tactic call ran for 0.001 secs (0.001u,0.s) (success)
Proving fold_unify...
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving to_typed_of_typed_ident...
Crunching: (iterate HIS body = iterate HIS body')
Tactic call ran for 2.92 secs (2.879u,0.031s) (success)
Proving eq_invert_bind_args_unknown...
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving eq_unify_unknown...
Tactic call ran for 0. secs (0.u,0.s) (success)
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner b 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
f0 := fun t t0 : zmodType => (0, 0)
 : forall t t0 : zmodType, GRing.Zmodule.sort t * GRing.Zmodule.sort t0
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_horner
           (fun n : int =>
            reducebig 0 (bigopz.index_iotaz 0 (n + 1))
              (fun k : int =>
               BigBody k +%R true
                 (match n with
                  | Posz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 true true
                      | Negz m1 => binomial_rec n1 m1 true false
                      end
                  | Negz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 false true
                      | Negz m1 => binomial_rec n1 m1 false false
                      end
                  end%:~R ^ Posz 2 *
                  match n + k with
                  | Posz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 true true
                      | Negz m1 => binomial_rec n1 m1 true false
                      end
                  | Negz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 false true
                      | Negz m1 => binomial_rec n1 m1 false false
                      end
                  end%:~R ^ Posz 2 *
                  (reducebig 0 (bigopz.index_iotaz 1 (n + 1))
                     (fun k0 : int =>
                      BigBody k0 +%R true (k0%:~R ^ Posz 3)^-1) +
                   reducebig 0 (bigopz.index_iotaz 1 (k + 1))
                     (fun m : int =>
                      BigBody m +%R true
                        ((-1) ^ (m + 1) /
                         ((Posz 2)%:~R * m%:~R ^ Posz 3 *
                          match n with
                          | Posz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 true true
                              | Negz m1 => binomial_rec n1 m1 true false
                              end
                          | Negz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 false true
                              | Negz m1 => binomial_rec n1 m1 false false
                              end
                          end%:~R *
                          match n + m with
                          | Posz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 true true
                              | Negz m1 => binomial_rec n1 m1 true false
                              end
                          | Negz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 false true
                              | Negz m1 => binomial_rec n1 m1 false false
                              end
                          end%:~R))))))) 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
"~~~~~~~~~~~~~~~~~~"
"Translating Coq.Init.Logic.eq"
"Coq.Init.Logic.eq has been translated."
"Translating MetaCoq.Translations.MiniHoTT.paths"
"paths has been translated as pathsᵗ"
"Translating Coq.Init.Logic.False"
"Coq.Init.Logic.False has been translated."
"Translating MetaCoq.Translations.times_bool_fun.NotFunext"
"NotFunext has been translated as NotFunextᵗ"
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: (((((1%Q + rat_of_Z 2)%Q *
             ((1%Q + rat_of_Z 2)%Q * (1%Q + rat_of_Z 2)%Q)%Q)%Q *
            ((-
              ((((1%Q + rat_of_Z 1)%Q *
                 ((1%Q + rat_of_Z 1)%Q * (1%Q + rat_of_Z 1)%Q)%Q)%Q *
                b (Posz 1))%Q +
               ((((- rat_of_Z 1)%Q *
                  (((rat_of_Z 17 * (1%Q * 1%Q)%Q)%Q + (rat_of_Z 51 * 1%Q)%Q)%Q +
                   rat_of_Z 39)%Q)%Q * ((rat_of_Z 2 * 1%Q)%Q + rat_of_Z 3)%Q)%Q *
                ((-
                  ((((0%Q + rat_of_Z 1)%Q *
                     ((0%Q + rat_of_Z 1)%Q * (0%Q + rat_of_Z 1)%Q)%Q)%Q *
                    b (Posz 0))%Q +
                   ((((- rat_of_Z 1)%Q *
                      (((rat_of_Z 17 * (0%Q * 0%Q)%Q)%Q +
                        (rat_of_Z 51 * 0%Q)%Q)%Q + 
                       rat_of_Z 39)%Q)%Q *
                     ((rat_of_Z 2 * 0%Q)%Q + rat_of_Z 3)%Q)%Q * 
                    b (Posz 1))%Q)%Q)%Q *
                 (((0%Q + rat_of_Z 2)%Q *
                   ((0%Q + rat_of_Z 2)%Q * (0%Q + rat_of_Z 2)%Q)%Q)%Q^-1)%Q)%Q)%Q)%Q)%Q *
             (((1%Q + rat_of_Z 2)%Q *
               ((1%Q + rat_of_Z 2)%Q * (1%Q + rat_of_Z 2)%Q)%Q)%Q^-1)%Q)%Q)%Q +
           ((((- rat_of_Z 1)%Q *
              (((rat_of_Z 17 * (1%Q * 1%Q)%Q)%Q + (rat_of_Z 51 * 1%Q)%Q)%Q +
               rat_of_Z 39)%Q)%Q * ((rat_of_Z 2 * 1%Q)%Q + rat_of_Z 3)%Q)%Q *
            ((-
              ((((0%Q + rat_of_Z 1)%Q *
                 ((0%Q + rat_of_Z 1)%Q * (0%Q + rat_of_Z 1)%Q)%Q)%Q *
                b (Posz 0))%Q +
               ((((- rat_of_Z 1)%Q *
                  (((rat_of_Z 17 * (0%Q * 0%Q)%Q)%Q + (rat_of_Z 51 * 0%Q)%Q)%Q +
                   rat_of_Z 39)%Q)%Q * ((rat_of_Z 2 * 0%Q)%Q + rat_of_Z 3)%Q)%Q *
                b (Posz 1))%Q)%Q)%Q *
             (((0%Q + rat_of_Z 2)%Q *
               ((0%Q + rat_of_Z 2)%Q * (0%Q + rat_of_Z 2)%Q)%Q)%Q^-1)%Q)%Q)%Q)%Q +
          (((1%Q + rat_of_Z 1)%Q *
            ((1%Q + rat_of_Z 1)%Q * (1%Q + rat_of_Z 1)%Q)%Q)%Q * 
           b (Posz 1))%Q)%Q; 0%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: (((((1%Q + rat_of_Z 2)%Q *
             ((1%Q + rat_of_Z 2)%Q * (1%Q + rat_of_Z 2)%Q)%Q)%Q *
            ((-
              ((((1%Q + rat_of_Z 1)%Q *
                 ((1%Q + rat_of_Z 1)%Q * (1%Q + rat_of_Z 1)%Q)%Q)%Q *
                b (Posz 1))%Q +
               ((((- rat_of_Z 1)%Q *
                  (((rat_of_Z 17 * (1%Q * 1%Q)%Q)%Q + (rat_of_Z 51 * 1%Q)%Q)%Q +
                   rat_of_Z 39)%Q)%Q * ((rat_of_Z 2 * 1%Q)%Q + rat_of_Z 3)%Q)%Q *
                ((-
                  ((((0%Q + rat_of_Z 1)%Q *
                     ((0%Q + rat_of_Z 1)%Q * (0%Q + rat_of_Z 1)%Q)%Q)%Q *
                    b (Posz 0))%Q +
                   ((((- rat_of_Z 1)%Q *
                      (((rat_of_Z 17 * (0%Q * 0%Q)%Q)%Q +
                        (rat_of_Z 51 * 0%Q)%Q)%Q + 
                       rat_of_Z 39)%Q)%Q *
                     ((rat_of_Z 2 * 0%Q)%Q + rat_of_Z 3)%Q)%Q * 
                    b (Posz 1))%Q)%Q)%Q *
                 (((0%Q + rat_of_Z 2)%Q *
                   ((0%Q + rat_of_Z 2)%Q * (0%Q + rat_of_Z 2)%Q)%Q)%Q^-1)%Q)%Q)%Q)%Q)%Q *
             (((1%Q + rat_of_Z 2)%Q *
               ((1%Q + rat_of_Z 2)%Q * (1%Q + rat_of_Z 2)%Q)%Q)%Q^-1)%Q)%Q)%Q +
           ((((- rat_of_Z 1)%Q *
              (((rat_of_Z 17 * (1%Q * 1%Q)%Q)%Q + (rat_of_Z 51 * 1%Q)%Q)%Q +
               rat_of_Z 39)%Q)%Q * ((rat_of_Z 2 * 1%Q)%Q + rat_of_Z 3)%Q)%Q *
            ((-
              ((((0%Q + rat_of_Z 1)%Q *
                 ((0%Q + rat_of_Z 1)%Q * (0%Q + rat_of_Z 1)%Q)%Q)%Q *
                b (Posz 0))%Q +
               ((((- rat_of_Z 1)%Q *
                  (((rat_of_Z 17 * (0%Q * 0%Q)%Q)%Q + (rat_of_Z 51 * 0%Q)%Q)%Q +
                   rat_of_Z 39)%Q)%Q * ((rat_of_Z 2 * 0%Q)%Q + rat_of_Z 3)%Q)%Q *
                b (Posz 1))%Q)%Q)%Q *
             (((0%Q + rat_of_Z 2)%Q *
               ((0%Q + rat_of_Z 2)%Q * (0%Q + rat_of_Z 2)%Q)%Q)%Q^-1)%Q)%Q)%Q)%Q +
          (((1%Q + rat_of_Z 1)%Q *
            ((1%Q + rat_of_Z 1)%Q * (1%Q + rat_of_Z 1)%Q)%Q)%Q * 
           b (Posz 1))%Q)%Q; 0%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Reifying...
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: (((((1%Q + rat_of_Z 2)%Q *
             ((1%Q + rat_of_Z 2)%Q * (1%Q + rat_of_Z 2)%Q)%Q)%Q *
            ((-
              ((((1%Q + rat_of_Z 1)%Q *
                 ((1%Q + rat_of_Z 1)%Q * (1%Q + rat_of_Z 1)%Q)%Q)%Q *
                b (Posz 1))%Q +
               ((((- rat_of_Z 1)%Q *
                  (((rat_of_Z 17 * (1%Q * 1%Q)%Q)%Q + (rat_of_Z 51 * 1%Q)%Q)%Q +
                   rat_of_Z 39)%Q)%Q * ((rat_of_Z 2 * 1%Q)%Q + rat_of_Z 3)%Q)%Q *
                ((-
                  ((((0%Q + rat_of_Z 1)%Q *
                     ((0%Q + rat_of_Z 1)%Q * (0%Q + rat_of_Z 1)%Q)%Q)%Q *
                    b (Posz 0))%Q +
                   ((((- rat_of_Z 1)%Q *
                      (((rat_of_Z 17 * (0%Q * 0%Q)%Q)%Q +
                        (rat_of_Z 51 * 0%Q)%Q)%Q + 
                       rat_of_Z 39)%Q)%Q *
                     ((rat_of_Z 2 * 0%Q)%Q + rat_of_Z 3)%Q)%Q * 
                    b (Posz 1))%Q)%Q)%Q *
                 (((0%Q + rat_of_Z 2)%Q *
                   ((0%Q + rat_of_Z 2)%Q * (0%Q + rat_of_Z 2)%Q)%Q)%Q^-1)%Q)%Q)%Q)%Q)%Q *
             (((1%Q + rat_of_Z 2)%Q *
               ((1%Q + rat_of_Z 2)%Q * (1%Q + rat_of_Z 2)%Q)%Q)%Q^-1)%Q)%Q)%Q +
           ((((- rat_of_Z 1)%Q *
              (((rat_of_Z 17 * (1%Q * 1%Q)%Q)%Q + (rat_of_Z 51 * 1%Q)%Q)%Q +
               rat_of_Z 39)%Q)%Q * ((rat_of_Z 2 * 1%Q)%Q + rat_of_Z 3)%Q)%Q *
            ((-
              ((((0%Q + rat_of_Z 1)%Q *
                 ((0%Q + rat_of_Z 1)%Q * (0%Q + rat_of_Z 1)%Q)%Q)%Q *
                b (Posz 0))%Q +
               ((((- rat_of_Z 1)%Q *
                  (((rat_of_Z 17 * (0%Q * 0%Q)%Q)%Q + (rat_of_Z 51 * 0%Q)%Q)%Q +
                   rat_of_Z 39)%Q)%Q * ((rat_of_Z 2 * 0%Q)%Q + rat_of_Z 3)%Q)%Q *
                b (Posz 1))%Q)%Q)%Q *
             (((0%Q + rat_of_Z 2)%Q *
               ((0%Q + rat_of_Z 2)%Q * (0%Q + rat_of_Z 2)%Q)%Q)%Q^-1)%Q)%Q)%Q)%Q +
          (((1%Q + rat_of_Z 1)%Q *
            ((1%Q + rat_of_Z 1)%Q * (1%Q + rat_of_Z 1)%Q)%Q)%Q * 
           b (Posz 1))%Q)%Q; 0%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: (((((1%Q + rat_of_Z 2)%Q *
             ((1%Q + rat_of_Z 2)%Q * (1%Q + rat_of_Z 2)%Q)%Q)%Q *
            ((-
              ((((1%Q + rat_of_Z 1)%Q *
                 ((1%Q + rat_of_Z 1)%Q * (1%Q + rat_of_Z 1)%Q)%Q)%Q *
                b (Posz 1))%Q +
               ((((- rat_of_Z 1)%Q *
                  (((rat_of_Z 17 * (1%Q * 1%Q)%Q)%Q + (rat_of_Z 51 * 1%Q)%Q)%Q +
                   rat_of_Z 39)%Q)%Q * ((rat_of_Z 2 * 1%Q)%Q + rat_of_Z 3)%Q)%Q *
                ((-
                  ((((0%Q + rat_of_Z 1)%Q *
                     ((0%Q + rat_of_Z 1)%Q * (0%Q + rat_of_Z 1)%Q)%Q)%Q *
                    b (Posz 0))%Q +
                   ((((- rat_of_Z 1)%Q *
                      (((rat_of_Z 17 * (0%Q * 0%Q)%Q)%Q +
                        (rat_of_Z 51 * 0%Q)%Q)%Q + 
                       rat_of_Z 39)%Q)%Q *
                     ((rat_of_Z 2 * 0%Q)%Q + rat_of_Z 3)%Q)%Q * 
                    b (Posz 1))%Q)%Q)%Q *
                 (((0%Q + rat_of_Z 2)%Q *
                   ((0%Q + rat_of_Z 2)%Q * (0%Q + rat_of_Z 2)%Q)%Q)%Q^-1)%Q)%Q)%Q)%Q)%Q *
             (((1%Q + rat_of_Z 2)%Q *
               ((1%Q + rat_of_Z 2)%Q * (1%Q + rat_of_Z 2)%Q)%Q)%Q^-1)%Q)%Q)%Q +
           ((((- rat_of_Z 1)%Q *
              (((rat_of_Z 17 * (1%Q * 1%Q)%Q)%Q + (rat_of_Z 51 * 1%Q)%Q)%Q +
               rat_of_Z 39)%Q)%Q * ((rat_of_Z 2 * 1%Q)%Q + rat_of_Z 3)%Q)%Q *
            ((-
              ((((0%Q + rat_of_Z 1)%Q *
                 ((0%Q + rat_of_Z 1)%Q * (0%Q + rat_of_Z 1)%Q)%Q)%Q *
                b (Posz 0))%Q +
               ((((- rat_of_Z 1)%Q *
                  (((rat_of_Z 17 * (0%Q * 0%Q)%Q)%Q + (rat_of_Z 51 * 0%Q)%Q)%Q +
                   rat_of_Z 39)%Q)%Q * ((rat_of_Z 2 * 0%Q)%Q + rat_of_Z 3)%Q)%Q *
                b (Posz 1))%Q)%Q)%Q *
             (((0%Q + rat_of_Z 2)%Q *
               ((0%Q + rat_of_Z 2)%Q * (0%Q + rat_of_Z 2)%Q)%Q)%Q^-1)%Q)%Q)%Q)%Q +
          (((1%Q + rat_of_Z 1)%Q *
            ((1%Q + rat_of_Z 1)%Q * (1%Q + rat_of_Z 1)%Q)%Q)%Q * 
           b (Posz 1))%Q)%Q; 0%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: ((((match rat_of_Z 2 with
             | {| valq := y |} =>
                 fracq
                   (let (y1, y2) := y in
                    match y2 with
                    | Posz 1 =>
                        match y1 with
                        | Posz 0 => (1%R, 1%R)
                        | Posz 1 => (Posz 2, 1%R)
                        | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                        | Negz _ => ((1 + y1)%R, 1%R)
                        end
                    | _ => ((1 * y2 + y1)%R, y2)
                    end)
             end *
             (match rat_of_Z 2 with
              | {| valq := y |} =>
                  fracq
                    (let (y1, y2) := y in
                     match y2 with
                     | Posz 1 =>
                         match y1 with
                         | Posz 0 => (1%R, 1%R)
                         | Posz 1 => (Posz 2, 1%R)
                         | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                         | Negz _ => ((1 + y1)%R, 1%R)
                         end
                     | _ => ((1 * y2 + y1)%R, y2)
                     end)
              end *
              match rat_of_Z 2 with
              | {| valq := y |} =>
                  fracq
                    (let (y1, y2) := y in
                     match y2 with
                     | Posz 1 =>
                         match y1 with
                         | Posz 0 => (1%R, 1%R)
                         | Posz 1 => (Posz 2, 1%R)
                         | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                         | Negz _ => ((1 + y1)%R, 1%R)
                         end
                     | _ => ((1 * y2 + y1)%R, y2)
                     end)
              end)%Q)%Q *
            ((-
              (((match rat_of_Z 1 with
                 | {| valq := y |} =>
                     fracq
                       (let (y1, y2) := y in
                        match y2 with
                        | Posz 1 =>
                            match y1 with
                            | Posz 0 => (1%R, 1%R)
                            | Posz 1 => (Posz 2, 1%R)
                            | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                            | Negz _ => ((1 + y1)%R, 1%R)
                            end
                        | _ => ((1 * y2 + y1)%R, y2)
                        end)
                 end *
                 (match rat_of_Z 1 with
                  | {| valq := y |} =>
                      fracq
                        (let (y1, y2) := y in
                         match y2 with
                         | Posz 1 =>
                             match y1 with
                             | Posz 0 => (1%R, 1%R)
                             | Posz 1 => (Posz 2, 1%R)
                             | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                             | Negz _ => ((1 + y1)%R, 1%R)
                             end
                         | _ => ((1 * y2 + y1)%R, y2)
                         end)
                  end *
                  match rat_of_Z 1 with
                  | {| valq := y |} =>
                      fracq
                        (let (y1, y2) := y in
                         match y2 with
                         | Posz 1 =>
                             match y1 with
                             | Posz 0 => (1%R, 1%R)
                             | Posz 1 => (Posz 2, 1%R)
                             | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                             | Negz _ => ((1 + y1)%R, 1%R)
                             end
                         | _ => ((1 * y2 + y1)%R, y2)
                         end)
                  end)%Q)%Q * b (Posz 1))%Q +
               ((((- rat_of_Z 1)%Q *
                  (((rat_of_Z 17 * fracq (1%R, 1%R))%Q +
                    (rat_of_Z 51 * 1%Q)%Q)%Q + rat_of_Z 39)%Q)%Q *
                 ((rat_of_Z 2 * 1%Q)%Q + rat_of_Z 3)%Q)%Q *
                ((-
                  (((match rat_of_Z 1 with
                     | {| valq := y |} =>
                         fracq
                           (let (y1, y2) := y in
                            match y2 with
                            | Posz 1 => (y1, 1%R)
                            | _ => ((0 * y2 + y1)%R, y2)
                            end)
                     end *
                     (match rat_of_Z 1 with
                      | {| valq := y |} =>
                          fracq
                            (let (y1, y2) := y in
                             match y2 with
                             | Posz 1 => (y1, 1%R)
                             | _ => ((0 * y2 + y1)%R, y2)
                             end)
                      end *
                      match rat_of_Z 1 with
                      | {| valq := y |} =>
                          fracq
                            (let (y1, y2) := y in
                             match y2 with
                             | Posz 1 => (y1, 1%R)
                             | _ => ((0 * y2 + y1)%R, y2)
                             end)
                      end)%Q)%Q * b (Posz 0))%Q +
                   ((((- rat_of_Z 1)%Q *
                      (((rat_of_Z 17 * fracq (0%R, 1%R))%Q +
                        (rat_of_Z 51 * 0%Q)%Q)%Q + 
                       rat_of_Z 39)%Q)%Q *
                     ((rat_of_Z 2 * 0%Q)%Q + rat_of_Z 3)%Q)%Q * 
                    b (Posz 1))%Q)%Q)%Q *
                 ((match rat_of_Z 2 with
                   | {| valq := y |} =>
                       fracq
                         (let (y1, y2) := y in
                          match y2 with
                          | Posz 1 => (y1, 1%R)
                          | _ => ((0 * y2 + y1)%R, y2)
                          end)
                   end *
                   (match rat_of_Z 2 with
                    | {| valq := y |} =>
                        fracq
                          (let (y1, y2) := y in
                           match y2 with
                           | Posz 1 => (y1, 1%R)
                           | _ => ((0 * y2 + y1)%R, y2)
                           end)
                    end *
                    match rat_of_Z 2 with
                    | {| valq := y |} =>
                        fracq
                          (let (y1, y2) := y in
                           match y2 with
                           | Posz 1 => (y1, 1%R)
                           | _ => ((0 * y2 + y1)%R, y2)
                           end)
                    end)%Q)%Q^-1)%Q)%Q)%Q)%Q)%Q *
             ((match rat_of_Z 2 with
               | {| valq := y |} =>
                   fracq
                     (let (y1, y2) := y in
                      match y2 with
                      | Posz 1 =>
                          match y1 with
                          | Posz 0 => (1%R, 1%R)
                          | Posz 1 => (Posz 2, 1%R)
                          | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                          | Negz _ => ((1 + y1)%R, 1%R)
                          end
                      | _ => ((1 * y2 + y1)%R, y2)
                      end)
               end *
               (match rat_of_Z 2 with
                | {| valq := y |} =>
                    fracq
                      (let (y1, y2) := y in
                       match y2 with
                       | Posz 1 =>
                           match y1 with
                           | Posz 0 => (1%R, 1%R)
                           | Posz 1 => (Posz 2, 1%R)
                           | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                           | Negz _ => ((1 + y1)%R, 1%R)
                           end
                       | _ => ((1 * y2 + y1)%R, y2)
                       end)
                end *
                match rat_of_Z 2 with
                | {| valq := y |} =>
                    fracq
                      (let (y1, y2) := y in
                       match y2 with
                       | Posz 1 =>
                           match y1 with
                           | Posz 0 => (1%R, 1%R)
                           | Posz 1 => (Posz 2, 1%R)
                           | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                           | Negz _ => ((1 + y1)%R, 1%R)
                           end
                       | _ => ((1 * y2 + y1)%R, y2)
                       end)
                end)%Q)%Q^-1)%Q)%Q)%Q +
           ((((- rat_of_Z 1)%Q *
              (((rat_of_Z 17 * fracq (1%R, 1%R))%Q + (rat_of_Z 51 * 1%Q)%Q)%Q +
               rat_of_Z 39)%Q)%Q * ((rat_of_Z 2 * 1%Q)%Q + rat_of_Z 3)%Q)%Q *
            ((-
              (((match rat_of_Z 1 with
                 | {| valq := y |} =>
                     fracq
                       (let (y1, y2) := y in
                        match y2 with
                        | Posz 1 => (y1, 1%R)
                        | _ => ((0 * y2 + y1)%R, y2)
                        end)
                 end *
                 (match rat_of_Z 1 with
                  | {| valq := y |} =>
                      fracq
                        (let (y1, y2) := y in
                         match y2 with
                         | Posz 1 => (y1, 1%R)
                         | _ => ((0 * y2 + y1)%R, y2)
                         end)
                  end *
                  match rat_of_Z 1 with
                  | {| valq := y |} =>
                      fracq
                        (let (y1, y2) := y in
                         match y2 with
                         | Posz 1 => (y1, 1%R)
                         | _ => ((0 * y2 + y1)%R, y2)
                         end)
                  end)%Q)%Q * b (Posz 0))%Q +
               ((((- rat_of_Z 1)%Q *
                  (((rat_of_Z 17 * fracq (0%R, 1%R))%Q +
                    (rat_of_Z 51 * 0%Q)%Q)%Q + rat_of_Z 39)%Q)%Q *
                 ((rat_of_Z 2 * 0%Q)%Q + rat_of_Z 3)%Q)%Q * 
                b (Posz 1))%Q)%Q)%Q *
             ((match rat_of_Z 2 with
               | {| valq := y |} =>
                   fracq
                     (let (y1, y2) := y in
                      match y2 with
                      | Posz 1 => (y1, 1%R)
                      | _ => ((0 * y2 + y1)%R, y2)
                      end)
               end *
               (match rat_of_Z 2 with
                | {| valq := y |} =>
                    fracq
                      (let (y1, y2) := y in
                       match y2 with
                       | Posz 1 => (y1, 1%R)
                       | _ => ((0 * y2 + y1)%R, y2)
                       end)
                end *
                match rat_of_Z 2 with
                | {| valq := y |} =>
                    fracq
                      (let (y1, y2) := y in
                       match y2 with
                       | Posz 1 => (y1, 1%R)
                       | _ => ((0 * y2 + y1)%R, y2)
                       end)
                end)%Q)%Q^-1)%Q)%Q)%Q)%Q +
          ((match rat_of_Z 1 with
            | {| valq := y |} =>
                fracq
                  (let (y1, y2) := y in
                   match y2 with
                   | Posz 1 =>
                       match y1 with
                       | Posz 0 => (1%R, 1%R)
                       | Posz 1 => (Posz 2, 1%R)
                       | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                       | Negz _ => ((1 + y1)%R, 1%R)
                       end
                   | _ => ((1 * y2 + y1)%R, y2)
                   end)
            end *
            (match rat_of_Z 1 with
             | {| valq := y |} =>
                 fracq
                   (let (y1, y2) := y in
                    match y2 with
                    | Posz 1 =>
                        match y1 with
                        | Posz 0 => (1%R, 1%R)
                        | Posz 1 => (Posz 2, 1%R)
                        | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                        | Negz _ => ((1 + y1)%R, 1%R)
                        end
                    | _ => ((1 * y2 + y1)%R, y2)
                    end)
             end *
             match rat_of_Z 1 with
             | {| valq := y |} =>
                 fracq
                   (let (y1, y2) := y in
                    match y2 with
                    | Posz 1 =>
                        match y1 with
                        | Posz 0 => (1%R, 1%R)
                        | Posz 1 => (Posz 2, 1%R)
                        | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                        | Negz _ => ((1 + y1)%R, 1%R)
                        end
                    | _ => ((1 * y2 + y1)%R, y2)
                    end)
             end)%Q)%Q * b (Posz 1))%Q)%Q; 0%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner b 1]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching:
(forall f : nat -> Vector 2,
 (forall i : nat, WF_Matrix (f i)) ->
 f 0 ⊗ vkron a (shift f 1) = vkron (S a) f)
Crunching:
(Forall (fun r : R => IZR (0 * 0) <= r < 1) Hm ->
 (forall r : R, IZR (0 * 0) <= r < 1 -> H r = body' r) ->
 iterate Hm H = iterate Hm body')
Crunching:
(Forall (fun r : R => 0 <= r < 1) Hm ->
 (forall r : R, 0 <= r < 1 -> H r = body' r) ->
 iterate Hm H = iterate Hm body')
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: (((((1%Q + rat_of_Z 2)%Q *
             ((1%Q + rat_of_Z 2)%Q * (1%Q + rat_of_Z 2)%Q)%Q)%Q *
            ((-
              ((((1%Q + rat_of_Z 1)%Q *
                 ((1%Q + rat_of_Z 1)%Q * (1%Q + rat_of_Z 1)%Q)%Q)%Q *
                b (Posz 1))%Q +
               ((((- rat_of_Z 1)%Q *
                  (((rat_of_Z 17 * (1%Q * 1%Q)%Q)%Q + (rat_of_Z 51 * 1%Q)%Q)%Q +
                   rat_of_Z 39)%Q)%Q * ((rat_of_Z 2 * 1%Q)%Q + rat_of_Z 3)%Q)%Q *
                ((-
                  ((((0%Q + rat_of_Z 1)%Q *
                     ((0%Q + rat_of_Z 1)%Q * (0%Q + rat_of_Z 1)%Q)%Q)%Q *
                    b (Posz 0))%Q +
                   ((((- rat_of_Z 1)%Q *
                      (((rat_of_Z 17 * (0%Q * 0%Q)%Q)%Q +
                        (rat_of_Z 51 * 0%Q)%Q)%Q + 
                       rat_of_Z 39)%Q)%Q *
                     ((rat_of_Z 2 * 0%Q)%Q + rat_of_Z 3)%Q)%Q * 
                    b (Posz 1))%Q)%Q)%Q *
                 (((0%Q + rat_of_Z 2)%Q *
                   ((0%Q + rat_of_Z 2)%Q * (0%Q + rat_of_Z 2)%Q)%Q)%Q^-1)%Q)%Q)%Q)%Q)%Q *
             (((1%Q + rat_of_Z 2)%Q *
               ((1%Q + rat_of_Z 2)%Q * (1%Q + rat_of_Z 2)%Q)%Q)%Q^-1)%Q)%Q)%Q +
           ((((- rat_of_Z 1)%Q *
              (((rat_of_Z 17 * (1%Q * 1%Q)%Q)%Q + (rat_of_Z 51 * 1%Q)%Q)%Q +
               rat_of_Z 39)%Q)%Q * ((rat_of_Z 2 * 1%Q)%Q + rat_of_Z 3)%Q)%Q *
            ((-
              ((((0%Q + rat_of_Z 1)%Q *
                 ((0%Q + rat_of_Z 1)%Q * (0%Q + rat_of_Z 1)%Q)%Q)%Q *
                b (Posz 0))%Q +
               ((((- rat_of_Z 1)%Q *
                  (((rat_of_Z 17 * (0%Q * 0%Q)%Q)%Q + (rat_of_Z 51 * 0%Q)%Q)%Q +
                   rat_of_Z 39)%Q)%Q * ((rat_of_Z 2 * 0%Q)%Q + rat_of_Z 3)%Q)%Q *
                b (Posz 1))%Q)%Q)%Q *
             (((0%Q + rat_of_Z 2)%Q *
               ((0%Q + rat_of_Z 2)%Q * (0%Q + rat_of_Z 2)%Q)%Q)%Q^-1)%Q)%Q)%Q)%Q +
          (((1%Q + rat_of_Z 1)%Q *
            ((1%Q + rat_of_Z 1)%Q * (1%Q + rat_of_Z 1)%Q)%Q)%Q * 
           b (Posz 1))%Q)%Q; 0%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: (((((1%Q + rat_of_Z 2)%Q *
             ((1%Q + rat_of_Z 2)%Q * (1%Q + rat_of_Z 2)%Q)%Q)%Q *
            ((-
              ((((1%Q + rat_of_Z 1)%Q *
                 ((1%Q + rat_of_Z 1)%Q * (1%Q + rat_of_Z 1)%Q)%Q)%Q *
                b (Posz 1))%Q +
               ((((- rat_of_Z 1)%Q *
                  (((rat_of_Z 17 * (1%Q * 1%Q)%Q)%Q + (rat_of_Z 51 * 1%Q)%Q)%Q +
                   rat_of_Z 39)%Q)%Q * ((rat_of_Z 2 * 1%Q)%Q + rat_of_Z 3)%Q)%Q *
                ((-
                  ((((0%Q + rat_of_Z 1)%Q *
                     ((0%Q + rat_of_Z 1)%Q * (0%Q + rat_of_Z 1)%Q)%Q)%Q *
                    b (Posz 0))%Q +
                   ((((- rat_of_Z 1)%Q *
                      (((rat_of_Z 17 * (0%Q * 0%Q)%Q)%Q +
                        (rat_of_Z 51 * 0%Q)%Q)%Q + 
                       rat_of_Z 39)%Q)%Q *
                     ((rat_of_Z 2 * 0%Q)%Q + rat_of_Z 3)%Q)%Q * 
                    b (Posz 1))%Q)%Q)%Q *
                 (((0%Q + rat_of_Z 2)%Q *
                   ((0%Q + rat_of_Z 2)%Q * (0%Q + rat_of_Z 2)%Q)%Q)%Q^-1)%Q)%Q)%Q)%Q)%Q *
             (((1%Q + rat_of_Z 2)%Q *
               ((1%Q + rat_of_Z 2)%Q * (1%Q + rat_of_Z 2)%Q)%Q)%Q^-1)%Q)%Q)%Q +
           ((((- rat_of_Z 1)%Q *
              (((rat_of_Z 17 * (1%Q * 1%Q)%Q)%Q + (rat_of_Z 51 * 1%Q)%Q)%Q +
               rat_of_Z 39)%Q)%Q * ((rat_of_Z 2 * 1%Q)%Q + rat_of_Z 3)%Q)%Q *
            ((-
              ((((0%Q + rat_of_Z 1)%Q *
                 ((0%Q + rat_of_Z 1)%Q * (0%Q + rat_of_Z 1)%Q)%Q)%Q *
                b (Posz 0))%Q +
               ((((- rat_of_Z 1)%Q *
                  (((rat_of_Z 17 * (0%Q * 0%Q)%Q)%Q + (rat_of_Z 51 * 0%Q)%Q)%Q +
                   rat_of_Z 39)%Q)%Q * ((rat_of_Z 2 * 0%Q)%Q + rat_of_Z 3)%Q)%Q *
                b (Posz 1))%Q)%Q)%Q *
             (((0%Q + rat_of_Z 2)%Q *
               ((0%Q + rat_of_Z 2)%Q * (0%Q + rat_of_Z 2)%Q)%Q)%Q^-1)%Q)%Q)%Q)%Q +
          (((1%Q + rat_of_Z 1)%Q *
            ((1%Q + rat_of_Z 1)%Q * (1%Q + rat_of_Z 1)%Q)%Q)%Q * 
           b (Posz 1))%Q)%Q; 0%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Compiling decision tree...
Splitting rewrite rules...
Crunching: (f 0 ⊗ vkron n (fun i : nat => f (i + 1)) = vkron (S n) f)
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: fracq
           ((valq
               (((match rat_of_Z 2 with
                  | {| valq := y |} =>
                      fracq
                        (let (y1, y2) := y in
                         match y2 with
                         | Posz 1 =>
                             match y1 with
                             | Posz 0 => (1%R, 1%R)
                             | Posz 1 => (Posz 2, 1%R)
                             | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                             | Negz _ => ((1 + y1)%R, 1%R)
                             end
                         | _ => ((1 * y2 + y1)%R, y2)
                         end)
                  end *
                  (match rat_of_Z 2 with
                   | {| valq := y |} =>
                       fracq
                         (let (y1, y2) := y in
                          match y2 with
                          | Posz 1 =>
                              match y1 with
                              | Posz 0 => (1%R, 1%R)
                              | Posz 1 => (Posz 2, 1%R)
                              | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                              | Negz _ => ((1 + y1)%R, 1%R)
                              end
                          | _ => ((1 * y2 + y1)%R, y2)
                          end)
                   end *
                   match rat_of_Z 2 with
                   | {| valq := y |} =>
                       fracq
                         (let (y1, y2) := y in
                          match y2 with
                          | Posz 1 =>
                              match y1 with
                              | Posz 0 => (1%R, 1%R)
                              | Posz 1 => (Posz 2, 1%R)
                              | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                              | Negz _ => ((1 + y1)%R, 1%R)
                              end
                          | _ => ((1 * y2 + y1)%R, y2)
                          end)
                   end)%Q)%Q *
                 ((-
                   (((match rat_of_Z 1 with
                      | {| valq := y |} =>
                          fracq
                            (let (y1, y2) := y in
                             match y2 with
                             | Posz 1 =>
                                 match y1 with
                                 | Posz 0 => (1%R, 1%R)
                                 | Posz 1 => (Posz 2, 1%R)
                                 | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                                 | Negz _ => ((1 + y1)%R, 1%R)
                                 end
                             | _ => ((1 * y2 + y1)%R, y2)
                             end)
                      end *
                      (match rat_of_Z 1 with
                       | {| valq := y |} =>
                           fracq
                             (let (y1, y2) := y in
                              match y2 with
                              | Posz 1 =>
                                  match y1 with
                                  | Posz 0 => (1%R, 1%R)
                                  | Posz 1 => (Posz 2, 1%R)
                                  | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                                  | Negz _ => ((1 + y1)%R, 1%R)
                                  end
                              | _ => ((1 * y2 + y1)%R, y2)
                              end)
                       end *
                       match rat_of_Z 1 with
                       | {| valq := y |} =>
                           fracq
                             (let (y1, y2) := y in
                              match y2 with
                              | Posz 1 =>
                                  match y1 with
                                  | Posz 0 => (1%R, 1%R)
                                  | Posz 1 => (Posz 2, 1%R)
                                  | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                                  | Negz _ => ((1 + y1)%R, 1%R)
                                  end
                              | _ => ((1 * y2 + y1)%R, y2)
                              end)
                       end)%Q)%Q * b (Posz 1))%Q +
                    ((((- rat_of_Z 1)%Q *
                       (((rat_of_Z 17 * fracq ((1 * 1)%R, 1%R))%Q +
                         (rat_of_Z 51 * 1%Q)%Q)%Q + 
                        rat_of_Z 39)%Q)%Q *
                      ((rat_of_Z 2 * 1%Q)%Q + rat_of_Z 3)%Q)%Q *
                     ((-
                       (((match rat_of_Z 1 with
                          | {| valq := y |} =>
                              fracq
                                (let (y1, y2) := y in
                                 match y2 with
                                 | Posz 1 => (y1, 1%R)
                                 | _ => ((0 * y2 + y1)%R, y2)
                                 end)
                          end *
                          (match rat_of_Z 1 with
                           | {| valq := y |} =>
                               fracq
                                 (let (y1, y2) := y in
                                  match y2 with
                                  | Posz 1 => (y1, 1%R)
                                  | _ => ((0 * y2 + y1)%R, y2)
                                  end)
                           end *
                           match rat_of_Z 1 with
                           | {| valq := y |} =>
                               fracq
                                 (let (y1, y2) := y in
                                  match y2 with
                                  | Posz 1 => (y1, 1%R)
                                  | _ => ((0 * y2 + y1)%R, y2)
                                  end)
                           end)%Q)%Q * b (Posz 0))%Q +
                        ((((- rat_of_Z 1)%Q *
                           (((rat_of_Z 17 * fracq ((0 * 0)%R, 1%R))%Q +
                             (rat_of_Z 51 * 0%Q)%Q)%Q + 
                            rat_of_Z 39)%Q)%Q *
                          ((rat_of_Z 2 * 0%Q)%Q + rat_of_Z 3)%Q)%Q *
                         b (Posz 1))%Q)%Q)%Q *
                      ((match rat_of_Z 2 with
                        | {| valq := y |} =>
                            fracq
                              (let (y1, y2) := y in
                               match y2 with
                               | Posz 1 => (y1, 1%R)
                               | _ => ((0 * y2 + y1)%R, y2)
                               end)
                        end *
                        (match rat_of_Z 2 with
                         | {| valq := y |} =>
                             fracq
                               (let (y1, y2) := y in
                                match y2 with
                                | Posz 1 => (y1, 1%R)
                                | _ => ((0 * y2 + y1)%R, y2)
                                end)
                         end *
                         match rat_of_Z 2 with
                         | {| valq := y |} =>
                             fracq
                               (let (y1, y2) := y in
                                match y2 with
                                | Posz 1 => (y1, 1%R)
                                | _ => ((0 * y2 + y1)%R, y2)
                                end)
                         end)%Q)%Q^-1)%Q)%Q)%Q)%Q)%Q *
                  ((match rat_of_Z 2 with
                    | {| valq := y |} =>
                        fracq
                          (let (y1, y2) := y in
                           match y2 with
                           | Posz 1 =>
                               match y1 with
                               | Posz 0 => (1%R, 1%R)
                               | Posz 1 => (Posz 2, 1%R)
                               | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                               | Negz _ => ((1 + y1)%R, 1%R)
                               end
                           | _ => ((1 * y2 + y1)%R, y2)
                           end)
                    end *
                    (match rat_of_Z 2 with
                     | {| valq := y |} =>
                         fracq
                           (let (y1, y2) := y in
                            match y2 with
                            | Posz 1 =>
                                match y1 with
                                | Posz 0 => (1%R, 1%R)
                                | Posz 1 => (Posz 2, 1%R)
                                | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                                | Negz _ => ((1 + y1)%R, 1%R)
                                end
                            | _ => ((1 * y2 + y1)%R, y2)
                            end)
                     end *
                     match rat_of_Z 2 with
                     | {| valq := y |} =>
                         fracq
                           (let (y1, y2) := y in
                            match y2 with
                            | Posz 1 =>
                                match y1 with
                                | Posz 0 => (1%R, 1%R)
                                | Posz 1 => (Posz 2, 1%R)
                                | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                                | Negz _ => ((1 + y1)%R, 1%R)
                                end
                            | _ => ((1 * y2 + y1)%R, y2)
                            end)
                     end)%Q)%Q^-1)%Q)%Q)%Q +
                ((((- rat_of_Z 1)%Q *
                   (((rat_of_Z 17 * fracq ((1 * 1)%R, 1%R))%Q +
                     (rat_of_Z 51 * 1%Q)%Q)%Q + rat_of_Z 39)%Q)%Q *
                  ((rat_of_Z 2 * 1%Q)%Q + rat_of_Z 3)%Q)%Q *
                 ((-
                   (((match rat_of_Z 1 with
                      | {| valq := y |} =>
                          fracq
                            (let (y1, y2) := y in
                             match y2 with
                             | Posz 1 => (y1, 1%R)
                             | _ => ((0 * y2 + y1)%R, y2)
                             end)
                      end *
                      (match rat_of_Z 1 with
                       | {| valq := y |} =>
                           fracq
                             (let (y1, y2) := y in
                              match y2 with
                              | Posz 1 => (y1, 1%R)
                              | _ => ((0 * y2 + y1)%R, y2)
                              end)
                       end *
                       match rat_of_Z 1 with
                       | {| valq := y |} =>
                           fracq
                             (let (y1, y2) := y in
                              match y2 with
                              | Posz 1 => (y1, 1%R)
                              | _ => ((0 * y2 + y1)%R, y2)
                              end)
                       end)%Q)%Q * b (Posz 0))%Q +
                    ((((- rat_of_Z 1)%Q *
                       (((rat_of_Z 17 * fracq ((0 * 0)%R, 1%R))%Q +
                         (rat_of_Z 51 * 0%Q)%Q)%Q + 
                        rat_of_Z 39)%Q)%Q *
                      ((rat_of_Z 2 * 0%Q)%Q + rat_of_Z 3)%Q)%Q * 
                     b (Posz 1))%Q)%Q)%Q *
                  ((match rat_of_Z 2 with
                    | {| valq := y |} =>
                        fracq
                          (let (y1, y2) := y in
                           match y2 with
                           | Posz 1 => (y1, 1%R)
                           | _ => ((0 * y2 + y1)%R, y2)
                           end)
                    end *
                    (match rat_of_Z 2 with
                     | {| valq := y |} =>
                         fracq
                           (let (y1, y2) := y in
                            match y2 with
                            | Posz 1 => (y1, 1%R)
                            | _ => ((0 * y2 + y1)%R, y2)
                            end)
                     end *
                     match rat_of_Z 2 with
                     | {| valq := y |} =>
                         fracq
                           (let (y1, y2) := y in
                            match y2 with
                            | Posz 1 => (y1, 1%R)
                            | _ => ((0 * y2 + y1)%R, y2)
                            end)
                     end)%Q)%Q^-1)%Q)%Q)%Q)%Q).1 *
            (valq
               ((match rat_of_Z 1 with
                 | {| valq := y |} =>
                     fracq
                       (let (y1, y2) := y in
                        match y2 with
                        | Posz 1 =>
                            match y1 with
                            | Posz 0 => (1%R, 1%R)
                            | Posz 1 => (Posz 2, 1%R)
                            | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                            | Negz _ => ((1 + y1)%R, 1%R)
                            end
                        | _ => ((1 * y2 + y1)%R, y2)
                        end)
                 end *
                 (match rat_of_Z 1 with
                  | {| valq := y |} =>
                      fracq
                        (let (y1, y2) := y in
                         match y2 with
                         | Posz 1 =>
                             match y1 with
                             | Posz 0 => (1%R, 1%R)
                             | Posz 1 => (Posz 2, 1%R)
                             | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                             | Negz _ => ((1 + y1)%R, 1%R)
                             end
                         | _ => ((1 * y2 + y1)%R, y2)
                         end)
                  end *
                  match rat_of_Z 1 with
                  | {| valq := y |} =>
                      fracq
                        (let (y1, y2) := y in
                         match y2 with
                         | Posz 1 =>
                             match y1 with
                             | Posz 0 => (1%R, 1%R)
                             | Posz 1 => (Posz 2, 1%R)
                             | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                             | Negz _ => ((1 + y1)%R, 1%R)
                             end
                         | _ => ((1 * y2 + y1)%R, y2)
                         end)
                  end)%Q)%Q * b (Posz 1))%Q).2 +
            (valq
               ((match rat_of_Z 1 with
                 | {| valq := y |} =>
                     fracq
                       (let (y1, y2) := y in
                        match y2 with
                        | Posz 1 =>
                            match y1 with
                            | Posz 0 => (1%R, 1%R)
                            | Posz 1 => (Posz 2, 1%R)
                            | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                            | Negz _ => ((1 + y1)%R, 1%R)
                            end
                        | _ => ((1 * y2 + y1)%R, y2)
                        end)
                 end *
                 (match rat_of_Z 1 with
                  | {| valq := y |} =>
                      fracq
                        (let (y1, y2) := y in
                         match y2 with
                         | Posz 1 =>
                             match y1 with
                             | Posz 0 => (1%R, 1%R)
                             | Posz 1 => (Posz 2, 1%R)
                             | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                             | Negz _ => ((1 + y1)%R, 1%R)
                             end
                         | _ => ((1 * y2 + y1)%R, y2)
                         end)
                  end *
                  match rat_of_Z 1 with
                  | {| valq := y |} =>
                      fracq
                        (let (y1, y2) := y in
                         match y2 with
                         | Posz 1 =>
                             match y1 with
                             | Posz 0 => (1%R, 1%R)
                             | Posz 1 => (Posz 2, 1%R)
                             | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                             | Negz _ => ((1 + y1)%R, 1%R)
                             end
                         | _ => ((1 * y2 + y1)%R, y2)
                         end)
                  end)%Q)%Q * b (Posz 1))%Q).1 *
            (valq
               (((match rat_of_Z 2 with
                  | {| valq := y |} =>
                      fracq
                        (let (y1, y2) := y in
                         match y2 with
                         | Posz 1 =>
                             match y1 with
                             | Posz 0 => (1%R, 1%R)
                             | Posz 1 => (Posz 2, 1%R)
                             | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                             | Negz _ => ((1 + y1)%R, 1%R)
                             end
                         | _ => ((1 * y2 + y1)%R, y2)
                         end)
                  end *
                  (match rat_of_Z 2 with
                   | {| valq := y |} =>
                       fracq
                         (let (y1, y2) := y in
                          match y2 with
                          | Posz 1 =>
                              match y1 with
                              | Posz 0 => (1%R, 1%R)
                              | Posz 1 => (Posz 2, 1%R)
                              | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                              | Negz _ => ((1 + y1)%R, 1%R)
                              end
                          | _ => ((1 * y2 + y1)%R, y2)
                          end)
                   end *
                   match rat_of_Z 2 with
                   | {| valq := y |} =>
                       fracq
                         (let (y1, y2) := y in
                          match y2 with
                          | Posz 1 =>
                              match y1 with
                              | Posz 0 => (1%R, 1%R)
                              | Posz 1 => (Posz 2, 1%R)
                              | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                              | Negz _ => ((1 + y1)%R, 1%R)
                              end
                          | _ => ((1 * y2 + y1)%R, y2)
                          end)
                   end)%Q)%Q *
                 ((-
                   (((match rat_of_Z 1 with
                      | {| valq := y |} =>
                          fracq
                            (let (y1, y2) := y in
                             match y2 with
                             | Posz 1 =>
                                 match y1 with
                                 | Posz 0 => (1%R, 1%R)
                                 | Posz 1 => (Posz 2, 1%R)
                                 | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                                 | Negz _ => ((1 + y1)%R, 1%R)
                                 end
                             | _ => ((1 * y2 + y1)%R, y2)
                             end)
                      end *
                      (match rat_of_Z 1 with
                       | {| valq := y |} =>
                           fracq
                             (let (y1, y2) := y in
                              match y2 with
                              | Posz 1 =>
                                  match y1 with
                                  | Posz 0 => (1%R, 1%R)
                                  | Posz 1 => (Posz 2, 1%R)
                                  | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                                  | Negz _ => ((1 + y1)%R, 1%R)
                                  end
                              | _ => ((1 * y2 + y1)%R, y2)
                              end)
                       end *
                       match rat_of_Z 1 with
                       | {| valq := y |} =>
                           fracq
                             (let (y1, y2) := y in
                              match y2 with
                              | Posz 1 =>
                                  match y1 with
                                  | Posz 0 => (1%R, 1%R)
                                  | Posz 1 => (Posz 2, 1%R)
                                  | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                                  | Negz _ => ((1 + y1)%R, 1%R)
                                  end
                              | _ => ((1 * y2 + y1)%R, y2)
                              end)
                       end)%Q)%Q * b (Posz 1))%Q +
                    ((((- rat_of_Z 1)%Q *
                       (((rat_of_Z 17 * fracq ((1 * 1)%R, 1%R))%Q +
                         (rat_of_Z 51 * 1%Q)%Q)%Q + 
                        rat_of_Z 39)%Q)%Q *
                      ((rat_of_Z 2 * 1%Q)%Q + rat_of_Z 3)%Q)%Q *
                     ((-
                       (((match rat_of_Z 1 with
                          | {| valq := y |} =>
                              fracq
                                (let (y1, y2) := y in
                                 match y2 with
                                 | Posz 1 => (y1, 1%R)
                                 | _ => ((0 * y2 + y1)%R, y2)
                                 end)
                          end *
                          (match rat_of_Z 1 with
                           | {| valq := y |} =>
                               fracq
                                 (let (y1, y2) := y in
                                  match y2 with
                                  | Posz 1 => (y1, 1%R)
                                  | _ => ((0 * y2 + y1)%R, y2)
                                  end)
                           end *
                           match rat_of_Z 1 with
                           | {| valq := y |} =>
                               fracq
                                 (let (y1, y2) := y in
                                  match y2 with
                                  | Posz 1 => (y1, 1%R)
                                  | _ => ((0 * y2 + y1)%R, y2)
                                  end)
                           end)%Q)%Q * b (Posz 0))%Q +
                        ((((- rat_of_Z 1)%Q *
                           (((rat_of_Z 17 * fracq ((0 * 0)%R, 1%R))%Q +
                             (rat_of_Z 51 * 0%Q)%Q)%Q + 
                            rat_of_Z 39)%Q)%Q *
                          ((rat_of_Z 2 * 0%Q)%Q + rat_of_Z 3)%Q)%Q *
                         b (Posz 1))%Q)%Q)%Q *
                      ((match rat_of_Z 2 with
                        | {| valq := y |} =>
                            fracq
                              (let (y1, y2) := y in
                               match y2 with
                               | Posz 1 => (y1, 1%R)
                               | _ => ((0 * y2 + y1)%R, y2)
                               end)
                        end *
                        (match rat_of_Z 2 with
                         | {| valq := y |} =>
                             fracq
                               (let (y1, y2) := y in
                                match y2 with
                                | Posz 1 => (y1, 1%R)
                                | _ => ((0 * y2 + y1)%R, y2)
                                end)
                         end *
                         match rat_of_Z 2 with
                         | {| valq := y |} =>
                             fracq
                               (let (y1, y2) := y in
                                match y2 with
                                | Posz 1 => (y1, 1%R)
                                | _ => ((0 * y2 + y1)%R, y2)
                                end)
                         end)%Q)%Q^-1)%Q)%Q)%Q)%Q)%Q *
                  ((match rat_of_Z 2 with
                    | {| valq := y |} =>
                        fracq
                          (let (y1, y2) := y in
                           match y2 with
                           | Posz 1 =>
                               match y1 with
                               | Posz 0 => (1%R, 1%R)
                               | Posz 1 => (Posz 2, 1%R)
                               | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                               | Negz _ => ((1 + y1)%R, 1%R)
                               end
                           | _ => ((1 * y2 + y1)%R, y2)
                           end)
                    end *
                    (match rat_of_Z 2 with
                     | {| valq := y |} =>
                         fracq
                           (let (y1, y2) := y in
                            match y2 with
                            | Posz 1 =>
                                match y1 with
                                | Posz 0 => (1%R, 1%R)
                                | Posz 1 => (Posz 2, 1%R)
                                | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                                | Negz _ => ((1 + y1)%R, 1%R)
                                end
                            | _ => ((1 * y2 + y1)%R, y2)
                            end)
                     end *
                     match rat_of_Z 2 with
                     | {| valq := y |} =>
                         fracq
                           (let (y1, y2) := y in
                            match y2 with
                            | Posz 1 =>
                                match y1 with
                                | Posz 0 => (1%R, 1%R)
                                | Posz 1 => (Posz 2, 1%R)
                                | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                                | Negz _ => ((1 + y1)%R, 1%R)
                                end
                            | _ => ((1 * y2 + y1)%R, y2)
                            end)
                     end)%Q)%Q^-1)%Q)%Q)%Q +
                ((((- rat_of_Z 1)%Q *
                   (((rat_of_Z 17 * fracq ((1 * 1)%R, 1%R))%Q +
                     (rat_of_Z 51 * 1%Q)%Q)%Q + rat_of_Z 39)%Q)%Q *
                  ((rat_of_Z 2 * 1%Q)%Q + rat_of_Z 3)%Q)%Q *
                 ((-
                   (((match rat_of_Z 1 with
                      | {| valq := y |} =>
                          fracq
                            (let (y1, y2) := y in
                             match y2 with
                             | Posz 1 => (y1, 1%R)
                             | _ => ((0 * y2 + y1)%R, y2)
                             end)
                      end *
                      (match rat_of_Z 1 with
                       | {| valq := y |} =>
                           fracq
                             (let (y1, y2) := y in
                              match y2 with
                              | Posz 1 => (y1, 1%R)
                              | _ => ((0 * y2 + y1)%R, y2)
                              end)
                       end *
                       match rat_of_Z 1 with
                       | {| valq := y |} =>
                           fracq
                             (let (y1, y2) := y in
                              match y2 with
                              | Posz 1 => (y1, 1%R)
                              | _ => ((0 * y2 + y1)%R, y2)
                              end)
                       end)%Q)%Q * b (Posz 0))%Q +
                    ((((- rat_of_Z 1)%Q *
                       (((rat_of_Z 17 * fracq ((0 * 0)%R, 1%R))%Q +
                         (rat_of_Z 51 * 0%Q)%Q)%Q + 
                        rat_of_Z 39)%Q)%Q *
                      ((rat_of_Z 2 * 0%Q)%Q + rat_of_Z 3)%Q)%Q * 
                     b (Posz 1))%Q)%Q)%Q *
                  ((match rat_of_Z 2 with
                    | {| valq := y |} =>
                        fracq
                          (let (y1, y2) := y in
                           match y2 with
                           | Posz 1 => (y1, 1%R)
                           | _ => ((0 * y2 + y1)%R, y2)
                           end)
                    end *
                    (match rat_of_Z 2 with
                     | {| valq := y |} =>
                         fracq
                           (let (y1, y2) := y in
                            match y2 with
                            | Posz 1 => (y1, 1%R)
                            | _ => ((0 * y2 + y1)%R, y2)
                            end)
                     end *
                     match rat_of_Z 2 with
                     | {| valq := y |} =>
                         fracq
                           (let (y1, y2) := y in
                            match y2 with
                            | Posz 1 => (y1, 1%R)
                            | _ => ((0 * y2 + y1)%R, y2)
                            end)
                     end)%Q)%Q^-1)%Q)%Q)%Q)%Q).2,
           (valq
              (((match rat_of_Z 2 with
                 | {| valq := y |} =>
                     fracq
                       (let (y1, y2) := y in
                        match y2 with
                        | Posz 1 =>
                            match y1 with
                            | Posz 0 => (1%R, 1%R)
                            | Posz 1 => (Posz 2, 1%R)
                            | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                            | Negz _ => ((1 + y1)%R, 1%R)
                            end
                        | _ => ((1 * y2 + y1)%R, y2)
                        end)
                 end *
                 (match rat_of_Z 2 with
                  | {| valq := y |} =>
                      fracq
                        (let (y1, y2) := y in
                         match y2 with
                         | Posz 1 =>
                             match y1 with
                             | Posz 0 => (1%R, 1%R)
                             | Posz 1 => (Posz 2, 1%R)
                             | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                             | Negz _ => ((1 + y1)%R, 1%R)
                             end
                         | _ => ((1 * y2 + y1)%R, y2)
                         end)
                  end *
                  match rat_of_Z 2 with
                  | {| valq := y |} =>
                      fracq
                        (let (y1, y2) := y in
                         match y2 with
                         | Posz 1 =>
                             match y1 with
                             | Posz 0 => (1%R, 1%R)
                             | Posz 1 => (Posz 2, 1%R)
                             | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                             | Negz _ => ((1 + y1)%R, 1%R)
                             end
                         | _ => ((1 * y2 + y1)%R, y2)
                         end)
                  end)%Q)%Q *
                ((-
                  (((match rat_of_Z 1 with
                     | {| valq := y |} =>
                         fracq
                           (let (y1, y2) := y in
                            match y2 with
                            | Posz 1 =>
                                match y1 with
                                | Posz 0 => (1%R, 1%R)
                                | Posz 1 => (Posz 2, 1%R)
                                | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                                | Negz _ => ((1 + y1)%R, 1%R)
                                end
                            | _ => ((1 * y2 + y1)%R, y2)
                            end)
                     end *
                     (match rat_of_Z 1 with
                      | {| valq := y |} =>
                          fracq
                            (let (y1, y2) := y in
                             match y2 with
                             | Posz 1 =>
                                 match y1 with
                                 | Posz 0 => (1%R, 1%R)
                                 | Posz 1 => (Posz 2, 1%R)
                                 | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                                 | Negz _ => ((1 + y1)%R, 1%R)
                                 end
                             | _ => ((1 * y2 + y1)%R, y2)
                             end)
                      end *
                      match rat_of_Z 1 with
                      | {| valq := y |} =>
                          fracq
                            (let (y1, y2) := y in
                             match y2 with
                             | Posz 1 =>
                                 match y1 with
                                 | Posz 0 => (1%R, 1%R)
                                 | Posz 1 => (Posz 2, 1%R)
                                 | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                                 | Negz _ => ((1 + y1)%R, 1%R)
                                 end
                             | _ => ((1 * y2 + y1)%R, y2)
                             end)
                      end)%Q)%Q * b (Posz 1))%Q +
                   ((((- rat_of_Z 1)%Q *
                      (((rat_of_Z 17 * fracq ((1 * 1)%R, 1%R))%Q +
                        (rat_of_Z 51 * 1%Q)%Q)%Q + 
                       rat_of_Z 39)%Q)%Q *
                     ((rat_of_Z 2 * 1%Q)%Q + rat_of_Z 3)%Q)%Q *
                    ((-
                      (((match rat_of_Z 1 with
                         | {| valq := y |} =>
                             fracq
                               (let (y1, y2) := y in
                                match y2 with
                                | Posz 1 => (y1, 1%R)
                                | _ => ((0 * y2 + y1)%R, y2)
                                end)
                         end *
                         (match rat_of_Z 1 with
                          | {| valq := y |} =>
                              fracq
                                (let (y1, y2) := y in
                                 match y2 with
                                 | Posz 1 => (y1, 1%R)
                                 | _ => ((0 * y2 + y1)%R, y2)
                                 end)
                          end *
                          match rat_of_Z 1 with
                          | {| valq := y |} =>
                              fracq
                                (let (y1, y2) := y in
                                 match y2 with
                                 | Posz 1 => (y1, 1%R)
                                 | _ => ((0 * y2 + y1)%R, y2)
                                 end)
                          end)%Q)%Q * b (Posz 0))%Q +
                       ((((- rat_of_Z 1)%Q *
                          (((rat_of_Z 17 * fracq ((0 * 0)%R, 1%R))%Q +
                            (rat_of_Z 51 * 0%Q)%Q)%Q + 
                           rat_of_Z 39)%Q)%Q *
                         ((rat_of_Z 2 * 0%Q)%Q + rat_of_Z 3)%Q)%Q *
                        b (Posz 1))%Q)%Q)%Q *
                     ((match rat_of_Z 2 with
                       | {| valq := y |} =>
                           fracq
                             (let (y1, y2) := y in
                              match y2 with
                              | Posz 1 => (y1, 1%R)
                              | _ => ((0 * y2 + y1)%R, y2)
                              end)
                       end *
                       (match rat_of_Z 2 with
                        | {| valq := y |} =>
                            fracq
                              (let (y1, y2) := y in
                               match y2 with
                               | Posz 1 => (y1, 1%R)
                               | _ => ((0 * y2 + y1)%R, y2)
                               end)
                        end *
                        match rat_of_Z 2 with
                        | {| valq := y |} =>
                            fracq
                              (let (y1, y2) := y in
                               match y2 with
                               | Posz 1 => (y1, 1%R)
                               | _ => ((0 * y2 + y1)%R, y2)
                               end)
                        end)%Q)%Q^-1)%Q)%Q)%Q)%Q)%Q *
                 ((match rat_of_Z 2 with
                   | {| valq := y |} =>
                       fracq
                         (let (y1, y2) := y in
                          match y2 with
                          | Posz 1 =>
                              match y1 with
                              | Posz 0 => (1%R, 1%R)
                              | Posz 1 => (Posz 2, 1%R)
                              | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                              | Negz _ => ((1 + y1)%R, 1%R)
                              end
                          | _ => ((1 * y2 + y1)%R, y2)
                          end)
                   end *
                   (match rat_of_Z 2 with
                    | {| valq := y |} =>
                        fracq
                          (let (y1, y2) := y in
                           match y2 with
                           | Posz 1 =>
                               match y1 with
                               | Posz 0 => (1%R, 1%R)
                               | Posz 1 => (Posz 2, 1%R)
                               | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                               | Negz _ => ((1 + y1)%R, 1%R)
                               end
                           | _ => ((1 * y2 + y1)%R, y2)
                           end)
                    end *
                    match rat_of_Z 2 with
                    | {| valq := y |} =>
                        fracq
                          (let (y1, y2) := y in
                           match y2 with
                           | Posz 1 =>
                               match y1 with
                               | Posz 0 => (1%R, 1%R)
                               | Posz 1 => (Posz 2, 1%R)
                               | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                               | Negz _ => ((1 + y1)%R, 1%R)
                               end
                           | _ => ((1 * y2 + y1)%R, y2)
                           end)
                    end)%Q)%Q^-1)%Q)%Q)%Q +
               ((((- rat_of_Z 1)%Q *
                  (((rat_of_Z 17 * fracq ((1 * 1)%R, 1%R))%Q +
                    (rat_of_Z 51 * 1%Q)%Q)%Q + rat_of_Z 39)%Q)%Q *
                 ((rat_of_Z 2 * 1%Q)%Q + rat_of_Z 3)%Q)%Q *
                ((-
                  (((match rat_of_Z 1 with
                     | {| valq := y |} =>
                         fracq
                           (let (y1, y2) := y in
                            match y2 with
                            | Posz 1 => (y1, 1%R)
                            | _ => ((0 * y2 + y1)%R, y2)
                            end)
                     end *
                     (match rat_of_Z 1 with
                      | {| valq := y |} =>
                          fracq
                            (let (y1, y2) := y in
                             match y2 with
                             | Posz 1 => (y1, 1%R)
                             | _ => ((0 * y2 + y1)%R, y2)
                             end)
                      end *
                      match rat_of_Z 1 with
                      | {| valq := y |} =>
                          fracq
                            (let (y1, y2) := y in
                             match y2 with
                             | Posz 1 => (y1, 1%R)
                             | _ => ((0 * y2 + y1)%R, y2)
                             end)
                      end)%Q)%Q * b (Posz 0))%Q +
                   ((((- rat_of_Z 1)%Q *
                      (((rat_of_Z 17 * fracq ((0 * 0)%R, 1%R))%Q +
                        (rat_of_Z 51 * 0%Q)%Q)%Q + 
                       rat_of_Z 39)%Q)%Q *
                     ((rat_of_Z 2 * 0%Q)%Q + rat_of_Z 3)%Q)%Q * 
                    b (Posz 1))%Q)%Q)%Q *
                 ((match rat_of_Z 2 with
                   | {| valq := y |} =>
                       fracq
                         (let (y1, y2) := y in
                          match y2 with
                          | Posz 1 => (y1, 1%R)
                          | _ => ((0 * y2 + y1)%R, y2)
                          end)
                   end *
                   (match rat_of_Z 2 with
                    | {| valq := y |} =>
                        fracq
                          (let (y1, y2) := y in
                           match y2 with
                           | Posz 1 => (y1, 1%R)
                           | _ => ((0 * y2 + y1)%R, y2)
                           end)
                    end *
                    match rat_of_Z 2 with
                    | {| valq := y |} =>
                        fracq
                          (let (y1, y2) := y in
                           match y2 with
                           | Posz 1 => (y1, 1%R)
                           | _ => ((0 * y2 + y1)%R, y2)
                           end)
                    end)%Q)%Q^-1)%Q)%Q)%Q)%Q).2 *
           (valq
              ((match rat_of_Z 1 with
                | {| valq := y |} =>
                    fracq
                      (let (y1, y2) := y in
                       match y2 with
                       | Posz 1 =>
                           match y1 with
                           | Posz 0 => (1%R, 1%R)
                           | Posz 1 => (Posz 2, 1%R)
                           | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                           | Negz _ => ((1 + y1)%R, 1%R)
                           end
                       | _ => ((1 * y2 + y1)%R, y2)
                       end)
                end *
                (match rat_of_Z 1 with
                 | {| valq := y |} =>
                     fracq
                       (let (y1, y2) := y in
                        match y2 with
                        | Posz 1 =>
                            match y1 with
                            | Posz 0 => (1%R, 1%R)
                            | Posz 1 => (Posz 2, 1%R)
                            | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                            | Negz _ => ((1 + y1)%R, 1%R)
                            end
                        | _ => ((1 * y2 + y1)%R, y2)
                        end)
                 end *
                 match rat_of_Z 1 with
                 | {| valq := y |} =>
                     fracq
                       (let (y1, y2) := y in
                        match y2 with
                        | Posz 1 =>
                            match y1 with
                            | Posz 0 => (1%R, 1%R)
                            | Posz 1 => (Posz 2, 1%R)
                            | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                            | Negz _ => ((1 + y1)%R, 1%R)
                            end
                        | _ => ((1 * y2 + y1)%R, y2)
                        end)
                 end)%Q)%Q * b (Posz 1))%Q).2); 0%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Assembling rewrite_head...
Reducing rewrite_head...
Tactic call ran for 0.251 secs (0.249u,0.s) (success)
Tactic call ran for 0.265 secs (0.264u,0.s) (success)
Tactic call ran for 0.186 secs (0.184u,0.s) (success)
Assembling rewrite_head_no_dtree...
Reducing rewrite_head_no_dtree...
Proving Rewriter_Wf...
Tactic call ran for 0.151 secs (0.149u,0.001s) (success)
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: ((((match rat_of_Z 2 with
             | {| valq := y |} =>
                 fracq
                   (let (y1, y2) := y in
                    match y2 with
                    | Posz 1 =>
                        match y1 with
                        | Posz 0 => (1%R, 1%R)
                        | Posz 1 => (Posz 2, 1%R)
                        | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                        | Negz _ => ((1 + y1)%R, 1%R)
                        end
                    | _ => ((1 * y2 + y1)%R, y2)
                    end)
             end *
             (match rat_of_Z 2 with
              | {| valq := y |} =>
                  fracq
                    (let (y1, y2) := y in
                     match y2 with
                     | Posz 1 =>
                         match y1 with
                         | Posz 0 => (1%R, 1%R)
                         | Posz 1 => (Posz 2, 1%R)
                         | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                         | Negz _ => ((1 + y1)%R, 1%R)
                         end
                     | _ => ((1 * y2 + y1)%R, y2)
                     end)
              end *
              match rat_of_Z 2 with
              | {| valq := y |} =>
                  fracq
                    (let (y1, y2) := y in
                     match y2 with
                     | Posz 1 =>
                         match y1 with
                         | Posz 0 => (1%R, 1%R)
                         | Posz 1 => (Posz 2, 1%R)
                         | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                         | Negz _ => ((1 + y1)%R, 1%R)
                         end
                     | _ => ((1 * y2 + y1)%R, y2)
                     end)
              end)%Q)%Q *
            ((-
              (((match rat_of_Z 1 with
                 | {| valq := y |} =>
                     fracq
                       (let (y1, y2) := y in
                        match y2 with
                        | Posz 1 =>
                            match y1 with
                            | Posz 0 => (1%R, 1%R)
                            | Posz 1 => (Posz 2, 1%R)
                            | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                            | Negz _ => ((1 + y1)%R, 1%R)
                            end
                        | _ => ((1 * y2 + y1)%R, y2)
                        end)
                 end *
                 (match rat_of_Z 1 with
                  | {| valq := y |} =>
                      fracq
                        (let (y1, y2) := y in
                         match y2 with
                         | Posz 1 =>
                             match y1 with
                             | Posz 0 => (1%R, 1%R)
                             | Posz 1 => (Posz 2, 1%R)
                             | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                             | Negz _ => ((1 + y1)%R, 1%R)
                             end
                         | _ => ((1 * y2 + y1)%R, y2)
                         end)
                  end *
                  match rat_of_Z 1 with
                  | {| valq := y |} =>
                      fracq
                        (let (y1, y2) := y in
                         match y2 with
                         | Posz 1 =>
                             match y1 with
                             | Posz 0 => (1%R, 1%R)
                             | Posz 1 => (Posz 2, 1%R)
                             | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                             | Negz _ => ((1 + y1)%R, 1%R)
                             end
                         | _ => ((1 * y2 + y1)%R, y2)
                         end)
                  end)%Q)%Q * b (Posz 1))%Q +
               ((((- rat_of_Z 1)%Q *
                  (((rat_of_Z 17 * fracq (1%R, 1%R))%Q +
                    (rat_of_Z 51 * 1%Q)%Q)%Q + rat_of_Z 39)%Q)%Q *
                 ((rat_of_Z 2 * 1%Q)%Q + rat_of_Z 3)%Q)%Q *
                ((-
                  (((match rat_of_Z 1 with
                     | {| valq := y |} =>
                         fracq
                           (let (y1, y2) := y in
                            match y2 with
                            | Posz 1 => (y1, 1%R)
                            | _ => ((0 * y2 + y1)%R, y2)
                            end)
                     end *
                     (match rat_of_Z 1 with
                      | {| valq := y |} =>
                          fracq
                            (let (y1, y2) := y in
                             match y2 with
                             | Posz 1 => (y1, 1%R)
                             | _ => ((0 * y2 + y1)%R, y2)
                             end)
                      end *
                      match rat_of_Z 1 with
                      | {| valq := y |} =>
                          fracq
                            (let (y1, y2) := y in
                             match y2 with
                             | Posz 1 => (y1, 1%R)
                             | _ => ((0 * y2 + y1)%R, y2)
                             end)
                      end)%Q)%Q * b (Posz 0))%Q +
                   ((((- rat_of_Z 1)%Q *
                      (((rat_of_Z 17 * fracq (0%R, 1%R))%Q +
                        (rat_of_Z 51 * 0%Q)%Q)%Q + 
                       rat_of_Z 39)%Q)%Q *
                     ((rat_of_Z 2 * 0%Q)%Q + rat_of_Z 3)%Q)%Q * 
                    b (Posz 1))%Q)%Q)%Q *
                 ((match rat_of_Z 2 with
                   | {| valq := y |} =>
                       fracq
                         (let (y1, y2) := y in
                          match y2 with
                          | Posz 1 => (y1, 1%R)
                          | _ => ((0 * y2 + y1)%R, y2)
                          end)
                   end *
                   (match rat_of_Z 2 with
                    | {| valq := y |} =>
                        fracq
                          (let (y1, y2) := y in
                           match y2 with
                           | Posz 1 => (y1, 1%R)
                           | _ => ((0 * y2 + y1)%R, y2)
                           end)
                    end *
                    match rat_of_Z 2 with
                    | {| valq := y |} =>
                        fracq
                          (let (y1, y2) := y in
                           match y2 with
                           | Posz 1 => (y1, 1%R)
                           | _ => ((0 * y2 + y1)%R, y2)
                           end)
                    end)%Q)%Q^-1)%Q)%Q)%Q)%Q)%Q *
             ((match rat_of_Z 2 with
               | {| valq := y |} =>
                   fracq
                     (let (y1, y2) := y in
                      match y2 with
                      | Posz 1 =>
                          match y1 with
                          | Posz 0 => (1%R, 1%R)
                          | Posz 1 => (Posz 2, 1%R)
                          | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                          | Negz _ => ((1 + y1)%R, 1%R)
                          end
                      | _ => ((1 * y2 + y1)%R, y2)
                      end)
               end *
               (match rat_of_Z 2 with
                | {| valq := y |} =>
                    fracq
                      (let (y1, y2) := y in
                       match y2 with
                       | Posz 1 =>
                           match y1 with
                           | Posz 0 => (1%R, 1%R)
                           | Posz 1 => (Posz 2, 1%R)
                           | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                           | Negz _ => ((1 + y1)%R, 1%R)
                           end
                       | _ => ((1 * y2 + y1)%R, y2)
                       end)
                end *
                match rat_of_Z 2 with
                | {| valq := y |} =>
                    fracq
                      (let (y1, y2) := y in
                       match y2 with
                       | Posz 1 =>
                           match y1 with
                           | Posz 0 => (1%R, 1%R)
                           | Posz 1 => (Posz 2, 1%R)
                           | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                           | Negz _ => ((1 + y1)%R, 1%R)
                           end
                       | _ => ((1 * y2 + y1)%R, y2)
                       end)
                end)%Q)%Q^-1)%Q)%Q)%Q +
           ((((- rat_of_Z 1)%Q *
              (((rat_of_Z 17 * fracq (1%R, 1%R))%Q + (rat_of_Z 51 * 1%Q)%Q)%Q +
               rat_of_Z 39)%Q)%Q * ((rat_of_Z 2 * 1%Q)%Q + rat_of_Z 3)%Q)%Q *
            ((-
              (((match rat_of_Z 1 with
                 | {| valq := y |} =>
                     fracq
                       (let (y1, y2) := y in
                        match y2 with
                        | Posz 1 => (y1, 1%R)
                        | _ => ((0 * y2 + y1)%R, y2)
                        end)
                 end *
                 (match rat_of_Z 1 with
                  | {| valq := y |} =>
                      fracq
                        (let (y1, y2) := y in
                         match y2 with
                         | Posz 1 => (y1, 1%R)
                         | _ => ((0 * y2 + y1)%R, y2)
                         end)
                  end *
                  match rat_of_Z 1 with
                  | {| valq := y |} =>
                      fracq
                        (let (y1, y2) := y in
                         match y2 with
                         | Posz 1 => (y1, 1%R)
                         | _ => ((0 * y2 + y1)%R, y2)
                         end)
                  end)%Q)%Q * b (Posz 0))%Q +
               ((((- rat_of_Z 1)%Q *
                  (((rat_of_Z 17 * fracq (0%R, 1%R))%Q +
                    (rat_of_Z 51 * 0%Q)%Q)%Q + rat_of_Z 39)%Q)%Q *
                 ((rat_of_Z 2 * 0%Q)%Q + rat_of_Z 3)%Q)%Q * 
                b (Posz 1))%Q)%Q)%Q *
             ((match rat_of_Z 2 with
               | {| valq := y |} =>
                   fracq
                     (let (y1, y2) := y in
                      match y2 with
                      | Posz 1 => (y1, 1%R)
                      | _ => ((0 * y2 + y1)%R, y2)
                      end)
               end *
               (match rat_of_Z 2 with
                | {| valq := y |} =>
                    fracq
                      (let (y1, y2) := y in
                       match y2 with
                       | Posz 1 => (y1, 1%R)
                       | _ => ((0 * y2 + y1)%R, y2)
                       end)
                end *
                match rat_of_Z 2 with
                | {| valq := y |} =>
                    fracq
                      (let (y1, y2) := y in
                       match y2 with
                       | Posz 1 => (y1, 1%R)
                       | _ => ((0 * y2 + y1)%R, y2)
                       end)
                end)%Q)%Q^-1)%Q)%Q)%Q)%Q +
          ((match rat_of_Z 1 with
            | {| valq := y |} =>
                fracq
                  (let (y1, y2) := y in
                   match y2 with
                   | Posz 1 =>
                       match y1 with
                       | Posz 0 => (1%R, 1%R)
                       | Posz 1 => (Posz 2, 1%R)
                       | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                       | Negz _ => ((1 + y1)%R, 1%R)
                       end
                   | _ => ((1 * y2 + y1)%R, y2)
                   end)
            end *
            (match rat_of_Z 1 with
             | {| valq := y |} =>
                 fracq
                   (let (y1, y2) := y in
                    match y2 with
                    | Posz 1 =>
                        match y1 with
                        | Posz 0 => (1%R, 1%R)
                        | Posz 1 => (Posz 2, 1%R)
                        | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                        | Negz _ => ((1 + y1)%R, 1%R)
                        end
                    | _ => ((1 * y2 + y1)%R, y2)
                    end)
             end *
             match rat_of_Z 1 with
             | {| valq := y |} =>
                 fracq
                   (let (y1, y2) := y in
                    match y2 with
                    | Posz 1 =>
                        match y1 with
                        | Posz 0 => (1%R, 1%R)
                        | Posz 1 => (Posz 2, 1%R)
                        | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                        | Negz _ => ((1 + y1)%R, 1%R)
                        end
                    | _ => ((1 * y2 + y1)%R, y2)
                    end)
             end)%Q)%Q * b (Posz 1))%Q)%Q; 0%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Tactic call ran for 1.988 secs (1.938u,0.036s) (success)
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner b 1]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching:
(Forall (fun r : R => 0 <= r < 1) Hb ->
 (forall r : R, 0 <= r < 1 -> a r = body' r) ->
 iterate Hb a = iterate Hb body')
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: (((((1%Q + rat_of_Z 2)%Q *
             ((1%Q + rat_of_Z 2)%Q * (1%Q + rat_of_Z 2)%Q)%Q)%Q *
            ((-
              ((((1%Q + rat_of_Z 1)%Q *
                 ((1%Q + rat_of_Z 1)%Q * (1%Q + rat_of_Z 1)%Q)%Q)%Q *
                b (Posz 1))%Q +
               ((((- rat_of_Z 1)%Q *
                  (((rat_of_Z 17 * (1%Q * 1%Q)%Q)%Q + (rat_of_Z 51 * 1%Q)%Q)%Q +
                   rat_of_Z 39)%Q)%Q * ((rat_of_Z 2 * 1%Q)%Q + rat_of_Z 3)%Q)%Q *
                ((-
                  ((((0%Q + rat_of_Z 1)%Q *
                     ((0%Q + rat_of_Z 1)%Q * (0%Q + rat_of_Z 1)%Q)%Q)%Q *
                    b (Posz 0))%Q +
                   ((((- rat_of_Z 1)%Q *
                      (((rat_of_Z 17 * (0%Q * 0%Q)%Q)%Q +
                        (rat_of_Z 51 * 0%Q)%Q)%Q + 
                       rat_of_Z 39)%Q)%Q *
                     ((rat_of_Z 2 * 0%Q)%Q + rat_of_Z 3)%Q)%Q * 
                    b (Posz 1))%Q)%Q)%Q *
                 (((0%Q + rat_of_Z 2)%Q *
                   ((0%Q + rat_of_Z 2)%Q * (0%Q + rat_of_Z 2)%Q)%Q)%Q^-1)%Q)%Q)%Q)%Q)%Q *
             (((1%Q + rat_of_Z 2)%Q *
               ((1%Q + rat_of_Z 2)%Q * (1%Q + rat_of_Z 2)%Q)%Q)%Q^-1)%Q)%Q)%Q +
           ((((- rat_of_Z 1)%Q *
              (((rat_of_Z 17 * (1%Q * 1%Q)%Q)%Q + (rat_of_Z 51 * 1%Q)%Q)%Q +
               rat_of_Z 39)%Q)%Q * ((rat_of_Z 2 * 1%Q)%Q + rat_of_Z 3)%Q)%Q *
            ((-
              ((((0%Q + rat_of_Z 1)%Q *
                 ((0%Q + rat_of_Z 1)%Q * (0%Q + rat_of_Z 1)%Q)%Q)%Q *
                b (Posz 0))%Q +
               ((((- rat_of_Z 1)%Q *
                  (((rat_of_Z 17 * (0%Q * 0%Q)%Q)%Q + (rat_of_Z 51 * 0%Q)%Q)%Q +
                   rat_of_Z 39)%Q)%Q * ((rat_of_Z 2 * 0%Q)%Q + rat_of_Z 3)%Q)%Q *
                b (Posz 1))%Q)%Q)%Q *
             (((0%Q + rat_of_Z 2)%Q *
               ((0%Q + rat_of_Z 2)%Q * (0%Q + rat_of_Z 2)%Q)%Q)%Q^-1)%Q)%Q)%Q)%Q +
          (((1%Q + rat_of_Z 1)%Q *
            ((1%Q + rat_of_Z 1)%Q * (1%Q + rat_of_Z 1)%Q)%Q)%Q * 
           b (Posz 1))%Q)%Q; 0%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: (((((1%Q + rat_of_Z 2)%Q *
             ((1%Q + rat_of_Z 2)%Q * (1%Q + rat_of_Z 2)%Q)%Q)%Q *
            ((-
              ((((1%Q + rat_of_Z 1)%Q *
                 ((1%Q + rat_of_Z 1)%Q * (1%Q + rat_of_Z 1)%Q)%Q)%Q *
                b (Posz 1))%Q +
               ((((- rat_of_Z 1)%Q *
                  (((rat_of_Z 17 * (1%Q * 1%Q)%Q)%Q + (rat_of_Z 51 * 1%Q)%Q)%Q +
                   rat_of_Z 39)%Q)%Q * ((rat_of_Z 2 * 1%Q)%Q + rat_of_Z 3)%Q)%Q *
                ((-
                  ((((0%Q + rat_of_Z 1)%Q *
                     ((0%Q + rat_of_Z 1)%Q * (0%Q + rat_of_Z 1)%Q)%Q)%Q *
                    b (Posz 0))%Q +
                   ((((- rat_of_Z 1)%Q *
                      (((rat_of_Z 17 * (0%Q * 0%Q)%Q)%Q +
                        (rat_of_Z 51 * 0%Q)%Q)%Q + 
                       rat_of_Z 39)%Q)%Q *
                     ((rat_of_Z 2 * 0%Q)%Q + rat_of_Z 3)%Q)%Q * 
                    b (Posz 1))%Q)%Q)%Q *
                 (((0%Q + rat_of_Z 2)%Q *
                   ((0%Q + rat_of_Z 2)%Q * (0%Q + rat_of_Z 2)%Q)%Q)%Q^-1)%Q)%Q)%Q)%Q)%Q *
             (((1%Q + rat_of_Z 2)%Q *
               ((1%Q + rat_of_Z 2)%Q * (1%Q + rat_of_Z 2)%Q)%Q)%Q^-1)%Q)%Q)%Q +
           ((((- rat_of_Z 1)%Q *
              (((rat_of_Z 17 * (1%Q * 1%Q)%Q)%Q + (rat_of_Z 51 * 1%Q)%Q)%Q +
               rat_of_Z 39)%Q)%Q * ((rat_of_Z 2 * 1%Q)%Q + rat_of_Z 3)%Q)%Q *
            ((-
              ((((0%Q + rat_of_Z 1)%Q *
                 ((0%Q + rat_of_Z 1)%Q * (0%Q + rat_of_Z 1)%Q)%Q)%Q *
                b (Posz 0))%Q +
               ((((- rat_of_Z 1)%Q *
                  (((rat_of_Z 17 * (0%Q * 0%Q)%Q)%Q + (rat_of_Z 51 * 0%Q)%Q)%Q +
                   rat_of_Z 39)%Q)%Q * ((rat_of_Z 2 * 0%Q)%Q + rat_of_Z 3)%Q)%Q *
                b (Posz 1))%Q)%Q)%Q *
             (((0%Q + rat_of_Z 2)%Q *
               ((0%Q + rat_of_Z 2)%Q * (0%Q + rat_of_Z 2)%Q)%Q)%Q^-1)%Q)%Q)%Q)%Q +
          (((1%Q + rat_of_Z 1)%Q *
            ((1%Q + rat_of_Z 1)%Q * (1%Q + rat_of_Z 1)%Q)%Q)%Q * 
           b (Posz 1))%Q)%Q; 0%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Proving Rewriter_Interp...
Crunching: (iterate [] body = iterate [] body')
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: fracq
           ((valq
               (((match rat_of_Z 2 with
                  | {| valq := y |} =>
                      fracq
                        (let (y1, y2) := y in
                         match y2 with
                         | Posz 1 =>
                             match y1 with
                             | Posz 0 => (1%R, 1%R)
                             | Posz 1 => (Posz 2, 1%R)
                             | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                             | Negz _ => ((1 + y1)%R, 1%R)
                             end
                         | _ => ((1 * y2 + y1)%R, y2)
                         end)
                  end *
                  (match rat_of_Z 2 with
                   | {| valq := y |} =>
                       fracq
                         (let (y1, y2) := y in
                          match y2 with
                          | Posz 1 =>
                              match y1 with
                              | Posz 0 => (1%R, 1%R)
                              | Posz 1 => (Posz 2, 1%R)
                              | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                              | Negz _ => ((1 + y1)%R, 1%R)
                              end
                          | _ => ((1 * y2 + y1)%R, y2)
                          end)
                   end *
                   match rat_of_Z 2 with
                   | {| valq := y |} =>
                       fracq
                         (let (y1, y2) := y in
                          match y2 with
                          | Posz 1 =>
                              match y1 with
                              | Posz 0 => (1%R, 1%R)
                              | Posz 1 => (Posz 2, 1%R)
                              | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                              | Negz _ => ((1 + y1)%R, 1%R)
                              end
                          | _ => ((1 * y2 + y1)%R, y2)
                          end)
                   end)%Q)%Q *
                 ((-
                   (((match rat_of_Z 1 with
                      | {| valq := y |} =>
                          fracq
                            (let (y1, y2) := y in
                             match y2 with
                             | Posz 1 =>
                                 match y1 with
                                 | Posz 0 => (1%R, 1%R)
                                 | Posz 1 => (Posz 2, 1%R)
                                 | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                                 | Negz _ => ((1 + y1)%R, 1%R)
                                 end
                             | _ => ((1 * y2 + y1)%R, y2)
                             end)
                      end *
                      (match rat_of_Z 1 with
                       | {| valq := y |} =>
                           fracq
                             (let (y1, y2) := y in
                              match y2 with
                              | Posz 1 =>
                                  match y1 with
                                  | Posz 0 => (1%R, 1%R)
                                  | Posz 1 => (Posz 2, 1%R)
                                  | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                                  | Negz _ => ((1 + y1)%R, 1%R)
                                  end
                              | _ => ((1 * y2 + y1)%R, y2)
                              end)
                       end *
                       match rat_of_Z 1 with
                       | {| valq := y |} =>
                           fracq
                             (let (y1, y2) := y in
                              match y2 with
                              | Posz 1 =>
                                  match y1 with
                                  | Posz 0 => (1%R, 1%R)
                                  | Posz 1 => (Posz 2, 1%R)
                                  | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                                  | Negz _ => ((1 + y1)%R, 1%R)
                                  end
                              | _ => ((1 * y2 + y1)%R, y2)
                              end)
                       end)%Q)%Q * b (Posz 1))%Q +
                    ((((- rat_of_Z 1)%Q *
                       (((rat_of_Z 17 * fracq ((1 * 1)%R, 1%R))%Q +
                         (rat_of_Z 51 * 1%Q)%Q)%Q + 
                        rat_of_Z 39)%Q)%Q *
                      ((rat_of_Z 2 * 1%Q)%Q + rat_of_Z 3)%Q)%Q *
                     ((-
                       (((match rat_of_Z 1 with
                          | {| valq := y |} =>
                              fracq
                                (let (y1, y2) := y in
                                 match y2 with
                                 | Posz 1 => (y1, 1%R)
                                 | _ => ((0 * y2 + y1)%R, y2)
                                 end)
                          end *
                          (match rat_of_Z 1 with
                           | {| valq := y |} =>
                               fracq
                                 (let (y1, y2) := y in
                                  match y2 with
                                  | Posz 1 => (y1, 1%R)
                                  | _ => ((0 * y2 + y1)%R, y2)
                                  end)
                           end *
                           match rat_of_Z 1 with
                           | {| valq := y |} =>
                               fracq
                                 (let (y1, y2) := y in
                                  match y2 with
                                  | Posz 1 => (y1, 1%R)
                                  | _ => ((0 * y2 + y1)%R, y2)
                                  end)
                           end)%Q)%Q * b (Posz 0))%Q +
                        ((((- rat_of_Z 1)%Q *
                           (((rat_of_Z 17 * fracq ((0 * 0)%R, 1%R))%Q +
                             (rat_of_Z 51 * 0%Q)%Q)%Q + 
                            rat_of_Z 39)%Q)%Q *
                          ((rat_of_Z 2 * 0%Q)%Q + rat_of_Z 3)%Q)%Q *
                         b (Posz 1))%Q)%Q)%Q *
                      ((match rat_of_Z 2 with
                        | {| valq := y |} =>
                            fracq
                              (let (y1, y2) := y in
                               match y2 with
                               | Posz 1 => (y1, 1%R)
                               | _ => ((0 * y2 + y1)%R, y2)
                               end)
                        end *
                        (match rat_of_Z 2 with
                         | {| valq := y |} =>
                             fracq
                               (let (y1, y2) := y in
                                match y2 with
                                | Posz 1 => (y1, 1%R)
                                | _ => ((0 * y2 + y1)%R, y2)
                                end)
                         end *
                         match rat_of_Z 2 with
                         | {| valq := y |} =>
                             fracq
                               (let (y1, y2) := y in
                                match y2 with
                                | Posz 1 => (y1, 1%R)
                                | _ => ((0 * y2 + y1)%R, y2)
                                end)
                         end)%Q)%Q^-1)%Q)%Q)%Q)%Q)%Q *
                  ((match rat_of_Z 2 with
                    | {| valq := y |} =>
                        fracq
                          (let (y1, y2) := y in
                           match y2 with
                           | Posz 1 =>
                               match y1 with
                               | Posz 0 => (1%R, 1%R)
                               | Posz 1 => (Posz 2, 1%R)
                               | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                               | Negz _ => ((1 + y1)%R, 1%R)
                               end
                           | _ => ((1 * y2 + y1)%R, y2)
                           end)
                    end *
                    (match rat_of_Z 2 with
                     | {| valq := y |} =>
                         fracq
                           (let (y1, y2) := y in
                            match y2 with
                            | Posz 1 =>
                                match y1 with
                                | Posz 0 => (1%R, 1%R)
                                | Posz 1 => (Posz 2, 1%R)
                                | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                                | Negz _ => ((1 + y1)%R, 1%R)
                                end
                            | _ => ((1 * y2 + y1)%R, y2)
                            end)
                     end *
                     match rat_of_Z 2 with
                     | {| valq := y |} =>
                         fracq
                           (let (y1, y2) := y in
                            match y2 with
                            | Posz 1 =>
                                match y1 with
                                | Posz 0 => (1%R, 1%R)
                                | Posz 1 => (Posz 2, 1%R)
                                | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                                | Negz _ => ((1 + y1)%R, 1%R)
                                end
                            | _ => ((1 * y2 + y1)%R, y2)
                            end)
                     end)%Q)%Q^-1)%Q)%Q)%Q +
                ((((- rat_of_Z 1)%Q *
                   (((rat_of_Z 17 * fracq ((1 * 1)%R, 1%R))%Q +
                     (rat_of_Z 51 * 1%Q)%Q)%Q + rat_of_Z 39)%Q)%Q *
                  ((rat_of_Z 2 * 1%Q)%Q + rat_of_Z 3)%Q)%Q *
                 ((-
                   (((match rat_of_Z 1 with
                      | {| valq := y |} =>
                          fracq
                            (let (y1, y2) := y in
                             match y2 with
                             | Posz 1 => (y1, 1%R)
                             | _ => ((0 * y2 + y1)%R, y2)
                             end)
                      end *
                      (match rat_of_Z 1 with
                       | {| valq := y |} =>
                           fracq
                             (let (y1, y2) := y in
                              match y2 with
                              | Posz 1 => (y1, 1%R)
                              | _ => ((0 * y2 + y1)%R, y2)
                              end)
                       end *
                       match rat_of_Z 1 with
                       | {| valq := y |} =>
                           fracq
                             (let (y1, y2) := y in
                              match y2 with
                              | Posz 1 => (y1, 1%R)
                              | _ => ((0 * y2 + y1)%R, y2)
                              end)
                       end)%Q)%Q * b (Posz 0))%Q +
                    ((((- rat_of_Z 1)%Q *
                       (((rat_of_Z 17 * fracq ((0 * 0)%R, 1%R))%Q +
                         (rat_of_Z 51 * 0%Q)%Q)%Q + 
                        rat_of_Z 39)%Q)%Q *
                      ((rat_of_Z 2 * 0%Q)%Q + rat_of_Z 3)%Q)%Q * 
                     b (Posz 1))%Q)%Q)%Q *
                  ((match rat_of_Z 2 with
                    | {| valq := y |} =>
                        fracq
                          (let (y1, y2) := y in
                           match y2 with
                           | Posz 1 => (y1, 1%R)
                           | _ => ((0 * y2 + y1)%R, y2)
                           end)
                    end *
                    (match rat_of_Z 2 with
                     | {| valq := y |} =>
                         fracq
                           (let (y1, y2) := y in
                            match y2 with
                            | Posz 1 => (y1, 1%R)
                            | _ => ((0 * y2 + y1)%R, y2)
                            end)
                     end *
                     match rat_of_Z 2 with
                     | {| valq := y |} =>
                         fracq
                           (let (y1, y2) := y in
                            match y2 with
                            | Posz 1 => (y1, 1%R)
                            | _ => ((0 * y2 + y1)%R, y2)
                            end)
                     end)%Q)%Q^-1)%Q)%Q)%Q)%Q).1 *
            (valq
               ((match rat_of_Z 1 with
                 | {| valq := y |} =>
                     fracq
                       (let (y1, y2) := y in
                        match y2 with
                        | Posz 1 =>
                            match y1 with
                            | Posz 0 => (1%R, 1%R)
                            | Posz 1 => (Posz 2, 1%R)
                            | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                            | Negz _ => ((1 + y1)%R, 1%R)
                            end
                        | _ => ((1 * y2 + y1)%R, y2)
                        end)
                 end *
                 (match rat_of_Z 1 with
                  | {| valq := y |} =>
                      fracq
                        (let (y1, y2) := y in
                         match y2 with
                         | Posz 1 =>
                             match y1 with
                             | Posz 0 => (1%R, 1%R)
                             | Posz 1 => (Posz 2, 1%R)
                             | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                             | Negz _ => ((1 + y1)%R, 1%R)
                             end
                         | _ => ((1 * y2 + y1)%R, y2)
                         end)
                  end *
                  match rat_of_Z 1 with
                  | {| valq := y |} =>
                      fracq
                        (let (y1, y2) := y in
                         match y2 with
                         | Posz 1 =>
                             match y1 with
                             | Posz 0 => (1%R, 1%R)
                             | Posz 1 => (Posz 2, 1%R)
                             | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                             | Negz _ => ((1 + y1)%R, 1%R)
                             end
                         | _ => ((1 * y2 + y1)%R, y2)
                         end)
                  end)%Q)%Q * b (Posz 1))%Q).2 +
            (valq
               ((match rat_of_Z 1 with
                 | {| valq := y |} =>
                     fracq
                       (let (y1, y2) := y in
                        match y2 with
                        | Posz 1 =>
                            match y1 with
                            | Posz 0 => (1%R, 1%R)
                            | Posz 1 => (Posz 2, 1%R)
                            | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                            | Negz _ => ((1 + y1)%R, 1%R)
                            end
                        | _ => ((1 * y2 + y1)%R, y2)
                        end)
                 end *
                 (match rat_of_Z 1 with
                  | {| valq := y |} =>
                      fracq
                        (let (y1, y2) := y in
                         match y2 with
                         | Posz 1 =>
                             match y1 with
                             | Posz 0 => (1%R, 1%R)
                             | Posz 1 => (Posz 2, 1%R)
                             | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                             | Negz _ => ((1 + y1)%R, 1%R)
                             end
                         | _ => ((1 * y2 + y1)%R, y2)
                         end)
                  end *
                  match rat_of_Z 1 with
                  | {| valq := y |} =>
                      fracq
                        (let (y1, y2) := y in
                         match y2 with
                         | Posz 1 =>
                             match y1 with
                             | Posz 0 => (1%R, 1%R)
                             | Posz 1 => (Posz 2, 1%R)
                             | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                             | Negz _ => ((1 + y1)%R, 1%R)
                             end
                         | _ => ((1 * y2 + y1)%R, y2)
                         end)
                  end)%Q)%Q * b (Posz 1))%Q).1 *
            (valq
               (((match rat_of_Z 2 with
                  | {| valq := y |} =>
                      fracq
                        (let (y1, y2) := y in
                         match y2 with
                         | Posz 1 =>
                             match y1 with
                             | Posz 0 => (1%R, 1%R)
                             | Posz 1 => (Posz 2, 1%R)
                             | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                             | Negz _ => ((1 + y1)%R, 1%R)
                             end
                         | _ => ((1 * y2 + y1)%R, y2)
                         end)
                  end *
                  (match rat_of_Z 2 with
                   | {| valq := y |} =>
                       fracq
                         (let (y1, y2) := y in
                          match y2 with
                          | Posz 1 =>
                              match y1 with
                              | Posz 0 => (1%R, 1%R)
                              | Posz 1 => (Posz 2, 1%R)
                              | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                              | Negz _ => ((1 + y1)%R, 1%R)
                              end
                          | _ => ((1 * y2 + y1)%R, y2)
                          end)
                   end *
                   match rat_of_Z 2 with
                   | {| valq := y |} =>
                       fracq
                         (let (y1, y2) := y in
                          match y2 with
                          | Posz 1 =>
                              match y1 with
                              | Posz 0 => (1%R, 1%R)
                              | Posz 1 => (Posz 2, 1%R)
                              | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                              | Negz _ => ((1 + y1)%R, 1%R)
                              end
                          | _ => ((1 * y2 + y1)%R, y2)
                          end)
                   end)%Q)%Q *
                 ((-
                   (((match rat_of_Z 1 with
                      | {| valq := y |} =>
                          fracq
                            (let (y1, y2) := y in
                             match y2 with
                             | Posz 1 =>
                                 match y1 with
                                 | Posz 0 => (1%R, 1%R)
                                 | Posz 1 => (Posz 2, 1%R)
                                 | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                                 | Negz _ => ((1 + y1)%R, 1%R)
                                 end
                             | _ => ((1 * y2 + y1)%R, y2)
                             end)
                      end *
                      (match rat_of_Z 1 with
                       | {| valq := y |} =>
                           fracq
                             (let (y1, y2) := y in
                              match y2 with
                              | Posz 1 =>
                                  match y1 with
                                  | Posz 0 => (1%R, 1%R)
                                  | Posz 1 => (Posz 2, 1%R)
                                  | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                                  | Negz _ => ((1 + y1)%R, 1%R)
                                  end
                              | _ => ((1 * y2 + y1)%R, y2)
                              end)
                       end *
                       match rat_of_Z 1 with
                       | {| valq := y |} =>
                           fracq
                             (let (y1, y2) := y in
                              match y2 with
                              | Posz 1 =>
                                  match y1 with
                                  | Posz 0 => (1%R, 1%R)
                                  | Posz 1 => (Posz 2, 1%R)
                                  | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                                  | Negz _ => ((1 + y1)%R, 1%R)
                                  end
                              | _ => ((1 * y2 + y1)%R, y2)
                              end)
                       end)%Q)%Q * b (Posz 1))%Q +
                    ((((- rat_of_Z 1)%Q *
                       (((rat_of_Z 17 * fracq ((1 * 1)%R, 1%R))%Q +
                         (rat_of_Z 51 * 1%Q)%Q)%Q + 
                        rat_of_Z 39)%Q)%Q *
                      ((rat_of_Z 2 * 1%Q)%Q + rat_of_Z 3)%Q)%Q *
                     ((-
                       (((match rat_of_Z 1 with
                          | {| valq := y |} =>
                              fracq
                                (let (y1, y2) := y in
                                 match y2 with
                                 | Posz 1 => (y1, 1%R)
                                 | _ => ((0 * y2 + y1)%R, y2)
                                 end)
                          end *
                          (match rat_of_Z 1 with
                           | {| valq := y |} =>
                               fracq
                                 (let (y1, y2) := y in
                                  match y2 with
                                  | Posz 1 => (y1, 1%R)
                                  | _ => ((0 * y2 + y1)%R, y2)
                                  end)
                           end *
                           match rat_of_Z 1 with
                           | {| valq := y |} =>
                               fracq
                                 (let (y1, y2) := y in
                                  match y2 with
                                  | Posz 1 => (y1, 1%R)
                                  | _ => ((0 * y2 + y1)%R, y2)
                                  end)
                           end)%Q)%Q * b (Posz 0))%Q +
                        ((((- rat_of_Z 1)%Q *
                           (((rat_of_Z 17 * fracq ((0 * 0)%R, 1%R))%Q +
                             (rat_of_Z 51 * 0%Q)%Q)%Q + 
                            rat_of_Z 39)%Q)%Q *
                          ((rat_of_Z 2 * 0%Q)%Q + rat_of_Z 3)%Q)%Q *
                         b (Posz 1))%Q)%Q)%Q *
                      ((match rat_of_Z 2 with
                        | {| valq := y |} =>
                            fracq
                              (let (y1, y2) := y in
                               match y2 with
                               | Posz 1 => (y1, 1%R)
                               | _ => ((0 * y2 + y1)%R, y2)
                               end)
                        end *
                        (match rat_of_Z 2 with
                         | {| valq := y |} =>
                             fracq
                               (let (y1, y2) := y in
                                match y2 with
                                | Posz 1 => (y1, 1%R)
                                | _ => ((0 * y2 + y1)%R, y2)
                                end)
                         end *
                         match rat_of_Z 2 with
                         | {| valq := y |} =>
                             fracq
                               (let (y1, y2) := y in
                                match y2 with
                                | Posz 1 => (y1, 1%R)
                                | _ => ((0 * y2 + y1)%R, y2)
                                end)
                         end)%Q)%Q^-1)%Q)%Q)%Q)%Q)%Q *
                  ((match rat_of_Z 2 with
                    | {| valq := y |} =>
                        fracq
                          (let (y1, y2) := y in
                           match y2 with
                           | Posz 1 =>
                               match y1 with
                               | Posz 0 => (1%R, 1%R)
                               | Posz 1 => (Posz 2, 1%R)
                               | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                               | Negz _ => ((1 + y1)%R, 1%R)
                               end
                           | _ => ((1 * y2 + y1)%R, y2)
                           end)
                    end *
                    (match rat_of_Z 2 with
                     | {| valq := y |} =>
                         fracq
                           (let (y1, y2) := y in
                            match y2 with
                            | Posz 1 =>
                                match y1 with
                                | Posz 0 => (1%R, 1%R)
                                | Posz 1 => (Posz 2, 1%R)
                                | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                                | Negz _ => ((1 + y1)%R, 1%R)
                                end
                            | _ => ((1 * y2 + y1)%R, y2)
                            end)
                     end *
                     match rat_of_Z 2 with
                     | {| valq := y |} =>
                         fracq
                           (let (y1, y2) := y in
                            match y2 with
                            | Posz 1 =>
                                match y1 with
                                | Posz 0 => (1%R, 1%R)
                                | Posz 1 => (Posz 2, 1%R)
                                | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                                | Negz _ => ((1 + y1)%R, 1%R)
                                end
                            | _ => ((1 * y2 + y1)%R, y2)
                            end)
                     end)%Q)%Q^-1)%Q)%Q)%Q +
                ((((- rat_of_Z 1)%Q *
                   (((rat_of_Z 17 * fracq ((1 * 1)%R, 1%R))%Q +
                     (rat_of_Z 51 * 1%Q)%Q)%Q + rat_of_Z 39)%Q)%Q *
                  ((rat_of_Z 2 * 1%Q)%Q + rat_of_Z 3)%Q)%Q *
                 ((-
                   (((match rat_of_Z 1 with
                      | {| valq := y |} =>
                          fracq
                            (let (y1, y2) := y in
                             match y2 with
                             | Posz 1 => (y1, 1%R)
                             | _ => ((0 * y2 + y1)%R, y2)
                             end)
                      end *
                      (match rat_of_Z 1 with
                       | {| valq := y |} =>
                           fracq
                             (let (y1, y2) := y in
                              match y2 with
                              | Posz 1 => (y1, 1%R)
                              | _ => ((0 * y2 + y1)%R, y2)
                              end)
                       end *
                       match rat_of_Z 1 with
                       | {| valq := y |} =>
                           fracq
                             (let (y1, y2) := y in
                              match y2 with
                              | Posz 1 => (y1, 1%R)
                              | _ => ((0 * y2 + y1)%R, y2)
                              end)
                       end)%Q)%Q * b (Posz 0))%Q +
                    ((((- rat_of_Z 1)%Q *
                       (((rat_of_Z 17 * fracq ((0 * 0)%R, 1%R))%Q +
                         (rat_of_Z 51 * 0%Q)%Q)%Q + 
                        rat_of_Z 39)%Q)%Q *
                      ((rat_of_Z 2 * 0%Q)%Q + rat_of_Z 3)%Q)%Q * 
                     b (Posz 1))%Q)%Q)%Q *
                  ((match rat_of_Z 2 with
                    | {| valq := y |} =>
                        fracq
                          (let (y1, y2) := y in
                           match y2 with
                           | Posz 1 => (y1, 1%R)
                           | _ => ((0 * y2 + y1)%R, y2)
                           end)
                    end *
                    (match rat_of_Z 2 with
                     | {| valq := y |} =>
                         fracq
                           (let (y1, y2) := y in
                            match y2 with
                            | Posz 1 => (y1, 1%R)
                            | _ => ((0 * y2 + y1)%R, y2)
                            end)
                     end *
                     match rat_of_Z 2 with
                     | {| valq := y |} =>
                         fracq
                           (let (y1, y2) := y in
                            match y2 with
                            | Posz 1 => (y1, 1%R)
                            | _ => ((0 * y2 + y1)%R, y2)
                            end)
                     end)%Q)%Q^-1)%Q)%Q)%Q)%Q).2,
           (valq
              (((match rat_of_Z 2 with
                 | {| valq := y |} =>
                     fracq
                       (let (y1, y2) := y in
                        match y2 with
                        | Posz 1 =>
                            match y1 with
                            | Posz 0 => (1%R, 1%R)
                            | Posz 1 => (Posz 2, 1%R)
                            | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                            | Negz _ => ((1 + y1)%R, 1%R)
                            end
                        | _ => ((1 * y2 + y1)%R, y2)
                        end)
                 end *
                 (match rat_of_Z 2 with
                  | {| valq := y |} =>
                      fracq
                        (let (y1, y2) := y in
                         match y2 with
                         | Posz 1 =>
                             match y1 with
                             | Posz 0 => (1%R, 1%R)
                             | Posz 1 => (Posz 2, 1%R)
                             | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                             | Negz _ => ((1 + y1)%R, 1%R)
                             end
                         | _ => ((1 * y2 + y1)%R, y2)
                         end)
                  end *
                  match rat_of_Z 2 with
                  | {| valq := y |} =>
                      fracq
                        (let (y1, y2) := y in
                         match y2 with
                         | Posz 1 =>
                             match y1 with
                             | Posz 0 => (1%R, 1%R)
                             | Posz 1 => (Posz 2, 1%R)
                             | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                             | Negz _ => ((1 + y1)%R, 1%R)
                             end
                         | _ => ((1 * y2 + y1)%R, y2)
                         end)
                  end)%Q)%Q *
                ((-
                  (((match rat_of_Z 1 with
                     | {| valq := y |} =>
                         fracq
                           (let (y1, y2) := y in
                            match y2 with
                            | Posz 1 =>
                                match y1 with
                                | Posz 0 => (1%R, 1%R)
                                | Posz 1 => (Posz 2, 1%R)
                                | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                                | Negz _ => ((1 + y1)%R, 1%R)
                                end
                            | _ => ((1 * y2 + y1)%R, y2)
                            end)
                     end *
                     (match rat_of_Z 1 with
                      | {| valq := y |} =>
                          fracq
                            (let (y1, y2) := y in
                             match y2 with
                             | Posz 1 =>
                                 match y1 with
                                 | Posz 0 => (1%R, 1%R)
                                 | Posz 1 => (Posz 2, 1%R)
                                 | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                                 | Negz _ => ((1 + y1)%R, 1%R)
                                 end
                             | _ => ((1 * y2 + y1)%R, y2)
                             end)
                      end *
                      match rat_of_Z 1 with
                      | {| valq := y |} =>
                          fracq
                            (let (y1, y2) := y in
                             match y2 with
                             | Posz 1 =>
                                 match y1 with
                                 | Posz 0 => (1%R, 1%R)
                                 | Posz 1 => (Posz 2, 1%R)
                                 | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                                 | Negz _ => ((1 + y1)%R, 1%R)
                                 end
                             | _ => ((1 * y2 + y1)%R, y2)
                             end)
                      end)%Q)%Q * b (Posz 1))%Q +
                   ((((- rat_of_Z 1)%Q *
                      (((rat_of_Z 17 * fracq ((1 * 1)%R, 1%R))%Q +
                        (rat_of_Z 51 * 1%Q)%Q)%Q + 
                       rat_of_Z 39)%Q)%Q *
                     ((rat_of_Z 2 * 1%Q)%Q + rat_of_Z 3)%Q)%Q *
                    ((-
                      (((match rat_of_Z 1 with
                         | {| valq := y |} =>
                             fracq
                               (let (y1, y2) := y in
                                match y2 with
                                | Posz 1 => (y1, 1%R)
                                | _ => ((0 * y2 + y1)%R, y2)
                                end)
                         end *
                         (match rat_of_Z 1 with
                          | {| valq := y |} =>
                              fracq
                                (let (y1, y2) := y in
                                 match y2 with
                                 | Posz 1 => (y1, 1%R)
                                 | _ => ((0 * y2 + y1)%R, y2)
                                 end)
                          end *
                          match rat_of_Z 1 with
                          | {| valq := y |} =>
                              fracq
                                (let (y1, y2) := y in
                                 match y2 with
                                 | Posz 1 => (y1, 1%R)
                                 | _ => ((0 * y2 + y1)%R, y2)
                                 end)
                          end)%Q)%Q * b (Posz 0))%Q +
                       ((((- rat_of_Z 1)%Q *
                          (((rat_of_Z 17 * fracq ((0 * 0)%R, 1%R))%Q +
                            (rat_of_Z 51 * 0%Q)%Q)%Q + 
                           rat_of_Z 39)%Q)%Q *
                         ((rat_of_Z 2 * 0%Q)%Q + rat_of_Z 3)%Q)%Q *
                        b (Posz 1))%Q)%Q)%Q *
                     ((match rat_of_Z 2 with
                       | {| valq := y |} =>
                           fracq
                             (let (y1, y2) := y in
                              match y2 with
                              | Posz 1 => (y1, 1%R)
                              | _ => ((0 * y2 + y1)%R, y2)
                              end)
                       end *
                       (match rat_of_Z 2 with
                        | {| valq := y |} =>
                            fracq
                              (let (y1, y2) := y in
                               match y2 with
                               | Posz 1 => (y1, 1%R)
                               | _ => ((0 * y2 + y1)%R, y2)
                               end)
                        end *
                        match rat_of_Z 2 with
                        | {| valq := y |} =>
                            fracq
                              (let (y1, y2) := y in
                               match y2 with
                               | Posz 1 => (y1, 1%R)
                               | _ => ((0 * y2 + y1)%R, y2)
                               end)
                        end)%Q)%Q^-1)%Q)%Q)%Q)%Q)%Q *
                 ((match rat_of_Z 2 with
                   | {| valq := y |} =>
                       fracq
                         (let (y1, y2) := y in
                          match y2 with
                          | Posz 1 =>
                              match y1 with
                              | Posz 0 => (1%R, 1%R)
                              | Posz 1 => (Posz 2, 1%R)
                              | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                              | Negz _ => ((1 + y1)%R, 1%R)
                              end
                          | _ => ((1 * y2 + y1)%R, y2)
                          end)
                   end *
                   (match rat_of_Z 2 with
                    | {| valq := y |} =>
                        fracq
                          (let (y1, y2) := y in
                           match y2 with
                           | Posz 1 =>
                               match y1 with
                               | Posz 0 => (1%R, 1%R)
                               | Posz 1 => (Posz 2, 1%R)
                               | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                               | Negz _ => ((1 + y1)%R, 1%R)
                               end
                           | _ => ((1 * y2 + y1)%R, y2)
                           end)
                    end *
                    match rat_of_Z 2 with
                    | {| valq := y |} =>
                        fracq
                          (let (y1, y2) := y in
                           match y2 with
                           | Posz 1 =>
                               match y1 with
                               | Posz 0 => (1%R, 1%R)
                               | Posz 1 => (Posz 2, 1%R)
                               | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                               | Negz _ => ((1 + y1)%R, 1%R)
                               end
                           | _ => ((1 * y2 + y1)%R, y2)
                           end)
                    end)%Q)%Q^-1)%Q)%Q)%Q +
               ((((- rat_of_Z 1)%Q *
                  (((rat_of_Z 17 * fracq ((1 * 1)%R, 1%R))%Q +
                    (rat_of_Z 51 * 1%Q)%Q)%Q + rat_of_Z 39)%Q)%Q *
                 ((rat_of_Z 2 * 1%Q)%Q + rat_of_Z 3)%Q)%Q *
                ((-
                  (((match rat_of_Z 1 with
                     | {| valq := y |} =>
                         fracq
                           (let (y1, y2) := y in
                            match y2 with
                            | Posz 1 => (y1, 1%R)
                            | _ => ((0 * y2 + y1)%R, y2)
                            end)
                     end *
                     (match rat_of_Z 1 with
                      | {| valq := y |} =>
                          fracq
                            (let (y1, y2) := y in
                             match y2 with
                             | Posz 1 => (y1, 1%R)
                             | _ => ((0 * y2 + y1)%R, y2)
                             end)
                      end *
                      match rat_of_Z 1 with
                      | {| valq := y |} =>
                          fracq
                            (let (y1, y2) := y in
                             match y2 with
                             | Posz 1 => (y1, 1%R)
                             | _ => ((0 * y2 + y1)%R, y2)
                             end)
                      end)%Q)%Q * b (Posz 0))%Q +
                   ((((- rat_of_Z 1)%Q *
                      (((rat_of_Z 17 * fracq ((0 * 0)%R, 1%R))%Q +
                        (rat_of_Z 51 * 0%Q)%Q)%Q + 
                       rat_of_Z 39)%Q)%Q *
                     ((rat_of_Z 2 * 0%Q)%Q + rat_of_Z 3)%Q)%Q * 
                    b (Posz 1))%Q)%Q)%Q *
                 ((match rat_of_Z 2 with
                   | {| valq := y |} =>
                       fracq
                         (let (y1, y2) := y in
                          match y2 with
                          | Posz 1 => (y1, 1%R)
                          | _ => ((0 * y2 + y1)%R, y2)
                          end)
                   end *
                   (match rat_of_Z 2 with
                    | {| valq := y |} =>
                        fracq
                          (let (y1, y2) := y in
                           match y2 with
                           | Posz 1 => (y1, 1%R)
                           | _ => ((0 * y2 + y1)%R, y2)
                           end)
                    end *
                    match rat_of_Z 2 with
                    | {| valq := y |} =>
                        fracq
                          (let (y1, y2) := y in
                           match y2 with
                           | Posz 1 => (y1, 1%R)
                           | _ => ((0 * y2 + y1)%R, y2)
                           end)
                    end)%Q)%Q^-1)%Q)%Q)%Q)%Q).2 *
           (valq
              ((match rat_of_Z 1 with
                | {| valq := y |} =>
                    fracq
                      (let (y1, y2) := y in
                       match y2 with
                       | Posz 1 =>
                           match y1 with
                           | Posz 0 => (1%R, 1%R)
                           | Posz 1 => (Posz 2, 1%R)
                           | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                           | Negz _ => ((1 + y1)%R, 1%R)
                           end
                       | _ => ((1 * y2 + y1)%R, y2)
                       end)
                end *
                (match rat_of_Z 1 with
                 | {| valq := y |} =>
                     fracq
                       (let (y1, y2) := y in
                        match y2 with
                        | Posz 1 =>
                            match y1 with
                            | Posz 0 => (1%R, 1%R)
                            | Posz 1 => (Posz 2, 1%R)
                            | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                            | Negz _ => ((1 + y1)%R, 1%R)
                            end
                        | _ => ((1 * y2 + y1)%R, y2)
                        end)
                 end *
                 match rat_of_Z 1 with
                 | {| valq := y |} =>
                     fracq
                       (let (y1, y2) := y in
                        match y2 with
                        | Posz 1 =>
                            match y1 with
                            | Posz 0 => (1%R, 1%R)
                            | Posz 1 => (Posz 2, 1%R)
                            | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                            | Negz _ => ((1 + y1)%R, 1%R)
                            end
                        | _ => ((1 * y2 + y1)%R, y2)
                        end)
                 end)%Q)%Q * b (Posz 1))%Q).2); 0%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching: (iterate [] body = iterate [] body')
Crunching:
(Forall (fun r : R => 0 <= r < 1) Hn ->
 (forall r : R, 0 <= r < 1 -> GT r = c0 r) -> iterate Hn GT = iterate Hn c0)
Tactic call ran for 1.733 secs (1.716u,0.009s) (success)
Tactic call ran for 1.16 secs (1.144u,0.013s) (success)
Crunching:
(Forall (fun r : R => 0 <= r < 1) l ->
 (forall r : R, 0 <= r < 1 -> le_mn0 r = f r) ->
 iterate l le_mn0 = iterate l f)
Assembling verified rewriter...
Refining with verified rewriter...
Finished transaction in 33.395 secs (32.812u,0.463s) (successful)
Crunching:
(Forall (fun r : R => 0 <= r < 1) l ->
 (forall r : R, 0 <= r < 1 -> le_mn0 r = f r) ->
 iterate l le_mn0 = iterate l f)
Crunching:
(Forall (fun r : R => 0 <= r < 1) l ->
 (forall r : R, 0 <= r < 1 -> le_mn0 r = f r) ->
 iterate l le_mn0 = iterate l f)
"T has been translated as Tᵗ"
"tm has been translated as tmᵗ"
Coq.Init.Datatypes.nat has been translated.
Coq.Init.Datatypes.bool has been translated.
Crunching:
(Forall (fun r : R => 0 <= r < 1) l ->
 (forall r : R, 0 <= r < 1 -> le_mn0 r = f r) ->
 iterate l le_mn0 = iterate l f)
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: ((((match rat_of_Z 2 with
             | {| valq := y |} =>
                 fracq
                   (let (y1, y2) := y in
                    match y2 with
                    | Posz 1 =>
                        match y1 with
                        | Posz 0 => (1%R, 1%R)
                        | Posz 1 => (Posz 2, 1%R)
                        | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                        | Negz _ => ((1 + y1)%R, 1%R)
                        end
                    | _ => ((1 * y2 + y1)%R, y2)
                    end)
             end *
             (match rat_of_Z 2 with
              | {| valq := y |} =>
                  fracq
                    (let (y1, y2) := y in
                     match y2 with
                     | Posz 1 =>
                         match y1 with
                         | Posz 0 => (1%R, 1%R)
                         | Posz 1 => (Posz 2, 1%R)
                         | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                         | Negz _ => ((1 + y1)%R, 1%R)
                         end
                     | _ => ((1 * y2 + y1)%R, y2)
                     end)
              end *
              match rat_of_Z 2 with
              | {| valq := y |} =>
                  fracq
                    (let (y1, y2) := y in
                     match y2 with
                     | Posz 1 =>
                         match y1 with
                         | Posz 0 => (1%R, 1%R)
                         | Posz 1 => (Posz 2, 1%R)
                         | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                         | Negz _ => ((1 + y1)%R, 1%R)
                         end
                     | _ => ((1 * y2 + y1)%R, y2)
                     end)
              end)%Q)%Q *
            ((-
              (((match rat_of_Z 1 with
                 | {| valq := y |} =>
                     fracq
                       (let (y1, y2) := y in
                        match y2 with
                        | Posz 1 =>
                            match y1 with
                            | Posz 0 => (1%R, 1%R)
                            | Posz 1 => (Posz 2, 1%R)
                            | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                            | Negz _ => ((1 + y1)%R, 1%R)
                            end
                        | _ => ((1 * y2 + y1)%R, y2)
                        end)
                 end *
                 (match rat_of_Z 1 with
                  | {| valq := y |} =>
                      fracq
                        (let (y1, y2) := y in
                         match y2 with
                         | Posz 1 =>
                             match y1 with
                             | Posz 0 => (1%R, 1%R)
                             | Posz 1 => (Posz 2, 1%R)
                             | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                             | Negz _ => ((1 + y1)%R, 1%R)
                             end
                         | _ => ((1 * y2 + y1)%R, y2)
                         end)
                  end *
                  match rat_of_Z 1 with
                  | {| valq := y |} =>
                      fracq
                        (let (y1, y2) := y in
                         match y2 with
                         | Posz 1 =>
                             match y1 with
                             | Posz 0 => (1%R, 1%R)
                             | Posz 1 => (Posz 2, 1%R)
                             | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                             | Negz _ => ((1 + y1)%R, 1%R)
                             end
                         | _ => ((1 * y2 + y1)%R, y2)
                         end)
                  end)%Q)%Q * b (Posz 1))%Q +
               ((((- rat_of_Z 1)%Q *
                  (((rat_of_Z 17 * fracq (1%R, 1%R))%Q +
                    (rat_of_Z 51 * 1%Q)%Q)%Q + rat_of_Z 39)%Q)%Q *
                 ((rat_of_Z 2 * 1%Q)%Q + rat_of_Z 3)%Q)%Q *
                ((-
                  (((match rat_of_Z 1 with
                     | {| valq := y |} =>
                         fracq
                           (let (y1, y2) := y in
                            match y2 with
                            | Posz 1 => (y1, 1%R)
                            | _ => ((0 * y2 + y1)%R, y2)
                            end)
                     end *
                     (match rat_of_Z 1 with
                      | {| valq := y |} =>
                          fracq
                            (let (y1, y2) := y in
                             match y2 with
                             | Posz 1 => (y1, 1%R)
                             | _ => ((0 * y2 + y1)%R, y2)
                             end)
                      end *
                      match rat_of_Z 1 with
                      | {| valq := y |} =>
                          fracq
                            (let (y1, y2) := y in
                             match y2 with
                             | Posz 1 => (y1, 1%R)
                             | _ => ((0 * y2 + y1)%R, y2)
                             end)
                      end)%Q)%Q * b (Posz 0))%Q +
                   ((((- rat_of_Z 1)%Q *
                      (((rat_of_Z 17 * fracq (0%R, 1%R))%Q +
                        (rat_of_Z 51 * 0%Q)%Q)%Q + 
                       rat_of_Z 39)%Q)%Q *
                     ((rat_of_Z 2 * 0%Q)%Q + rat_of_Z 3)%Q)%Q * 
                    b (Posz 1))%Q)%Q)%Q *
                 ((match rat_of_Z 2 with
                   | {| valq := y |} =>
                       fracq
                         (let (y1, y2) := y in
                          match y2 with
                          | Posz 1 => (y1, 1%R)
                          | _ => ((0 * y2 + y1)%R, y2)
                          end)
                   end *
                   (match rat_of_Z 2 with
                    | {| valq := y |} =>
                        fracq
                          (let (y1, y2) := y in
                           match y2 with
                           | Posz 1 => (y1, 1%R)
                           | _ => ((0 * y2 + y1)%R, y2)
                           end)
                    end *
                    match rat_of_Z 2 with
                    | {| valq := y |} =>
                        fracq
                          (let (y1, y2) := y in
                           match y2 with
                           | Posz 1 => (y1, 1%R)
                           | _ => ((0 * y2 + y1)%R, y2)
                           end)
                    end)%Q)%Q^-1)%Q)%Q)%Q)%Q)%Q *
             ((match rat_of_Z 2 with
               | {| valq := y |} =>
                   fracq
                     (let (y1, y2) := y in
                      match y2 with
                      | Posz 1 =>
                          match y1 with
                          | Posz 0 => (1%R, 1%R)
                          | Posz 1 => (Posz 2, 1%R)
                          | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                          | Negz _ => ((1 + y1)%R, 1%R)
                          end
                      | _ => ((1 * y2 + y1)%R, y2)
                      end)
               end *
               (match rat_of_Z 2 with
                | {| valq := y |} =>
                    fracq
                      (let (y1, y2) := y in
                       match y2 with
                       | Posz 1 =>
                           match y1 with
                           | Posz 0 => (1%R, 1%R)
                           | Posz 1 => (Posz 2, 1%R)
                           | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                           | Negz _ => ((1 + y1)%R, 1%R)
                           end
                       | _ => ((1 * y2 + y1)%R, y2)
                       end)
                end *
                match rat_of_Z 2 with
                | {| valq := y |} =>
                    fracq
                      (let (y1, y2) := y in
                       match y2 with
                       | Posz 1 =>
                           match y1 with
                           | Posz 0 => (1%R, 1%R)
                           | Posz 1 => (Posz 2, 1%R)
                           | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                           | Negz _ => ((1 + y1)%R, 1%R)
                           end
                       | _ => ((1 * y2 + y1)%R, y2)
                       end)
                end)%Q)%Q^-1)%Q)%Q)%Q +
           ((((- rat_of_Z 1)%Q *
              (((rat_of_Z 17 * fracq (1%R, 1%R))%Q + (rat_of_Z 51 * 1%Q)%Q)%Q +
               rat_of_Z 39)%Q)%Q * ((rat_of_Z 2 * 1%Q)%Q + rat_of_Z 3)%Q)%Q *
            ((-
              (((match rat_of_Z 1 with
                 | {| valq := y |} =>
                     fracq
                       (let (y1, y2) := y in
                        match y2 with
                        | Posz 1 => (y1, 1%R)
                        | _ => ((0 * y2 + y1)%R, y2)
                        end)
                 end *
                 (match rat_of_Z 1 with
                  | {| valq := y |} =>
                      fracq
                        (let (y1, y2) := y in
                         match y2 with
                         | Posz 1 => (y1, 1%R)
                         | _ => ((0 * y2 + y1)%R, y2)
                         end)
                  end *
                  match rat_of_Z 1 with
                  | {| valq := y |} =>
                      fracq
                        (let (y1, y2) := y in
                         match y2 with
                         | Posz 1 => (y1, 1%R)
                         | _ => ((0 * y2 + y1)%R, y2)
                         end)
                  end)%Q)%Q * b (Posz 0))%Q +
               ((((- rat_of_Z 1)%Q *
                  (((rat_of_Z 17 * fracq (0%R, 1%R))%Q +
                    (rat_of_Z 51 * 0%Q)%Q)%Q + rat_of_Z 39)%Q)%Q *
                 ((rat_of_Z 2 * 0%Q)%Q + rat_of_Z 3)%Q)%Q * 
                b (Posz 1))%Q)%Q)%Q *
             ((match rat_of_Z 2 with
               | {| valq := y |} =>
                   fracq
                     (let (y1, y2) := y in
                      match y2 with
                      | Posz 1 => (y1, 1%R)
                      | _ => ((0 * y2 + y1)%R, y2)
                      end)
               end *
               (match rat_of_Z 2 with
                | {| valq := y |} =>
                    fracq
                      (let (y1, y2) := y in
                       match y2 with
                       | Posz 1 => (y1, 1%R)
                       | _ => ((0 * y2 + y1)%R, y2)
                       end)
                end *
                match rat_of_Z 2 with
                | {| valq := y |} =>
                    fracq
                      (let (y1, y2) := y in
                       match y2 with
                       | Posz 1 => (y1, 1%R)
                       | _ => ((0 * y2 + y1)%R, y2)
                       end)
                end)%Q)%Q^-1)%Q)%Q)%Q)%Q +
          ((match rat_of_Z 1 with
            | {| valq := y |} =>
                fracq
                  (let (y1, y2) := y in
                   match y2 with
                   | Posz 1 =>
                       match y1 with
                       | Posz 0 => (1%R, 1%R)
                       | Posz 1 => (Posz 2, 1%R)
                       | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                       | Negz _ => ((1 + y1)%R, 1%R)
                       end
                   | _ => ((1 * y2 + y1)%R, y2)
                   end)
            end *
            (match rat_of_Z 1 with
             | {| valq := y |} =>
                 fracq
                   (let (y1, y2) := y in
                    match y2 with
                    | Posz 1 =>
                        match y1 with
                        | Posz 0 => (1%R, 1%R)
                        | Posz 1 => (Posz 2, 1%R)
                        | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                        | Negz _ => ((1 + y1)%R, 1%R)
                        end
                    | _ => ((1 * y2 + y1)%R, y2)
                    end)
             end *
             match rat_of_Z 1 with
             | {| valq := y |} =>
                 fracq
                   (let (y1, y2) := y in
                    match y2 with
                    | Posz 1 =>
                        match y1 with
                        | Posz 0 => (1%R, 1%R)
                        | Posz 1 => (Posz 2, 1%R)
                        | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                        | Negz _ => ((1 + y1)%R, 1%R)
                        end
                    | _ => ((1 * y2 + y1)%R, y2)
                    end)
             end)%Q)%Q * b (Posz 1))%Q)%Q; 0%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Success: (dlet y0 : Z := e1 + e2 in
          [y; y + 1; y + 2; y + y0; y + (y0 + 1)])
Crunching:
(Forall (fun r : R => 0 <= r < 1) l ->
 (forall r : R, 0 <= r < 1 -> l1 r = H r) -> iterate l l1 = iterate l H)
Crunching:
(Forall (fun r : R => 0 <= r < 1) [] ->
 (forall r : R, 0 <= r < 1 -> l1 r = H r) -> iterate [] l1 = iterate [] H)
Coq.Init.Datatypes.nat has been translated.
Coq.Init.Datatypes.bool has been translated.
Coq.Init.Datatypes.list has been translated.
"HD has been translated as HDᵗ"
"MAP has been translated as MAPᵗ"
Success: [x1; x1; x1; x2; x2; x2; x3; x3; x3]
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner b 1]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: (((((1%Q + rat_of_Z 2)%Q *
             ((1%Q + rat_of_Z 2)%Q * (1%Q + rat_of_Z 2)%Q)%Q)%Q *
            ((-
              ((((1%Q + rat_of_Z 1)%Q *
                 ((1%Q + rat_of_Z 1)%Q * (1%Q + rat_of_Z 1)%Q)%Q)%Q *
                b (Posz 1))%Q +
               ((((- rat_of_Z 1)%Q *
                  (((rat_of_Z 17 * (1%Q * 1%Q)%Q)%Q + (rat_of_Z 51 * 1%Q)%Q)%Q +
                   rat_of_Z 39)%Q)%Q * ((rat_of_Z 2 * 1%Q)%Q + rat_of_Z 3)%Q)%Q *
                ((-
                  ((((0%Q + rat_of_Z 1)%Q *
                     ((0%Q + rat_of_Z 1)%Q * (0%Q + rat_of_Z 1)%Q)%Q)%Q *
                    b (Posz 0))%Q +
                   ((((- rat_of_Z 1)%Q *
                      (((rat_of_Z 17 * (0%Q * 0%Q)%Q)%Q +
                        (rat_of_Z 51 * 0%Q)%Q)%Q + 
                       rat_of_Z 39)%Q)%Q *
                     ((rat_of_Z 2 * 0%Q)%Q + rat_of_Z 3)%Q)%Q * 
                    b (Posz 1))%Q)%Q)%Q *
                 (((0%Q + rat_of_Z 2)%Q *
                   ((0%Q + rat_of_Z 2)%Q * (0%Q + rat_of_Z 2)%Q)%Q)%Q^-1)%Q)%Q)%Q)%Q)%Q *
             (((1%Q + rat_of_Z 2)%Q *
               ((1%Q + rat_of_Z 2)%Q * (1%Q + rat_of_Z 2)%Q)%Q)%Q^-1)%Q)%Q)%Q +
           ((((- rat_of_Z 1)%Q *
              (((rat_of_Z 17 * (1%Q * 1%Q)%Q)%Q + (rat_of_Z 51 * 1%Q)%Q)%Q +
               rat_of_Z 39)%Q)%Q * ((rat_of_Z 2 * 1%Q)%Q + rat_of_Z 3)%Q)%Q *
            ((-
              ((((0%Q + rat_of_Z 1)%Q *
                 ((0%Q + rat_of_Z 1)%Q * (0%Q + rat_of_Z 1)%Q)%Q)%Q *
                b (Posz 0))%Q +
               ((((- rat_of_Z 1)%Q *
                  (((rat_of_Z 17 * (0%Q * 0%Q)%Q)%Q + (rat_of_Z 51 * 0%Q)%Q)%Q +
                   rat_of_Z 39)%Q)%Q * ((rat_of_Z 2 * 0%Q)%Q + rat_of_Z 3)%Q)%Q *
                b (Posz 1))%Q)%Q)%Q *
             (((0%Q + rat_of_Z 2)%Q *
               ((0%Q + rat_of_Z 2)%Q * (0%Q + rat_of_Z 2)%Q)%Q)%Q^-1)%Q)%Q)%Q)%Q +
          (((1%Q + rat_of_Z 1)%Q *
            ((1%Q + rat_of_Z 1)%Q * (1%Q + rat_of_Z 1)%Q)%Q)%Q * 
           b (Posz 1))%Q)%Q; 0%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: (((((1%Q + rat_of_Z 2)%Q *
             ((1%Q + rat_of_Z 2)%Q * (1%Q + rat_of_Z 2)%Q)%Q)%Q *
            ((-
              ((((1%Q + rat_of_Z 1)%Q *
                 ((1%Q + rat_of_Z 1)%Q * (1%Q + rat_of_Z 1)%Q)%Q)%Q *
                b (Posz 1))%Q +
               ((((- rat_of_Z 1)%Q *
                  (((rat_of_Z 17 * (1%Q * 1%Q)%Q)%Q + (rat_of_Z 51 * 1%Q)%Q)%Q +
                   rat_of_Z 39)%Q)%Q * ((rat_of_Z 2 * 1%Q)%Q + rat_of_Z 3)%Q)%Q *
                ((-
                  ((((0%Q + rat_of_Z 1)%Q *
                     ((0%Q + rat_of_Z 1)%Q * (0%Q + rat_of_Z 1)%Q)%Q)%Q *
                    b (Posz 0))%Q +
                   ((((- rat_of_Z 1)%Q *
                      (((rat_of_Z 17 * (0%Q * 0%Q)%Q)%Q +
                        (rat_of_Z 51 * 0%Q)%Q)%Q + 
                       rat_of_Z 39)%Q)%Q *
                     ((rat_of_Z 2 * 0%Q)%Q + rat_of_Z 3)%Q)%Q * 
                    b (Posz 1))%Q)%Q)%Q *
                 (((0%Q + rat_of_Z 2)%Q *
                   ((0%Q + rat_of_Z 2)%Q * (0%Q + rat_of_Z 2)%Q)%Q)%Q^-1)%Q)%Q)%Q)%Q)%Q *
             (((1%Q + rat_of_Z 2)%Q *
               ((1%Q + rat_of_Z 2)%Q * (1%Q + rat_of_Z 2)%Q)%Q)%Q^-1)%Q)%Q)%Q +
           ((((- rat_of_Z 1)%Q *
              (((rat_of_Z 17 * (1%Q * 1%Q)%Q)%Q + (rat_of_Z 51 * 1%Q)%Q)%Q +
               rat_of_Z 39)%Q)%Q * ((rat_of_Z 2 * 1%Q)%Q + rat_of_Z 3)%Q)%Q *
            ((-
              ((((0%Q + rat_of_Z 1)%Q *
                 ((0%Q + rat_of_Z 1)%Q * (0%Q + rat_of_Z 1)%Q)%Q)%Q *
                b (Posz 0))%Q +
               ((((- rat_of_Z 1)%Q *
                  (((rat_of_Z 17 * (0%Q * 0%Q)%Q)%Q + (rat_of_Z 51 * 0%Q)%Q)%Q +
                   rat_of_Z 39)%Q)%Q * ((rat_of_Z 2 * 0%Q)%Q + rat_of_Z 3)%Q)%Q *
                b (Posz 1))%Q)%Q)%Q *
             (((0%Q + rat_of_Z 2)%Q *
               ((0%Q + rat_of_Z 2)%Q * (0%Q + rat_of_Z 2)%Q)%Q)%Q^-1)%Q)%Q)%Q)%Q +
          (((1%Q + rat_of_Z 1)%Q *
            ((1%Q + rat_of_Z 1)%Q * (1%Q + rat_of_Z 1)%Q)%Q)%Q * 
           b (Posz 1))%Q)%Q; 0%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: fracq
           ((valq
               (((match rat_of_Z 2 with
                  | {| valq := y |} =>
                      fracq
                        (let (y1, y2) := y in
                         match y2 with
                         | Posz 1 =>
                             match y1 with
                             | Posz 0 => (1%R, 1%R)
                             | Posz 1 => (Posz 2, 1%R)
                             | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                             | Negz _ => ((1 + y1)%R, 1%R)
                             end
                         | _ => ((1 * y2 + y1)%R, y2)
                         end)
                  end *
                  (match rat_of_Z 2 with
                   | {| valq := y |} =>
                       fracq
                         (let (y1, y2) := y in
                          match y2 with
                          | Posz 1 =>
                              match y1 with
                              | Posz 0 => (1%R, 1%R)
                              | Posz 1 => (Posz 2, 1%R)
                              | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                              | Negz _ => ((1 + y1)%R, 1%R)
                              end
                          | _ => ((1 * y2 + y1)%R, y2)
                          end)
                   end *
                   match rat_of_Z 2 with
                   | {| valq := y |} =>
                       fracq
                         (let (y1, y2) := y in
                          match y2 with
                          | Posz 1 =>
                              match y1 with
                              | Posz 0 => (1%R, 1%R)
                              | Posz 1 => (Posz 2, 1%R)
                              | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                              | Negz _ => ((1 + y1)%R, 1%R)
                              end
                          | _ => ((1 * y2 + y1)%R, y2)
                          end)
                   end)%Q)%Q *
                 ((-
                   (((match rat_of_Z 1 with
                      | {| valq := y |} =>
                          fracq
                            (let (y1, y2) := y in
                             match y2 with
                             | Posz 1 =>
                                 match y1 with
                                 | Posz 0 => (1%R, 1%R)
                                 | Posz 1 => (Posz 2, 1%R)
                                 | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                                 | Negz _ => ((1 + y1)%R, 1%R)
                                 end
                             | _ => ((1 * y2 + y1)%R, y2)
                             end)
                      end *
                      (match rat_of_Z 1 with
                       | {| valq := y |} =>
                           fracq
                             (let (y1, y2) := y in
                              match y2 with
                              | Posz 1 =>
                                  match y1 with
                                  | Posz 0 => (1%R, 1%R)
                                  | Posz 1 => (Posz 2, 1%R)
                                  | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                                  | Negz _ => ((1 + y1)%R, 1%R)
                                  end
                              | _ => ((1 * y2 + y1)%R, y2)
                              end)
                       end *
                       match rat_of_Z 1 with
                       | {| valq := y |} =>
                           fracq
                             (let (y1, y2) := y in
                              match y2 with
                              | Posz 1 =>
                                  match y1 with
                                  | Posz 0 => (1%R, 1%R)
                                  | Posz 1 => (Posz 2, 1%R)
                                  | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                                  | Negz _ => ((1 + y1)%R, 1%R)
                                  end
                              | _ => ((1 * y2 + y1)%R, y2)
                              end)
                       end)%Q)%Q * b (Posz 1))%Q +
                    ((((- rat_of_Z 1)%Q *
                       (((rat_of_Z 17 * fracq ((1 * 1)%R, 1%R))%Q +
                         (rat_of_Z 51 * 1%Q)%Q)%Q + 
                        rat_of_Z 39)%Q)%Q *
                      ((rat_of_Z 2 * 1%Q)%Q + rat_of_Z 3)%Q)%Q *
                     ((-
                       (((match rat_of_Z 1 with
                          | {| valq := y |} =>
                              fracq
                                (let (y1, y2) := y in
                                 match y2 with
                                 | Posz 1 => (y1, 1%R)
                                 | _ => ((0 * y2 + y1)%R, y2)
                                 end)
                          end *
                          (match rat_of_Z 1 with
                           | {| valq := y |} =>
                               fracq
                                 (let (y1, y2) := y in
                                  match y2 with
                                  | Posz 1 => (y1, 1%R)
                                  | _ => ((0 * y2 + y1)%R, y2)
                                  end)
                           end *
                           match rat_of_Z 1 with
                           | {| valq := y |} =>
                               fracq
                                 (let (y1, y2) := y in
                                  match y2 with
                                  | Posz 1 => (y1, 1%R)
                                  | _ => ((0 * y2 + y1)%R, y2)
                                  end)
                           end)%Q)%Q * b (Posz 0))%Q +
                        ((((- rat_of_Z 1)%Q *
                           (((rat_of_Z 17 * fracq ((0 * 0)%R, 1%R))%Q +
                             (rat_of_Z 51 * 0%Q)%Q)%Q + 
                            rat_of_Z 39)%Q)%Q *
                          ((rat_of_Z 2 * 0%Q)%Q + rat_of_Z 3)%Q)%Q *
                         b (Posz 1))%Q)%Q)%Q *
                      ((match rat_of_Z 2 with
                        | {| valq := y |} =>
                            fracq
                              (let (y1, y2) := y in
                               match y2 with
                               | Posz 1 => (y1, 1%R)
                               | _ => ((0 * y2 + y1)%R, y2)
                               end)
                        end *
                        (match rat_of_Z 2 with
                         | {| valq := y |} =>
                             fracq
                               (let (y1, y2) := y in
                                match y2 with
                                | Posz 1 => (y1, 1%R)
                                | _ => ((0 * y2 + y1)%R, y2)
                                end)
                         end *
                         match rat_of_Z 2 with
                         | {| valq := y |} =>
                             fracq
                               (let (y1, y2) := y in
                                match y2 with
                                | Posz 1 => (y1, 1%R)
                                | _ => ((0 * y2 + y1)%R, y2)
                                end)
                         end)%Q)%Q^-1)%Q)%Q)%Q)%Q)%Q *
                  ((match rat_of_Z 2 with
                    | {| valq := y |} =>
                        fracq
                          (let (y1, y2) := y in
                           match y2 with
                           | Posz 1 =>
                               match y1 with
                               | Posz 0 => (1%R, 1%R)
                               | Posz 1 => (Posz 2, 1%R)
                               | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                               | Negz _ => ((1 + y1)%R, 1%R)
                               end
                           | _ => ((1 * y2 + y1)%R, y2)
                           end)
                    end *
                    (match rat_of_Z 2 with
                     | {| valq := y |} =>
                         fracq
                           (let (y1, y2) := y in
                            match y2 with
                            | Posz 1 =>
                                match y1 with
                                | Posz 0 => (1%R, 1%R)
                                | Posz 1 => (Posz 2, 1%R)
                                | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                                | Negz _ => ((1 + y1)%R, 1%R)
                                end
                            | _ => ((1 * y2 + y1)%R, y2)
                            end)
                     end *
                     match rat_of_Z 2 with
                     | {| valq := y |} =>
                         fracq
                           (let (y1, y2) := y in
                            match y2 with
                            | Posz 1 =>
                                match y1 with
                                | Posz 0 => (1%R, 1%R)
                                | Posz 1 => (Posz 2, 1%R)
                                | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                                | Negz _ => ((1 + y1)%R, 1%R)
                                end
                            | _ => ((1 * y2 + y1)%R, y2)
                            end)
                     end)%Q)%Q^-1)%Q)%Q)%Q +
                ((((- rat_of_Z 1)%Q *
                   (((rat_of_Z 17 * fracq ((1 * 1)%R, 1%R))%Q +
                     (rat_of_Z 51 * 1%Q)%Q)%Q + rat_of_Z 39)%Q)%Q *
                  ((rat_of_Z 2 * 1%Q)%Q + rat_of_Z 3)%Q)%Q *
                 ((-
                   (((match rat_of_Z 1 with
                      | {| valq := y |} =>
                          fracq
                            (let (y1, y2) := y in
                             match y2 with
                             | Posz 1 => (y1, 1%R)
                             | _ => ((0 * y2 + y1)%R, y2)
                             end)
                      end *
                      (match rat_of_Z 1 with
                       | {| valq := y |} =>
                           fracq
                             (let (y1, y2) := y in
                              match y2 with
                              | Posz 1 => (y1, 1%R)
                              | _ => ((0 * y2 + y1)%R, y2)
                              end)
                       end *
                       match rat_of_Z 1 with
                       | {| valq := y |} =>
                           fracq
                             (let (y1, y2) := y in
                              match y2 with
                              | Posz 1 => (y1, 1%R)
                              | _ => ((0 * y2 + y1)%R, y2)
                              end)
                       end)%Q)%Q * b (Posz 0))%Q +
                    ((((- rat_of_Z 1)%Q *
                       (((rat_of_Z 17 * fracq ((0 * 0)%R, 1%R))%Q +
                         (rat_of_Z 51 * 0%Q)%Q)%Q + 
                        rat_of_Z 39)%Q)%Q *
                      ((rat_of_Z 2 * 0%Q)%Q + rat_of_Z 3)%Q)%Q * 
                     b (Posz 1))%Q)%Q)%Q *
                  ((match rat_of_Z 2 with
                    | {| valq := y |} =>
                        fracq
                          (let (y1, y2) := y in
                           match y2 with
                           | Posz 1 => (y1, 1%R)
                           | _ => ((0 * y2 + y1)%R, y2)
                           end)
                    end *
                    (match rat_of_Z 2 with
                     | {| valq := y |} =>
                         fracq
                           (let (y1, y2) := y in
                            match y2 with
                            | Posz 1 => (y1, 1%R)
                            | _ => ((0 * y2 + y1)%R, y2)
                            end)
                     end *
                     match rat_of_Z 2 with
                     | {| valq := y |} =>
                         fracq
                           (let (y1, y2) := y in
                            match y2 with
                            | Posz 1 => (y1, 1%R)
                            | _ => ((0 * y2 + y1)%R, y2)
                            end)
                     end)%Q)%Q^-1)%Q)%Q)%Q)%Q).1 *
            (valq
               ((match rat_of_Z 1 with
                 | {| valq := y |} =>
                     fracq
                       (let (y1, y2) := y in
                        match y2 with
                        | Posz 1 =>
                            match y1 with
                            | Posz 0 => (1%R, 1%R)
                            | Posz 1 => (Posz 2, 1%R)
                            | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                            | Negz _ => ((1 + y1)%R, 1%R)
                            end
                        | _ => ((1 * y2 + y1)%R, y2)
                        end)
                 end *
                 (match rat_of_Z 1 with
                  | {| valq := y |} =>
                      fracq
                        (let (y1, y2) := y in
                         match y2 with
                         | Posz 1 =>
                             match y1 with
                             | Posz 0 => (1%R, 1%R)
                             | Posz 1 => (Posz 2, 1%R)
                             | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                             | Negz _ => ((1 + y1)%R, 1%R)
                             end
                         | _ => ((1 * y2 + y1)%R, y2)
                         end)
                  end *
                  match rat_of_Z 1 with
                  | {| valq := y |} =>
                      fracq
                        (let (y1, y2) := y in
                         match y2 with
                         | Posz 1 =>
                             match y1 with
                             | Posz 0 => (1%R, 1%R)
                             | Posz 1 => (Posz 2, 1%R)
                             | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                             | Negz _ => ((1 + y1)%R, 1%R)
                             end
                         | _ => ((1 * y2 + y1)%R, y2)
                         end)
                  end)%Q)%Q * b (Posz 1))%Q).2 +
            (valq
               ((match rat_of_Z 1 with
                 | {| valq := y |} =>
                     fracq
                       (let (y1, y2) := y in
                        match y2 with
                        | Posz 1 =>
                            match y1 with
                            | Posz 0 => (1%R, 1%R)
                            | Posz 1 => (Posz 2, 1%R)
                            | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                            | Negz _ => ((1 + y1)%R, 1%R)
                            end
                        | _ => ((1 * y2 + y1)%R, y2)
                        end)
                 end *
                 (match rat_of_Z 1 with
                  | {| valq := y |} =>
                      fracq
                        (let (y1, y2) := y in
                         match y2 with
                         | Posz 1 =>
                             match y1 with
                             | Posz 0 => (1%R, 1%R)
                             | Posz 1 => (Posz 2, 1%R)
                             | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                             | Negz _ => ((1 + y1)%R, 1%R)
                             end
                         | _ => ((1 * y2 + y1)%R, y2)
                         end)
                  end *
                  match rat_of_Z 1 with
                  | {| valq := y |} =>
                      fracq
                        (let (y1, y2) := y in
                         match y2 with
                         | Posz 1 =>
                             match y1 with
                             | Posz 0 => (1%R, 1%R)
                             | Posz 1 => (Posz 2, 1%R)
                             | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                             | Negz _ => ((1 + y1)%R, 1%R)
                             end
                         | _ => ((1 * y2 + y1)%R, y2)
                         end)
                  end)%Q)%Q * b (Posz 1))%Q).1 *
            (valq
               (((match rat_of_Z 2 with
                  | {| valq := y |} =>
                      fracq
                        (let (y1, y2) := y in
                         match y2 with
                         | Posz 1 =>
                             match y1 with
                             | Posz 0 => (1%R, 1%R)
                             | Posz 1 => (Posz 2, 1%R)
                             | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                             | Negz _ => ((1 + y1)%R, 1%R)
                             end
                         | _ => ((1 * y2 + y1)%R, y2)
                         end)
                  end *
                  (match rat_of_Z 2 with
                   | {| valq := y |} =>
                       fracq
                         (let (y1, y2) := y in
                          match y2 with
                          | Posz 1 =>
                              match y1 with
                              | Posz 0 => (1%R, 1%R)
                              | Posz 1 => (Posz 2, 1%R)
                              | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                              | Negz _ => ((1 + y1)%R, 1%R)
                              end
                          | _ => ((1 * y2 + y1)%R, y2)
                          end)
                   end *
                   match rat_of_Z 2 with
                   | {| valq := y |} =>
                       fracq
                         (let (y1, y2) := y in
                          match y2 with
                          | Posz 1 =>
                              match y1 with
                              | Posz 0 => (1%R, 1%R)
                              | Posz 1 => (Posz 2, 1%R)
                              | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                              | Negz _ => ((1 + y1)%R, 1%R)
                              end
                          | _ => ((1 * y2 + y1)%R, y2)
                          end)
                   end)%Q)%Q *
                 ((-
                   (((match rat_of_Z 1 with
                      | {| valq := y |} =>
                          fracq
                            (let (y1, y2) := y in
                             match y2 with
                             | Posz 1 =>
                                 match y1 with
                                 | Posz 0 => (1%R, 1%R)
                                 | Posz 1 => (Posz 2, 1%R)
                                 | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                                 | Negz _ => ((1 + y1)%R, 1%R)
                                 end
                             | _ => ((1 * y2 + y1)%R, y2)
                             end)
                      end *
                      (match rat_of_Z 1 with
                       | {| valq := y |} =>
                           fracq
                             (let (y1, y2) := y in
                              match y2 with
                              | Posz 1 =>
                                  match y1 with
                                  | Posz 0 => (1%R, 1%R)
                                  | Posz 1 => (Posz 2, 1%R)
                                  | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                                  | Negz _ => ((1 + y1)%R, 1%R)
                                  end
                              | _ => ((1 * y2 + y1)%R, y2)
                              end)
                       end *
                       match rat_of_Z 1 with
                       | {| valq := y |} =>
                           fracq
                             (let (y1, y2) := y in
                              match y2 with
                              | Posz 1 =>
                                  match y1 with
                                  | Posz 0 => (1%R, 1%R)
                                  | Posz 1 => (Posz 2, 1%R)
                                  | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                                  | Negz _ => ((1 + y1)%R, 1%R)
                                  end
                              | _ => ((1 * y2 + y1)%R, y2)
                              end)
                       end)%Q)%Q * b (Posz 1))%Q +
                    ((((- rat_of_Z 1)%Q *
                       (((rat_of_Z 17 * fracq ((1 * 1)%R, 1%R))%Q +
                         (rat_of_Z 51 * 1%Q)%Q)%Q + 
                        rat_of_Z 39)%Q)%Q *
                      ((rat_of_Z 2 * 1%Q)%Q + rat_of_Z 3)%Q)%Q *
                     ((-
                       (((match rat_of_Z 1 with
                          | {| valq := y |} =>
                              fracq
                                (let (y1, y2) := y in
                                 match y2 with
                                 | Posz 1 => (y1, 1%R)
                                 | _ => ((0 * y2 + y1)%R, y2)
                                 end)
                          end *
                          (match rat_of_Z 1 with
                           | {| valq := y |} =>
                               fracq
                                 (let (y1, y2) := y in
                                  match y2 with
                                  | Posz 1 => (y1, 1%R)
                                  | _ => ((0 * y2 + y1)%R, y2)
                                  end)
                           end *
                           match rat_of_Z 1 with
                           | {| valq := y |} =>
                               fracq
                                 (let (y1, y2) := y in
                                  match y2 with
                                  | Posz 1 => (y1, 1%R)
                                  | _ => ((0 * y2 + y1)%R, y2)
                                  end)
                           end)%Q)%Q * b (Posz 0))%Q +
                        ((((- rat_of_Z 1)%Q *
                           (((rat_of_Z 17 * fracq ((0 * 0)%R, 1%R))%Q +
                             (rat_of_Z 51 * 0%Q)%Q)%Q + 
                            rat_of_Z 39)%Q)%Q *
                          ((rat_of_Z 2 * 0%Q)%Q + rat_of_Z 3)%Q)%Q *
                         b (Posz 1))%Q)%Q)%Q *
                      ((match rat_of_Z 2 with
                        | {| valq := y |} =>
                            fracq
                              (let (y1, y2) := y in
                               match y2 with
                               | Posz 1 => (y1, 1%R)
                               | _ => ((0 * y2 + y1)%R, y2)
                               end)
                        end *
                        (match rat_of_Z 2 with
                         | {| valq := y |} =>
                             fracq
                               (let (y1, y2) := y in
                                match y2 with
                                | Posz 1 => (y1, 1%R)
                                | _ => ((0 * y2 + y1)%R, y2)
                                end)
                         end *
                         match rat_of_Z 2 with
                         | {| valq := y |} =>
                             fracq
                               (let (y1, y2) := y in
                                match y2 with
                                | Posz 1 => (y1, 1%R)
                                | _ => ((0 * y2 + y1)%R, y2)
                                end)
                         end)%Q)%Q^-1)%Q)%Q)%Q)%Q)%Q *
                  ((match rat_of_Z 2 with
                    | {| valq := y |} =>
                        fracq
                          (let (y1, y2) := y in
                           match y2 with
                           | Posz 1 =>
                               match y1 with
                               | Posz 0 => (1%R, 1%R)
                               | Posz 1 => (Posz 2, 1%R)
                               | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                               | Negz _ => ((1 + y1)%R, 1%R)
                               end
                           | _ => ((1 * y2 + y1)%R, y2)
                           end)
                    end *
                    (match rat_of_Z 2 with
                     | {| valq := y |} =>
                         fracq
                           (let (y1, y2) := y in
                            match y2 with
                            | Posz 1 =>
                                match y1 with
                                | Posz 0 => (1%R, 1%R)
                                | Posz 1 => (Posz 2, 1%R)
                                | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                                | Negz _ => ((1 + y1)%R, 1%R)
                                end
                            | _ => ((1 * y2 + y1)%R, y2)
                            end)
                     end *
                     match rat_of_Z 2 with
                     | {| valq := y |} =>
                         fracq
                           (let (y1, y2) := y in
                            match y2 with
                            | Posz 1 =>
                                match y1 with
                                | Posz 0 => (1%R, 1%R)
                                | Posz 1 => (Posz 2, 1%R)
                                | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                                | Negz _ => ((1 + y1)%R, 1%R)
                                end
                            | _ => ((1 * y2 + y1)%R, y2)
                            end)
                     end)%Q)%Q^-1)%Q)%Q)%Q +
                ((((- rat_of_Z 1)%Q *
                   (((rat_of_Z 17 * fracq ((1 * 1)%R, 1%R))%Q +
                     (rat_of_Z 51 * 1%Q)%Q)%Q + rat_of_Z 39)%Q)%Q *
                  ((rat_of_Z 2 * 1%Q)%Q + rat_of_Z 3)%Q)%Q *
                 ((-
                   (((match rat_of_Z 1 with
                      | {| valq := y |} =>
                          fracq
                            (let (y1, y2) := y in
                             match y2 with
                             | Posz 1 => (y1, 1%R)
                             | _ => ((0 * y2 + y1)%R, y2)
                             end)
                      end *
                      (match rat_of_Z 1 with
                       | {| valq := y |} =>
                           fracq
                             (let (y1, y2) := y in
                              match y2 with
                              | Posz 1 => (y1, 1%R)
                              | _ => ((0 * y2 + y1)%R, y2)
                              end)
                       end *
                       match rat_of_Z 1 with
                       | {| valq := y |} =>
                           fracq
                             (let (y1, y2) := y in
                              match y2 with
                              | Posz 1 => (y1, 1%R)
                              | _ => ((0 * y2 + y1)%R, y2)
                              end)
                       end)%Q)%Q * b (Posz 0))%Q +
                    ((((- rat_of_Z 1)%Q *
                       (((rat_of_Z 17 * fracq ((0 * 0)%R, 1%R))%Q +
                         (rat_of_Z 51 * 0%Q)%Q)%Q + 
                        rat_of_Z 39)%Q)%Q *
                      ((rat_of_Z 2 * 0%Q)%Q + rat_of_Z 3)%Q)%Q * 
                     b (Posz 1))%Q)%Q)%Q *
                  ((match rat_of_Z 2 with
                    | {| valq := y |} =>
                        fracq
                          (let (y1, y2) := y in
                           match y2 with
                           | Posz 1 => (y1, 1%R)
                           | _ => ((0 * y2 + y1)%R, y2)
                           end)
                    end *
                    (match rat_of_Z 2 with
                     | {| valq := y |} =>
                         fracq
                           (let (y1, y2) := y in
                            match y2 with
                            | Posz 1 => (y1, 1%R)
                            | _ => ((0 * y2 + y1)%R, y2)
                            end)
                     end *
                     match rat_of_Z 2 with
                     | {| valq := y |} =>
                         fracq
                           (let (y1, y2) := y in
                            match y2 with
                            | Posz 1 => (y1, 1%R)
                            | _ => ((0 * y2 + y1)%R, y2)
                            end)
                     end)%Q)%Q^-1)%Q)%Q)%Q)%Q).2,
           (valq
              (((match rat_of_Z 2 with
                 | {| valq := y |} =>
                     fracq
                       (let (y1, y2) := y in
                        match y2 with
                        | Posz 1 =>
                            match y1 with
                            | Posz 0 => (1%R, 1%R)
                            | Posz 1 => (Posz 2, 1%R)
                            | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                            | Negz _ => ((1 + y1)%R, 1%R)
                            end
                        | _ => ((1 * y2 + y1)%R, y2)
                        end)
                 end *
                 (match rat_of_Z 2 with
                  | {| valq := y |} =>
                      fracq
                        (let (y1, y2) := y in
                         match y2 with
                         | Posz 1 =>
                             match y1 with
                             | Posz 0 => (1%R, 1%R)
                             | Posz 1 => (Posz 2, 1%R)
                             | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                             | Negz _ => ((1 + y1)%R, 1%R)
                             end
                         | _ => ((1 * y2 + y1)%R, y2)
                         end)
                  end *
                  match rat_of_Z 2 with
                  | {| valq := y |} =>
                      fracq
                        (let (y1, y2) := y in
                         match y2 with
                         | Posz 1 =>
                             match y1 with
                             | Posz 0 => (1%R, 1%R)
                             | Posz 1 => (Posz 2, 1%R)
                             | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                             | Negz _ => ((1 + y1)%R, 1%R)
                             end
                         | _ => ((1 * y2 + y1)%R, y2)
                         end)
                  end)%Q)%Q *
                ((-
                  (((match rat_of_Z 1 with
                     | {| valq := y |} =>
                         fracq
                           (let (y1, y2) := y in
                            match y2 with
                            | Posz 1 =>
                                match y1 with
                                | Posz 0 => (1%R, 1%R)
                                | Posz 1 => (Posz 2, 1%R)
                                | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                                | Negz _ => ((1 + y1)%R, 1%R)
                                end
                            | _ => ((1 * y2 + y1)%R, y2)
                            end)
                     end *
                     (match rat_of_Z 1 with
                      | {| valq := y |} =>
                          fracq
                            (let (y1, y2) := y in
                             match y2 with
                             | Posz 1 =>
                                 match y1 with
                                 | Posz 0 => (1%R, 1%R)
                                 | Posz 1 => (Posz 2, 1%R)
                                 | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                                 | Negz _ => ((1 + y1)%R, 1%R)
                                 end
                             | _ => ((1 * y2 + y1)%R, y2)
                             end)
                      end *
                      match rat_of_Z 1 with
                      | {| valq := y |} =>
                          fracq
                            (let (y1, y2) := y in
                             match y2 with
                             | Posz 1 =>
                                 match y1 with
                                 | Posz 0 => (1%R, 1%R)
                                 | Posz 1 => (Posz 2, 1%R)
                                 | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                                 | Negz _ => ((1 + y1)%R, 1%R)
                                 end
                             | _ => ((1 * y2 + y1)%R, y2)
                             end)
                      end)%Q)%Q * b (Posz 1))%Q +
                   ((((- rat_of_Z 1)%Q *
                      (((rat_of_Z 17 * fracq ((1 * 1)%R, 1%R))%Q +
                        (rat_of_Z 51 * 1%Q)%Q)%Q + 
                       rat_of_Z 39)%Q)%Q *
                     ((rat_of_Z 2 * 1%Q)%Q + rat_of_Z 3)%Q)%Q *
                    ((-
                      (((match rat_of_Z 1 with
                         | {| valq := y |} =>
                             fracq
                               (let (y1, y2) := y in
                                match y2 with
                                | Posz 1 => (y1, 1%R)
                                | _ => ((0 * y2 + y1)%R, y2)
                                end)
                         end *
                         (match rat_of_Z 1 with
                          | {| valq := y |} =>
                              fracq
                                (let (y1, y2) := y in
                                 match y2 with
                                 | Posz 1 => (y1, 1%R)
                                 | _ => ((0 * y2 + y1)%R, y2)
                                 end)
                          end *
                          match rat_of_Z 1 with
                          | {| valq := y |} =>
                              fracq
                                (let (y1, y2) := y in
                                 match y2 with
                                 | Posz 1 => (y1, 1%R)
                                 | _ => ((0 * y2 + y1)%R, y2)
                                 end)
                          end)%Q)%Q * b (Posz 0))%Q +
                       ((((- rat_of_Z 1)%Q *
                          (((rat_of_Z 17 * fracq ((0 * 0)%R, 1%R))%Q +
                            (rat_of_Z 51 * 0%Q)%Q)%Q + 
                           rat_of_Z 39)%Q)%Q *
                         ((rat_of_Z 2 * 0%Q)%Q + rat_of_Z 3)%Q)%Q *
                        b (Posz 1))%Q)%Q)%Q *
                     ((match rat_of_Z 2 with
                       | {| valq := y |} =>
                           fracq
                             (let (y1, y2) := y in
                              match y2 with
                              | Posz 1 => (y1, 1%R)
                              | _ => ((0 * y2 + y1)%R, y2)
                              end)
                       end *
                       (match rat_of_Z 2 with
                        | {| valq := y |} =>
                            fracq
                              (let (y1, y2) := y in
                               match y2 with
                               | Posz 1 => (y1, 1%R)
                               | _ => ((0 * y2 + y1)%R, y2)
                               end)
                        end *
                        match rat_of_Z 2 with
                        | {| valq := y |} =>
                            fracq
                              (let (y1, y2) := y in
                               match y2 with
                               | Posz 1 => (y1, 1%R)
                               | _ => ((0 * y2 + y1)%R, y2)
                               end)
                        end)%Q)%Q^-1)%Q)%Q)%Q)%Q)%Q *
                 ((match rat_of_Z 2 with
                   | {| valq := y |} =>
                       fracq
                         (let (y1, y2) := y in
                          match y2 with
                          | Posz 1 =>
                              match y1 with
                              | Posz 0 => (1%R, 1%R)
                              | Posz 1 => (Posz 2, 1%R)
                              | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                              | Negz _ => ((1 + y1)%R, 1%R)
                              end
                          | _ => ((1 * y2 + y1)%R, y2)
                          end)
                   end *
                   (match rat_of_Z 2 with
                    | {| valq := y |} =>
                        fracq
                          (let (y1, y2) := y in
                           match y2 with
                           | Posz 1 =>
                               match y1 with
                               | Posz 0 => (1%R, 1%R)
                               | Posz 1 => (Posz 2, 1%R)
                               | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                               | Negz _ => ((1 + y1)%R, 1%R)
                               end
                           | _ => ((1 * y2 + y1)%R, y2)
                           end)
                    end *
                    match rat_of_Z 2 with
                    | {| valq := y |} =>
                        fracq
                          (let (y1, y2) := y in
                           match y2 with
                           | Posz 1 =>
                               match y1 with
                               | Posz 0 => (1%R, 1%R)
                               | Posz 1 => (Posz 2, 1%R)
                               | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                               | Negz _ => ((1 + y1)%R, 1%R)
                               end
                           | _ => ((1 * y2 + y1)%R, y2)
                           end)
                    end)%Q)%Q^-1)%Q)%Q)%Q +
               ((((- rat_of_Z 1)%Q *
                  (((rat_of_Z 17 * fracq ((1 * 1)%R, 1%R))%Q +
                    (rat_of_Z 51 * 1%Q)%Q)%Q + rat_of_Z 39)%Q)%Q *
                 ((rat_of_Z 2 * 1%Q)%Q + rat_of_Z 3)%Q)%Q *
                ((-
                  (((match rat_of_Z 1 with
                     | {| valq := y |} =>
                         fracq
                           (let (y1, y2) := y in
                            match y2 with
                            | Posz 1 => (y1, 1%R)
                            | _ => ((0 * y2 + y1)%R, y2)
                            end)
                     end *
                     (match rat_of_Z 1 with
                      | {| valq := y |} =>
                          fracq
                            (let (y1, y2) := y in
                             match y2 with
                             | Posz 1 => (y1, 1%R)
                             | _ => ((0 * y2 + y1)%R, y2)
                             end)
                      end *
                      match rat_of_Z 1 with
                      | {| valq := y |} =>
                          fracq
                            (let (y1, y2) := y in
                             match y2 with
                             | Posz 1 => (y1, 1%R)
                             | _ => ((0 * y2 + y1)%R, y2)
                             end)
                      end)%Q)%Q * b (Posz 0))%Q +
                   ((((- rat_of_Z 1)%Q *
                      (((rat_of_Z 17 * fracq ((0 * 0)%R, 1%R))%Q +
                        (rat_of_Z 51 * 0%Q)%Q)%Q + 
                       rat_of_Z 39)%Q)%Q *
                     ((rat_of_Z 2 * 0%Q)%Q + rat_of_Z 3)%Q)%Q * 
                    b (Posz 1))%Q)%Q)%Q *
                 ((match rat_of_Z 2 with
                   | {| valq := y |} =>
                       fracq
                         (let (y1, y2) := y in
                          match y2 with
                          | Posz 1 => (y1, 1%R)
                          | _ => ((0 * y2 + y1)%R, y2)
                          end)
                   end *
                   (match rat_of_Z 2 with
                    | {| valq := y |} =>
                        fracq
                          (let (y1, y2) := y in
                           match y2 with
                           | Posz 1 => (y1, 1%R)
                           | _ => ((0 * y2 + y1)%R, y2)
                           end)
                    end *
                    match rat_of_Z 2 with
                    | {| valq := y |} =>
                        fracq
                          (let (y1, y2) := y in
                           match y2 with
                           | Posz 1 => (y1, 1%R)
                           | _ => ((0 * y2 + y1)%R, y2)
                           end)
                    end)%Q)%Q^-1)%Q)%Q)%Q)%Q).2 *
           (valq
              ((match rat_of_Z 1 with
                | {| valq := y |} =>
                    fracq
                      (let (y1, y2) := y in
                       match y2 with
                       | Posz 1 =>
                           match y1 with
                           | Posz 0 => (1%R, 1%R)
                           | Posz 1 => (Posz 2, 1%R)
                           | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                           | Negz _ => ((1 + y1)%R, 1%R)
                           end
                       | _ => ((1 * y2 + y1)%R, y2)
                       end)
                end *
                (match rat_of_Z 1 with
                 | {| valq := y |} =>
                     fracq
                       (let (y1, y2) := y in
                        match y2 with
                        | Posz 1 =>
                            match y1 with
                            | Posz 0 => (1%R, 1%R)
                            | Posz 1 => (Posz 2, 1%R)
                            | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                            | Negz _ => ((1 + y1)%R, 1%R)
                            end
                        | _ => ((1 * y2 + y1)%R, y2)
                        end)
                 end *
                 match rat_of_Z 1 with
                 | {| valq := y |} =>
                     fracq
                       (let (y1, y2) := y in
                        match y2 with
                        | Posz 1 =>
                            match y1 with
                            | Posz 0 => (1%R, 1%R)
                            | Posz 1 => (Posz 2, 1%R)
                            | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                            | Negz _ => ((1 + y1)%R, 1%R)
                            end
                        | _ => ((1 * y2 + y1)%R, y2)
                        end)
                 end)%Q)%Q * b (Posz 1))%Q).2); 0%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building ident_interp...
Building base_eq_dec...
Building base_beq_and_reflect...
Building base_beq...
Building reflect_base_beq...
Building baseHasNatAndCorrect...
Building baseHasNat...
Building baseHasNatCorrect...
Building base_interp_beq...
Building reflect_base_interp_beq...
Building try_make_base_transport_cps...
Building try_make_base_transport_cps_correct...
Building all_idents...
Building all_ident_and_interp...
Building buildEagerIdentAndInterpCorrect...
Building buildEagerIdent...
Building buildInterpEagerIdentCorrect...
Building toRestrictedIdentAndCorrect...
Building toRestrictedIdent...
Building toFromRestrictedIdent...
Crunching: (iterate HIS body = iterate HIS body')
Building buildIdentAndInterpCorrect...
Building buildIdent...
Building buildInterpIdentCorrect...
Building ident_is_var_like...
Building eqv_Reflexive_Proper...
Building ident_interp_Proper...
Building invertIdent...
Building buildInvertIdentCorrect...
Building base_default...
Building package...
Building all_base...
Building all_idents...
Building ident_index...
check_guarded: true
check_positive: true
check_universes: true
cumulative sprop: false
definitional uip: false
Building eta_ident_cps_gen...
"toto has been translated as totoᵗ"
totoᵗ : unit -> (forall A : Type, A -> A) -> Type -> Type
     : unit -> (forall A : Type, A -> A) -> Type -> Type
"FALSE has been translated as FALSEᵗ"
"toto"
Building eta_ident_cps_gen_expand_literal...
Building eta_ident_cps...
Building simple_idents...
Building all_raw_idents...
Building raw_ident_index...
Building raw_ident_index_idempotent...
Building eta_raw_ident_cps_gen...
Building raw_ident_to_ident...
Building raw_ident_infos_of...
Building split_raw_ident_gen...
"a has been translated as aᵗ"
"T has been translated as Tᵗ"
"tm has been translated as tmᵗ"
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: 0%Q;
         fracq
           ((valq
               (((match rat_of_Z 2 with
                  | {| valq := y |} =>
                      fracq
                        (let (y1, y2) := y in
                         match y2 with
                         | Posz 1 =>
                             match y1 with
                             | Posz 0 => (1%R, 1%R)
                             | Posz 1 => (Posz 2, 1%R)
                             | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                             | Negz _ => ((1 + y1)%R, 1%R)
                             end
                         | _ => ((1 * y2 + y1)%R, y2)
                         end)
                  end *
                  (match rat_of_Z 2 with
                   | {| valq := y |} =>
                       fracq
                         (let (y1, y2) := y in
                          match y2 with
                          | Posz 1 =>
                              match y1 with
                              | Posz 0 => (1%R, 1%R)
                              | Posz 1 => (Posz 2, 1%R)
                              | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                              | Negz _ => ((1 + y1)%R, 1%R)
                              end
                          | _ => ((1 * y2 + y1)%R, y2)
                          end)
                   end *
                   match rat_of_Z 2 with
                   | {| valq := y |} =>
                       fracq
                         (let (y1, y2) := y in
                          match y2 with
                          | Posz 1 =>
                              match y1 with
                              | Posz 0 => (1%R, 1%R)
                              | Posz 1 => (Posz 2, 1%R)
                              | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                              | Negz _ => ((1 + y1)%R, 1%R)
                              end
                          | _ => ((1 * y2 + y1)%R, y2)
                          end)
                   end)%Q)%Q *
                 ((-
                   (((match rat_of_Z 1 with
                      | {| valq := y |} =>
                          fracq
                            (let (y1, y2) := y in
                             match y2 with
                             | Posz 1 =>
                                 match y1 with
                                 | Posz 0 => (1%R, 1%R)
                                 | Posz 1 => (Posz 2, 1%R)
                                 | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                                 | Negz _ => ((1 + y1)%R, 1%R)
                                 end
                             | _ => ((1 * y2 + y1)%R, y2)
                             end)
                      end *
                      (match rat_of_Z 1 with
                       | {| valq := y |} =>
                           fracq
                             (let (y1, y2) := y in
                              match y2 with
                              | Posz 1 =>
                                  match y1 with
                                  | Posz 0 => (1%R, 1%R)
                                  | Posz 1 => (Posz 2, 1%R)
                                  | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                                  | Negz _ => ((1 + y1)%R, 1%R)
                                  end
                              | _ => ((1 * y2 + y1)%R, y2)
                              end)
                       end *
                       match rat_of_Z 1 with
                       | {| valq := y |} =>
                           fracq
                             (let (y1, y2) := y in
                              match y2 with
                              | Posz 1 =>
                                  match y1 with
                                  | Posz 0 => (1%R, 1%R)
                                  | Posz 1 => (Posz 2, 1%R)
                                  | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                                  | Negz _ => ((1 + y1)%R, 1%R)
                                  end
                              | _ => ((1 * y2 + y1)%R, y2)
                              end)
                       end)%Q)%Q * b (Posz 1))%Q +
                    ((((- rat_of_Z 1)%Q *
                       (((rat_of_Z 17 * fracq ((1 * 1)%R, 1%R))%Q +
                         (rat_of_Z 51 * 1%Q)%Q)%Q + 
                        rat_of_Z 39)%Q)%Q *
                      ((rat_of_Z 2 * 1%Q)%Q + rat_of_Z 3)%Q)%Q *
                     ((-
                       (((match rat_of_Z 1 with
                          | {| valq := y |} =>
                              fracq
                                (let (y1, y2) := y in
                                 match y2 with
                                 | Posz 1 => (y1, 1%R)
                                 | _ => ((0 * y2 + y1)%R, y2)
                                 end)
                          end *
                          (match rat_of_Z 1 with
                           | {| valq := y |} =>
                               fracq
                                 (let (y1, y2) := y in
                                  match y2 with
                                  | Posz 1 => (y1, 1%R)
                                  | _ => ((0 * y2 + y1)%R, y2)
                                  end)
                           end *
                           match rat_of_Z 1 with
                           | {| valq := y |} =>
                               fracq
                                 (let (y1, y2) := y in
                                  match y2 with
                                  | Posz 1 => (y1, 1%R)
                                  | _ => ((0 * y2 + y1)%R, y2)
                                  end)
                           end)%Q)%Q * b (Posz 0))%Q +
                        ((((- rat_of_Z 1)%Q *
                           (((rat_of_Z 17 * fracq ((0 * 0)%R, 1%R))%Q +
                             (rat_of_Z 51 * 0%Q)%Q)%Q + 
                            rat_of_Z 39)%Q)%Q *
                          ((rat_of_Z 2 * 0%Q)%Q + rat_of_Z 3)%Q)%Q *
                         b (Posz 1))%Q)%Q)%Q *
                      ((match rat_of_Z 2 with
                        | {| valq := y |} =>
                            fracq
                              (let (y1, y2) := y in
                               match y2 with
                               | Posz 1 => (y1, 1%R)
                               | _ => ((0 * y2 + y1)%R, y2)
                               end)
                        end *
                        (match rat_of_Z 2 with
                         | {| valq := y |} =>
                             fracq
                               (let (y1, y2) := y in
                                match y2 with
                                | Posz 1 => (y1, 1%R)
                                | _ => ((0 * y2 + y1)%R, y2)
                                end)
                         end *
                         match rat_of_Z 2 with
                         | {| valq := y |} =>
                             fracq
                               (let (y1, y2) := y in
                                match y2 with
                                | Posz 1 => (y1, 1%R)
                                | _ => ((0 * y2 + y1)%R, y2)
                                end)
                         end)%Q)%Q^-1)%Q)%Q)%Q)%Q)%Q *
                  ((match rat_of_Z 2 with
                    | {| valq := y |} =>
                        fracq
                          (let (y1, y2) := y in
                           match y2 with
                           | Posz 1 =>
                               match y1 with
                               | Posz 0 => (1%R, 1%R)
                               | Posz 1 => (Posz 2, 1%R)
                               | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                               | Negz _ => ((1 + y1)%R, 1%R)
                               end
                           | _ => ((1 * y2 + y1)%R, y2)
                           end)
                    end *
                    (match rat_of_Z 2 with
                     | {| valq := y |} =>
                         fracq
                           (let (y1, y2) := y in
                            match y2 with
                            | Posz 1 =>
                                match y1 with
                                | Posz 0 => (1%R, 1%R)
                                | Posz 1 => (Posz 2, 1%R)
                                | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                                | Negz _ => ((1 + y1)%R, 1%R)
                                end
                            | _ => ((1 * y2 + y1)%R, y2)
                            end)
                     end *
                     match rat_of_Z 2 with
                     | {| valq := y |} =>
                         fracq
                           (let (y1, y2) := y in
                            match y2 with
                            | Posz 1 =>
                                match y1 with
                                | Posz 0 => (1%R, 1%R)
                                | Posz 1 => (Posz 2, 1%R)
                                | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                                | Negz _ => ((1 + y1)%R, 1%R)
                                end
                            | _ => ((1 * y2 + y1)%R, y2)
                            end)
                     end)%Q)%Q^-1)%Q)%Q)%Q +
                ((((- rat_of_Z 1)%Q *
                   (((rat_of_Z 17 * fracq ((1 * 1)%R, 1%R))%Q +
                     (rat_of_Z 51 * 1%Q)%Q)%Q + rat_of_Z 39)%Q)%Q *
                  ((rat_of_Z 2 * 1%Q)%Q + rat_of_Z 3)%Q)%Q *
                 ((-
                   (((match rat_of_Z 1 with
                      | {| valq := y |} =>
                          fracq
                            (let (y1, y2) := y in
                             match y2 with
                             | Posz 1 => (y1, 1%R)
                             | _ => ((0 * y2 + y1)%R, y2)
                             end)
                      end *
                      (match rat_of_Z 1 with
                       | {| valq := y |} =>
                           fracq
                             (let (y1, y2) := y in
                              match y2 with
                              | Posz 1 => (y1, 1%R)
                              | _ => ((0 * y2 + y1)%R, y2)
                              end)
                       end *
                       match rat_of_Z 1 with
                       | {| valq := y |} =>
                           fracq
                             (let (y1, y2) := y in
                              match y2 with
                              | Posz 1 => (y1, 1%R)
                              | _ => ((0 * y2 + y1)%R, y2)
                              end)
                       end)%Q)%Q * b (Posz 0))%Q +
                    ((((- rat_of_Z 1)%Q *
                       (((rat_of_Z 17 * fracq ((0 * 0)%R, 1%R))%Q +
                         (rat_of_Z 51 * 0%Q)%Q)%Q + 
                        rat_of_Z 39)%Q)%Q *
                      ((rat_of_Z 2 * 0%Q)%Q + rat_of_Z 3)%Q)%Q * 
                     b (Posz 1))%Q)%Q)%Q *
                  ((match rat_of_Z 2 with
                    | {| valq := y |} =>
                        fracq
                          (let (y1, y2) := y in
                           match y2 with
                           | Posz 1 => (y1, 1%R)
                           | _ => ((0 * y2 + y1)%R, y2)
                           end)
                    end *
                    (match rat_of_Z 2 with
                     | {| valq := y |} =>
                         fracq
                           (let (y1, y2) := y in
                            match y2 with
                            | Posz 1 => (y1, 1%R)
                            | _ => ((0 * y2 + y1)%R, y2)
                            end)
                     end *
                     match rat_of_Z 2 with
                     | {| valq := y |} =>
                         fracq
                           (let (y1, y2) := y in
                            match y2 with
                            | Posz 1 => (y1, 1%R)
                            | _ => ((0 * y2 + y1)%R, y2)
                            end)
                     end)%Q)%Q^-1)%Q)%Q)%Q)%Q).1 *
            (valq
               ((match rat_of_Z 1 with
                 | {| valq := y |} =>
                     fracq
                       (let (y1, y2) := y in
                        match y2 with
                        | Posz 1 =>
                            match y1 with
                            | Posz 0 => (1%R, 1%R)
                            | Posz 1 => (Posz 2, 1%R)
                            | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                            | Negz _ => ((1 + y1)%R, 1%R)
                            end
                        | _ => ((1 * y2 + y1)%R, y2)
                        end)
                 end *
                 (match rat_of_Z 1 with
                  | {| valq := y |} =>
                      fracq
                        (let (y1, y2) := y in
                         match y2 with
                         | Posz 1 =>
                             match y1 with
                             | Posz 0 => (1%R, 1%R)
                             | Posz 1 => (Posz 2, 1%R)
                             | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                             | Negz _ => ((1 + y1)%R, 1%R)
                             end
                         | _ => ((1 * y2 + y1)%R, y2)
                         end)
                  end *
                  match rat_of_Z 1 with
                  | {| valq := y |} =>
                      fracq
                        (let (y1, y2) := y in
                         match y2 with
                         | Posz 1 =>
                             match y1 with
                             | Posz 0 => (1%R, 1%R)
                             | Posz 1 => (Posz 2, 1%R)
                             | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                             | Negz _ => ((1 + y1)%R, 1%R)
                             end
                         | _ => ((1 * y2 + y1)%R, y2)
                         end)
                  end)%Q)%Q * b (Posz 1))%Q).2 +
            (valq
               ((match rat_of_Z 1 with
                 | {| valq := y |} =>
                     fracq
                       (let (y1, y2) := y in
                        match y2 with
                        | Posz 1 =>
                            match y1 with
                            | Posz 0 => (1%R, 1%R)
                            | Posz 1 => (Posz 2, 1%R)
                            | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                            | Negz _ => ((1 + y1)%R, 1%R)
                            end
                        | _ => ((1 * y2 + y1)%R, y2)
                        end)
                 end *
                 (match rat_of_Z 1 with
                  | {| valq := y |} =>
                      fracq
                        (let (y1, y2) := y in
                         match y2 with
                         | Posz 1 =>
                             match y1 with
                             | Posz 0 => (1%R, 1%R)
                             | Posz 1 => (Posz 2, 1%R)
                             | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                             | Negz _ => ((1 + y1)%R, 1%R)
                             end
                         | _ => ((1 * y2 + y1)%R, y2)
                         end)
                  end *
                  match rat_of_Z 1 with
                  | {| valq := y |} =>
                      fracq
                        (let (y1, y2) := y in
                         match y2 with
                         | Posz 1 =>
                             match y1 with
                             | Posz 0 => (1%R, 1%R)
                             | Posz 1 => (Posz 2, 1%R)
                             | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                             | Negz _ => ((1 + y1)%R, 1%R)
                             end
                         | _ => ((1 * y2 + y1)%R, y2)
                         end)
                  end)%Q)%Q * b (Posz 1))%Q).1 *
            (valq
               (((match rat_of_Z 2 with
                  | {| valq := y |} =>
                      fracq
                        (let (y1, y2) := y in
                         match y2 with
                         | Posz 1 =>
                             match y1 with
                             | Posz 0 => (1%R, 1%R)
                             | Posz 1 => (Posz 2, 1%R)
                             | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                             | Negz _ => ((1 + y1)%R, 1%R)
                             end
                         | _ => ((1 * y2 + y1)%R, y2)
                         end)
                  end *
                  (match rat_of_Z 2 with
                   | {| valq := y |} =>
                       fracq
                         (let (y1, y2) := y in
                          match y2 with
                          | Posz 1 =>
                              match y1 with
                              | Posz 0 => (1%R, 1%R)
                              | Posz 1 => (Posz 2, 1%R)
                              | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                              | Negz _ => ((1 + y1)%R, 1%R)
                              end
                          | _ => ((1 * y2 + y1)%R, y2)
                          end)
                   end *
                   match rat_of_Z 2 with
                   | {| valq := y |} =>
                       fracq
                         (let (y1, y2) := y in
                          match y2 with
                          | Posz 1 =>
                              match y1 with
                              | Posz 0 => (1%R, 1%R)
                              | Posz 1 => (Posz 2, 1%R)
                              | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                              | Negz _ => ((1 + y1)%R, 1%R)
                              end
                          | _ => ((1 * y2 + y1)%R, y2)
                          end)
                   end)%Q)%Q *
                 ((-
                   (((match rat_of_Z 1 with
                      | {| valq := y |} =>
                          fracq
                            (let (y1, y2) := y in
                             match y2 with
                             | Posz 1 =>
                                 match y1 with
                                 | Posz 0 => (1%R, 1%R)
                                 | Posz 1 => (Posz 2, 1%R)
                                 | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                                 | Negz _ => ((1 + y1)%R, 1%R)
                                 end
                             | _ => ((1 * y2 + y1)%R, y2)
                             end)
                      end *
                      (match rat_of_Z 1 with
                       | {| valq := y |} =>
                           fracq
                             (let (y1, y2) := y in
                              match y2 with
                              | Posz 1 =>
                                  match y1 with
                                  | Posz 0 => (1%R, 1%R)
                                  | Posz 1 => (Posz 2, 1%R)
                                  | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                                  | Negz _ => ((1 + y1)%R, 1%R)
                                  end
                              | _ => ((1 * y2 + y1)%R, y2)
                              end)
                       end *
                       match rat_of_Z 1 with
                       | {| valq := y |} =>
                           fracq
                             (let (y1, y2) := y in
                              match y2 with
                              | Posz 1 =>
                                  match y1 with
                                  | Posz 0 => (1%R, 1%R)
                                  | Posz 1 => (Posz 2, 1%R)
                                  | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                                  | Negz _ => ((1 + y1)%R, 1%R)
                                  end
                              | _ => ((1 * y2 + y1)%R, y2)
                              end)
                       end)%Q)%Q * b (Posz 1))%Q +
                    ((((- rat_of_Z 1)%Q *
                       (((rat_of_Z 17 * fracq ((1 * 1)%R, 1%R))%Q +
                         (rat_of_Z 51 * 1%Q)%Q)%Q + 
                        rat_of_Z 39)%Q)%Q *
                      ((rat_of_Z 2 * 1%Q)%Q + rat_of_Z 3)%Q)%Q *
                     ((-
                       (((match rat_of_Z 1 with
                          | {| valq := y |} =>
                              fracq
                                (let (y1, y2) := y in
                                 match y2 with
                                 | Posz 1 => (y1, 1%R)
                                 | _ => ((0 * y2 + y1)%R, y2)
                                 end)
                          end *
                          (match rat_of_Z 1 with
                           | {| valq := y |} =>
                               fracq
                                 (let (y1, y2) := y in
                                  match y2 with
                                  | Posz 1 => (y1, 1%R)
                                  | _ => ((0 * y2 + y1)%R, y2)
                                  end)
                           end *
                           match rat_of_Z 1 with
                           | {| valq := y |} =>
                               fracq
                                 (let (y1, y2) := y in
                                  match y2 with
                                  | Posz 1 => (y1, 1%R)
                                  | _ => ((0 * y2 + y1)%R, y2)
                                  end)
                           end)%Q)%Q * b (Posz 0))%Q +
                        ((((- rat_of_Z 1)%Q *
                           (((rat_of_Z 17 * fracq ((0 * 0)%R, 1%R))%Q +
                             (rat_of_Z 51 * 0%Q)%Q)%Q + 
                            rat_of_Z 39)%Q)%Q *
                          ((rat_of_Z 2 * 0%Q)%Q + rat_of_Z 3)%Q)%Q *
                         b (Posz 1))%Q)%Q)%Q *
                      ((match rat_of_Z 2 with
                        | {| valq := y |} =>
                            fracq
                              (let (y1, y2) := y in
                               match y2 with
                               | Posz 1 => (y1, 1%R)
                               | _ => ((0 * y2 + y1)%R, y2)
                               end)
                        end *
                        (match rat_of_Z 2 with
                         | {| valq := y |} =>
                             fracq
                               (let (y1, y2) := y in
                                match y2 with
                                | Posz 1 => (y1, 1%R)
                                | _ => ((0 * y2 + y1)%R, y2)
                                end)
                         end *
                         match rat_of_Z 2 with
                         | {| valq := y |} =>
                             fracq
                               (let (y1, y2) := y in
                                match y2 with
                                | Posz 1 => (y1, 1%R)
                                | _ => ((0 * y2 + y1)%R, y2)
                                end)
                         end)%Q)%Q^-1)%Q)%Q)%Q)%Q)%Q *
                  ((match rat_of_Z 2 with
                    | {| valq := y |} =>
                        fracq
                          (let (y1, y2) := y in
                           match y2 with
                           | Posz 1 =>
                               match y1 with
                               | Posz 0 => (1%R, 1%R)
                               | Posz 1 => (Posz 2, 1%R)
                               | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                               | Negz _ => ((1 + y1)%R, 1%R)
                               end
                           | _ => ((1 * y2 + y1)%R, y2)
                           end)
                    end *
                    (match rat_of_Z 2 with
                     | {| valq := y |} =>
                         fracq
                           (let (y1, y2) := y in
                            match y2 with
                            | Posz 1 =>
                                match y1 with
                                | Posz 0 => (1%R, 1%R)
                                | Posz 1 => (Posz 2, 1%R)
                                | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                                | Negz _ => ((1 + y1)%R, 1%R)
                                end
                            | _ => ((1 * y2 + y1)%R, y2)
                            end)
                     end *
                     match rat_of_Z 2 with
                     | {| valq := y |} =>
                         fracq
                           (let (y1, y2) := y in
                            match y2 with
                            | Posz 1 =>
                                match y1 with
                                | Posz 0 => (1%R, 1%R)
                                | Posz 1 => (Posz 2, 1%R)
                                | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                                | Negz _ => ((1 + y1)%R, 1%R)
                                end
                            | _ => ((1 * y2 + y1)%R, y2)
                            end)
                     end)%Q)%Q^-1)%Q)%Q)%Q +
                ((((- rat_of_Z 1)%Q *
                   (((rat_of_Z 17 * fracq ((1 * 1)%R, 1%R))%Q +
                     (rat_of_Z 51 * 1%Q)%Q)%Q + rat_of_Z 39)%Q)%Q *
                  ((rat_of_Z 2 * 1%Q)%Q + rat_of_Z 3)%Q)%Q *
                 ((-
                   (((match rat_of_Z 1 with
                      | {| valq := y |} =>
                          fracq
                            (let (y1, y2) := y in
                             match y2 with
                             | Posz 1 => (y1, 1%R)
                             | _ => ((0 * y2 + y1)%R, y2)
                             end)
                      end *
                      (match rat_of_Z 1 with
                       | {| valq := y |} =>
                           fracq
                             (let (y1, y2) := y in
                              match y2 with
                              | Posz 1 => (y1, 1%R)
                              | _ => ((0 * y2 + y1)%R, y2)
                              end)
                       end *
                       match rat_of_Z 1 with
                       | {| valq := y |} =>
                           fracq
                             (let (y1, y2) := y in
                              match y2 with
                              | Posz 1 => (y1, 1%R)
                              | _ => ((0 * y2 + y1)%R, y2)
                              end)
                       end)%Q)%Q * b (Posz 0))%Q +
                    ((((- rat_of_Z 1)%Q *
                       (((rat_of_Z 17 * fracq ((0 * 0)%R, 1%R))%Q +
                         (rat_of_Z 51 * 0%Q)%Q)%Q + 
                        rat_of_Z 39)%Q)%Q *
                      ((rat_of_Z 2 * 0%Q)%Q + rat_of_Z 3)%Q)%Q * 
                     b (Posz 1))%Q)%Q)%Q *
                  ((match rat_of_Z 2 with
                    | {| valq := y |} =>
                        fracq
                          (let (y1, y2) := y in
                           match y2 with
                           | Posz 1 => (y1, 1%R)
                           | _ => ((0 * y2 + y1)%R, y2)
                           end)
                    end *
                    (match rat_of_Z 2 with
                     | {| valq := y |} =>
                         fracq
                           (let (y1, y2) := y in
                            match y2 with
                            | Posz 1 => (y1, 1%R)
                            | _ => ((0 * y2 + y1)%R, y2)
                            end)
                     end *
                     match rat_of_Z 2 with
                     | {| valq := y |} =>
                         fracq
                           (let (y1, y2) := y in
                            match y2 with
                            | Posz 1 => (y1, 1%R)
                            | _ => ((0 * y2 + y1)%R, y2)
                            end)
                     end)%Q)%Q^-1)%Q)%Q)%Q)%Q).2,
           (valq
              (((match rat_of_Z 2 with
                 | {| valq := y |} =>
                     fracq
                       (let (y1, y2) := y in
                        match y2 with
                        | Posz 1 =>
                            match y1 with
                            | Posz 0 => (1%R, 1%R)
                            | Posz 1 => (Posz 2, 1%R)
                            | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                            | Negz _ => ((1 + y1)%R, 1%R)
                            end
                        | _ => ((1 * y2 + y1)%R, y2)
                        end)
                 end *
                 (match rat_of_Z 2 with
                  | {| valq := y |} =>
                      fracq
                        (let (y1, y2) := y in
                         match y2 with
                         | Posz 1 =>
                             match y1 with
                             | Posz 0 => (1%R, 1%R)
                             | Posz 1 => (Posz 2, 1%R)
                             | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                             | Negz _ => ((1 + y1)%R, 1%R)
                             end
                         | _ => ((1 * y2 + y1)%R, y2)
                         end)
                  end *
                  match rat_of_Z 2 with
                  | {| valq := y |} =>
                      fracq
                        (let (y1, y2) := y in
                         match y2 with
                         | Posz 1 =>
                             match y1 with
                             | Posz 0 => (1%R, 1%R)
                             | Posz 1 => (Posz 2, 1%R)
                             | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                             | Negz _ => ((1 + y1)%R, 1%R)
                             end
                         | _ => ((1 * y2 + y1)%R, y2)
                         end)
                  end)%Q)%Q *
                ((-
                  (((match rat_of_Z 1 with
                     | {| valq := y |} =>
                         fracq
                           (let (y1, y2) := y in
                            match y2 with
                            | Posz 1 =>
                                match y1 with
                                | Posz 0 => (1%R, 1%R)
                                | Posz 1 => (Posz 2, 1%R)
                                | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                                | Negz _ => ((1 + y1)%R, 1%R)
                                end
                            | _ => ((1 * y2 + y1)%R, y2)
                            end)
                     end *
                     (match rat_of_Z 1 with
                      | {| valq := y |} =>
                          fracq
                            (let (y1, y2) := y in
                             match y2 with
                             | Posz 1 =>
                                 match y1 with
                                 | Posz 0 => (1%R, 1%R)
                                 | Posz 1 => (Posz 2, 1%R)
                                 | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                                 | Negz _ => ((1 + y1)%R, 1%R)
                                 end
                             | _ => ((1 * y2 + y1)%R, y2)
                             end)
                      end *
                      match rat_of_Z 1 with
                      | {| valq := y |} =>
                          fracq
                            (let (y1, y2) := y in
                             match y2 with
                             | Posz 1 =>
                                 match y1 with
                                 | Posz 0 => (1%R, 1%R)
                                 | Posz 1 => (Posz 2, 1%R)
                                 | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                                 | Negz _ => ((1 + y1)%R, 1%R)
                                 end
                             | _ => ((1 * y2 + y1)%R, y2)
                             end)
                      end)%Q)%Q * b (Posz 1))%Q +
                   ((((- rat_of_Z 1)%Q *
                      (((rat_of_Z 17 * fracq ((1 * 1)%R, 1%R))%Q +
                        (rat_of_Z 51 * 1%Q)%Q)%Q + 
                       rat_of_Z 39)%Q)%Q *
                     ((rat_of_Z 2 * 1%Q)%Q + rat_of_Z 3)%Q)%Q *
                    ((-
                      (((match rat_of_Z 1 with
                         | {| valq := y |} =>
                             fracq
                               (let (y1, y2) := y in
                                match y2 with
                                | Posz 1 => (y1, 1%R)
                                | _ => ((0 * y2 + y1)%R, y2)
                                end)
                         end *
                         (match rat_of_Z 1 with
                          | {| valq := y |} =>
                              fracq
                                (let (y1, y2) := y in
                                 match y2 with
                                 | Posz 1 => (y1, 1%R)
                                 | _ => ((0 * y2 + y1)%R, y2)
                                 end)
                          end *
                          match rat_of_Z 1 with
                          | {| valq := y |} =>
                              fracq
                                (let (y1, y2) := y in
                                 match y2 with
                                 | Posz 1 => (y1, 1%R)
                                 | _ => ((0 * y2 + y1)%R, y2)
                                 end)
                          end)%Q)%Q * b (Posz 0))%Q +
                       ((((- rat_of_Z 1)%Q *
                          (((rat_of_Z 17 * fracq ((0 * 0)%R, 1%R))%Q +
                            (rat_of_Z 51 * 0%Q)%Q)%Q + 
                           rat_of_Z 39)%Q)%Q *
                         ((rat_of_Z 2 * 0%Q)%Q + rat_of_Z 3)%Q)%Q *
                        b (Posz 1))%Q)%Q)%Q *
                     ((match rat_of_Z 2 with
                       | {| valq := y |} =>
                           fracq
                             (let (y1, y2) := y in
                              match y2 with
                              | Posz 1 => (y1, 1%R)
                              | _ => ((0 * y2 + y1)%R, y2)
                              end)
                       end *
                       (match rat_of_Z 2 with
                        | {| valq := y |} =>
                            fracq
                              (let (y1, y2) := y in
                               match y2 with
                               | Posz 1 => (y1, 1%R)
                               | _ => ((0 * y2 + y1)%R, y2)
                               end)
                        end *
                        match rat_of_Z 2 with
                        | {| valq := y |} =>
                            fracq
                              (let (y1, y2) := y in
                               match y2 with
                               | Posz 1 => (y1, 1%R)
                               | _ => ((0 * y2 + y1)%R, y2)
                               end)
                        end)%Q)%Q^-1)%Q)%Q)%Q)%Q)%Q *
                 ((match rat_of_Z 2 with
                   | {| valq := y |} =>
                       fracq
                         (let (y1, y2) := y in
                          match y2 with
                          | Posz 1 =>
                              match y1 with
                              | Posz 0 => (1%R, 1%R)
                              | Posz 1 => (Posz 2, 1%R)
                              | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                              | Negz _ => ((1 + y1)%R, 1%R)
                              end
                          | _ => ((1 * y2 + y1)%R, y2)
                          end)
                   end *
                   (match rat_of_Z 2 with
                    | {| valq := y |} =>
                        fracq
                          (let (y1, y2) := y in
                           match y2 with
                           | Posz 1 =>
                               match y1 with
                               | Posz 0 => (1%R, 1%R)
                               | Posz 1 => (Posz 2, 1%R)
                               | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                               | Negz _ => ((1 + y1)%R, 1%R)
                               end
                           | _ => ((1 * y2 + y1)%R, y2)
                           end)
                    end *
                    match rat_of_Z 2 with
                    | {| valq := y |} =>
                        fracq
                          (let (y1, y2) := y in
                           match y2 with
                           | Posz 1 =>
                               match y1 with
                               | Posz 0 => (1%R, 1%R)
                               | Posz 1 => (Posz 2, 1%R)
                               | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                               | Negz _ => ((1 + y1)%R, 1%R)
                               end
                           | _ => ((1 * y2 + y1)%R, y2)
                           end)
                    end)%Q)%Q^-1)%Q)%Q)%Q +
               ((((- rat_of_Z 1)%Q *
                  (((rat_of_Z 17 * fracq ((1 * 1)%R, 1%R))%Q +
                    (rat_of_Z 51 * 1%Q)%Q)%Q + rat_of_Z 39)%Q)%Q *
                 ((rat_of_Z 2 * 1%Q)%Q + rat_of_Z 3)%Q)%Q *
                ((-
                  (((match rat_of_Z 1 with
                     | {| valq := y |} =>
                         fracq
                           (let (y1, y2) := y in
                            match y2 with
                            | Posz 1 => (y1, 1%R)
                            | _ => ((0 * y2 + y1)%R, y2)
                            end)
                     end *
                     (match rat_of_Z 1 with
                      | {| valq := y |} =>
                          fracq
                            (let (y1, y2) := y in
                             match y2 with
                             | Posz 1 => (y1, 1%R)
                             | _ => ((0 * y2 + y1)%R, y2)
                             end)
                      end *
                      match rat_of_Z 1 with
                      | {| valq := y |} =>
                          fracq
                            (let (y1, y2) := y in
                             match y2 with
                             | Posz 1 => (y1, 1%R)
                             | _ => ((0 * y2 + y1)%R, y2)
                             end)
                      end)%Q)%Q * b (Posz 0))%Q +
                   ((((- rat_of_Z 1)%Q *
                      (((rat_of_Z 17 * fracq ((0 * 0)%R, 1%R))%Q +
                        (rat_of_Z 51 * 0%Q)%Q)%Q + 
                       rat_of_Z 39)%Q)%Q *
                     ((rat_of_Z 2 * 0%Q)%Q + rat_of_Z 3)%Q)%Q * 
                    b (Posz 1))%Q)%Q)%Q *
                 ((match rat_of_Z 2 with
                   | {| valq := y |} =>
                       fracq
                         (let (y1, y2) := y in
                          match y2 with
                          | Posz 1 => (y1, 1%R)
                          | _ => ((0 * y2 + y1)%R, y2)
                          end)
                   end *
                   (match rat_of_Z 2 with
                    | {| valq := y |} =>
                        fracq
                          (let (y1, y2) := y in
                           match y2 with
                           | Posz 1 => (y1, 1%R)
                           | _ => ((0 * y2 + y1)%R, y2)
                           end)
                    end *
                    match rat_of_Z 2 with
                    | {| valq := y |} =>
                        fracq
                          (let (y1, y2) := y in
                           match y2 with
                           | Posz 1 => (y1, 1%R)
                           | _ => ((0 * y2 + y1)%R, y2)
                           end)
                    end)%Q)%Q^-1)%Q)%Q)%Q)%Q).2 *
           (valq
              ((match rat_of_Z 1 with
                | {| valq := y |} =>
                    fracq
                      (let (y1, y2) := y in
                       match y2 with
                       | Posz 1 =>
                           match y1 with
                           | Posz 0 => (1%R, 1%R)
                           | Posz 1 => (Posz 2, 1%R)
                           | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                           | Negz _ => ((1 + y1)%R, 1%R)
                           end
                       | _ => ((1 * y2 + y1)%R, y2)
                       end)
                end *
                (match rat_of_Z 1 with
                 | {| valq := y |} =>
                     fracq
                       (let (y1, y2) := y in
                        match y2 with
                        | Posz 1 =>
                            match y1 with
                            | Posz 0 => (1%R, 1%R)
                            | Posz 1 => (Posz 2, 1%R)
                            | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                            | Negz _ => ((1 + y1)%R, 1%R)
                            end
                        | _ => ((1 * y2 + y1)%R, y2)
                        end)
                 end *
                 match rat_of_Z 1 with
                 | {| valq := y |} =>
                     fracq
                       (let (y1, y2) := y in
                        match y2 with
                        | Posz 1 =>
                            match y1 with
                            | Posz 0 => (1%R, 1%R)
                            | Posz 1 => (Posz 2, 1%R)
                            | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                            | Negz _ => ((1 + y1)%R, 1%R)
                            end
                        | _ => ((1 * y2 + y1)%R, y2)
                        end)
                 end)%Q)%Q * b (Posz 1))%Q).2)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Building invert_bind_args...
Building invert_bind_args_unknown...
Building all_pattern_idents...
Building eta_pattern_ident_cps_gen...
Building eta_pattern_ident_cps_gen_expand_literal...
Building split_types...
Building add_types_from_raw_sig...
Building to_type_split_types_subst_default_eq...
Building projT1_add_types_from_raw_sig_eq...
Building arg_types_unfolded...
Building type_of_list_arg_types_beq_unfolded...
Building to_typed_unfolded...
Building of_typed_ident_unfolded...
Building arg_types_of_typed_ident_unfolded...
Building unify...
Building unify_unknown...
Building final ident package...
Proving is_simple_correct0...
Tactic call ran for 0.38 secs (0.371u,0.009s) (success)
Proving invert_bind_args_raw_to_typed...
Tactic call ran for 0.232 secs (0.23u,0.s) (success)
Proving fold_invert_bind_args...
Tactic call ran for 0.027 secs (0.027u,0.s) (success)
Proving split_ident_to_ident...
Tactic call ran for 0.014 secs (0.014u,0.s) (success)
Proving eq_indep_types_of_eq_types...
Tactic call ran for 0.843 secs (0.821u,0.018s) (success)
Proving fold_eta_ident_cps...
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving fold_unify...
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving to_typed_of_typed_ident...
Tactic call ran for 1.518 secs (1.513u,0.002s) (success)
Proving eq_invert_bind_args_unknown...
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving eq_unify_unknown...
Tactic call ran for 0. secs (0.u,0.s) (success)
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: ((((match rat_of_Z 2 with
             | {| valq := y |} =>
                 fracq
                   (let (y1, y2) := y in
                    match y2 with
                    | Posz 1 =>
                        match y1 with
                        | Posz 0 => (1%R, 1%R)
                        | Posz 1 => (Posz 2, 1%R)
                        | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                        | Negz _ => ((1 + y1)%R, 1%R)
                        end
                    | _ => ((1 * y2 + y1)%R, y2)
                    end)
             end *
             (match rat_of_Z 2 with
              | {| valq := y |} =>
                  fracq
                    (let (y1, y2) := y in
                     match y2 with
                     | Posz 1 =>
                         match y1 with
                         | Posz 0 => (1%R, 1%R)
                         | Posz 1 => (Posz 2, 1%R)
                         | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                         | Negz _ => ((1 + y1)%R, 1%R)
                         end
                     | _ => ((1 * y2 + y1)%R, y2)
                     end)
              end *
              match rat_of_Z 2 with
              | {| valq := y |} =>
                  fracq
                    (let (y1, y2) := y in
                     match y2 with
                     | Posz 1 =>
                         match y1 with
                         | Posz 0 => (1%R, 1%R)
                         | Posz 1 => (Posz 2, 1%R)
                         | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                         | Negz _ => ((1 + y1)%R, 1%R)
                         end
                     | _ => ((1 * y2 + y1)%R, y2)
                     end)
              end)%Q)%Q *
            ((-
              (((match rat_of_Z 1 with
                 | {| valq := y |} =>
                     fracq
                       (let (y1, y2) := y in
                        match y2 with
                        | Posz 1 =>
                            match y1 with
                            | Posz 0 => (1%R, 1%R)
                            | Posz 1 => (Posz 2, 1%R)
                            | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                            | Negz _ => ((1 + y1)%R, 1%R)
                            end
                        | _ => ((1 * y2 + y1)%R, y2)
                        end)
                 end *
                 (match rat_of_Z 1 with
                  | {| valq := y |} =>
                      fracq
                        (let (y1, y2) := y in
                         match y2 with
                         | Posz 1 =>
                             match y1 with
                             | Posz 0 => (1%R, 1%R)
                             | Posz 1 => (Posz 2, 1%R)
                             | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                             | Negz _ => ((1 + y1)%R, 1%R)
                             end
                         | _ => ((1 * y2 + y1)%R, y2)
                         end)
                  end *
                  match rat_of_Z 1 with
                  | {| valq := y |} =>
                      fracq
                        (let (y1, y2) := y in
                         match y2 with
                         | Posz 1 =>
                             match y1 with
                             | Posz 0 => (1%R, 1%R)
                             | Posz 1 => (Posz 2, 1%R)
                             | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                             | Negz _ => ((1 + y1)%R, 1%R)
                             end
                         | _ => ((1 * y2 + y1)%R, y2)
                         end)
                  end)%Q)%Q * b (Posz 1))%Q +
               ((((- rat_of_Z 1)%Q *
                  (((rat_of_Z 17 * fracq (1%R, 1%R))%Q +
                    (rat_of_Z 51 * 1%Q)%Q)%Q + rat_of_Z 39)%Q)%Q *
                 ((rat_of_Z 2 * 1%Q)%Q + rat_of_Z 3)%Q)%Q *
                ((-
                  (((match rat_of_Z 1 with
                     | {| valq := y |} =>
                         fracq
                           (let (y1, y2) := y in
                            match y2 with
                            | Posz 1 => (y1, 1%R)
                            | _ => ((0 * y2 + y1)%R, y2)
                            end)
                     end *
                     (match rat_of_Z 1 with
                      | {| valq := y |} =>
                          fracq
                            (let (y1, y2) := y in
                             match y2 with
                             | Posz 1 => (y1, 1%R)
                             | _ => ((0 * y2 + y1)%R, y2)
                             end)
                      end *
                      match rat_of_Z 1 with
                      | {| valq := y |} =>
                          fracq
                            (let (y1, y2) := y in
                             match y2 with
                             | Posz 1 => (y1, 1%R)
                             | _ => ((0 * y2 + y1)%R, y2)
                             end)
                      end)%Q)%Q * b (Posz 0))%Q +
                   ((((- rat_of_Z 1)%Q *
                      (((rat_of_Z 17 * fracq (0%R, 1%R))%Q +
                        (rat_of_Z 51 * 0%Q)%Q)%Q + 
                       rat_of_Z 39)%Q)%Q *
                     ((rat_of_Z 2 * 0%Q)%Q + rat_of_Z 3)%Q)%Q * 
                    b (Posz 1))%Q)%Q)%Q *
                 ((match rat_of_Z 2 with
                   | {| valq := y |} =>
                       fracq
                         (let (y1, y2) := y in
                          match y2 with
                          | Posz 1 => (y1, 1%R)
                          | _ => ((0 * y2 + y1)%R, y2)
                          end)
                   end *
                   (match rat_of_Z 2 with
                    | {| valq := y |} =>
                        fracq
                          (let (y1, y2) := y in
                           match y2 with
                           | Posz 1 => (y1, 1%R)
                           | _ => ((0 * y2 + y1)%R, y2)
                           end)
                    end *
                    match rat_of_Z 2 with
                    | {| valq := y |} =>
                        fracq
                          (let (y1, y2) := y in
                           match y2 with
                           | Posz 1 => (y1, 1%R)
                           | _ => ((0 * y2 + y1)%R, y2)
                           end)
                    end)%Q)%Q^-1)%Q)%Q)%Q)%Q)%Q *
             ((match rat_of_Z 2 with
               | {| valq := y |} =>
                   fracq
                     (let (y1, y2) := y in
                      match y2 with
                      | Posz 1 =>
                          match y1 with
                          | Posz 0 => (1%R, 1%R)
                          | Posz 1 => (Posz 2, 1%R)
                          | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                          | Negz _ => ((1 + y1)%R, 1%R)
                          end
                      | _ => ((1 * y2 + y1)%R, y2)
                      end)
               end *
               (match rat_of_Z 2 with
                | {| valq := y |} =>
                    fracq
                      (let (y1, y2) := y in
                       match y2 with
                       | Posz 1 =>
                           match y1 with
                           | Posz 0 => (1%R, 1%R)
                           | Posz 1 => (Posz 2, 1%R)
                           | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                           | Negz _ => ((1 + y1)%R, 1%R)
                           end
                       | _ => ((1 * y2 + y1)%R, y2)
                       end)
                end *
                match rat_of_Z 2 with
                | {| valq := y |} =>
                    fracq
                      (let (y1, y2) := y in
                       match y2 with
                       | Posz 1 =>
                           match y1 with
                           | Posz 0 => (1%R, 1%R)
                           | Posz 1 => (Posz 2, 1%R)
                           | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                           | Negz _ => ((1 + y1)%R, 1%R)
                           end
                       | _ => ((1 * y2 + y1)%R, y2)
                       end)
                end)%Q)%Q^-1)%Q)%Q)%Q +
           ((((- rat_of_Z 1)%Q *
              (((rat_of_Z 17 * fracq (1%R, 1%R))%Q + (rat_of_Z 51 * 1%Q)%Q)%Q +
               rat_of_Z 39)%Q)%Q * ((rat_of_Z 2 * 1%Q)%Q + rat_of_Z 3)%Q)%Q *
            ((-
              (((match rat_of_Z 1 with
                 | {| valq := y |} =>
                     fracq
                       (let (y1, y2) := y in
                        match y2 with
                        | Posz 1 => (y1, 1%R)
                        | _ => ((0 * y2 + y1)%R, y2)
                        end)
                 end *
                 (match rat_of_Z 1 with
                  | {| valq := y |} =>
                      fracq
                        (let (y1, y2) := y in
                         match y2 with
                         | Posz 1 => (y1, 1%R)
                         | _ => ((0 * y2 + y1)%R, y2)
                         end)
                  end *
                  match rat_of_Z 1 with
                  | {| valq := y |} =>
                      fracq
                        (let (y1, y2) := y in
                         match y2 with
                         | Posz 1 => (y1, 1%R)
                         | _ => ((0 * y2 + y1)%R, y2)
                         end)
                  end)%Q)%Q * b (Posz 0))%Q +
               ((((- rat_of_Z 1)%Q *
                  (((rat_of_Z 17 * fracq (0%R, 1%R))%Q +
                    (rat_of_Z 51 * 0%Q)%Q)%Q + rat_of_Z 39)%Q)%Q *
                 ((rat_of_Z 2 * 0%Q)%Q + rat_of_Z 3)%Q)%Q * 
                b (Posz 1))%Q)%Q)%Q *
             ((match rat_of_Z 2 with
               | {| valq := y |} =>
                   fracq
                     (let (y1, y2) := y in
                      match y2 with
                      | Posz 1 => (y1, 1%R)
                      | _ => ((0 * y2 + y1)%R, y2)
                      end)
               end *
               (match rat_of_Z 2 with
                | {| valq := y |} =>
                    fracq
                      (let (y1, y2) := y in
                       match y2 with
                       | Posz 1 => (y1, 1%R)
                       | _ => ((0 * y2 + y1)%R, y2)
                       end)
                end *
                match rat_of_Z 2 with
                | {| valq := y |} =>
                    fracq
                      (let (y1, y2) := y in
                       match y2 with
                       | Posz 1 => (y1, 1%R)
                       | _ => ((0 * y2 + y1)%R, y2)
                       end)
                end)%Q)%Q^-1)%Q)%Q)%Q)%Q +
          ((match rat_of_Z 1 with
            | {| valq := y |} =>
                fracq
                  (let (y1, y2) := y in
                   match y2 with
                   | Posz 1 =>
                       match y1 with
                       | Posz 0 => (1%R, 1%R)
                       | Posz 1 => (Posz 2, 1%R)
                       | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                       | Negz _ => ((1 + y1)%R, 1%R)
                       end
                   | _ => ((1 * y2 + y1)%R, y2)
                   end)
            end *
            (match rat_of_Z 1 with
             | {| valq := y |} =>
                 fracq
                   (let (y1, y2) := y in
                    match y2 with
                    | Posz 1 =>
                        match y1 with
                        | Posz 0 => (1%R, 1%R)
                        | Posz 1 => (Posz 2, 1%R)
                        | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                        | Negz _ => ((1 + y1)%R, 1%R)
                        end
                    | _ => ((1 * y2 + y1)%R, y2)
                    end)
             end *
             match rat_of_Z 1 with
             | {| valq := y |} =>
                 fracq
                   (let (y1, y2) := y in
                    match y2 with
                    | Posz 1 =>
                        match y1 with
                        | Posz 0 => (1%R, 1%R)
                        | Posz 1 => (Posz 2, 1%R)
                        | Posz (_.+2 as n) => (Posz n.+1, 1%R)
                        | Negz _ => ((1 + y1)%R, 1%R)
                        end
                    | _ => ((1 * y2 + y1)%R, y2)
                    end)
             end)%Q)%Q * b (Posz 1))%Q)%Q; 0%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Reifying...
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner b 1]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching: (Rabs 2 = 2 -> pr_Ps Hab 0 1)
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner b 1]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Compiling decision tree...
Splitting rewrite rules...
Assembling rewrite_head...
Reducing rewrite_head...
Tactic call ran for 0.124 secs (0.12u,0.003s) (success)
Tactic call ran for 0.041 secs (0.041u,0.s) (success)
Tactic call ran for 0.114 secs (0.113u,0.s) (success)
Crunching:
(~
 (forall rnds : list R,
  Forall (fun r : R => 0 <= r < exp 0) rnds -> x rnds <-> x' rnds))
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: (((((1%Q + rat_of_Z 2)%Q *
             ((1%Q + rat_of_Z 2)%Q * (1%Q + rat_of_Z 2)%Q)%Q)%Q *
            ((-
              ((((1%Q + rat_of_Z 1)%Q *
                 ((1%Q + rat_of_Z 1)%Q * (1%Q + rat_of_Z 1)%Q)%Q)%Q *
                b (Posz 1))%Q +
               ((((- rat_of_Z 1)%Q *
                  (((rat_of_Z 17 * (1%Q * 1%Q)%Q)%Q + (rat_of_Z 51 * 1%Q)%Q)%Q +
                   rat_of_Z 39)%Q)%Q * ((rat_of_Z 2 * 1%Q)%Q + rat_of_Z 3)%Q)%Q *
                ((-
                  ((((0%Q + rat_of_Z 1)%Q *
                     ((0%Q + rat_of_Z 1)%Q * (0%Q + rat_of_Z 1)%Q)%Q)%Q *
                    b (Posz 0))%Q +
                   ((((- rat_of_Z 1)%Q *
                      (((rat_of_Z 17 * (0%Q * 0%Q)%Q)%Q +
                        (rat_of_Z 51 * 0%Q)%Q)%Q + 
                       rat_of_Z 39)%Q)%Q *
                     ((rat_of_Z 2 * 0%Q)%Q + rat_of_Z 3)%Q)%Q * 
                    b (Posz 1))%Q)%Q)%Q *
                 (((0%Q + rat_of_Z 2)%Q *
                   ((0%Q + rat_of_Z 2)%Q * (0%Q + rat_of_Z 2)%Q)%Q)%Q^-1)%Q)%Q)%Q)%Q)%Q *
             (((1%Q + rat_of_Z 2)%Q *
               ((1%Q + rat_of_Z 2)%Q * (1%Q + rat_of_Z 2)%Q)%Q)%Q^-1)%Q)%Q)%Q +
           ((((- rat_of_Z 1)%Q *
              (((rat_of_Z 17 * (1%Q * 1%Q)%Q)%Q + (rat_of_Z 51 * 1%Q)%Q)%Q +
               rat_of_Z 39)%Q)%Q * ((rat_of_Z 2 * 1%Q)%Q + rat_of_Z 3)%Q)%Q *
            ((-
              ((((0%Q + rat_of_Z 1)%Q *
                 ((0%Q + rat_of_Z 1)%Q * (0%Q + rat_of_Z 1)%Q)%Q)%Q *
                b (Posz 0))%Q +
               ((((- rat_of_Z 1)%Q *
                  (((rat_of_Z 17 * (0%Q * 0%Q)%Q)%Q + (rat_of_Z 51 * 0%Q)%Q)%Q +
                   rat_of_Z 39)%Q)%Q * ((rat_of_Z 2 * 0%Q)%Q + rat_of_Z 3)%Q)%Q *
                b (Posz 1))%Q)%Q)%Q *
             (((0%Q + rat_of_Z 2)%Q *
               ((0%Q + rat_of_Z 2)%Q * (0%Q + rat_of_Z 2)%Q)%Q)%Q^-1)%Q)%Q)%Q)%Q +
          (((1%Q + rat_of_Z 1)%Q *
            ((1%Q + rat_of_Z 1)%Q * (1%Q + rat_of_Z 1)%Q)%Q)%Q * 
           b (Posz 1))%Q)%Q; 0%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: (((((1%Q + rat_of_Z 2)%Q *
             ((1%Q + rat_of_Z 2)%Q * (1%Q + rat_of_Z 2)%Q)%Q)%Q *
            ((-
              ((((1%Q + rat_of_Z 1)%Q *
                 ((1%Q + rat_of_Z 1)%Q * (1%Q + rat_of_Z 1)%Q)%Q)%Q *
                b (Posz 1))%Q +
               ((((- rat_of_Z 1)%Q *
                  (((rat_of_Z 17 * (1%Q * 1%Q)%Q)%Q + (rat_of_Z 51 * 1%Q)%Q)%Q +
                   rat_of_Z 39)%Q)%Q * ((rat_of_Z 2 * 1%Q)%Q + rat_of_Z 3)%Q)%Q *
                ((-
                  ((((0%Q + rat_of_Z 1)%Q *
                     ((0%Q + rat_of_Z 1)%Q * (0%Q + rat_of_Z 1)%Q)%Q)%Q *
                    b (Posz 0))%Q +
                   ((((- rat_of_Z 1)%Q *
                      (((rat_of_Z 17 * (0%Q * 0%Q)%Q)%Q +
                        (rat_of_Z 51 * 0%Q)%Q)%Q + 
                       rat_of_Z 39)%Q)%Q *
                     ((rat_of_Z 2 * 0%Q)%Q + rat_of_Z 3)%Q)%Q * 
                    b (Posz 1))%Q)%Q)%Q *
                 (((0%Q + rat_of_Z 2)%Q *
                   ((0%Q + rat_of_Z 2)%Q * (0%Q + rat_of_Z 2)%Q)%Q)%Q^-1)%Q)%Q)%Q)%Q)%Q *
             (((1%Q + rat_of_Z 2)%Q *
               ((1%Q + rat_of_Z 2)%Q * (1%Q + rat_of_Z 2)%Q)%Q)%Q^-1)%Q)%Q)%Q +
           ((((- rat_of_Z 1)%Q *
              (((rat_of_Z 17 * (1%Q * 1%Q)%Q)%Q + (rat_of_Z 51 * 1%Q)%Q)%Q +
               rat_of_Z 39)%Q)%Q * ((rat_of_Z 2 * 1%Q)%Q + rat_of_Z 3)%Q)%Q *
            ((-
              ((((0%Q + rat_of_Z 1)%Q *
                 ((0%Q + rat_of_Z 1)%Q * (0%Q + rat_of_Z 1)%Q)%Q)%Q *
                b (Posz 0))%Q +
               ((((- rat_of_Z 1)%Q *
                  (((rat_of_Z 17 * (0%Q * 0%Q)%Q)%Q + (rat_of_Z 51 * 0%Q)%Q)%Q +
                   rat_of_Z 39)%Q)%Q * ((rat_of_Z 2 * 0%Q)%Q + rat_of_Z 3)%Q)%Q *
                b (Posz 1))%Q)%Q)%Q *
             (((0%Q + rat_of_Z 2)%Q *
               ((0%Q + rat_of_Z 2)%Q * (0%Q + rat_of_Z 2)%Q)%Q)%Q^-1)%Q)%Q)%Q)%Q +
          (((1%Q + rat_of_Z 1)%Q *
            ((1%Q + rat_of_Z 1)%Q * (1%Q + rat_of_Z 1)%Q)%Q)%Q * 
           b (Posz 1))%Q)%Q; 0%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Assembling rewrite_head_no_dtree...
Reducing rewrite_head_no_dtree...
Proving Rewriter_Wf...
Tactic call ran for 0.041 secs (0.041u,0.s) (success)
Tactic call ran for 0.691 secs (0.67u,0.011s) (success)
"notFunext has been translated as notFunextᵗ"
Proving Rewriter_Interp...
Tactic call ran for 0.642 secs (0.637u,0.002s) (success)
Tactic call ran for 0.296 secs (0.29u,0.004s) (success)
Crunching: (C <= H3 + z)
Assembling verified rewriter...
Refining with verified rewriter...
Finished transaction in 19.287 secs (18.887u,0.267s) (successful)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (∣0⟩ = basis_vector 2 0)
Coq.Init.Datatypes.nat has been translated.
Coq.Init.Datatypes.list has been translated.
listᵗ : forall A : TYPE, list A.1 -> Type
     : forall A : TYPE, list A.1 -> Type
nilᵗ : forall A : TYPE, listᵗ A []
     : forall A : TYPE, listᵗ A []
consᵗ
:
forall (A : TYPE) (x : El A) (lH : ∃ l : list A.1, listᵗ A l),
listᵗ A (x.1 :: lH.1)
     : forall (A : TYPE) (x : El A) (lH : ∃ l : list A.1, listᵗ A l),
       listᵗ A (x.1 :: lH.1)
Crunching: (Rabs 2 = 2 -> pr_Ps Hab 0 1)
Crunching: (Rabs 2 = 2 -> pr_Ps Hab 0 1)
Debug:
In environment
GT, k_ : int
H : annotated_recs_s.precond.Sn2 GT k_
H0 : 0 <= k_
H1 : k_ < GT
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: s (int.shift 2 GT) k_; annotated_recs_s.Sn2_cf0_0 GT k_; 
        s GT k_; annotated_recs_s.Sn2_cf1_0 GT k_; 
        s (int.shift 1 GT) k_; annotated_recs_s.Sn2_cf0_1 GT k_;
         s GT (int.shift 1 k_)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
_Hyp_, h' : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf2 n; b (int.shift 1 (int.shift 1 n));
         annotated_recs_c.P_cf1 n; b (int.shift 1 n);
         annotated_recs_c.P_cf0 n; b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching:
(S H ⨂ A × f_to_vec (S H) f = vkron (S H) (fun k : nat => A × ∣ f k ⟩))
Debug:
In environment
x, nzr : int
i : 0 <= nzr
j : nzr < x
onD := annotated_recs_s.Sn2_cf1_0 x nzr * s (int.shift 1 x) nzr : rat_Ring
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: s (int.shift 2 x) nzr; annotated_recs_s.Sn2_cf0_0 x nzr; 
        s x nzr; onD; annotated_recs_s.Sn2_cf0_1 x nzr; 
        s x (int.shift 1 nzr)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching:
((fun x z0 : nat =>
  Σ (fun y : nat => ((z ⨂ Az) x y * f_to_vec z RS y z0)%C) (2 ^ z)) =
 vkron z (fun k x z : nat => Σ (fun y : nat => (Az x y * ∣ RS k ⟩ y z)%C) 2))
Crunching:
(~
 (forall rnds : list R,
  Forall (fun r : R => 0 <= r < exp 0) rnds -> x rnds <-> x' rnds))
Debug:
In environment
v : int -> int -> rat
v_ann : v.Ann v
v_Sn2 := v.Sn2_ v_ann : v.Sn2 v
v_SnSk := v.SnSk_ v_ann : v.SnSk v
v_Sk2 := v.Sk2_ v_ann : v.Sk2 v
b := fun n : int => \sum_(0 <= k < n + 1 :> int) v n k : int -> rat
n : int
abelG : (2 : int) <= n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: v.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
v : int -> int -> rat
v_ann : v.Ann v
v_Sn2 := v.Sn2_ v_ann : v.Sn2 v
v_SnSk := v.SnSk_ v_ann : v.SnSk v
v_Sk2 := v.Sk2_ v_ann : v.Sk2 v
b := fun n : int => \sum_(0 <= k < n + 1 :> int) v n k : int -> rat
n : int
lin_xy : (2 : int) <= n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: v.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
EQ, h' : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf2 n; b (int.shift 1 (int.shift 1 n));
         annotated_recs_c.P_cf1 n; b (int.shift 1 n);
         annotated_recs_c.P_cf0 n; b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
v : int -> int -> rat
v_ann : v.Ann v
v_Sn2 := v.Sn2_ v_ann : v.Sn2 v
v_SnSk := v.SnSk_ v_ann : v.SnSk v
v_Sk2 := v.Sk2_ v_ann : v.Sk2 v
b := fun n : int => \sum_(0 <= k < n + 1 :> int) v n k : int -> rat
n : int
k : (2 : int) <= n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: v.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
v : int -> int -> rat
v_ann : v.Ann v
v_Sn2 := v.Sn2_ v_ann : v.Sn2 v
v_SnSk := v.SnSk_ v_ann : v.SnSk v
v_Sk2 := v.Sk2_ v_ann : v.Sk2 v
b := fun n : int => \sum_(0 <= k < n + 1 :> int) v n k : int -> rat
n : int
k : (2 : int) <= n
notD : ?Goal
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: v.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
v : int -> int -> rat
v_ann : v.Ann v
v_Sn2 := v.Sn2_ v_ann : v.Sn2 v
v_SnSk := v.SnSk_ v_ann : v.SnSk v
v_Sk2 := v.Sk2_ v_ann : v.Sk2 v
b := fun n : int => \sum_(0 <= k < n + 1 :> int) v n k : int -> rat
n : int
k : (2 : int) <= n
p_prime : ?Goal
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: v.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
v : int -> int -> rat
v_ann : v.Ann v
v_Sn2 := v.Sn2_ v_ann : v.Sn2 v
v_SnSk := v.SnSk_ v_ann : v.SnSk v
v_Sk2 := v.Sk2_ v_ann : v.Sk2 v
b := fun n : int => \sum_(0 <= k < n + 1 :> int) v n k : int -> rat
n : int
H : (2 : int) <= n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: v.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
v : int -> int -> rat
v_ann : v.Ann v
v_Sn2 := v.Sn2_ v_ann : v.Sn2 v
v_SnSk := v.SnSk_ v_ann : v.SnSk v
v_Sk2 := v.Sk2_ v_ann : v.Sk2 v
b := fun n : int => \sum_(0 <= k < n + 1 :> int) v n k : int -> rat
n : int
P : (2 : int) <= n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: v.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
v : int -> int -> rat
v_ann : v.Ann v
v_Sn2 := v.Sn2_ v_ann : v.Sn2 v
v_SnSk := v.SnSk_ v_ann : v.SnSk v
v_Sk2 := v.Sk2_ v_ann : v.Sk2 v
b := fun n : int => \sum_(0 <= k < n + 1 :> int) v n k : int -> rat
n : int
P : (2 : int) <= n
notD : ?Goal
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: v.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
v : int -> int -> rat
v_ann : v.Ann v
v_Sn2 := v.Sn2_ v_ann : v.Sn2 v
v_SnSk := v.SnSk_ v_ann : v.SnSk v
v_Sk2 := v.Sk2_ v_ann : v.Sk2 v
b := fun n : int => \sum_(0 <= k < n + 1 :> int) v n k : int -> rat
n : int
P : (2 : int) <= n
p_prime : ?Goal
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: v.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
((a + b) * (a ^ Ha + b ^ Ha) <= 2 * (a * a ^ Ha + b * b ^ Ha))
Crunching:
(0%nat <> 2%nat -> (2 * 2 ^ Hxy * 2)%nat = (2 ^ (1 + Hxy + 1))%nat)
Debug:
In environment
v : int -> int -> rat
v_ann : v.Ann v
v_Sn2 := v.Sn2_ v_ann : v.Sn2 v
v_SnSk := v.SnSk_ v_ann : v.SnSk v
v_Sk2 := v.Sk2_ v_ann : v.Sk2 v
b := fun n : int => \sum_(0 <= k < n + 1 :> int) v n k : int -> rat
n : int
abelG : (2 : int) <= n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: v.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
v : int -> int -> rat
v_ann : v.Ann v
v_Sn2 := v.Sn2_ v_ann : v.Sn2 v
v_SnSk := v.SnSk_ v_ann : v.SnSk v
v_Sk2 := v.Sk2_ v_ann : v.Sk2 v
b := fun n : int => \sum_(0 <= k < n + 1 :> int) v n k : int -> rat
n : int
abelG : (2 : int) <= n
notD : ?Goal
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: v.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
v : int -> int -> rat
v_ann : v.Ann v
v_Sn2 := v.Sn2_ v_ann : v.Sn2 v
v_SnSk := v.SnSk_ v_ann : v.SnSk v
v_Sk2 := v.Sk2_ v_ann : v.Sk2 v
b := fun n : int => \sum_(0 <= k < n + 1 :> int) v n k : int -> rat
n : int
abelG : (2 : int) <= n
p_prime : ?Goal
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: v.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching: (pr_Ps H2 0 1)
Debug:
In environment
n : int
eq_uv : is_true ((0 <= n) == true)
h' : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf2 n; b (int.shift 1 (int.shift 1 n));
         annotated_recs_c.P_cf1 n; b (int.shift 1 n);
         annotated_recs_c.P_cf0 n; b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
v : int -> int -> rat
v_ann : v.Ann v
v_Sn2 := v.Sn2_ v_ann : v.Sn2 v
v_SnSk := v.SnSk_ v_ann : v.SnSk v
v_Sk2 := v.Sk2_ v_ann : v.Sk2 v
b := fun n : int => \sum_(0 <= k < n + 1 :> int) v n k : int -> rat
n : int
lin_xy : (2 : int) <= n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: v.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
v : int -> int -> rat
v_ann : v.Ann v
v_Sn2 := v.Sn2_ v_ann : v.Sn2 v
v_SnSk := v.SnSk_ v_ann : v.SnSk v
v_Sk2 := v.Sk2_ v_ann : v.Sk2 v
b := fun n : int => \sum_(0 <= k < n + 1 :> int) v n k : int -> rat
n : int
lin_xy : (2 : int) <= n
notD : ?Goal
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: v.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
v : int -> int -> rat
v_ann : v.Ann v
v_Sn2 := v.Sn2_ v_ann : v.Sn2 v
v_SnSk := v.SnSk_ v_ann : v.SnSk v
v_Sk2 := v.Sk2_ v_ann : v.Sk2 v
b := fun n : int => \sum_(0 <= k < n + 1 :> int) v n k : int -> rat
n : int
lin_xy : (2 : int) <= n
p_prime : ?Goal
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: v.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
eq_uv : is_true ((0 <= n) == true)
h' : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf2 n; b (int.shift 1 (int.shift 1 n));
         annotated_recs_c.P_cf1 n; b (int.shift 1 n);
         annotated_recs_c.P_cf0 n; b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching:
(((forall n m : nat, (m <= n)%nat -> (n - m)%nat = 0%nat -> n = m) ->
  forall n0 m : nat, (m <= n0)%nat -> (n0 - m)%nat = 0%nat -> n0 = m) ->
 pr_Ps H2 Hab eq)
Debug:
In environment
n : int
eq_uv : is_true ((0 <= n) == true)
h' : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf2 n; b (int.shift 1 (int.shift 1 n));
         annotated_recs_c.P_cf1 n; b (int.shift 1 n);
         annotated_recs_c.P_cf0 n; b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching:
(forall f : nat -> nat -> nat -> R * R,
 (fix vkron (n : nat) (f0 : nat -> nat -> nat -> R * R) {struct n} :
      nat -> nat -> R * R :=
    match n with
    | 0 =>
        fun x y : nat =>
        if
         if
          (fix eqb (n0 m : nat) {struct n0} : bool :=
             match n0 with
             | 0 => match m with
                    | 0 => true
                    | S _ => false
                    end
             | S n' => match m with
                       | 0 => false
                       | S m' => eqb n' m'
                       end
             end) x y
         then
          (fix leb (n0 m : nat) {struct n0} : bool :=
             match n0 with
             | 0 => true
             | S n' => match m with
                       | 0 => false
                       | S m' => leb n' m'
                       end
             end) x 0
         else false
        then (R1, R0)
        else (R0, R0)
    | S n' =>
        fun x y : nat =>
        (((let (x0, _) :=
             vkron n' f0
               (let (x0, _) :=
                  (fix divmod (x0 y0 q u : nat) {struct x0} : nat * nat :=
                     match x0 with
                     | 0%nat => (q, u)
                     | S x' =>
                         match u with
                         | 0%nat => divmod x' y0 (S q) y0
                         | S u' => divmod x' y0 q u'
                         end
                     end) x 1%nat 0%nat 1%nat in
                x0)
               (let (x0, _) :=
                  (fix divmod (x0 y0 q u : nat) {struct x0} : nat * nat :=
                     match x0 with
                     | 0%nat => (q, u)
                     | S x' =>
                         match u with
                         | 0%nat => divmod x' y0 (S q) y0
                         | S u' => divmod x' y0 q u'
                         end
                     end) y 0%nat 0%nat 0%nat in
                x0) in
           x0) *
          (let (x0, _) :=
             f0 n'
               match
                 (let (_, y0) :=
                    (fix divmod (x0 y0 q u : nat) {struct x0} : nat * nat :=
                       match x0 with
                       | 0%nat => (q, u)
                       | S x' =>
                           match u with
                           | 0%nat => divmod x' y0 (S q) y0
                           | S u' => divmod x' y0 q u'
                           end
                       end) x 1%nat 0%nat 1%nat in
                  y0)
               with
               | 0%nat => 1%nat
               | S _ => 0%nat
               end 0%nat in
           x0) +
          -
          ((let (_, y0) :=
              vkron n' f0
                (let (x0, _) :=
                   (fix divmod (x0 y0 q u : nat) {struct x0} : nat * nat :=
                      match x0 with
                      | 0%nat => (q, u)
                      | S x' =>
                          match u with
                          | 0%nat => divmod x' y0 (S q) y0
                          | S u' => divmod x' y0 q u'
                          end
                      end) x 1%nat 0%nat 1%nat in
                 x0)
                (let (x0, _) :=
                   (fix divmod (x0 y0 q u : nat) {struct x0} : nat * nat :=
                      match x0 with
                      | 0%nat => (q, u)
                      | S x' =>
                          match u with
                          | 0%nat => divmod x' y0 (S q) y0
                          | S u' => divmod x' y0 q u'
                          end
                      end) y 0%nat 0%nat 0%nat in
                 x0) in
            y0) *
           (let (_, y0) :=
              f0 n'
                match
                  (let (_, y0) :=
                     (fix divmod (x0 y0 q u : nat) {struct x0} : nat * nat :=
                        match x0 with
                        | 0%nat => (q, u)
                        | S x' =>
                            match u with
                            | 0%nat => divmod x' y0 (S q) y0
                            | S u' => divmod x' y0 q u'
                            end
                        end) x 1%nat 0%nat 1%nat in
                   y0)
                with
                | 0%nat => 1%nat
                | S _ => 0%nat
                end 0%nat in
            y0)))%R,
        ((let (x0, _) :=
            vkron n' f0
              (let (x0, _) :=
                 (fix divmod (x0 y0 q u : nat) {struct x0} : nat * nat :=
                    match x0 with
                    | 0%nat => (q, u)
                    | S x' =>
                        match u with
                        | 0%nat => divmod x' y0 (S q) y0
                        | S u' => divmod x' y0 q u'
                        end
                    end) x 1%nat 0%nat 1%nat in
               x0)
              (let (x0, _) :=
                 (fix divmod (x0 y0 q u : nat) {struct x0} : nat * nat :=
                    match x0 with
                    | 0%nat => (q, u)
                    | S x' =>
                        match u with
                        | 0%nat => divmod x' y0 (S q) y0
                        | S u' => divmod x' y0 q u'
                        end
                    end) y 0%nat 0%nat 0%nat in
               x0) in
          x0) *
         (let (_, y0) :=
            f0 n'
              match
                (let (_, y0) :=
                   (fix divmod (x0 y0 q u : nat) {struct x0} : nat * nat :=
                      match x0 with
                      | 0%nat => (q, u)
                      | S x' =>
                          match u with
                          | 0%nat => divmod x' y0 (S q) y0
                          | S u' => divmod x' y0 q u'
                          end
                      end) x 1%nat 0%nat 1%nat in
                 y0)
              with
              | 0%nat => 1%nat
              | S _ => 0%nat
              end 0%nat in
          y0) +
         (let (_, y0) :=
            vkron n' f0
              (let (x0, _) :=
                 (fix divmod (x0 y0 q u : nat) {struct x0} : nat * nat :=
                    match x0 with
                    | 0%nat => (q, u)
                    | S x' =>
                        match u with
                        | 0%nat => divmod x' y0 (S q) y0
                        | S u' => divmod x' y0 q u'
                        end
                    end) x 1%nat 0%nat 1%nat in
               x0)
              (let (x0, _) :=
                 (fix divmod (x0 y0 q u : nat) {struct x0} : nat * nat :=
                    match x0 with
                    | 0%nat => (q, u)
                    | S x' =>
                        match u with
                        | 0%nat => divmod x' y0 (S q) y0
                        | S u' => divmod x' y0 q u'
                        end
                    end) y 0%nat 0%nat 0%nat in
               x0) in
          y0) *
         (let (x0, _) :=
            f0 n'
              match
                (let (_, y0) :=
                   (fix divmod (x0 y0 q u : nat) {struct x0} : nat * nat :=
                      match x0 with
                      | 0%nat => (q, u)
                      | S x' =>
                          match u with
                          | 0%nat => divmod x' y0 (S q) y0
                          | S u' => divmod x' y0 q u'
                          end
                      end) x 1%nat 0%nat 1%nat in
                 y0)
              with
              | 0%nat => 1%nat
              | S _ => 0%nat
              end 0%nat in
          x0))%R)
    end) H2
   (fun i x y : nat =>
    (((let (x0, _) := n in x0) * (let (x0, _) := f i x y in x0) +
      - ((let (_, y0) := n in y0) * (let (_, y0) := f i x y in y0)))%R,
    ((let (x0, _) := n in x0) * (let (_, y0) := f i x y in y0) +
     (let (_, y0) := n in y0) * (let (x0, _) := f i x y in x0))%R)) =
 (fun x y : nat =>
  (((let (x0, _) :=
       (fix Cpow (c : R * R) (n : nat) {struct n} : R * R :=
          match n with
          | 0%nat => (R1, R0)
          | S n' =>
              ((let (x0, _) := c in x0) * (let (x0, _) := Cpow c n' in x0) +
               -
               ((let (_, y0) := c in y0) * (let (_, y0) := Cpow c n' in y0)),
              (let (x0, _) := c in x0) * (let (_, y0) := Cpow c n' in y0) +
              (let (_, y0) := c in y0) * (let (x0, _) := Cpow c n' in x0))
          end) n H2 in
     x0) *
    (let (x0, _) :=
       (fix vkron (n : nat) (f0 : nat -> nat -> nat -> R * R) {struct n} :
            nat -> nat -> R * R :=
          match n with
          | 0%nat =>
              fun x0 y0 : nat =>
              if
               if
                (fix eqb (n0 m : nat) {struct n0} : bool :=
                   match n0 with
                   | 0%nat => match m with
                              | 0%nat => true
                              | S _ => false
                              end
                   | S n' =>
                       match m with
                       | 0%nat => false
                       | S m' => eqb n' m'
                       end
                   end) x0 y0
               then
                (fix leb (n0 m : nat) {struct n0} : bool :=
                   match n0 with
                   | 0%nat => true
                   | S n' =>
                       match m with
                       | 0%nat => false
                       | S m' => leb n' m'
                       end
                   end) x0 0%nat
               else false
              then (R1, R0)
              else (R0, R0)
          | S n' =>
              fun x0 y0 : nat =>
              ((let (x1, _) :=
                  vkron n' f0
                    (let (x1, _) :=
                       (fix divmod (x1 y1 q u : nat) {struct x1} :
                            nat * nat :=
                          match x1 with
                          | 0%nat => (q, u)
                          | S x' =>
                              match u with
                              | 0%nat => divmod x' y1 (S q) y1
                              | S u' => divmod x' y1 q u'
                              end
                          end) x0 1%nat 0%nat 1%nat in
                     x1)
                    (let (x1, _) :=
                       (fix divmod (x1 y1 q u : nat) {struct x1} :
                            nat * nat :=
                          match x1 with
                          | 0%nat => (q, u)
                          | S x' =>
                              match u with
                              | 0%nat => divmod x' y1 (S q) y1
                              | S u' => divmod x' y1 q u'
                              end
                          end) y0 0%nat 0%nat 0%nat in
                     x1) in
                x1) *
               (let (x1, _) :=
                  f0 n'
                    match
                      (let (_, y1) :=
                         (fix divmod (x1 y1 q u : nat) {struct x1} :
                              nat * nat :=
                            match x1 with
                            | 0%nat => (q, u)
                            | S x' =>
                                match u with
                                | 0%nat => divmod x' y1 (S q) y1
                                | S u' => divmod x' y1 q u'
                                end
                            end) x0 1%nat 0%nat 1%nat in
                       y1)
                    with
                    | 0%nat => 1%nat
                    | S _ => 0%nat
                    end 0%nat in
                x1) +
               -
               ((let (_, y1) :=
                   vkron n' f0
                     (let (x1, _) :=
                        (fix divmod (x1 y1 q u : nat) {struct x1} :
                             nat * nat :=
                           match x1 with
                           | 0%nat => (q, u)
                           | S x' =>
                               match u with
                               | 0%nat => divmod x' y1 (S q) y1
                               | S u' => divmod x' y1 q u'
                               end
                           end) x0 1%nat 0%nat 1%nat in
                      x1)
                     (let (x1, _) :=
                        (fix divmod (x1 y1 q u : nat) {struct x1} :
                             nat * nat :=
                           match x1 with
                           | 0%nat => (q, u)
                           | S x' =>
                               match u with
                               | 0%nat => divmod x' y1 (S q) y1
                               | S u' => divmod x' y1 q u'
                               end
                           end) y0 0%nat 0%nat 0%nat in
                      x1) in
                 y1) *
                (let (_, y1) :=
                   f0 n'
                     match
                       (let (_, y1) :=
                          (fix divmod (x1 y1 q u : nat) {struct x1} :
                               nat * nat :=
                             match x1 with
                             | 0%nat => (q, u)
                             | S x' =>
                                 match u with
                                 | 0%nat => divmod x' y1 (S q) y1
                                 | S u' => divmod x' y1 q u'
                                 end
                             end) x0 1%nat 0%nat 1%nat in
                        y1)
                     with
                     | 0%nat => 1%nat
                     | S _ => 0%nat
                     end 0%nat in
                 y1)),
              (let (x1, _) :=
                 vkron n' f0
                   (let (x1, _) :=
                      (fix divmod (x1 y1 q u : nat) {struct x1} :
                           nat * nat :=
                         match x1 with
                         | 0%nat => (q, u)
                         | S x' =>
                             match u with
                             | 0%nat => divmod x' y1 (S q) y1
                             | S u' => divmod x' y1 q u'
                             end
                         end) x0 1%nat 0%nat 1%nat in
                    x1)
                   (let (x1, _) :=
                      (fix divmod (x1 y1 q u : nat) {struct x1} :
                           nat * nat :=
                         match x1 with
                         | 0%nat => (q, u)
                         | S x' =>
                             match u with
                             | 0%nat => divmod x' y1 (S q) y1
                             | S u' => divmod x' y1 q u'
                             end
                         end) y0 0%nat 0%nat 0%nat in
                    x1) in
               x1) *
              (let (_, y1) :=
                 f0 n'
                   match
                     (let (_, y1) :=
                        (fix divmod (x1 y1 q u : nat) {struct x1} :
                             nat * nat :=
                           match x1 with
                           | 0%nat => (q, u)
                           | S x' =>
                               match u with
                               | 0%nat => divmod x' y1 (S q) y1
                               | S u' => divmod x' y1 q u'
                               end
                           end) x0 1%nat 0%nat 1%nat in
                      y1)
                   with
                   | 0%nat => 1%nat
                   | S _ => 0%nat
                   end 0%nat in
               y1) +
              (let (_, y1) :=
                 vkron n' f0
                   (let (x1, _) :=
                      (fix divmod (x1 y1 q u : nat) {struct x1} :
                           nat * nat :=
                         match x1 with
                         | 0%nat => (q, u)
                         | S x' =>
                             match u with
                             | 0%nat => divmod x' y1 (S q) y1
                             | S u' => divmod x' y1 q u'
                             end
                         end) x0 1%nat 0%nat 1%nat in
                    x1)
                   (let (x1, _) :=
                      (fix divmod (x1 y1 q u : nat) {struct x1} :
                           nat * nat :=
                         match x1 with
                         | 0%nat => (q, u)
                         | S x' =>
                             match u with
                             | 0%nat => divmod x' y1 (S q) y1
                             | S u' => divmod x' y1 q u'
                             end
                         end) y0 0%nat 0%nat 0%nat in
                    x1) in
               y1) *
              (let (x1, _) :=
                 f0 n'
                   match
                     (let (_, y1) :=
                        (fix divmod (x1 y1 q u : nat) {struct x1} :
                             nat * nat :=
                           match x1 with
                           | 0%nat => (q, u)
                           | S x' =>
                               match u with
                               | 0%nat => divmod x' y1 (S q) y1
                               | S u' => divmod x' y1 q u'
                               end
                           end) x0 1%nat 0%nat 1%nat in
                      y1)
                   with
                   | 0%nat => 1%nat
                   | S _ => 0%nat
                   end 0%nat in
               x1))
          end) H2 f x y in
     x0) +
    -
    ((let (_, y0) :=
        (fix Cpow (c : R * R) (n : nat) {struct n} : R * R :=
           match n with
           | 0%nat => (R1, R0)
           | S n' =>
               ((let (x0, _) := c in x0) * (let (x0, _) := Cpow c n' in x0) +
                -
                ((let (_, y0) := c in y0) * (let (_, y0) := Cpow c n' in y0)),
               (let (x0, _) := c in x0) * (let (_, y0) := Cpow c n' in y0) +
               (let (_, y0) := c in y0) * (let (x0, _) := Cpow c n' in x0))
           end) n H2 in
      y0) *
     (let (_, y0) :=
        (fix vkron (n : nat) (f0 : nat -> nat -> nat -> R * R) {struct n} :
             nat -> nat -> R * R :=
           match n with
           | 0%nat =>
               fun x0 y0 : nat =>
               if
                if
                 (fix eqb (n0 m : nat) {struct n0} : bool :=
                    match n0 with
                    | 0%nat =>
                        match m with
                        | 0%nat => true
                        | S _ => false
                        end
                    | S n' =>
                        match m with
                        | 0%nat => false
                        | S m' => eqb n' m'
                        end
                    end) x0 y0
                then
                 (fix leb (n0 m : nat) {struct n0} : bool :=
                    match n0 with
                    | 0%nat => true
                    | S n' =>
                        match m with
                        | 0%nat => false
                        | S m' => leb n' m'
                        end
                    end) x0 0%nat
                else false
               then (R1, R0)
               else (R0, R0)
           | S n' =>
               fun x0 y0 : nat =>
               ((let (x1, _) :=
                   vkron n' f0
                     (let (x1, _) :=
                        (fix divmod (x1 y1 q u : nat) {struct x1} :
                             nat * nat :=
                           match x1 with
                           | 0%nat => (q, u)
                           | S x' =>
                               match u with
                               | 0%nat => divmod x' y1 (S q) y1
                               | S u' => divmod x' y1 q u'
                               end
                           end) x0 1%nat 0%nat 1%nat in
                      x1)
                     (let (x1, _) :=
                        (fix divmod (x1 y1 q u : nat) {struct x1} :
                             nat * nat :=
                           match x1 with
                           | 0%nat => (q, u)
                           | S x' =>
                               match u with
                               | 0%nat => divmod x' y1 (S q) y1
                               | S u' => divmod x' y1 q u'
                               end
                           end) y0 0%nat 0%nat 0%nat in
                      x1) in
                 x1) *
                (let (x1, _) :=
                   f0 n'
                     match
                       (let (_, y1) :=
                          (fix divmod (x1 y1 q u : nat) {struct x1} :
                               nat * nat :=
                             match x1 with
                             | 0%nat => (q, u)
                             | S x' =>
                                 match u with
                                 | 0%nat => divmod x' y1 (S q) y1
                                 | S u' => divmod x' y1 q u'
                                 end
                             end) x0 1%nat 0%nat 1%nat in
                        y1)
                     with
                     | 0%nat => 1%nat
                     | S _ => 0%nat
                     end 0%nat in
                 x1) +
                -
                ((let (_, y1) :=
                    vkron n' f0
                      (let (x1, _) :=
                         (fix divmod (x1 y1 q u : nat) {struct x1} :
                              nat * nat :=
                            match x1 with
                            | 0%nat => (q, u)
                            | S x' =>
                                match u with
                                | 0%nat => divmod x' y1 (S q) y1
                                | S u' => divmod x' y1 q u'
                                end
                            end) x0 1%nat 0%nat 1%nat in
                       x1)
                      (let (x1, _) :=
                         (fix divmod (x1 y1 q u : nat) {struct x1} :
                              nat * nat :=
                            match x1 with
                            | 0%nat => (q, u)
                            | S x' =>
                                match u with
                                | 0%nat => divmod x' y1 (S q) y1
                                | S u' => divmod x' y1 q u'
                                end
                            end) y0 0%nat 0%nat 0%nat in
                       x1) in
                  y1) *
                 (let (_, y1) :=
                    f0 n'
                      match
                        (let (_, y1) :=
                           (fix divmod (x1 y1 q u : nat) {struct x1} :
                                nat * nat :=
                              match x1 with
                              | 0%nat => (q, u)
                              | S x' =>
                                  match u with
                                  | 0%nat => divmod x' y1 (S q) y1
                                  | S u' => divmod x' y1 q u'
                                  end
                              end) x0 1%nat 0%nat 1%nat in
                         y1)
                      with
                      | 0%nat => 1%nat
                      | S _ => 0%nat
                      end 0%nat in
                  y1)),
               (let (x1, _) :=
                  vkron n' f0
                    (let (x1, _) :=
                       (fix divmod (x1 y1 q u : nat) {struct x1} :
                            nat * nat :=
                          match x1 with
                          | 0%nat => (q, u)
                          | S x' =>
                              match u with
                              | 0%nat => divmod x' y1 (S q) y1
                              | S u' => divmod x' y1 q u'
                              end
                          end) x0 1%nat 0%nat 1%nat in
                     x1)
                    (let (x1, _) :=
                       (fix divmod (x1 y1 q u : nat) {struct x1} :
                            nat * nat :=
                          match x1 with
                          | 0%nat => (q, u)
                          | S x' =>
                              match u with
                              | 0%nat => divmod x' y1 (S q) y1
                              | S u' => divmod x' y1 q u'
                              end
                          end) y0 0%nat 0%nat 0%nat in
                     x1) in
                x1) *
               (let (_, y1) :=
                  f0 n'
                    match
                      (let (_, y1) :=
                         (fix divmod (x1 y1 q u : nat) {struct x1} :
                              nat * nat :=
                            match x1 with
                            | 0%nat => (q, u)
                            | S x' =>
                                match u with
                                | 0%nat => divmod x' y1 (S q) y1
                                | S u' => divmod x' y1 q u'
                                end
                            end) x0 1%nat 0%nat 1%nat in
                       y1)
                    with
                    | 0%nat => 1%nat
                    | S _ => 0%nat
                    end 0%nat in
                y1) +
               (let (_, y1) :=
                  vkron n' f0
                    (let (x1, _) :=
                       (fix divmod (x1 y1 q u : nat) {struct x1} :
                            nat * nat :=
                          match x1 with
                          | 0%nat => (q, u)
                          | S x' =>
                              match u with
                              | 0%nat => divmod x' y1 (S q) y1
                              | S u' => divmod x' y1 q u'
                              end
                          end) x0 1%nat 0%nat 1%nat in
                     x1)
                    (let (x1, _) :=
                       (fix divmod (x1 y1 q u : nat) {struct x1} :
                            nat * nat :=
                          match x1 with
                          | 0%nat => (q, u)
                          | S x' =>
                              match u with
                              | 0%nat => divmod x' y1 (S q) y1
                              | S u' => divmod x' y1 q u'
                              end
                          end) y0 0%nat 0%nat 0%nat in
                     x1) in
                y1) *
               (let (x1, _) :=
                  f0 n'
                    match
                      (let (_, y1) :=
                         (fix divmod (x1 y1 q u : nat) {struct x1} :
                              nat * nat :=
                            match x1 with
                            | 0%nat => (q, u)
                            | S x' =>
                                match u with
                                | 0%nat => divmod x' y1 (S q) y1
                                | S u' => divmod x' y1 q u'
                                end
                            end) x0 1%nat 0%nat 1%nat in
                       y1)
                    with
                    | 0%nat => 1%nat
                    | S _ => 0%nat
                    end 0%nat in
                x1))
           end) H2 f x y in
      y0)))%R,
  ((let (x0, _) :=
      (fix Cpow (c : R * R) (n : nat) {struct n} : R * R :=
         match n with
         | 0%nat => (R1, R0)
         | S n' =>
             ((let (x0, _) := c in x0) * (let (x0, _) := Cpow c n' in x0) +
              - ((let (_, y0) := c in y0) * (let (_, y0) := Cpow c n' in y0)),
             (let (x0, _) := c in x0) * (let (_, y0) := Cpow c n' in y0) +
             (let (_, y0) := c in y0) * (let (x0, _) := Cpow c n' in x0))
         end) n H2 in
    x0) *
   (let (_, y0) :=
      (fix vkron (n : nat) (f0 : nat -> nat -> nat -> R * R) {struct n} :
           nat -> nat -> R * R :=
         match n with
         | 0%nat =>
             fun x0 y0 : nat =>
             if
              if
               (fix eqb (n0 m : nat) {struct n0} : bool :=
                  match n0 with
                  | 0%nat => match m with
                             | 0%nat => true
                             | S _ => false
                             end
                  | S n' =>
                      match m with
                      | 0%nat => false
                      | S m' => eqb n' m'
                      end
                  end) x0 y0
              then
               (fix leb (n0 m : nat) {struct n0} : bool :=
                  match n0 with
                  | 0%nat => true
                  | S n' =>
                      match m with
                      | 0%nat => false
                      | S m' => leb n' m'
                      end
                  end) x0 0%nat
              else false
             then (R1, R0)
             else (R0, R0)
         | S n' =>
             fun x0 y0 : nat =>
             ((let (x1, _) :=
                 vkron n' f0
                   (let (x1, _) :=
                      (fix divmod (x1 y1 q u : nat) {struct x1} :
                           nat * nat :=
                         match x1 with
                         | 0%nat => (q, u)
                         | S x' =>
                             match u with
                             | 0%nat => divmod x' y1 (S q) y1
                             | S u' => divmod x' y1 q u'
                             end
                         end) x0 1%nat 0%nat 1%nat in
                    x1)
                   (let (x1, _) :=
                      (fix divmod (x1 y1 q u : nat) {struct x1} :
                           nat * nat :=
                         match x1 with
                         | 0%nat => (q, u)
                         | S x' =>
                             match u with
                             | 0%nat => divmod x' y1 (S q) y1
                             | S u' => divmod x' y1 q u'
                             end
                         end) y0 0%nat 0%nat 0%nat in
                    x1) in
               x1) *
              (let (x1, _) :=
                 f0 n'
                   match
                     (let (_, y1) :=
                        (fix divmod (x1 y1 q u : nat) {struct x1} :
                             nat * nat :=
                           match x1 with
                           | 0%nat => (q, u)
                           | S x' =>
                               match u with
                               | 0%nat => divmod x' y1 (S q) y1
                               | S u' => divmod x' y1 q u'
                               end
                           end) x0 1%nat 0%nat 1%nat in
                      y1)
                   with
                   | 0%nat => 1%nat
                   | S _ => 0%nat
                   end 0%nat in
               x1) +
              -
              ((let (_, y1) :=
                  vkron n' f0
                    (let (x1, _) :=
                       (fix divmod (x1 y1 q u : nat) {struct x1} :
                            nat * nat :=
                          match x1 with
                          | 0%nat => (q, u)
                          | S x' =>
                              match u with
                              | 0%nat => divmod x' y1 (S q) y1
                              | S u' => divmod x' y1 q u'
                              end
                          end) x0 1%nat 0%nat 1%nat in
                     x1)
                    (let (x1, _) :=
                       (fix divmod (x1 y1 q u : nat) {struct x1} :
                            nat * nat :=
                          match x1 with
                          | 0%nat => (q, u)
                          | S x' =>
                              match u with
                              | 0%nat => divmod x' y1 (S q) y1
                              | S u' => divmod x' y1 q u'
                              end
                          end) y0 0%nat 0%nat 0%nat in
                     x1) in
                y1) *
               (let (_, y1) :=
                  f0 n'
                    match
                      (let (_, y1) :=
                         (fix divmod (x1 y1 q u : nat) {struct x1} :
                              nat * nat :=
                            match x1 with
                            | 0%nat => (q, u)
                            | S x' =>
                                match u with
                                | 0%nat => divmod x' y1 (S q) y1
                                | S u' => divmod x' y1 q u'
                                end
                            end) x0 1%nat 0%nat 1%nat in
                       y1)
                    with
                    | 0%nat => 1%nat
                    | S _ => 0%nat
                    end 0%nat in
                y1)),
             (let (x1, _) :=
                vkron n' f0
                  (let (x1, _) :=
                     (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                        match x1 with
                        | 0%nat => (q, u)
                        | S x' =>
                            match u with
                            | 0%nat => divmod x' y1 (S q) y1
                            | S u' => divmod x' y1 q u'
                            end
                        end) x0 1%nat 0%nat 1%nat in
                   x1)
                  (let (x1, _) :=
                     (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                        match x1 with
                        | 0%nat => (q, u)
                        | S x' =>
                            match u with
                            | 0%nat => divmod x' y1 (S q) y1
                            | S u' => divmod x' y1 q u'
                            end
                        end) y0 0%nat 0%nat 0%nat in
                   x1) in
              x1) *
             (let (_, y1) :=
                f0 n'
                  match
                    (let (_, y1) :=
                       (fix divmod (x1 y1 q u : nat) {struct x1} :
                            nat * nat :=
                          match x1 with
                          | 0%nat => (q, u)
                          | S x' =>
                              match u with
                              | 0%nat => divmod x' y1 (S q) y1
                              | S u' => divmod x' y1 q u'
                              end
                          end) x0 1%nat 0%nat 1%nat in
                     y1)
                  with
                  | 0%nat => 1%nat
                  | S _ => 0%nat
                  end 0%nat in
              y1) +
             (let (_, y1) :=
                vkron n' f0
                  (let (x1, _) :=
                     (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                        match x1 with
                        | 0%nat => (q, u)
                        | S x' =>
                            match u with
                            | 0%nat => divmod x' y1 (S q) y1
                            | S u' => divmod x' y1 q u'
                            end
                        end) x0 1%nat 0%nat 1%nat in
                   x1)
                  (let (x1, _) :=
                     (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                        match x1 with
                        | 0%nat => (q, u)
                        | S x' =>
                            match u with
                            | 0%nat => divmod x' y1 (S q) y1
                            | S u' => divmod x' y1 q u'
                            end
                        end) y0 0%nat 0%nat 0%nat in
                   x1) in
              y1) *
             (let (x1, _) :=
                f0 n'
                  match
                    (let (_, y1) :=
                       (fix divmod (x1 y1 q u : nat) {struct x1} :
                            nat * nat :=
                          match x1 with
                          | 0%nat => (q, u)
                          | S x' =>
                              match u with
                              | 0%nat => divmod x' y1 (S q) y1
                              | S u' => divmod x' y1 q u'
                              end
                          end) x0 1%nat 0%nat 1%nat in
                     y1)
                  with
                  | 0%nat => 1%nat
                  | S _ => 0%nat
                  end 0%nat in
              x1))
         end) H2 f x y in
    y0) +
   (let (_, y0) :=
      (fix Cpow (c : R * R) (n : nat) {struct n} : R * R :=
         match n with
         | 0%nat => (R1, R0)
         | S n' =>
             ((let (x0, _) := c in x0) * (let (x0, _) := Cpow c n' in x0) +
              - ((let (_, y0) := c in y0) * (let (_, y0) := Cpow c n' in y0)),
             (let (x0, _) := c in x0) * (let (_, y0) := Cpow c n' in y0) +
             (let (_, y0) := c in y0) * (let (x0, _) := Cpow c n' in x0))
         end) n H2 in
    y0) *
   (let (x0, _) :=
      (fix vkron (n : nat) (f0 : nat -> nat -> nat -> R * R) {struct n} :
           nat -> nat -> R * R :=
         match n with
         | 0%nat =>
             fun x0 y0 : nat =>
             if
              if
               (fix eqb (n0 m : nat) {struct n0} : bool :=
                  match n0 with
                  | 0%nat => match m with
                             | 0%nat => true
                             | S _ => false
                             end
                  | S n' =>
                      match m with
                      | 0%nat => false
                      | S m' => eqb n' m'
                      end
                  end) x0 y0
              then
               (fix leb (n0 m : nat) {struct n0} : bool :=
                  match n0 with
                  | 0%nat => true
                  | S n' =>
                      match m with
                      | 0%nat => false
                      | S m' => leb n' m'
                      end
                  end) x0 0%nat
              else false
             then (R1, R0)
             else (R0, R0)
         | S n' =>
             fun x0 y0 : nat =>
             ((let (x1, _) :=
                 vkron n' f0
                   (let (x1, _) :=
                      (fix divmod (x1 y1 q u : nat) {struct x1} :
                           nat * nat :=
                         match x1 with
                         | 0%nat => (q, u)
                         | S x' =>
                             match u with
                             | 0%nat => divmod x' y1 (S q) y1
                             | S u' => divmod x' y1 q u'
                             end
                         end) x0 1%nat 0%nat 1%nat in
                    x1)
                   (let (x1, _) :=
                      (fix divmod (x1 y1 q u : nat) {struct x1} :
                           nat * nat :=
                         match x1 with
                         | 0%nat => (q, u)
                         | S x' =>
                             match u with
                             | 0%nat => divmod x' y1 (S q) y1
                             | S u' => divmod x' y1 q u'
                             end
                         end) y0 0%nat 0%nat 0%nat in
                    x1) in
               x1) *
              (let (x1, _) :=
                 f0 n'
                   match
                     (let (_, y1) :=
                        (fix divmod (x1 y1 q u : nat) {struct x1} :
                             nat * nat :=
                           match x1 with
                           | 0%nat => (q, u)
                           | S x' =>
                               match u with
                               | 0%nat => divmod x' y1 (S q) y1
                               | S u' => divmod x' y1 q u'
                               end
                           end) x0 1%nat 0%nat 1%nat in
                      y1)
                   with
                   | 0%nat => 1%nat
                   | S _ => 0%nat
                   end 0%nat in
               x1) +
              -
              ((let (_, y1) :=
                  vkron n' f0
                    (let (x1, _) :=
                       (fix divmod (x1 y1 q u : nat) {struct x1} :
                            nat * nat :=
                          match x1 with
                          | 0%nat => (q, u)
                          | S x' =>
                              match u with
                              | 0%nat => divmod x' y1 (S q) y1
                              | S u' => divmod x' y1 q u'
                              end
                          end) x0 1%nat 0%nat 1%nat in
                     x1)
                    (let (x1, _) :=
                       (fix divmod (x1 y1 q u : nat) {struct x1} :
                            nat * nat :=
                          match x1 with
                          | 0%nat => (q, u)
                          | S x' =>
                              match u with
                              | 0%nat => divmod x' y1 (S q) y1
                              | S u' => divmod x' y1 q u'
                              end
                          end) y0 0%nat 0%nat 0%nat in
                     x1) in
                y1) *
               (let (_, y1) :=
                  f0 n'
                    match
                      (let (_, y1) :=
                         (fix divmod (x1 y1 q u : nat) {struct x1} :
                              nat * nat :=
                            match x1 with
                            | 0%nat => (q, u)
                            | S x' =>
                                match u with
                                | 0%nat => divmod x' y1 (S q) y1
                                | S u' => divmod x' y1 q u'
                                end
                            end) x0 1%nat 0%nat 1%nat in
                       y1)
                    with
                    | 0%nat => 1%nat
                    | S _ => 0%nat
                    end 0%nat in
                y1)),
             (let (x1, _) :=
                vkron n' f0
                  (let (x1, _) :=
                     (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                        match x1 with
                        | 0%nat => (q, u)
                        | S x' =>
                            match u with
                            | 0%nat => divmod x' y1 (S q) y1
                            | S u' => divmod x' y1 q u'
                            end
                        end) x0 1%nat 0%nat 1%nat in
                   x1)
                  (let (x1, _) :=
                     (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                        match x1 with
                        | 0%nat => (q, u)
                        | S x' =>
                            match u with
                            | 0%nat => divmod x' y1 (S q) y1
                            | S u' => divmod x' y1 q u'
                            end
                        end) y0 0%nat 0%nat 0%nat in
                   x1) in
              x1) *
             (let (_, y1) :=
                f0 n'
                  match
                    (let (_, y1) :=
                       (fix divmod (x1 y1 q u : nat) {struct x1} :
                            nat * nat :=
                          match x1 with
                          | 0%nat => (q, u)
                          | S x' =>
                              match u with
                              | 0%nat => divmod x' y1 (S q) y1
                              | S u' => divmod x' y1 q u'
                              end
                          end) x0 1%nat 0%nat 1%nat in
                     y1)
                  with
                  | 0%nat => 1%nat
                  | S _ => 0%nat
                  end 0%nat in
              y1) +
             (let (_, y1) :=
                vkron n' f0
                  (let (x1, _) :=
                     (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                        match x1 with
                        | 0%nat => (q, u)
                        | S x' =>
                            match u with
                            | 0%nat => divmod x' y1 (S q) y1
                            | S u' => divmod x' y1 q u'
                            end
                        end) x0 1%nat 0%nat 1%nat in
                   x1)
                  (let (x1, _) :=
                     (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                        match x1 with
                        | 0%nat => (q, u)
                        | S x' =>
                            match u with
                            | 0%nat => divmod x' y1 (S q) y1
                            | S u' => divmod x' y1 q u'
                            end
                        end) y0 0%nat 0%nat 0%nat in
                   x1) in
              y1) *
             (let (x1, _) :=
                f0 n'
                  match
                    (let (_, y1) :=
                       (fix divmod (x1 y1 q u : nat) {struct x1} :
                            nat * nat :=
                          match x1 with
                          | 0%nat => (q, u)
                          | S x' =>
                              match u with
                              | 0%nat => divmod x' y1 (S q) y1
                              | S u' => divmod x' y1 q u'
                              end
                          end) x0 1%nat 0%nat 1%nat in
                     y1)
                  with
                  | 0%nat => 1%nat
                  | S _ => 0%nat
                  end 0%nat in
              x1))
         end) H2 f x y in
    x0))%R)))
Debug:
In environment
v : int -> int -> rat
v_ann : v.Ann v
v_Sn2 := v.Sn2_ v_ann : v.Sn2 v
v_SnSk := v.SnSk_ v_ann : v.SnSk v
v_Sk2 := v.Sk2_ v_ann : v.Sk2 v
b := fun n : int => \sum_(0 <= k < n + 1 :> int) v n k : int -> rat
n : int
k : (2 : int) <= n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: v.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
v : int -> int -> rat
v_ann : v.Ann v
v_Sn2 := v.Sn2_ v_ann : v.Sn2 v
v_SnSk := v.SnSk_ v_ann : v.SnSk v
v_Sk2 := v.Sk2_ v_ann : v.Sk2 v
b := fun n : int => \sum_(0 <= k < n + 1 :> int) v n k : int -> rat
n : int
k : (2 : int) <= n
notD : ?Goal
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: v.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
_Hyp_, h' : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf2 n; b (int.shift 1 (int.shift 1 n));
         annotated_recs_c.P_cf1 n; b (int.shift 1 n);
         annotated_recs_c.P_cf0 n; b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
v : int -> int -> rat
v_ann : v.Ann v
v_Sn2 := v.Sn2_ v_ann : v.Sn2 v
v_SnSk := v.SnSk_ v_ann : v.SnSk v
v_Sk2 := v.Sk2_ v_ann : v.Sk2 v
b := fun n : int => \sum_(0 <= k < n + 1 :> int) v n k : int -> rat
n : int
k : (2 : int) <= n
n_gt0 : ?Goal
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: v.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
v : int -> int -> rat
v_ann : v.Ann v
v_Sn2 := v.Sn2_ v_ann : v.Sn2 v
v_SnSk := v.SnSk_ v_ann : v.SnSk v
v_Sk2 := v.Sk2_ v_ann : v.Sk2 v
b := fun n : int => \sum_(0 <= k < n + 1 :> int) v n k : int -> rat
n : int
k : (2 : int) <= n
p_prime : ?Goal
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: v.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : nat
_Hyp_ : is_true (0 <= Posz n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf2 (Posz n);
         b (int.shift 1 (int.shift 1 (Posz n)));
         annotated_recs_c.P_cf1 (Posz n); b (int.shift 1 (Posz n));
         annotated_recs_c.P_cf0 (Posz n); b (Posz n)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching: (P1 [])
Debug:
In environment
v : int -> int -> rat
v_ann : v.Ann v
v_Sn2 := v.Sn2_ v_ann : v.Sn2 v
v_SnSk := v.SnSk_ v_ann : v.SnSk v
v_Sk2 := v.Sk2_ v_ann : v.Sk2 v
b := fun n : int => \sum_(0 <= k < n + 1 :> int) v n k : int -> rat
n : int
sAB : (2 : int) <= n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: v.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching: (P1 [])
Debug:
In environment
v : int -> int -> rat
v_ann : v.Ann v
v_Sn2 := v.Sn2_ v_ann : v.Sn2 v
v_SnSk := v.SnSk_ v_ann : v.SnSk v
v_Sk2 := v.Sk2_ v_ann : v.Sk2 v
b := fun n : int => \sum_(0 <= k < n + 1 :> int) v n k : int -> rat
n : int
H : (2 : int) <= n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: v.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : nat
_Hyp_ : is_true (0 <= Posz n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf2 (Posz n);
         b (int.shift 1 (int.shift 1 (Posz n)));
         annotated_recs_c.P_cf1 (Posz n); b (int.shift 1 (Posz n));
         annotated_recs_c.P_cf0 (Posz n); b (Posz n)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
v : int -> int -> rat
v_ann : v.Ann v
v_Sn2 := v.Sn2_ v_ann : v.Sn2 v
v_SnSk := v.SnSk_ v_ann : v.SnSk v
v_Sk2 := v.Sk2_ v_ann : v.Sk2 v
b := fun n : int => \sum_(0 <= k < n + 1 :> int) v n k : int -> rat
n : int
H : (2 : int) <= n
notD : ?Goal
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: v.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
v : int -> int -> rat
v_ann : v.Ann v
v_Sn2 := v.Sn2_ v_ann : v.Sn2 v
v_SnSk := v.SnSk_ v_ann : v.SnSk v
v_Sk2 := v.Sk2_ v_ann : v.Sk2 v
b := fun n : int => \sum_(0 <= k < n + 1 :> int) v n k : int -> rat
n : int
H : (2 : int) <= n
p_prime : ?Goal
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: v.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
v : int -> int -> rat
v_ann : v.Ann v
v_Sn2 := v.Sn2_ v_ann : v.Sn2 v
v_SnSk := v.SnSk_ v_ann : v.SnSk v
v_Sk2 := v.Sk2_ v_ann : v.Sk2 v
b := fun n : int => \sum_(0 <= k < n + 1 :> int) v n k : int -> rat
n : int
P : (2 : int) <= n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: v.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
v : int -> int -> rat
v_ann : v.Ann v
v_Sn2 := v.Sn2_ v_ann : v.Sn2 v
v_SnSk := v.SnSk_ v_ann : v.SnSk v
v_Sk2 := v.Sk2_ v_ann : v.Sk2 v
b := fun n : int => \sum_(0 <= k < n + 1 :> int) v n k : int -> rat
n : int
P : (2 : int) <= n
notD : ?Goal
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: v.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
v : int -> int -> rat
v_ann : v.Ann v
v_Sn2 := v.Sn2_ v_ann : v.Sn2 v
v_SnSk := v.SnSk_ v_ann : v.SnSk v
v_Sk2 := v.Sk2_ v_ann : v.Sk2 v
b := fun n : int => \sum_(0 <= k < n + 1 :> int) v n k : int -> rat
n : int
P : (2 : int) <= n
p_prime : ?Goal
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: v.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching: (P1 [])
Debug:
In environment
v : int -> int -> rat
v_ann : v.Ann v
v_Sn2 := v.Sn2_ v_ann : v.Sn2 v
v_SnSk := v.SnSk_ v_ann : v.SnSk v
v_Sk2 := v.Sk2_ v_ann : v.Sk2 v
b := fun n : int => \sum_(0 <= k < n + 1 :> int) v n k : int -> rat
n : int
abelG : (2 : int) <= n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: v.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
v : int -> int -> rat
v_ann : v.Ann v
v_Sn2 := v.Sn2_ v_ann : v.Sn2 v
v_SnSk := v.SnSk_ v_ann : v.SnSk v
v_Sk2 := v.Sk2_ v_ann : v.Sk2 v
b := fun n : int => \sum_(0 <= k < n + 1 :> int) v n k : int -> rat
n : int
abelG : (2 : int) <= n
notD : ?Goal
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: v.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
v : int -> int -> rat
v_ann : v.Ann v
v_Sn2 := v.Sn2_ v_ann : v.Sn2 v
v_SnSk := v.SnSk_ v_ann : v.SnSk v
v_Sk2 := v.Sk2_ v_ann : v.Sk2 v
b := fun n : int => \sum_(0 <= k < n + 1 :> int) v n k : int -> rat
n : int
abelG : (2 : int) <= n
p_prime : ?Goal
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: v.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
"notη has been translated as notηᵗ"
"~~~~~~~~~~~~~~~~~~"
"Translating Coq.Init.Logic.eq"
"Coq.Init.Logic.eq was already translated"
"Translating MetaCoq.Translations.MiniHoTT.paths"
"MetaCoq.Translations.MiniHoTT.paths was already translated"
"Translating MetaCoq.Translations.times_bool_fun.UIP"
"UIP has been translated as UIPᵗ"
Debug:
In environment
v : int -> int -> rat
v_ann : v.Ann v
v_Sn2 := v.Sn2_ v_ann : v.Sn2 v
v_SnSk := v.SnSk_ v_ann : v.SnSk v
v_Sk2 := v.Sk2_ v_ann : v.Sk2 v
b := fun n : int => \sum_(0 <= k < n + 1 :> int) v n k : int -> rat
n : int
lin_xy : (2 : int) <= n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: v.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching:
(forall f : nat -> nat -> nat -> R * R,
 (fix vkron (n : nat) (f0 : nat -> nat -> nat -> R * R) {struct n} :
      nat -> nat -> R * R :=
    match n with
    | 0 =>
        fun x y : nat =>
        if
         if
          (fix eqb (n0 m : nat) {struct n0} : bool :=
             match n0 with
             | 0 => match m with
                    | 0 => true
                    | S _ => false
                    end
             | S n' => match m with
                       | 0 => false
                       | S m' => eqb n' m'
                       end
             end) x y
         then
          (fix leb (n0 m : nat) {struct n0} : bool :=
             match n0 with
             | 0 => true
             | S n' => match m with
                       | 0 => false
                       | S m' => leb n' m'
                       end
             end) x 0
         else false
        then (R1, R0)
        else (R0, R0)
    | S n' =>
        fun x y : nat =>
        (((let (x0, _) :=
             vkron n' f0
               (let (x0, _) :=
                  (fix divmod (x0 y0 q u : nat) {struct x0} : nat * nat :=
                     match x0 with
                     | 0%nat => (q, u)
                     | S x' =>
                         match u with
                         | 0%nat => divmod x' y0 (S q) y0
                         | S u' => divmod x' y0 q u'
                         end
                     end) x 1%nat 0%nat 1%nat in
                x0)
               (let (x0, _) :=
                  (fix divmod (x0 y0 q u : nat) {struct x0} : nat * nat :=
                     match x0 with
                     | 0%nat => (q, u)
                     | S x' =>
                         match u with
                         | 0%nat => divmod x' y0 (S q) y0
                         | S u' => divmod x' y0 q u'
                         end
                     end) y 0%nat 0%nat 0%nat in
                x0) in
           x0) *
          (let (x0, _) :=
             f0 n'
               match
                 (let (_, y0) :=
                    (fix divmod (x0 y0 q u : nat) {struct x0} : nat * nat :=
                       match x0 with
                       | 0%nat => (q, u)
                       | S x' =>
                           match u with
                           | 0%nat => divmod x' y0 (S q) y0
                           | S u' => divmod x' y0 q u'
                           end
                       end) x 1%nat 0%nat 1%nat in
                  y0)
               with
               | 0%nat => 1%nat
               | S _ => 0%nat
               end 0%nat in
           x0) +
          -
          ((let (_, y0) :=
              vkron n' f0
                (let (x0, _) :=
                   (fix divmod (x0 y0 q u : nat) {struct x0} : nat * nat :=
                      match x0 with
                      | 0%nat => (q, u)
                      | S x' =>
                          match u with
                          | 0%nat => divmod x' y0 (S q) y0
                          | S u' => divmod x' y0 q u'
                          end
                      end) x 1%nat 0%nat 1%nat in
                 x0)
                (let (x0, _) :=
                   (fix divmod (x0 y0 q u : nat) {struct x0} : nat * nat :=
                      match x0 with
                      | 0%nat => (q, u)
                      | S x' =>
                          match u with
                          | 0%nat => divmod x' y0 (S q) y0
                          | S u' => divmod x' y0 q u'
                          end
                      end) y 0%nat 0%nat 0%nat in
                 x0) in
            y0) *
           (let (_, y0) :=
              f0 n'
                match
                  (let (_, y0) :=
                     (fix divmod (x0 y0 q u : nat) {struct x0} : nat * nat :=
                        match x0 with
                        | 0%nat => (q, u)
                        | S x' =>
                            match u with
                            | 0%nat => divmod x' y0 (S q) y0
                            | S u' => divmod x' y0 q u'
                            end
                        end) x 1%nat 0%nat 1%nat in
                   y0)
                with
                | 0%nat => 1%nat
                | S _ => 0%nat
                end 0%nat in
            y0)))%R,
        ((let (x0, _) :=
            vkron n' f0
              (let (x0, _) :=
                 (fix divmod (x0 y0 q u : nat) {struct x0} : nat * nat :=
                    match x0 with
                    | 0%nat => (q, u)
                    | S x' =>
                        match u with
                        | 0%nat => divmod x' y0 (S q) y0
                        | S u' => divmod x' y0 q u'
                        end
                    end) x 1%nat 0%nat 1%nat in
               x0)
              (let (x0, _) :=
                 (fix divmod (x0 y0 q u : nat) {struct x0} : nat * nat :=
                    match x0 with
                    | 0%nat => (q, u)
                    | S x' =>
                        match u with
                        | 0%nat => divmod x' y0 (S q) y0
                        | S u' => divmod x' y0 q u'
                        end
                    end) y 0%nat 0%nat 0%nat in
               x0) in
          x0) *
         (let (_, y0) :=
            f0 n'
              match
                (let (_, y0) :=
                   (fix divmod (x0 y0 q u : nat) {struct x0} : nat * nat :=
                      match x0 with
                      | 0%nat => (q, u)
                      | S x' =>
                          match u with
                          | 0%nat => divmod x' y0 (S q) y0
                          | S u' => divmod x' y0 q u'
                          end
                      end) x 1%nat 0%nat 1%nat in
                 y0)
              with
              | 0%nat => 1%nat
              | S _ => 0%nat
              end 0%nat in
          y0) +
         (let (_, y0) :=
            vkron n' f0
              (let (x0, _) :=
                 (fix divmod (x0 y0 q u : nat) {struct x0} : nat * nat :=
                    match x0 with
                    | 0%nat => (q, u)
                    | S x' =>
                        match u with
                        | 0%nat => divmod x' y0 (S q) y0
                        | S u' => divmod x' y0 q u'
                        end
                    end) x 1%nat 0%nat 1%nat in
               x0)
              (let (x0, _) :=
                 (fix divmod (x0 y0 q u : nat) {struct x0} : nat * nat :=
                    match x0 with
                    | 0%nat => (q, u)
                    | S x' =>
                        match u with
                        | 0%nat => divmod x' y0 (S q) y0
                        | S u' => divmod x' y0 q u'
                        end
                    end) y 0%nat 0%nat 0%nat in
               x0) in
          y0) *
         (let (x0, _) :=
            f0 n'
              match
                (let (_, y0) :=
                   (fix divmod (x0 y0 q u : nat) {struct x0} : nat * nat :=
                      match x0 with
                      | 0%nat => (q, u)
                      | S x' =>
                          match u with
                          | 0%nat => divmod x' y0 (S q) y0
                          | S u' => divmod x' y0 q u'
                          end
                      end) x 1%nat 0%nat 1%nat in
                 y0)
              with
              | 0%nat => 1%nat
              | S _ => 0%nat
              end 0%nat in
          x0))%R)
    end) H2
   (fun i x y : nat =>
    (((let (x0, _) := n in x0) * (let (x0, _) := f i x y in x0) +
      - ((let (_, y0) := n in y0) * (let (_, y0) := f i x y in y0)))%R,
    ((let (x0, _) := n in x0) * (let (_, y0) := f i x y in y0) +
     (let (_, y0) := n in y0) * (let (x0, _) := f i x y in x0))%R)) =
 (fun x y : nat =>
  (((let (x0, _) :=
       (fix Cpow (c : R * R) (n : nat) {struct n} : R * R :=
          match n with
          | 0%nat => (R1, R0)
          | S n' =>
              ((let (x0, _) := c in x0) * (let (x0, _) := Cpow c n' in x0) +
               -
               ((let (_, y0) := c in y0) * (let (_, y0) := Cpow c n' in y0)),
              (let (x0, _) := c in x0) * (let (_, y0) := Cpow c n' in y0) +
              (let (_, y0) := c in y0) * (let (x0, _) := Cpow c n' in x0))
          end) n H2 in
     x0) *
    (let (x0, _) :=
       (fix vkron (n : nat) (f0 : nat -> nat -> nat -> R * R) {struct n} :
            nat -> nat -> R * R :=
          match n with
          | 0%nat =>
              fun x0 y0 : nat =>
              if
               if
                (fix eqb (n0 m : nat) {struct n0} : bool :=
                   match n0 with
                   | 0%nat => match m with
                              | 0%nat => true
                              | S _ => false
                              end
                   | S n' =>
                       match m with
                       | 0%nat => false
                       | S m' => eqb n' m'
                       end
                   end) x0 y0
               then
                (fix leb (n0 m : nat) {struct n0} : bool :=
                   match n0 with
                   | 0%nat => true
                   | S n' =>
                       match m with
                       | 0%nat => false
                       | S m' => leb n' m'
                       end
                   end) x0 0%nat
               else false
              then (R1, R0)
              else (R0, R0)
          | S n' =>
              fun x0 y0 : nat =>
              ((let (x1, _) :=
                  vkron n' f0
                    (let (x1, _) :=
                       (fix divmod (x1 y1 q u : nat) {struct x1} :
                            nat * nat :=
                          match x1 with
                          | 0%nat => (q, u)
                          | S x' =>
                              match u with
                              | 0%nat => divmod x' y1 (S q) y1
                              | S u' => divmod x' y1 q u'
                              end
                          end) x0 1%nat 0%nat 1%nat in
                     x1)
                    (let (x1, _) :=
                       (fix divmod (x1 y1 q u : nat) {struct x1} :
                            nat * nat :=
                          match x1 with
                          | 0%nat => (q, u)
                          | S x' =>
                              match u with
                              | 0%nat => divmod x' y1 (S q) y1
                              | S u' => divmod x' y1 q u'
                              end
                          end) y0 0%nat 0%nat 0%nat in
                     x1) in
                x1) *
               (let (x1, _) :=
                  f0 n'
                    match
                      (let (_, y1) :=
                         (fix divmod (x1 y1 q u : nat) {struct x1} :
                              nat * nat :=
                            match x1 with
                            | 0%nat => (q, u)
                            | S x' =>
                                match u with
                                | 0%nat => divmod x' y1 (S q) y1
                                | S u' => divmod x' y1 q u'
                                end
                            end) x0 1%nat 0%nat 1%nat in
                       y1)
                    with
                    | 0%nat => 1%nat
                    | S _ => 0%nat
                    end 0%nat in
                x1) +
               -
               ((let (_, y1) :=
                   vkron n' f0
                     (let (x1, _) :=
                        (fix divmod (x1 y1 q u : nat) {struct x1} :
                             nat * nat :=
                           match x1 with
                           | 0%nat => (q, u)
                           | S x' =>
                               match u with
                               | 0%nat => divmod x' y1 (S q) y1
                               | S u' => divmod x' y1 q u'
                               end
                           end) x0 1%nat 0%nat 1%nat in
                      x1)
                     (let (x1, _) :=
                        (fix divmod (x1 y1 q u : nat) {struct x1} :
                             nat * nat :=
                           match x1 with
                           | 0%nat => (q, u)
                           | S x' =>
                               match u with
                               | 0%nat => divmod x' y1 (S q) y1
                               | S u' => divmod x' y1 q u'
                               end
                           end) y0 0%nat 0%nat 0%nat in
                      x1) in
                 y1) *
                (let (_, y1) :=
                   f0 n'
                     match
                       (let (_, y1) :=
                          (fix divmod (x1 y1 q u : nat) {struct x1} :
                               nat * nat :=
                             match x1 with
                             | 0%nat => (q, u)
                             | S x' =>
                                 match u with
                                 | 0%nat => divmod x' y1 (S q) y1
                                 | S u' => divmod x' y1 q u'
                                 end
                             end) x0 1%nat 0%nat 1%nat in
                        y1)
                     with
                     | 0%nat => 1%nat
                     | S _ => 0%nat
                     end 0%nat in
                 y1)),
              (let (x1, _) :=
                 vkron n' f0
                   (let (x1, _) :=
                      (fix divmod (x1 y1 q u : nat) {struct x1} :
                           nat * nat :=
                         match x1 with
                         | 0%nat => (q, u)
                         | S x' =>
                             match u with
                             | 0%nat => divmod x' y1 (S q) y1
                             | S u' => divmod x' y1 q u'
                             end
                         end) x0 1%nat 0%nat 1%nat in
                    x1)
                   (let (x1, _) :=
                      (fix divmod (x1 y1 q u : nat) {struct x1} :
                           nat * nat :=
                         match x1 with
                         | 0%nat => (q, u)
                         | S x' =>
                             match u with
                             | 0%nat => divmod x' y1 (S q) y1
                             | S u' => divmod x' y1 q u'
                             end
                         end) y0 0%nat 0%nat 0%nat in
                    x1) in
               x1) *
              (let (_, y1) :=
                 f0 n'
                   match
                     (let (_, y1) :=
                        (fix divmod (x1 y1 q u : nat) {struct x1} :
                             nat * nat :=
                           match x1 with
                           | 0%nat => (q, u)
                           | S x' =>
                               match u with
                               | 0%nat => divmod x' y1 (S q) y1
                               | S u' => divmod x' y1 q u'
                               end
                           end) x0 1%nat 0%nat 1%nat in
                      y1)
                   with
                   | 0%nat => 1%nat
                   | S _ => 0%nat
                   end 0%nat in
               y1) +
              (let (_, y1) :=
                 vkron n' f0
                   (let (x1, _) :=
                      (fix divmod (x1 y1 q u : nat) {struct x1} :
                           nat * nat :=
                         match x1 with
                         | 0%nat => (q, u)
                         | S x' =>
                             match u with
                             | 0%nat => divmod x' y1 (S q) y1
                             | S u' => divmod x' y1 q u'
                             end
                         end) x0 1%nat 0%nat 1%nat in
                    x1)
                   (let (x1, _) :=
                      (fix divmod (x1 y1 q u : nat) {struct x1} :
                           nat * nat :=
                         match x1 with
                         | 0%nat => (q, u)
                         | S x' =>
                             match u with
                             | 0%nat => divmod x' y1 (S q) y1
                             | S u' => divmod x' y1 q u'
                             end
                         end) y0 0%nat 0%nat 0%nat in
                    x1) in
               y1) *
              (let (x1, _) :=
                 f0 n'
                   match
                     (let (_, y1) :=
                        (fix divmod (x1 y1 q u : nat) {struct x1} :
                             nat * nat :=
                           match x1 with
                           | 0%nat => (q, u)
                           | S x' =>
                               match u with
                               | 0%nat => divmod x' y1 (S q) y1
                               | S u' => divmod x' y1 q u'
                               end
                           end) x0 1%nat 0%nat 1%nat in
                      y1)
                   with
                   | 0%nat => 1%nat
                   | S _ => 0%nat
                   end 0%nat in
               x1))
          end) H2 f x y in
     x0) +
    -
    ((let (_, y0) :=
        (fix Cpow (c : R * R) (n : nat) {struct n} : R * R :=
           match n with
           | 0%nat => (R1, R0)
           | S n' =>
               ((let (x0, _) := c in x0) * (let (x0, _) := Cpow c n' in x0) +
                -
                ((let (_, y0) := c in y0) * (let (_, y0) := Cpow c n' in y0)),
               (let (x0, _) := c in x0) * (let (_, y0) := Cpow c n' in y0) +
               (let (_, y0) := c in y0) * (let (x0, _) := Cpow c n' in x0))
           end) n H2 in
      y0) *
     (let (_, y0) :=
        (fix vkron (n : nat) (f0 : nat -> nat -> nat -> R * R) {struct n} :
             nat -> nat -> R * R :=
           match n with
           | 0%nat =>
               fun x0 y0 : nat =>
               if
                if
                 (fix eqb (n0 m : nat) {struct n0} : bool :=
                    match n0 with
                    | 0%nat =>
                        match m with
                        | 0%nat => true
                        | S _ => false
                        end
                    | S n' =>
                        match m with
                        | 0%nat => false
                        | S m' => eqb n' m'
                        end
                    end) x0 y0
                then
                 (fix leb (n0 m : nat) {struct n0} : bool :=
                    match n0 with
                    | 0%nat => true
                    | S n' =>
                        match m with
                        | 0%nat => false
                        | S m' => leb n' m'
                        end
                    end) x0 0%nat
                else false
               then (R1, R0)
               else (R0, R0)
           | S n' =>
               fun x0 y0 : nat =>
               ((let (x1, _) :=
                   vkron n' f0
                     (let (x1, _) :=
                        (fix divmod (x1 y1 q u : nat) {struct x1} :
                             nat * nat :=
                           match x1 with
                           | 0%nat => (q, u)
                           | S x' =>
                               match u with
                               | 0%nat => divmod x' y1 (S q) y1
                               | S u' => divmod x' y1 q u'
                               end
                           end) x0 1%nat 0%nat 1%nat in
                      x1)
                     (let (x1, _) :=
                        (fix divmod (x1 y1 q u : nat) {struct x1} :
                             nat * nat :=
                           match x1 with
                           | 0%nat => (q, u)
                           | S x' =>
                               match u with
                               | 0%nat => divmod x' y1 (S q) y1
                               | S u' => divmod x' y1 q u'
                               end
                           end) y0 0%nat 0%nat 0%nat in
                      x1) in
                 x1) *
                (let (x1, _) :=
                   f0 n'
                     match
                       (let (_, y1) :=
                          (fix divmod (x1 y1 q u : nat) {struct x1} :
                               nat * nat :=
                             match x1 with
                             | 0%nat => (q, u)
                             | S x' =>
                                 match u with
                                 | 0%nat => divmod x' y1 (S q) y1
                                 | S u' => divmod x' y1 q u'
                                 end
                             end) x0 1%nat 0%nat 1%nat in
                        y1)
                     with
                     | 0%nat => 1%nat
                     | S _ => 0%nat
                     end 0%nat in
                 x1) +
                -
                ((let (_, y1) :=
                    vkron n' f0
                      (let (x1, _) :=
                         (fix divmod (x1 y1 q u : nat) {struct x1} :
                              nat * nat :=
                            match x1 with
                            | 0%nat => (q, u)
                            | S x' =>
                                match u with
                                | 0%nat => divmod x' y1 (S q) y1
                                | S u' => divmod x' y1 q u'
                                end
                            end) x0 1%nat 0%nat 1%nat in
                       x1)
                      (let (x1, _) :=
                         (fix divmod (x1 y1 q u : nat) {struct x1} :
                              nat * nat :=
                            match x1 with
                            | 0%nat => (q, u)
                            | S x' =>
                                match u with
                                | 0%nat => divmod x' y1 (S q) y1
                                | S u' => divmod x' y1 q u'
                                end
                            end) y0 0%nat 0%nat 0%nat in
                       x1) in
                  y1) *
                 (let (_, y1) :=
                    f0 n'
                      match
                        (let (_, y1) :=
                           (fix divmod (x1 y1 q u : nat) {struct x1} :
                                nat * nat :=
                              match x1 with
                              | 0%nat => (q, u)
                              | S x' =>
                                  match u with
                                  | 0%nat => divmod x' y1 (S q) y1
                                  | S u' => divmod x' y1 q u'
                                  end
                              end) x0 1%nat 0%nat 1%nat in
                         y1)
                      with
                      | 0%nat => 1%nat
                      | S _ => 0%nat
                      end 0%nat in
                  y1)),
               (let (x1, _) :=
                  vkron n' f0
                    (let (x1, _) :=
                       (fix divmod (x1 y1 q u : nat) {struct x1} :
                            nat * nat :=
                          match x1 with
                          | 0%nat => (q, u)
                          | S x' =>
                              match u with
                              | 0%nat => divmod x' y1 (S q) y1
                              | S u' => divmod x' y1 q u'
                              end
                          end) x0 1%nat 0%nat 1%nat in
                     x1)
                    (let (x1, _) :=
                       (fix divmod (x1 y1 q u : nat) {struct x1} :
                            nat * nat :=
                          match x1 with
                          | 0%nat => (q, u)
                          | S x' =>
                              match u with
                              | 0%nat => divmod x' y1 (S q) y1
                              | S u' => divmod x' y1 q u'
                              end
                          end) y0 0%nat 0%nat 0%nat in
                     x1) in
                x1) *
               (let (_, y1) :=
                  f0 n'
                    match
                      (let (_, y1) :=
                         (fix divmod (x1 y1 q u : nat) {struct x1} :
                              nat * nat :=
                            match x1 with
                            | 0%nat => (q, u)
                            | S x' =>
                                match u with
                                | 0%nat => divmod x' y1 (S q) y1
                                | S u' => divmod x' y1 q u'
                                end
                            end) x0 1%nat 0%nat 1%nat in
                       y1)
                    with
                    | 0%nat => 1%nat
                    | S _ => 0%nat
                    end 0%nat in
                y1) +
               (let (_, y1) :=
                  vkron n' f0
                    (let (x1, _) :=
                       (fix divmod (x1 y1 q u : nat) {struct x1} :
                            nat * nat :=
                          match x1 with
                          | 0%nat => (q, u)
                          | S x' =>
                              match u with
                              | 0%nat => divmod x' y1 (S q) y1
                              | S u' => divmod x' y1 q u'
                              end
                          end) x0 1%nat 0%nat 1%nat in
                     x1)
                    (let (x1, _) :=
                       (fix divmod (x1 y1 q u : nat) {struct x1} :
                            nat * nat :=
                          match x1 with
                          | 0%nat => (q, u)
                          | S x' =>
                              match u with
                              | 0%nat => divmod x' y1 (S q) y1
                              | S u' => divmod x' y1 q u'
                              end
                          end) y0 0%nat 0%nat 0%nat in
                     x1) in
                y1) *
               (let (x1, _) :=
                  f0 n'
                    match
                      (let (_, y1) :=
                         (fix divmod (x1 y1 q u : nat) {struct x1} :
                              nat * nat :=
                            match x1 with
                            | 0%nat => (q, u)
                            | S x' =>
                                match u with
                                | 0%nat => divmod x' y1 (S q) y1
                                | S u' => divmod x' y1 q u'
                                end
                            end) x0 1%nat 0%nat 1%nat in
                       y1)
                    with
                    | 0%nat => 1%nat
                    | S _ => 0%nat
                    end 0%nat in
                x1))
           end) H2 f x y in
      y0)))%R,
  ((let (x0, _) :=
      (fix Cpow (c : R * R) (n : nat) {struct n} : R * R :=
         match n with
         | 0%nat => (R1, R0)
         | S n' =>
             ((let (x0, _) := c in x0) * (let (x0, _) := Cpow c n' in x0) +
              - ((let (_, y0) := c in y0) * (let (_, y0) := Cpow c n' in y0)),
             (let (x0, _) := c in x0) * (let (_, y0) := Cpow c n' in y0) +
             (let (_, y0) := c in y0) * (let (x0, _) := Cpow c n' in x0))
         end) n H2 in
    x0) *
   (let (_, y0) :=
      (fix vkron (n : nat) (f0 : nat -> nat -> nat -> R * R) {struct n} :
           nat -> nat -> R * R :=
         match n with
         | 0%nat =>
             fun x0 y0 : nat =>
             if
              if
               (fix eqb (n0 m : nat) {struct n0} : bool :=
                  match n0 with
                  | 0%nat => match m with
                             | 0%nat => true
                             | S _ => false
                             end
                  | S n' =>
                      match m with
                      | 0%nat => false
                      | S m' => eqb n' m'
                      end
                  end) x0 y0
              then
               (fix leb (n0 m : nat) {struct n0} : bool :=
                  match n0 with
                  | 0%nat => true
                  | S n' =>
                      match m with
                      | 0%nat => false
                      | S m' => leb n' m'
                      end
                  end) x0 0%nat
              else false
             then (R1, R0)
             else (R0, R0)
         | S n' =>
             fun x0 y0 : nat =>
             ((let (x1, _) :=
                 vkron n' f0
                   (let (x1, _) :=
                      (fix divmod (x1 y1 q u : nat) {struct x1} :
                           nat * nat :=
                         match x1 with
                         | 0%nat => (q, u)
                         | S x' =>
                             match u with
                             | 0%nat => divmod x' y1 (S q) y1
                             | S u' => divmod x' y1 q u'
                             end
                         end) x0 1%nat 0%nat 1%nat in
                    x1)
                   (let (x1, _) :=
                      (fix divmod (x1 y1 q u : nat) {struct x1} :
                           nat * nat :=
                         match x1 with
                         | 0%nat => (q, u)
                         | S x' =>
                             match u with
                             | 0%nat => divmod x' y1 (S q) y1
                             | S u' => divmod x' y1 q u'
                             end
                         end) y0 0%nat 0%nat 0%nat in
                    x1) in
               x1) *
              (let (x1, _) :=
                 f0 n'
                   match
                     (let (_, y1) :=
                        (fix divmod (x1 y1 q u : nat) {struct x1} :
                             nat * nat :=
                           match x1 with
                           | 0%nat => (q, u)
                           | S x' =>
                               match u with
                               | 0%nat => divmod x' y1 (S q) y1
                               | S u' => divmod x' y1 q u'
                               end
                           end) x0 1%nat 0%nat 1%nat in
                      y1)
                   with
                   | 0%nat => 1%nat
                   | S _ => 0%nat
                   end 0%nat in
               x1) +
              -
              ((let (_, y1) :=
                  vkron n' f0
                    (let (x1, _) :=
                       (fix divmod (x1 y1 q u : nat) {struct x1} :
                            nat * nat :=
                          match x1 with
                          | 0%nat => (q, u)
                          | S x' =>
                              match u with
                              | 0%nat => divmod x' y1 (S q) y1
                              | S u' => divmod x' y1 q u'
                              end
                          end) x0 1%nat 0%nat 1%nat in
                     x1)
                    (let (x1, _) :=
                       (fix divmod (x1 y1 q u : nat) {struct x1} :
                            nat * nat :=
                          match x1 with
                          | 0%nat => (q, u)
                          | S x' =>
                              match u with
                              | 0%nat => divmod x' y1 (S q) y1
                              | S u' => divmod x' y1 q u'
                              end
                          end) y0 0%nat 0%nat 0%nat in
                     x1) in
                y1) *
               (let (_, y1) :=
                  f0 n'
                    match
                      (let (_, y1) :=
                         (fix divmod (x1 y1 q u : nat) {struct x1} :
                              nat * nat :=
                            match x1 with
                            | 0%nat => (q, u)
                            | S x' =>
                                match u with
                                | 0%nat => divmod x' y1 (S q) y1
                                | S u' => divmod x' y1 q u'
                                end
                            end) x0 1%nat 0%nat 1%nat in
                       y1)
                    with
                    | 0%nat => 1%nat
                    | S _ => 0%nat
                    end 0%nat in
                y1)),
             (let (x1, _) :=
                vkron n' f0
                  (let (x1, _) :=
                     (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                        match x1 with
                        | 0%nat => (q, u)
                        | S x' =>
                            match u with
                            | 0%nat => divmod x' y1 (S q) y1
                            | S u' => divmod x' y1 q u'
                            end
                        end) x0 1%nat 0%nat 1%nat in
                   x1)
                  (let (x1, _) :=
                     (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                        match x1 with
                        | 0%nat => (q, u)
                        | S x' =>
                            match u with
                            | 0%nat => divmod x' y1 (S q) y1
                            | S u' => divmod x' y1 q u'
                            end
                        end) y0 0%nat 0%nat 0%nat in
                   x1) in
              x1) *
             (let (_, y1) :=
                f0 n'
                  match
                    (let (_, y1) :=
                       (fix divmod (x1 y1 q u : nat) {struct x1} :
                            nat * nat :=
                          match x1 with
                          | 0%nat => (q, u)
                          | S x' =>
                              match u with
                              | 0%nat => divmod x' y1 (S q) y1
                              | S u' => divmod x' y1 q u'
                              end
                          end) x0 1%nat 0%nat 1%nat in
                     y1)
                  with
                  | 0%nat => 1%nat
                  | S _ => 0%nat
                  end 0%nat in
              y1) +
             (let (_, y1) :=
                vkron n' f0
                  (let (x1, _) :=
                     (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                        match x1 with
                        | 0%nat => (q, u)
                        | S x' =>
                            match u with
                            | 0%nat => divmod x' y1 (S q) y1
                            | S u' => divmod x' y1 q u'
                            end
                        end) x0 1%nat 0%nat 1%nat in
                   x1)
                  (let (x1, _) :=
                     (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                        match x1 with
                        | 0%nat => (q, u)
                        | S x' =>
                            match u with
                            | 0%nat => divmod x' y1 (S q) y1
                            | S u' => divmod x' y1 q u'
                            end
                        end) y0 0%nat 0%nat 0%nat in
                   x1) in
              y1) *
             (let (x1, _) :=
                f0 n'
                  match
                    (let (_, y1) :=
                       (fix divmod (x1 y1 q u : nat) {struct x1} :
                            nat * nat :=
                          match x1 with
                          | 0%nat => (q, u)
                          | S x' =>
                              match u with
                              | 0%nat => divmod x' y1 (S q) y1
                              | S u' => divmod x' y1 q u'
                              end
                          end) x0 1%nat 0%nat 1%nat in
                     y1)
                  with
                  | 0%nat => 1%nat
                  | S _ => 0%nat
                  end 0%nat in
              x1))
         end) H2 f x y in
    y0) +
   (let (_, y0) :=
      (fix Cpow (c : R * R) (n : nat) {struct n} : R * R :=
         match n with
         | 0%nat => (R1, R0)
         | S n' =>
             ((let (x0, _) := c in x0) * (let (x0, _) := Cpow c n' in x0) +
              - ((let (_, y0) := c in y0) * (let (_, y0) := Cpow c n' in y0)),
             (let (x0, _) := c in x0) * (let (_, y0) := Cpow c n' in y0) +
             (let (_, y0) := c in y0) * (let (x0, _) := Cpow c n' in x0))
         end) n H2 in
    y0) *
   (let (x0, _) :=
      (fix vkron (n : nat) (f0 : nat -> nat -> nat -> R * R) {struct n} :
           nat -> nat -> R * R :=
         match n with
         | 0%nat =>
             fun x0 y0 : nat =>
             if
              if
               (fix eqb (n0 m : nat) {struct n0} : bool :=
                  match n0 with
                  | 0%nat => match m with
                             | 0%nat => true
                             | S _ => false
                             end
                  | S n' =>
                      match m with
                      | 0%nat => false
                      | S m' => eqb n' m'
                      end
                  end) x0 y0
              then
               (fix leb (n0 m : nat) {struct n0} : bool :=
                  match n0 with
                  | 0%nat => true
                  | S n' =>
                      match m with
                      | 0%nat => false
                      | S m' => leb n' m'
                      end
                  end) x0 0%nat
              else false
             then (R1, R0)
             else (R0, R0)
         | S n' =>
             fun x0 y0 : nat =>
             ((let (x1, _) :=
                 vkron n' f0
                   (let (x1, _) :=
                      (fix divmod (x1 y1 q u : nat) {struct x1} :
                           nat * nat :=
                         match x1 with
                         | 0%nat => (q, u)
                         | S x' =>
                             match u with
                             | 0%nat => divmod x' y1 (S q) y1
                             | S u' => divmod x' y1 q u'
                             end
                         end) x0 1%nat 0%nat 1%nat in
                    x1)
                   (let (x1, _) :=
                      (fix divmod (x1 y1 q u : nat) {struct x1} :
                           nat * nat :=
                         match x1 with
                         | 0%nat => (q, u)
                         | S x' =>
                             match u with
                             | 0%nat => divmod x' y1 (S q) y1
                             | S u' => divmod x' y1 q u'
                             end
                         end) y0 0%nat 0%nat 0%nat in
                    x1) in
               x1) *
              (let (x1, _) :=
                 f0 n'
                   match
                     (let (_, y1) :=
                        (fix divmod (x1 y1 q u : nat) {struct x1} :
                             nat * nat :=
                           match x1 with
                           | 0%nat => (q, u)
                           | S x' =>
                               match u with
                               | 0%nat => divmod x' y1 (S q) y1
                               | S u' => divmod x' y1 q u'
                               end
                           end) x0 1%nat 0%nat 1%nat in
                      y1)
                   with
                   | 0%nat => 1%nat
                   | S _ => 0%nat
                   end 0%nat in
               x1) +
              -
              ((let (_, y1) :=
                  vkron n' f0
                    (let (x1, _) :=
                       (fix divmod (x1 y1 q u : nat) {struct x1} :
                            nat * nat :=
                          match x1 with
                          | 0%nat => (q, u)
                          | S x' =>
                              match u with
                              | 0%nat => divmod x' y1 (S q) y1
                              | S u' => divmod x' y1 q u'
                              end
                          end) x0 1%nat 0%nat 1%nat in
                     x1)
                    (let (x1, _) :=
                       (fix divmod (x1 y1 q u : nat) {struct x1} :
                            nat * nat :=
                          match x1 with
                          | 0%nat => (q, u)
                          | S x' =>
                              match u with
                              | 0%nat => divmod x' y1 (S q) y1
                              | S u' => divmod x' y1 q u'
                              end
                          end) y0 0%nat 0%nat 0%nat in
                     x1) in
                y1) *
               (let (_, y1) :=
                  f0 n'
                    match
                      (let (_, y1) :=
                         (fix divmod (x1 y1 q u : nat) {struct x1} :
                              nat * nat :=
                            match x1 with
                            | 0%nat => (q, u)
                            | S x' =>
                                match u with
                                | 0%nat => divmod x' y1 (S q) y1
                                | S u' => divmod x' y1 q u'
                                end
                            end) x0 1%nat 0%nat 1%nat in
                       y1)
                    with
                    | 0%nat => 1%nat
                    | S _ => 0%nat
                    end 0%nat in
                y1)),
             (let (x1, _) :=
                vkron n' f0
                  (let (x1, _) :=
                     (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                        match x1 with
                        | 0%nat => (q, u)
                        | S x' =>
                            match u with
                            | 0%nat => divmod x' y1 (S q) y1
                            | S u' => divmod x' y1 q u'
                            end
                        end) x0 1%nat 0%nat 1%nat in
                   x1)
                  (let (x1, _) :=
                     (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                        match x1 with
                        | 0%nat => (q, u)
                        | S x' =>
                            match u with
                            | 0%nat => divmod x' y1 (S q) y1
                            | S u' => divmod x' y1 q u'
                            end
                        end) y0 0%nat 0%nat 0%nat in
                   x1) in
              x1) *
             (let (_, y1) :=
                f0 n'
                  match
                    (let (_, y1) :=
                       (fix divmod (x1 y1 q u : nat) {struct x1} :
                            nat * nat :=
                          match x1 with
                          | 0%nat => (q, u)
                          | S x' =>
                              match u with
                              | 0%nat => divmod x' y1 (S q) y1
                              | S u' => divmod x' y1 q u'
                              end
                          end) x0 1%nat 0%nat 1%nat in
                     y1)
                  with
                  | 0%nat => 1%nat
                  | S _ => 0%nat
                  end 0%nat in
              y1) +
             (let (_, y1) :=
                vkron n' f0
                  (let (x1, _) :=
                     (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                        match x1 with
                        | 0%nat => (q, u)
                        | S x' =>
                            match u with
                            | 0%nat => divmod x' y1 (S q) y1
                            | S u' => divmod x' y1 q u'
                            end
                        end) x0 1%nat 0%nat 1%nat in
                   x1)
                  (let (x1, _) :=
                     (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                        match x1 with
                        | 0%nat => (q, u)
                        | S x' =>
                            match u with
                            | 0%nat => divmod x' y1 (S q) y1
                            | S u' => divmod x' y1 q u'
                            end
                        end) y0 0%nat 0%nat 0%nat in
                   x1) in
              y1) *
             (let (x1, _) :=
                f0 n'
                  match
                    (let (_, y1) :=
                       (fix divmod (x1 y1 q u : nat) {struct x1} :
                            nat * nat :=
                          match x1 with
                          | 0%nat => (q, u)
                          | S x' =>
                              match u with
                              | 0%nat => divmod x' y1 (S q) y1
                              | S u' => divmod x' y1 q u'
                              end
                          end) x0 1%nat 0%nat 1%nat in
                     y1)
                  with
                  | 0%nat => 1%nat
                  | S _ => 0%nat
                  end 0%nat in
              x1))
         end) H2 f x y in
    x0))%R)))
Debug:
In environment
v : int -> int -> rat
v_ann : v.Ann v
v_Sn2 := v.Sn2_ v_ann : v.Sn2 v
v_SnSk := v.SnSk_ v_ann : v.SnSk v
v_Sk2 := v.Sk2_ v_ann : v.Sk2 v
b := fun n : int => \sum_(0 <= k < n + 1 :> int) v n k : int -> rat
n : int
lin_xy : (2 : int) <= n
notD : ?Goal
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: v.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
v : int -> int -> rat
v_ann : v.Ann v
v_Sn2 := v.Sn2_ v_ann : v.Sn2 v
v_SnSk := v.SnSk_ v_ann : v.SnSk v
v_Sk2 := v.Sk2_ v_ann : v.Sk2 v
b := fun n : int => \sum_(0 <= k < n + 1 :> int) v n k : int -> rat
n : int
lin_xy : (2 : int) <= n
p_prime : ?Goal
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: v.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
v : int -> int -> rat
v_ann : v.Ann v
v_Sn2 := v.Sn2_ v_ann : v.Sn2 v
v_SnSk := v.SnSk_ v_ann : v.SnSk v
v_Sk2 := v.Sk2_ v_ann : v.Sk2 v
b := fun n : int => \sum_(0 <= k < n + 1 :> int) v n k : int -> rat
n : int
k : (2 : int) <= n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: v.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
v : int -> int -> rat
v_ann : v.Ann v
v_Sn2 := v.Sn2_ v_ann : v.Sn2 v
v_SnSk := v.SnSk_ v_ann : v.SnSk v
v_Sk2 := v.Sk2_ v_ann : v.Sk2 v
b := fun n : int => \sum_(0 <= k < n + 1 :> int) v n k : int -> rat
n : int
k : (2 : int) <= n
notD : ?Goal
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: v.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
v : int -> int -> rat
v_ann : v.Ann v
v_Sn2 := v.Sn2_ v_ann : v.Sn2 v
v_SnSk := v.SnSk_ v_ann : v.SnSk v
v_Sk2 := v.Sk2_ v_ann : v.Sk2 v
b := fun n : int => \sum_(0 <= k < n + 1 :> int) v n k : int -> rat
n : int
k : (2 : int) <= n
notD : ?Goal
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: v.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching: (forall r : R, pr_Ps X2 H r -> X2 [])
Debug:
In environment
v : int -> int -> rat
v_ann : v.Ann v
v_Sn2 := v.Sn2_ v_ann : v.Sn2 v
v_SnSk := v.SnSk_ v_ann : v.SnSk v
v_Sk2 := v.Sk2_ v_ann : v.Sk2 v
b := fun n : int => \sum_(0 <= k < n + 1 :> int) v n k : int -> rat
n : int
k : (2 : int) <= n
n_gt0 : ?Goal
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: v.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
x : rat
le0i : 0 <= x
rhs := delta (x + 1) - delta x : rat_numDomainType
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: delta (x + 1); delta x; x]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             (add
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 2)) zero))
       (negb_
          (Feqb
             (add
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 3)) zero)))" (cannot unify 
"false" and "true").
Debug:
In environment
v : int -> int -> rat
v_ann : v.Ann v
v_Sn2 := v.Sn2_ v_ann : v.Sn2 v
v_SnSk := v.SnSk_ v_ann : v.SnSk v
v_Sk2 := v.Sk2_ v_ann : v.Sk2 v
b := fun n : int => \sum_(0 <= k < n + 1 :> int) v n k : int -> rat
n : int
k : (2 : int) <= n
p_prime : ?Goal
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: v.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
v : int -> int -> rat
v_ann : v.Ann v
v_Sn2 := v.Sn2_ v_ann : v.Sn2 v
v_SnSk := v.SnSk_ v_ann : v.SnSk v
v_Sk2 := v.Sk2_ v_ann : v.Sk2 v
b := fun n : int => \sum_(0 <= k < n + 1 :> int) v n k : int -> rat
n : int
k : (2 : int) <= n
p_prime : ?Goal
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: v.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching:
(forall f : nat -> nat -> nat -> R * R,
 (fix vkron (n : nat) (f0 : nat -> nat -> nat -> R * R) {struct n} :
      nat -> nat -> R * R :=
    match n with
    | 0 =>
        fun x y : nat =>
        if
         if
          (fix eqb (n0 m : nat) {struct n0} : bool :=
             match n0 with
             | 0 => match m with
                    | 0 => true
                    | S _ => false
                    end
             | S n' => match m with
                       | 0 => false
                       | S m' => eqb n' m'
                       end
             end) x y
         then
          (fix leb (n0 m : nat) {struct n0} : bool :=
             match n0 with
             | 0 => true
             | S n' => match m with
                       | 0 => false
                       | S m' => leb n' m'
                       end
             end) x 0
         else false
        then (R1, R0)
        else (R0, R0)
    | S n' =>
        fun x y : nat =>
        (((let (x0, _) :=
             vkron n' f0
               (let (x0, _) :=
                  (fix divmod (x0 y0 q u : nat) {struct x0} : nat * nat :=
                     match x0 with
                     | 0%nat => (q, u)
                     | S x' =>
                         match u with
                         | 0%nat => divmod x' y0 (S q) y0
                         | S u' => divmod x' y0 q u'
                         end
                     end) x 1%nat 0%nat 1%nat in
                x0)
               (let (x0, _) :=
                  (fix divmod (x0 y0 q u : nat) {struct x0} : nat * nat :=
                     match x0 with
                     | 0%nat => (q, u)
                     | S x' =>
                         match u with
                         | 0%nat => divmod x' y0 (S q) y0
                         | S u' => divmod x' y0 q u'
                         end
                     end) y 0%nat 0%nat 0%nat in
                x0) in
           x0) *
          (let (x0, _) :=
             f0 n'
               match
                 (let (_, y0) :=
                    (fix divmod (x0 y0 q u : nat) {struct x0} : nat * nat :=
                       match x0 with
                       | 0%nat => (q, u)
                       | S x' =>
                           match u with
                           | 0%nat => divmod x' y0 (S q) y0
                           | S u' => divmod x' y0 q u'
                           end
                       end) x 1%nat 0%nat 1%nat in
                  y0)
               with
               | 0%nat => 1%nat
               | S _ => 0%nat
               end 0%nat in
           x0) +
          -
          ((let (_, y0) :=
              vkron n' f0
                (let (x0, _) :=
                   (fix divmod (x0 y0 q u : nat) {struct x0} : nat * nat :=
                      match x0 with
                      | 0%nat => (q, u)
                      | S x' =>
                          match u with
                          | 0%nat => divmod x' y0 (S q) y0
                          | S u' => divmod x' y0 q u'
                          end
                      end) x 1%nat 0%nat 1%nat in
                 x0)
                (let (x0, _) :=
                   (fix divmod (x0 y0 q u : nat) {struct x0} : nat * nat :=
                      match x0 with
                      | 0%nat => (q, u)
                      | S x' =>
                          match u with
                          | 0%nat => divmod x' y0 (S q) y0
                          | S u' => divmod x' y0 q u'
                          end
                      end) y 0%nat 0%nat 0%nat in
                 x0) in
            y0) *
           (let (_, y0) :=
              f0 n'
                match
                  (let (_, y0) :=
                     (fix divmod (x0 y0 q u : nat) {struct x0} : nat * nat :=
                        match x0 with
                        | 0%nat => (q, u)
                        | S x' =>
                            match u with
                            | 0%nat => divmod x' y0 (S q) y0
                            | S u' => divmod x' y0 q u'
                            end
                        end) x 1%nat 0%nat 1%nat in
                   y0)
                with
                | 0%nat => 1%nat
                | S _ => 0%nat
                end 0%nat in
            y0)))%R,
        ((let (x0, _) :=
            vkron n' f0
              (let (x0, _) :=
                 (fix divmod (x0 y0 q u : nat) {struct x0} : nat * nat :=
                    match x0 with
                    | 0%nat => (q, u)
                    | S x' =>
                        match u with
                        | 0%nat => divmod x' y0 (S q) y0
                        | S u' => divmod x' y0 q u'
                        end
                    end) x 1%nat 0%nat 1%nat in
               x0)
              (let (x0, _) :=
                 (fix divmod (x0 y0 q u : nat) {struct x0} : nat * nat :=
                    match x0 with
                    | 0%nat => (q, u)
                    | S x' =>
                        match u with
                        | 0%nat => divmod x' y0 (S q) y0
                        | S u' => divmod x' y0 q u'
                        end
                    end) y 0%nat 0%nat 0%nat in
               x0) in
          x0) *
         (let (_, y0) :=
            f0 n'
              match
                (let (_, y0) :=
                   (fix divmod (x0 y0 q u : nat) {struct x0} : nat * nat :=
                      match x0 with
                      | 0%nat => (q, u)
                      | S x' =>
                          match u with
                          | 0%nat => divmod x' y0 (S q) y0
                          | S u' => divmod x' y0 q u'
                          end
                      end) x 1%nat 0%nat 1%nat in
                 y0)
              with
              | 0%nat => 1%nat
              | S _ => 0%nat
              end 0%nat in
          y0) +
         (let (_, y0) :=
            vkron n' f0
              (let (x0, _) :=
                 (fix divmod (x0 y0 q u : nat) {struct x0} : nat * nat :=
                    match x0 with
                    | 0%nat => (q, u)
                    | S x' =>
                        match u with
                        | 0%nat => divmod x' y0 (S q) y0
                        | S u' => divmod x' y0 q u'
                        end
                    end) x 1%nat 0%nat 1%nat in
               x0)
              (let (x0, _) :=
                 (fix divmod (x0 y0 q u : nat) {struct x0} : nat * nat :=
                    match x0 with
                    | 0%nat => (q, u)
                    | S x' =>
                        match u with
                        | 0%nat => divmod x' y0 (S q) y0
                        | S u' => divmod x' y0 q u'
                        end
                    end) y 0%nat 0%nat 0%nat in
               x0) in
          y0) *
         (let (x0, _) :=
            f0 n'
              match
                (let (_, y0) :=
                   (fix divmod (x0 y0 q u : nat) {struct x0} : nat * nat :=
                      match x0 with
                      | 0%nat => (q, u)
                      | S x' =>
                          match u with
                          | 0%nat => divmod x' y0 (S q) y0
                          | S u' => divmod x' y0 q u'
                          end
                      end) x 1%nat 0%nat 1%nat in
                 y0)
              with
              | 0%nat => 1%nat
              | S _ => 0%nat
              end 0%nat in
          x0))%R)
    end) H2
   (fun i x y : nat =>
    (((let (x0, _) := Ha in x0) * (let (x0, _) := f i x y in x0) +
      - ((let (_, y0) := Ha in y0) * (let (_, y0) := f i x y in y0)))%R,
    ((let (x0, _) := Ha in x0) * (let (_, y0) := f i x y in y0) +
     (let (_, y0) := Ha in y0) * (let (x0, _) := f i x y in x0))%R)) =
 (fun x y : nat =>
  (((let (x0, _) :=
       (fix Cpow (c : R * R) (n : nat) {struct n} : R * R :=
          match n with
          | 0%nat => (R1, R0)
          | S n' =>
              ((let (x0, _) := c in x0) * (let (x0, _) := Cpow c n' in x0) +
               -
               ((let (_, y0) := c in y0) * (let (_, y0) := Cpow c n' in y0)),
              (let (x0, _) := c in x0) * (let (_, y0) := Cpow c n' in y0) +
              (let (_, y0) := c in y0) * (let (x0, _) := Cpow c n' in x0))
          end) Ha H2 in
     x0) *
    (let (x0, _) :=
       (fix vkron (n : nat) (f0 : nat -> nat -> nat -> R * R) {struct n} :
            nat -> nat -> R * R :=
          match n with
          | 0%nat =>
              fun x0 y0 : nat =>
              if
               if
                (fix eqb (n0 m : nat) {struct n0} : bool :=
                   match n0 with
                   | 0%nat => match m with
                              | 0%nat => true
                              | S _ => false
                              end
                   | S n' =>
                       match m with
                       | 0%nat => false
                       | S m' => eqb n' m'
                       end
                   end) x0 y0
               then
                (fix leb (n0 m : nat) {struct n0} : bool :=
                   match n0 with
                   | 0%nat => true
                   | S n' =>
                       match m with
                       | 0%nat => false
                       | S m' => leb n' m'
                       end
                   end) x0 0%nat
               else false
              then (R1, R0)
              else (R0, R0)
          | S n' =>
              fun x0 y0 : nat =>
              ((let (x1, _) :=
                  vkron n' f0
                    (let (x1, _) :=
                       (fix divmod (x1 y1 q u : nat) {struct x1} :
                            nat * nat :=
                          match x1 with
                          | 0%nat => (q, u)
                          | S x' =>
                              match u with
                              | 0%nat => divmod x' y1 (S q) y1
                              | S u' => divmod x' y1 q u'
                              end
                          end) x0 1%nat 0%nat 1%nat in
                     x1)
                    (let (x1, _) :=
                       (fix divmod (x1 y1 q u : nat) {struct x1} :
                            nat * nat :=
                          match x1 with
                          | 0%nat => (q, u)
                          | S x' =>
                              match u with
                              | 0%nat => divmod x' y1 (S q) y1
                              | S u' => divmod x' y1 q u'
                              end
                          end) y0 0%nat 0%nat 0%nat in
                     x1) in
                x1) *
               (let (x1, _) :=
                  f0 n'
                    match
                      (let (_, y1) :=
                         (fix divmod (x1 y1 q u : nat) {struct x1} :
                              nat * nat :=
                            match x1 with
                            | 0%nat => (q, u)
                            | S x' =>
                                match u with
                                | 0%nat => divmod x' y1 (S q) y1
                                | S u' => divmod x' y1 q u'
                                end
                            end) x0 1%nat 0%nat 1%nat in
                       y1)
                    with
                    | 0%nat => 1%nat
                    | S _ => 0%nat
                    end 0%nat in
                x1) +
               -
               ((let (_, y1) :=
                   vkron n' f0
                     (let (x1, _) :=
                        (fix divmod (x1 y1 q u : nat) {struct x1} :
                             nat * nat :=
                           match x1 with
                           | 0%nat => (q, u)
                           | S x' =>
                               match u with
                               | 0%nat => divmod x' y1 (S q) y1
                               | S u' => divmod x' y1 q u'
                               end
                           end) x0 1%nat 0%nat 1%nat in
                      x1)
                     (let (x1, _) :=
                        (fix divmod (x1 y1 q u : nat) {struct x1} :
                             nat * nat :=
                           match x1 with
                           | 0%nat => (q, u)
                           | S x' =>
                               match u with
                               | 0%nat => divmod x' y1 (S q) y1
                               | S u' => divmod x' y1 q u'
                               end
                           end) y0 0%nat 0%nat 0%nat in
                      x1) in
                 y1) *
                (let (_, y1) :=
                   f0 n'
                     match
                       (let (_, y1) :=
                          (fix divmod (x1 y1 q u : nat) {struct x1} :
                               nat * nat :=
                             match x1 with
                             | 0%nat => (q, u)
                             | S x' =>
                                 match u with
                                 | 0%nat => divmod x' y1 (S q) y1
                                 | S u' => divmod x' y1 q u'
                                 end
                             end) x0 1%nat 0%nat 1%nat in
                        y1)
                     with
                     | 0%nat => 1%nat
                     | S _ => 0%nat
                     end 0%nat in
                 y1)),
              (let (x1, _) :=
                 vkron n' f0
                   (let (x1, _) :=
                      (fix divmod (x1 y1 q u : nat) {struct x1} :
                           nat * nat :=
                         match x1 with
                         | 0%nat => (q, u)
                         | S x' =>
                             match u with
                             | 0%nat => divmod x' y1 (S q) y1
                             | S u' => divmod x' y1 q u'
                             end
                         end) x0 1%nat 0%nat 1%nat in
                    x1)
                   (let (x1, _) :=
                      (fix divmod (x1 y1 q u : nat) {struct x1} :
                           nat * nat :=
                         match x1 with
                         | 0%nat => (q, u)
                         | S x' =>
                             match u with
                             | 0%nat => divmod x' y1 (S q) y1
                             | S u' => divmod x' y1 q u'
                             end
                         end) y0 0%nat 0%nat 0%nat in
                    x1) in
               x1) *
              (let (_, y1) :=
                 f0 n'
                   match
                     (let (_, y1) :=
                        (fix divmod (x1 y1 q u : nat) {struct x1} :
                             nat * nat :=
                           match x1 with
                           | 0%nat => (q, u)
                           | S x' =>
                               match u with
                               | 0%nat => divmod x' y1 (S q) y1
                               | S u' => divmod x' y1 q u'
                               end
                           end) x0 1%nat 0%nat 1%nat in
                      y1)
                   with
                   | 0%nat => 1%nat
                   | S _ => 0%nat
                   end 0%nat in
               y1) +
              (let (_, y1) :=
                 vkron n' f0
                   (let (x1, _) :=
                      (fix divmod (x1 y1 q u : nat) {struct x1} :
                           nat * nat :=
                         match x1 with
                         | 0%nat => (q, u)
                         | S x' =>
                             match u with
                             | 0%nat => divmod x' y1 (S q) y1
                             | S u' => divmod x' y1 q u'
                             end
                         end) x0 1%nat 0%nat 1%nat in
                    x1)
                   (let (x1, _) :=
                      (fix divmod (x1 y1 q u : nat) {struct x1} :
                           nat * nat :=
                         match x1 with
                         | 0%nat => (q, u)
                         | S x' =>
                             match u with
                             | 0%nat => divmod x' y1 (S q) y1
                             | S u' => divmod x' y1 q u'
                             end
                         end) y0 0%nat 0%nat 0%nat in
                    x1) in
               y1) *
              (let (x1, _) :=
                 f0 n'
                   match
                     (let (_, y1) :=
                        (fix divmod (x1 y1 q u : nat) {struct x1} :
                             nat * nat :=
                           match x1 with
                           | 0%nat => (q, u)
                           | S x' =>
                               match u with
                               | 0%nat => divmod x' y1 (S q) y1
                               | S u' => divmod x' y1 q u'
                               end
                           end) x0 1%nat 0%nat 1%nat in
                      y1)
                   with
                   | 0%nat => 1%nat
                   | S _ => 0%nat
                   end 0%nat in
               x1))
          end) H2 f x y in
     x0) +
    -
    ((let (_, y0) :=
        (fix Cpow (c : R * R) (n : nat) {struct n} : R * R :=
           match n with
           | 0%nat => (R1, R0)
           | S n' =>
               ((let (x0, _) := c in x0) * (let (x0, _) := Cpow c n' in x0) +
                -
                ((let (_, y0) := c in y0) * (let (_, y0) := Cpow c n' in y0)),
               (let (x0, _) := c in x0) * (let (_, y0) := Cpow c n' in y0) +
               (let (_, y0) := c in y0) * (let (x0, _) := Cpow c n' in x0))
           end) Ha H2 in
      y0) *
     (let (_, y0) :=
        (fix vkron (n : nat) (f0 : nat -> nat -> nat -> R * R) {struct n} :
             nat -> nat -> R * R :=
           match n with
           | 0%nat =>
               fun x0 y0 : nat =>
               if
                if
                 (fix eqb (n0 m : nat) {struct n0} : bool :=
                    match n0 with
                    | 0%nat =>
                        match m with
                        | 0%nat => true
                        | S _ => false
                        end
                    | S n' =>
                        match m with
                        | 0%nat => false
                        | S m' => eqb n' m'
                        end
                    end) x0 y0
                then
                 (fix leb (n0 m : nat) {struct n0} : bool :=
                    match n0 with
                    | 0%nat => true
                    | S n' =>
                        match m with
                        | 0%nat => false
                        | S m' => leb n' m'
                        end
                    end) x0 0%nat
                else false
               then (R1, R0)
               else (R0, R0)
           | S n' =>
               fun x0 y0 : nat =>
               ((let (x1, _) :=
                   vkron n' f0
                     (let (x1, _) :=
                        (fix divmod (x1 y1 q u : nat) {struct x1} :
                             nat * nat :=
                           match x1 with
                           | 0%nat => (q, u)
                           | S x' =>
                               match u with
                               | 0%nat => divmod x' y1 (S q) y1
                               | S u' => divmod x' y1 q u'
                               end
                           end) x0 1%nat 0%nat 1%nat in
                      x1)
                     (let (x1, _) :=
                        (fix divmod (x1 y1 q u : nat) {struct x1} :
                             nat * nat :=
                           match x1 with
                           | 0%nat => (q, u)
                           | S x' =>
                               match u with
                               | 0%nat => divmod x' y1 (S q) y1
                               | S u' => divmod x' y1 q u'
                               end
                           end) y0 0%nat 0%nat 0%nat in
                      x1) in
                 x1) *
                (let (x1, _) :=
                   f0 n'
                     match
                       (let (_, y1) :=
                          (fix divmod (x1 y1 q u : nat) {struct x1} :
                               nat * nat :=
                             match x1 with
                             | 0%nat => (q, u)
                             | S x' =>
                                 match u with
                                 | 0%nat => divmod x' y1 (S q) y1
                                 | S u' => divmod x' y1 q u'
                                 end
                             end) x0 1%nat 0%nat 1%nat in
                        y1)
                     with
                     | 0%nat => 1%nat
                     | S _ => 0%nat
                     end 0%nat in
                 x1) +
                -
                ((let (_, y1) :=
                    vkron n' f0
                      (let (x1, _) :=
                         (fix divmod (x1 y1 q u : nat) {struct x1} :
                              nat * nat :=
                            match x1 with
                            | 0%nat => (q, u)
                            | S x' =>
                                match u with
                                | 0%nat => divmod x' y1 (S q) y1
                                | S u' => divmod x' y1 q u'
                                end
                            end) x0 1%nat 0%nat 1%nat in
                       x1)
                      (let (x1, _) :=
                         (fix divmod (x1 y1 q u : nat) {struct x1} :
                              nat * nat :=
                            match x1 with
                            | 0%nat => (q, u)
                            | S x' =>
                                match u with
                                | 0%nat => divmod x' y1 (S q) y1
                                | S u' => divmod x' y1 q u'
                                end
                            end) y0 0%nat 0%nat 0%nat in
                       x1) in
                  y1) *
                 (let (_, y1) :=
                    f0 n'
                      match
                        (let (_, y1) :=
                           (fix divmod (x1 y1 q u : nat) {struct x1} :
                                nat * nat :=
                              match x1 with
                              | 0%nat => (q, u)
                              | S x' =>
                                  match u with
                                  | 0%nat => divmod x' y1 (S q) y1
                                  | S u' => divmod x' y1 q u'
                                  end
                              end) x0 1%nat 0%nat 1%nat in
                         y1)
                      with
                      | 0%nat => 1%nat
                      | S _ => 0%nat
                      end 0%nat in
                  y1)),
               (let (x1, _) :=
                  vkron n' f0
                    (let (x1, _) :=
                       (fix divmod (x1 y1 q u : nat) {struct x1} :
                            nat * nat :=
                          match x1 with
                          | 0%nat => (q, u)
                          | S x' =>
                              match u with
                              | 0%nat => divmod x' y1 (S q) y1
                              | S u' => divmod x' y1 q u'
                              end
                          end) x0 1%nat 0%nat 1%nat in
                     x1)
                    (let (x1, _) :=
                       (fix divmod (x1 y1 q u : nat) {struct x1} :
                            nat * nat :=
                          match x1 with
                          | 0%nat => (q, u)
                          | S x' =>
                              match u with
                              | 0%nat => divmod x' y1 (S q) y1
                              | S u' => divmod x' y1 q u'
                              end
                          end) y0 0%nat 0%nat 0%nat in
                     x1) in
                x1) *
               (let (_, y1) :=
                  f0 n'
                    match
                      (let (_, y1) :=
                         (fix divmod (x1 y1 q u : nat) {struct x1} :
                              nat * nat :=
                            match x1 with
                            | 0%nat => (q, u)
                            | S x' =>
                                match u with
                                | 0%nat => divmod x' y1 (S q) y1
                                | S u' => divmod x' y1 q u'
                                end
                            end) x0 1%nat 0%nat 1%nat in
                       y1)
                    with
                    | 0%nat => 1%nat
                    | S _ => 0%nat
                    end 0%nat in
                y1) +
               (let (_, y1) :=
                  vkron n' f0
                    (let (x1, _) :=
                       (fix divmod (x1 y1 q u : nat) {struct x1} :
                            nat * nat :=
                          match x1 with
                          | 0%nat => (q, u)
                          | S x' =>
                              match u with
                              | 0%nat => divmod x' y1 (S q) y1
                              | S u' => divmod x' y1 q u'
                              end
                          end) x0 1%nat 0%nat 1%nat in
                     x1)
                    (let (x1, _) :=
                       (fix divmod (x1 y1 q u : nat) {struct x1} :
                            nat * nat :=
                          match x1 with
                          | 0%nat => (q, u)
                          | S x' =>
                              match u with
                              | 0%nat => divmod x' y1 (S q) y1
                              | S u' => divmod x' y1 q u'
                              end
                          end) y0 0%nat 0%nat 0%nat in
                     x1) in
                y1) *
               (let (x1, _) :=
                  f0 n'
                    match
                      (let (_, y1) :=
                         (fix divmod (x1 y1 q u : nat) {struct x1} :
                              nat * nat :=
                            match x1 with
                            | 0%nat => (q, u)
                            | S x' =>
                                match u with
                                | 0%nat => divmod x' y1 (S q) y1
                                | S u' => divmod x' y1 q u'
                                end
                            end) x0 1%nat 0%nat 1%nat in
                       y1)
                    with
                    | 0%nat => 1%nat
                    | S _ => 0%nat
                    end 0%nat in
                x1))
           end) H2 f x y in
      y0)))%R,
  ((let (x0, _) :=
      (fix Cpow (c : R * R) (n : nat) {struct n} : R * R :=
         match n with
         | 0%nat => (R1, R0)
         | S n' =>
             ((let (x0, _) := c in x0) * (let (x0, _) := Cpow c n' in x0) +
              - ((let (_, y0) := c in y0) * (let (_, y0) := Cpow c n' in y0)),
             (let (x0, _) := c in x0) * (let (_, y0) := Cpow c n' in y0) +
             (let (_, y0) := c in y0) * (let (x0, _) := Cpow c n' in x0))
         end) Ha H2 in
    x0) *
   (let (_, y0) :=
      (fix vkron (n : nat) (f0 : nat -> nat -> nat -> R * R) {struct n} :
           nat -> nat -> R * R :=
         match n with
         | 0%nat =>
             fun x0 y0 : nat =>
             if
              if
               (fix eqb (n0 m : nat) {struct n0} : bool :=
                  match n0 with
                  | 0%nat => match m with
                             | 0%nat => true
                             | S _ => false
                             end
                  | S n' =>
                      match m with
                      | 0%nat => false
                      | S m' => eqb n' m'
                      end
                  end) x0 y0
              then
               (fix leb (n0 m : nat) {struct n0} : bool :=
                  match n0 with
                  | 0%nat => true
                  | S n' =>
                      match m with
                      | 0%nat => false
                      | S m' => leb n' m'
                      end
                  end) x0 0%nat
              else false
             then (R1, R0)
             else (R0, R0)
         | S n' =>
             fun x0 y0 : nat =>
             ((let (x1, _) :=
                 vkron n' f0
                   (let (x1, _) :=
                      (fix divmod (x1 y1 q u : nat) {struct x1} :
                           nat * nat :=
                         match x1 with
                         | 0%nat => (q, u)
                         | S x' =>
                             match u with
                             | 0%nat => divmod x' y1 (S q) y1
                             | S u' => divmod x' y1 q u'
                             end
                         end) x0 1%nat 0%nat 1%nat in
                    x1)
                   (let (x1, _) :=
                      (fix divmod (x1 y1 q u : nat) {struct x1} :
                           nat * nat :=
                         match x1 with
                         | 0%nat => (q, u)
                         | S x' =>
                             match u with
                             | 0%nat => divmod x' y1 (S q) y1
                             | S u' => divmod x' y1 q u'
                             end
                         end) y0 0%nat 0%nat 0%nat in
                    x1) in
               x1) *
              (let (x1, _) :=
                 f0 n'
                   match
                     (let (_, y1) :=
                        (fix divmod (x1 y1 q u : nat) {struct x1} :
                             nat * nat :=
                           match x1 with
                           | 0%nat => (q, u)
                           | S x' =>
                               match u with
                               | 0%nat => divmod x' y1 (S q) y1
                               | S u' => divmod x' y1 q u'
                               end
                           end) x0 1%nat 0%nat 1%nat in
                      y1)
                   with
                   | 0%nat => 1%nat
                   | S _ => 0%nat
                   end 0%nat in
               x1) +
              -
              ((let (_, y1) :=
                  vkron n' f0
                    (let (x1, _) :=
                       (fix divmod (x1 y1 q u : nat) {struct x1} :
                            nat * nat :=
                          match x1 with
                          | 0%nat => (q, u)
                          | S x' =>
                              match u with
                              | 0%nat => divmod x' y1 (S q) y1
                              | S u' => divmod x' y1 q u'
                              end
                          end) x0 1%nat 0%nat 1%nat in
                     x1)
                    (let (x1, _) :=
                       (fix divmod (x1 y1 q u : nat) {struct x1} :
                            nat * nat :=
                          match x1 with
                          | 0%nat => (q, u)
                          | S x' =>
                              match u with
                              | 0%nat => divmod x' y1 (S q) y1
                              | S u' => divmod x' y1 q u'
                              end
                          end) y0 0%nat 0%nat 0%nat in
                     x1) in
                y1) *
               (let (_, y1) :=
                  f0 n'
                    match
                      (let (_, y1) :=
                         (fix divmod (x1 y1 q u : nat) {struct x1} :
                              nat * nat :=
                            match x1 with
                            | 0%nat => (q, u)
                            | S x' =>
                                match u with
                                | 0%nat => divmod x' y1 (S q) y1
                                | S u' => divmod x' y1 q u'
                                end
                            end) x0 1%nat 0%nat 1%nat in
                       y1)
                    with
                    | 0%nat => 1%nat
                    | S _ => 0%nat
                    end 0%nat in
                y1)),
             (let (x1, _) :=
                vkron n' f0
                  (let (x1, _) :=
                     (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                        match x1 with
                        | 0%nat => (q, u)
                        | S x' =>
                            match u with
                            | 0%nat => divmod x' y1 (S q) y1
                            | S u' => divmod x' y1 q u'
                            end
                        end) x0 1%nat 0%nat 1%nat in
                   x1)
                  (let (x1, _) :=
                     (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                        match x1 with
                        | 0%nat => (q, u)
                        | S x' =>
                            match u with
                            | 0%nat => divmod x' y1 (S q) y1
                            | S u' => divmod x' y1 q u'
                            end
                        end) y0 0%nat 0%nat 0%nat in
                   x1) in
              x1) *
             (let (_, y1) :=
                f0 n'
                  match
                    (let (_, y1) :=
                       (fix divmod (x1 y1 q u : nat) {struct x1} :
                            nat * nat :=
                          match x1 with
                          | 0%nat => (q, u)
                          | S x' =>
                              match u with
                              | 0%nat => divmod x' y1 (S q) y1
                              | S u' => divmod x' y1 q u'
                              end
                          end) x0 1%nat 0%nat 1%nat in
                     y1)
                  with
                  | 0%nat => 1%nat
                  | S _ => 0%nat
                  end 0%nat in
              y1) +
             (let (_, y1) :=
                vkron n' f0
                  (let (x1, _) :=
                     (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                        match x1 with
                        | 0%nat => (q, u)
                        | S x' =>
                            match u with
                            | 0%nat => divmod x' y1 (S q) y1
                            | S u' => divmod x' y1 q u'
                            end
                        end) x0 1%nat 0%nat 1%nat in
                   x1)
                  (let (x1, _) :=
                     (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                        match x1 with
                        | 0%nat => (q, u)
                        | S x' =>
                            match u with
                            | 0%nat => divmod x' y1 (S q) y1
                            | S u' => divmod x' y1 q u'
                            end
                        end) y0 0%nat 0%nat 0%nat in
                   x1) in
              y1) *
             (let (x1, _) :=
                f0 n'
                  match
                    (let (_, y1) :=
                       (fix divmod (x1 y1 q u : nat) {struct x1} :
                            nat * nat :=
                          match x1 with
                          | 0%nat => (q, u)
                          | S x' =>
                              match u with
                              | 0%nat => divmod x' y1 (S q) y1
                              | S u' => divmod x' y1 q u'
                              end
                          end) x0 1%nat 0%nat 1%nat in
                     y1)
                  with
                  | 0%nat => 1%nat
                  | S _ => 0%nat
                  end 0%nat in
              x1))
         end) H2 f x y in
    y0) +
   (let (_, y0) :=
      (fix Cpow (c : R * R) (n : nat) {struct n} : R * R :=
         match n with
         | 0%nat => (R1, R0)
         | S n' =>
             ((let (x0, _) := c in x0) * (let (x0, _) := Cpow c n' in x0) +
              - ((let (_, y0) := c in y0) * (let (_, y0) := Cpow c n' in y0)),
             (let (x0, _) := c in x0) * (let (_, y0) := Cpow c n' in y0) +
             (let (_, y0) := c in y0) * (let (x0, _) := Cpow c n' in x0))
         end) Ha H2 in
    y0) *
   (let (x0, _) :=
      (fix vkron (n : nat) (f0 : nat -> nat -> nat -> R * R) {struct n} :
           nat -> nat -> R * R :=
         match n with
         | 0%nat =>
             fun x0 y0 : nat =>
             if
              if
               (fix eqb (n0 m : nat) {struct n0} : bool :=
                  match n0 with
                  | 0%nat => match m with
                             | 0%nat => true
                             | S _ => false
                             end
                  | S n' =>
                      match m with
                      | 0%nat => false
                      | S m' => eqb n' m'
                      end
                  end) x0 y0
              then
               (fix leb (n0 m : nat) {struct n0} : bool :=
                  match n0 with
                  | 0%nat => true
                  | S n' =>
                      match m with
                      | 0%nat => false
                      | S m' => leb n' m'
                      end
                  end) x0 0%nat
              else false
             then (R1, R0)
             else (R0, R0)
         | S n' =>
             fun x0 y0 : nat =>
             ((let (x1, _) :=
                 vkron n' f0
                   (let (x1, _) :=
                      (fix divmod (x1 y1 q u : nat) {struct x1} :
                           nat * nat :=
                         match x1 with
                         | 0%nat => (q, u)
                         | S x' =>
                             match u with
                             | 0%nat => divmod x' y1 (S q) y1
                             | S u' => divmod x' y1 q u'
                             end
                         end) x0 1%nat 0%nat 1%nat in
                    x1)
                   (let (x1, _) :=
                      (fix divmod (x1 y1 q u : nat) {struct x1} :
                           nat * nat :=
                         match x1 with
                         | 0%nat => (q, u)
                         | S x' =>
                             match u with
                             | 0%nat => divmod x' y1 (S q) y1
                             | S u' => divmod x' y1 q u'
                             end
                         end) y0 0%nat 0%nat 0%nat in
                    x1) in
               x1) *
              (let (x1, _) :=
                 f0 n'
                   match
                     (let (_, y1) :=
                        (fix divmod (x1 y1 q u : nat) {struct x1} :
                             nat * nat :=
                           match x1 with
                           | 0%nat => (q, u)
                           | S x' =>
                               match u with
                               | 0%nat => divmod x' y1 (S q) y1
                               | S u' => divmod x' y1 q u'
                               end
                           end) x0 1%nat 0%nat 1%nat in
                      y1)
                   with
                   | 0%nat => 1%nat
                   | S _ => 0%nat
                   end 0%nat in
               x1) +
              -
              ((let (_, y1) :=
                  vkron n' f0
                    (let (x1, _) :=
                       (fix divmod (x1 y1 q u : nat) {struct x1} :
                            nat * nat :=
                          match x1 with
                          | 0%nat => (q, u)
                          | S x' =>
                              match u with
                              | 0%nat => divmod x' y1 (S q) y1
                              | S u' => divmod x' y1 q u'
                              end
                          end) x0 1%nat 0%nat 1%nat in
                     x1)
                    (let (x1, _) :=
                       (fix divmod (x1 y1 q u : nat) {struct x1} :
                            nat * nat :=
                          match x1 with
                          | 0%nat => (q, u)
                          | S x' =>
                              match u with
                              | 0%nat => divmod x' y1 (S q) y1
                              | S u' => divmod x' y1 q u'
                              end
                          end) y0 0%nat 0%nat 0%nat in
                     x1) in
                y1) *
               (let (_, y1) :=
                  f0 n'
                    match
                      (let (_, y1) :=
                         (fix divmod (x1 y1 q u : nat) {struct x1} :
                              nat * nat :=
                            match x1 with
                            | 0%nat => (q, u)
                            | S x' =>
                                match u with
                                | 0%nat => divmod x' y1 (S q) y1
                                | S u' => divmod x' y1 q u'
                                end
                            end) x0 1%nat 0%nat 1%nat in
                       y1)
                    with
                    | 0%nat => 1%nat
                    | S _ => 0%nat
                    end 0%nat in
                y1)),
             (let (x1, _) :=
                vkron n' f0
                  (let (x1, _) :=
                     (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                        match x1 with
                        | 0%nat => (q, u)
                        | S x' =>
                            match u with
                            | 0%nat => divmod x' y1 (S q) y1
                            | S u' => divmod x' y1 q u'
                            end
                        end) x0 1%nat 0%nat 1%nat in
                   x1)
                  (let (x1, _) :=
                     (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                        match x1 with
                        | 0%nat => (q, u)
                        | S x' =>
                            match u with
                            | 0%nat => divmod x' y1 (S q) y1
                            | S u' => divmod x' y1 q u'
                            end
                        end) y0 0%nat 0%nat 0%nat in
                   x1) in
              x1) *
             (let (_, y1) :=
                f0 n'
                  match
                    (let (_, y1) :=
                       (fix divmod (x1 y1 q u : nat) {struct x1} :
                            nat * nat :=
                          match x1 with
                          | 0%nat => (q, u)
                          | S x' =>
                              match u with
                              | 0%nat => divmod x' y1 (S q) y1
                              | S u' => divmod x' y1 q u'
                              end
                          end) x0 1%nat 0%nat 1%nat in
                     y1)
                  with
                  | 0%nat => 1%nat
                  | S _ => 0%nat
                  end 0%nat in
              y1) +
             (let (_, y1) :=
                vkron n' f0
                  (let (x1, _) :=
                     (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                        match x1 with
                        | 0%nat => (q, u)
                        | S x' =>
                            match u with
                            | 0%nat => divmod x' y1 (S q) y1
                            | S u' => divmod x' y1 q u'
                            end
                        end) x0 1%nat 0%nat 1%nat in
                   x1)
                  (let (x1, _) :=
                     (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                        match x1 with
                        | 0%nat => (q, u)
                        | S x' =>
                            match u with
                            | 0%nat => divmod x' y1 (S q) y1
                            | S u' => divmod x' y1 q u'
                            end
                        end) y0 0%nat 0%nat 0%nat in
                   x1) in
              y1) *
             (let (x1, _) :=
                f0 n'
                  match
                    (let (_, y1) :=
                       (fix divmod (x1 y1 q u : nat) {struct x1} :
                            nat * nat :=
                          match x1 with
                          | 0%nat => (q, u)
                          | S x' =>
                              match u with
                              | 0%nat => divmod x' y1 (S q) y1
                              | S u' => divmod x' y1 q u'
                              end
                          end) x0 1%nat 0%nat 1%nat in
                     y1)
                  with
                  | 0%nat => 1%nat
                  | S _ => 0%nat
                  end 0%nat in
              x1))
         end) H2 f x y in
    x0))%R)))
Debug:
In environment
x : rat
le0i : 0 <= x
rhs := delta (x + 1) - delta x : rat_numDomainType
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: delta (x + 1); delta x; x]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             (add
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 2)) zero))
       (negb_
          (Feqb
             (add
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 3)) zero)))" (cannot unify 
"false" and "true").
Finished transaction in 5.304 secs (5.221u,0.077s) (successful)
Debug:
In environment
x : rat
n : 0 <= x
rhs := delta (x + 1) - delta x : rat_numDomainType
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: delta (x + 1); delta x; x]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             (add
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 2)) zero))
       (negb_
          (Feqb
             (add
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 3)) zero)))" (cannot unify 
"false" and "true").
Crunching: (P1 [])
Crunching: (P1 [])
Crunching: (P1 [])
Debug:
In environment
x : rat
n : 0 <= x
rhs := delta (x + 1) - delta x : rat_numDomainType
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: delta (x + 1); delta x; x]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             (add
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 2)) zero))
       (negb_
          (Feqb
             (add
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 3)) zero)))" (cannot unify 
"false" and "true").
Debug:
In environment
x : rat
le0i : 0 <= x
rhs := delta (x + 1) - delta x : rat_numDomainType
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: delta (x + 1); delta x; x]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             (add
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 2)) zero))
       (negb_
          (Feqb
             (add
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 3)) zero)))" (cannot unify 
"false" and "true").
Debug:
In environment
x : rat
le0i : 0 <= x
rhs := delta (x + 1) - delta x : rat_numDomainType
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: rhs; x]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             (add
                match match l with
                      | [::] => [::]
                      | _ :: x0 => x0
                      end with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 2)) zero))
       (negb_
          (Feqb
             (add
                match match l with
                      | [::] => [::]
                      | _ :: x0 => x0
                      end with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 3)) zero)))" (cannot unify 
"false" and "true").
Finished transaction in 3.128 secs (3.073u,0.051s) (successful)
Debug:
In environment
x : rat
le0i : 0 <= x
rhs := delta (x + 1) - delta x : rat_numDomainType
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: delta (x + 1); delta x; x]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             (add
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 2)) zero))
       (negb_
          (Feqb
             (add
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 3)) zero)))" (cannot unify 
"false" and "true").
Crunching:
(forall f : nat -> nat -> nat -> R * R,
 (fix vkron (n : nat) (f0 : nat -> nat -> nat -> R * R) {struct n} :
      nat -> nat -> R * R :=
    match n with
    | 0 =>
        fun x y : nat =>
        if
         if
          (fix eqb (n0 m : nat) {struct n0} : bool :=
             match n0 with
             | 0 => match m with
                    | 0 => true
                    | S _ => false
                    end
             | S n' => match m with
                       | 0 => false
                       | S m' => eqb n' m'
                       end
             end) x y
         then
          (fix leb (n0 m : nat) {struct n0} : bool :=
             match n0 with
             | 0 => true
             | S n' => match m with
                       | 0 => false
                       | S m' => leb n' m'
                       end
             end) x 0
         else false
        then (R1, R0)
        else (R0, R0)
    | S n' =>
        fun x y : nat =>
        (((let (x0, _) :=
             vkron n' f0
               (let (x0, _) :=
                  (fix divmod (x0 y0 q u : nat) {struct x0} : nat * nat :=
                     match x0 with
                     | 0%nat => (q, u)
                     | S x' =>
                         match u with
                         | 0%nat => divmod x' y0 (S q) y0
                         | S u' => divmod x' y0 q u'
                         end
                     end) x 1%nat 0%nat 1%nat in
                x0)
               (let (x0, _) :=
                  (fix divmod (x0 y0 q u : nat) {struct x0} : nat * nat :=
                     match x0 with
                     | 0%nat => (q, u)
                     | S x' =>
                         match u with
                         | 0%nat => divmod x' y0 (S q) y0
                         | S u' => divmod x' y0 q u'
                         end
                     end) y 0%nat 0%nat 0%nat in
                x0) in
           x0) *
          (let (x0, _) :=
             f0 n'
               match
                 (let (_, y0) :=
                    (fix divmod (x0 y0 q u : nat) {struct x0} : nat * nat :=
                       match x0 with
                       | 0%nat => (q, u)
                       | S x' =>
                           match u with
                           | 0%nat => divmod x' y0 (S q) y0
                           | S u' => divmod x' y0 q u'
                           end
                       end) x 1%nat 0%nat 1%nat in
                  y0)
               with
               | 0%nat => 1%nat
               | S _ => 0%nat
               end 0%nat in
           x0) +
          -
          ((let (_, y0) :=
              vkron n' f0
                (let (x0, _) :=
                   (fix divmod (x0 y0 q u : nat) {struct x0} : nat * nat :=
                      match x0 with
                      | 0%nat => (q, u)
                      | S x' =>
                          match u with
                          | 0%nat => divmod x' y0 (S q) y0
                          | S u' => divmod x' y0 q u'
                          end
                      end) x 1%nat 0%nat 1%nat in
                 x0)
                (let (x0, _) :=
                   (fix divmod (x0 y0 q u : nat) {struct x0} : nat * nat :=
                      match x0 with
                      | 0%nat => (q, u)
                      | S x' =>
                          match u with
                          | 0%nat => divmod x' y0 (S q) y0
                          | S u' => divmod x' y0 q u'
                          end
                      end) y 0%nat 0%nat 0%nat in
                 x0) in
            y0) *
           (let (_, y0) :=
              f0 n'
                match
                  (let (_, y0) :=
                     (fix divmod (x0 y0 q u : nat) {struct x0} : nat * nat :=
                        match x0 with
                        | 0%nat => (q, u)
                        | S x' =>
                            match u with
                            | 0%nat => divmod x' y0 (S q) y0
                            | S u' => divmod x' y0 q u'
                            end
                        end) x 1%nat 0%nat 1%nat in
                   y0)
                with
                | 0%nat => 1%nat
                | S _ => 0%nat
                end 0%nat in
            y0)))%R,
        ((let (x0, _) :=
            vkron n' f0
              (let (x0, _) :=
                 (fix divmod (x0 y0 q u : nat) {struct x0} : nat * nat :=
                    match x0 with
                    | 0%nat => (q, u)
                    | S x' =>
                        match u with
                        | 0%nat => divmod x' y0 (S q) y0
                        | S u' => divmod x' y0 q u'
                        end
                    end) x 1%nat 0%nat 1%nat in
               x0)
              (let (x0, _) :=
                 (fix divmod (x0 y0 q u : nat) {struct x0} : nat * nat :=
                    match x0 with
                    | 0%nat => (q, u)
                    | S x' =>
                        match u with
                        | 0%nat => divmod x' y0 (S q) y0
                        | S u' => divmod x' y0 q u'
                        end
                    end) y 0%nat 0%nat 0%nat in
               x0) in
          x0) *
         (let (_, y0) :=
            f0 n'
              match
                (let (_, y0) :=
                   (fix divmod (x0 y0 q u : nat) {struct x0} : nat * nat :=
                      match x0 with
                      | 0%nat => (q, u)
                      | S x' =>
                          match u with
                          | 0%nat => divmod x' y0 (S q) y0
                          | S u' => divmod x' y0 q u'
                          end
                      end) x 1%nat 0%nat 1%nat in
                 y0)
              with
              | 0%nat => 1%nat
              | S _ => 0%nat
              end 0%nat in
          y0) +
         (let (_, y0) :=
            vkron n' f0
              (let (x0, _) :=
                 (fix divmod (x0 y0 q u : nat) {struct x0} : nat * nat :=
                    match x0 with
                    | 0%nat => (q, u)
                    | S x' =>
                        match u with
                        | 0%nat => divmod x' y0 (S q) y0
                        | S u' => divmod x' y0 q u'
                        end
                    end) x 1%nat 0%nat 1%nat in
               x0)
              (let (x0, _) :=
                 (fix divmod (x0 y0 q u : nat) {struct x0} : nat * nat :=
                    match x0 with
                    | 0%nat => (q, u)
                    | S x' =>
                        match u with
                        | 0%nat => divmod x' y0 (S q) y0
                        | S u' => divmod x' y0 q u'
                        end
                    end) y 0%nat 0%nat 0%nat in
               x0) in
          y0) *
         (let (x0, _) :=
            f0 n'
              match
                (let (_, y0) :=
                   (fix divmod (x0 y0 q u : nat) {struct x0} : nat * nat :=
                      match x0 with
                      | 0%nat => (q, u)
                      | S x' =>
                          match u with
                          | 0%nat => divmod x' y0 (S q) y0
                          | S u' => divmod x' y0 q u'
                          end
                      end) x 1%nat 0%nat 1%nat in
                 y0)
              with
              | 0%nat => 1%nat
              | S _ => 0%nat
              end 0%nat in
          x0))%R)
    end) H2
   (fun i x y : nat =>
    (((let (x0, _) := l in x0) * (let (x0, _) := f i x y in x0) +
      - ((let (_, y0) := l in y0) * (let (_, y0) := f i x y in y0)))%R,
    ((let (x0, _) := l in x0) * (let (_, y0) := f i x y in y0) +
     (let (_, y0) := l in y0) * (let (x0, _) := f i x y in x0))%R)) =
 (fun x y : nat =>
  (((let (x0, _) :=
       (fix Cpow (c : R * R) (n : nat) {struct n} : R * R :=
          match n with
          | 0%nat => (R1, R0)
          | S n' =>
              ((let (x0, _) := c in x0) * (let (x0, _) := Cpow c n' in x0) +
               -
               ((let (_, y0) := c in y0) * (let (_, y0) := Cpow c n' in y0)),
              (let (x0, _) := c in x0) * (let (_, y0) := Cpow c n' in y0) +
              (let (_, y0) := c in y0) * (let (x0, _) := Cpow c n' in x0))
          end) l H2 in
     x0) *
    (let (x0, _) :=
       (fix vkron (n : nat) (f0 : nat -> nat -> nat -> R * R) {struct n} :
            nat -> nat -> R * R :=
          match n with
          | 0%nat =>
              fun x0 y0 : nat =>
              if
               if
                (fix eqb (n0 m : nat) {struct n0} : bool :=
                   match n0 with
                   | 0%nat => match m with
                              | 0%nat => true
                              | S _ => false
                              end
                   | S n' =>
                       match m with
                       | 0%nat => false
                       | S m' => eqb n' m'
                       end
                   end) x0 y0
               then
                (fix leb (n0 m : nat) {struct n0} : bool :=
                   match n0 with
                   | 0%nat => true
                   | S n' =>
                       match m with
                       | 0%nat => false
                       | S m' => leb n' m'
                       end
                   end) x0 0%nat
               else false
              then (R1, R0)
              else (R0, R0)
          | S n' =>
              fun x0 y0 : nat =>
              ((let (x1, _) :=
                  vkron n' f0
                    (let (x1, _) :=
                       (fix divmod (x1 y1 q u : nat) {struct x1} :
                            nat * nat :=
                          match x1 with
                          | 0%nat => (q, u)
                          | S x' =>
                              match u with
                              | 0%nat => divmod x' y1 (S q) y1
                              | S u' => divmod x' y1 q u'
                              end
                          end) x0 1%nat 0%nat 1%nat in
                     x1)
                    (let (x1, _) :=
                       (fix divmod (x1 y1 q u : nat) {struct x1} :
                            nat * nat :=
                          match x1 with
                          | 0%nat => (q, u)
                          | S x' =>
                              match u with
                              | 0%nat => divmod x' y1 (S q) y1
                              | S u' => divmod x' y1 q u'
                              end
                          end) y0 0%nat 0%nat 0%nat in
                     x1) in
                x1) *
               (let (x1, _) :=
                  f0 n'
                    match
                      (let (_, y1) :=
                         (fix divmod (x1 y1 q u : nat) {struct x1} :
                              nat * nat :=
                            match x1 with
                            | 0%nat => (q, u)
                            | S x' =>
                                match u with
                                | 0%nat => divmod x' y1 (S q) y1
                                | S u' => divmod x' y1 q u'
                                end
                            end) x0 1%nat 0%nat 1%nat in
                       y1)
                    with
                    | 0%nat => 1%nat
                    | S _ => 0%nat
                    end 0%nat in
                x1) +
               -
               ((let (_, y1) :=
                   vkron n' f0
                     (let (x1, _) :=
                        (fix divmod (x1 y1 q u : nat) {struct x1} :
                             nat * nat :=
                           match x1 with
                           | 0%nat => (q, u)
                           | S x' =>
                               match u with
                               | 0%nat => divmod x' y1 (S q) y1
                               | S u' => divmod x' y1 q u'
                               end
                           end) x0 1%nat 0%nat 1%nat in
                      x1)
                     (let (x1, _) :=
                        (fix divmod (x1 y1 q u : nat) {struct x1} :
                             nat * nat :=
                           match x1 with
                           | 0%nat => (q, u)
                           | S x' =>
                               match u with
                               | 0%nat => divmod x' y1 (S q) y1
                               | S u' => divmod x' y1 q u'
                               end
                           end) y0 0%nat 0%nat 0%nat in
                      x1) in
                 y1) *
                (let (_, y1) :=
                   f0 n'
                     match
                       (let (_, y1) :=
                          (fix divmod (x1 y1 q u : nat) {struct x1} :
                               nat * nat :=
                             match x1 with
                             | 0%nat => (q, u)
                             | S x' =>
                                 match u with
                                 | 0%nat => divmod x' y1 (S q) y1
                                 | S u' => divmod x' y1 q u'
                                 end
                             end) x0 1%nat 0%nat 1%nat in
                        y1)
                     with
                     | 0%nat => 1%nat
                     | S _ => 0%nat
                     end 0%nat in
                 y1)),
              (let (x1, _) :=
                 vkron n' f0
                   (let (x1, _) :=
                      (fix divmod (x1 y1 q u : nat) {struct x1} :
                           nat * nat :=
                         match x1 with
                         | 0%nat => (q, u)
                         | S x' =>
                             match u with
                             | 0%nat => divmod x' y1 (S q) y1
                             | S u' => divmod x' y1 q u'
                             end
                         end) x0 1%nat 0%nat 1%nat in
                    x1)
                   (let (x1, _) :=
                      (fix divmod (x1 y1 q u : nat) {struct x1} :
                           nat * nat :=
                         match x1 with
                         | 0%nat => (q, u)
                         | S x' =>
                             match u with
                             | 0%nat => divmod x' y1 (S q) y1
                             | S u' => divmod x' y1 q u'
                             end
                         end) y0 0%nat 0%nat 0%nat in
                    x1) in
               x1) *
              (let (_, y1) :=
                 f0 n'
                   match
                     (let (_, y1) :=
                        (fix divmod (x1 y1 q u : nat) {struct x1} :
                             nat * nat :=
                           match x1 with
                           | 0%nat => (q, u)
                           | S x' =>
                               match u with
                               | 0%nat => divmod x' y1 (S q) y1
                               | S u' => divmod x' y1 q u'
                               end
                           end) x0 1%nat 0%nat 1%nat in
                      y1)
                   with
                   | 0%nat => 1%nat
                   | S _ => 0%nat
                   end 0%nat in
               y1) +
              (let (_, y1) :=
                 vkron n' f0
                   (let (x1, _) :=
                      (fix divmod (x1 y1 q u : nat) {struct x1} :
                           nat * nat :=
                         match x1 with
                         | 0%nat => (q, u)
                         | S x' =>
                             match u with
                             | 0%nat => divmod x' y1 (S q) y1
                             | S u' => divmod x' y1 q u'
                             end
                         end) x0 1%nat 0%nat 1%nat in
                    x1)
                   (let (x1, _) :=
                      (fix divmod (x1 y1 q u : nat) {struct x1} :
                           nat * nat :=
                         match x1 with
                         | 0%nat => (q, u)
                         | S x' =>
                             match u with
                             | 0%nat => divmod x' y1 (S q) y1
                             | S u' => divmod x' y1 q u'
                             end
                         end) y0 0%nat 0%nat 0%nat in
                    x1) in
               y1) *
              (let (x1, _) :=
                 f0 n'
                   match
                     (let (_, y1) :=
                        (fix divmod (x1 y1 q u : nat) {struct x1} :
                             nat * nat :=
                           match x1 with
                           | 0%nat => (q, u)
                           | S x' =>
                               match u with
                               | 0%nat => divmod x' y1 (S q) y1
                               | S u' => divmod x' y1 q u'
                               end
                           end) x0 1%nat 0%nat 1%nat in
                      y1)
                   with
                   | 0%nat => 1%nat
                   | S _ => 0%nat
                   end 0%nat in
               x1))
          end) H2 f x y in
     x0) +
    -
    ((let (_, y0) :=
        (fix Cpow (c : R * R) (n : nat) {struct n} : R * R :=
           match n with
           | 0%nat => (R1, R0)
           | S n' =>
               ((let (x0, _) := c in x0) * (let (x0, _) := Cpow c n' in x0) +
                -
                ((let (_, y0) := c in y0) * (let (_, y0) := Cpow c n' in y0)),
               (let (x0, _) := c in x0) * (let (_, y0) := Cpow c n' in y0) +
               (let (_, y0) := c in y0) * (let (x0, _) := Cpow c n' in x0))
           end) l H2 in
      y0) *
     (let (_, y0) :=
        (fix vkron (n : nat) (f0 : nat -> nat -> nat -> R * R) {struct n} :
             nat -> nat -> R * R :=
           match n with
           | 0%nat =>
               fun x0 y0 : nat =>
               if
                if
                 (fix eqb (n0 m : nat) {struct n0} : bool :=
                    match n0 with
                    | 0%nat =>
                        match m with
                        | 0%nat => true
                        | S _ => false
                        end
                    | S n' =>
                        match m with
                        | 0%nat => false
                        | S m' => eqb n' m'
                        end
                    end) x0 y0
                then
                 (fix leb (n0 m : nat) {struct n0} : bool :=
                    match n0 with
                    | 0%nat => true
                    | S n' =>
                        match m with
                        | 0%nat => false
                        | S m' => leb n' m'
                        end
                    end) x0 0%nat
                else false
               then (R1, R0)
               else (R0, R0)
           | S n' =>
               fun x0 y0 : nat =>
               ((let (x1, _) :=
                   vkron n' f0
                     (let (x1, _) :=
                        (fix divmod (x1 y1 q u : nat) {struct x1} :
                             nat * nat :=
                           match x1 with
                           | 0%nat => (q, u)
                           | S x' =>
                               match u with
                               | 0%nat => divmod x' y1 (S q) y1
                               | S u' => divmod x' y1 q u'
                               end
                           end) x0 1%nat 0%nat 1%nat in
                      x1)
                     (let (x1, _) :=
                        (fix divmod (x1 y1 q u : nat) {struct x1} :
                             nat * nat :=
                           match x1 with
                           | 0%nat => (q, u)
                           | S x' =>
                               match u with
                               | 0%nat => divmod x' y1 (S q) y1
                               | S u' => divmod x' y1 q u'
                               end
                           end) y0 0%nat 0%nat 0%nat in
                      x1) in
                 x1) *
                (let (x1, _) :=
                   f0 n'
                     match
                       (let (_, y1) :=
                          (fix divmod (x1 y1 q u : nat) {struct x1} :
                               nat * nat :=
                             match x1 with
                             | 0%nat => (q, u)
                             | S x' =>
                                 match u with
                                 | 0%nat => divmod x' y1 (S q) y1
                                 | S u' => divmod x' y1 q u'
                                 end
                             end) x0 1%nat 0%nat 1%nat in
                        y1)
                     with
                     | 0%nat => 1%nat
                     | S _ => 0%nat
                     end 0%nat in
                 x1) +
                -
                ((let (_, y1) :=
                    vkron n' f0
                      (let (x1, _) :=
                         (fix divmod (x1 y1 q u : nat) {struct x1} :
                              nat * nat :=
                            match x1 with
                            | 0%nat => (q, u)
                            | S x' =>
                                match u with
                                | 0%nat => divmod x' y1 (S q) y1
                                | S u' => divmod x' y1 q u'
                                end
                            end) x0 1%nat 0%nat 1%nat in
                       x1)
                      (let (x1, _) :=
                         (fix divmod (x1 y1 q u : nat) {struct x1} :
                              nat * nat :=
                            match x1 with
                            | 0%nat => (q, u)
                            | S x' =>
                                match u with
                                | 0%nat => divmod x' y1 (S q) y1
                                | S u' => divmod x' y1 q u'
                                end
                            end) y0 0%nat 0%nat 0%nat in
                       x1) in
                  y1) *
                 (let (_, y1) :=
                    f0 n'
                      match
                        (let (_, y1) :=
                           (fix divmod (x1 y1 q u : nat) {struct x1} :
                                nat * nat :=
                              match x1 with
                              | 0%nat => (q, u)
                              | S x' =>
                                  match u with
                                  | 0%nat => divmod x' y1 (S q) y1
                                  | S u' => divmod x' y1 q u'
                                  end
                              end) x0 1%nat 0%nat 1%nat in
                         y1)
                      with
                      | 0%nat => 1%nat
                      | S _ => 0%nat
                      end 0%nat in
                  y1)),
               (let (x1, _) :=
                  vkron n' f0
                    (let (x1, _) :=
                       (fix divmod (x1 y1 q u : nat) {struct x1} :
                            nat * nat :=
                          match x1 with
                          | 0%nat => (q, u)
                          | S x' =>
                              match u with
                              | 0%nat => divmod x' y1 (S q) y1
                              | S u' => divmod x' y1 q u'
                              end
                          end) x0 1%nat 0%nat 1%nat in
                     x1)
                    (let (x1, _) :=
                       (fix divmod (x1 y1 q u : nat) {struct x1} :
                            nat * nat :=
                          match x1 with
                          | 0%nat => (q, u)
                          | S x' =>
                              match u with
                              | 0%nat => divmod x' y1 (S q) y1
                              | S u' => divmod x' y1 q u'
                              end
                          end) y0 0%nat 0%nat 0%nat in
                     x1) in
                x1) *
               (let (_, y1) :=
                  f0 n'
                    match
                      (let (_, y1) :=
                         (fix divmod (x1 y1 q u : nat) {struct x1} :
                              nat * nat :=
                            match x1 with
                            | 0%nat => (q, u)
                            | S x' =>
                                match u with
                                | 0%nat => divmod x' y1 (S q) y1
                                | S u' => divmod x' y1 q u'
                                end
                            end) x0 1%nat 0%nat 1%nat in
                       y1)
                    with
                    | 0%nat => 1%nat
                    | S _ => 0%nat
                    end 0%nat in
                y1) +
               (let (_, y1) :=
                  vkron n' f0
                    (let (x1, _) :=
                       (fix divmod (x1 y1 q u : nat) {struct x1} :
                            nat * nat :=
                          match x1 with
                          | 0%nat => (q, u)
                          | S x' =>
                              match u with
                              | 0%nat => divmod x' y1 (S q) y1
                              | S u' => divmod x' y1 q u'
                              end
                          end) x0 1%nat 0%nat 1%nat in
                     x1)
                    (let (x1, _) :=
                       (fix divmod (x1 y1 q u : nat) {struct x1} :
                            nat * nat :=
                          match x1 with
                          | 0%nat => (q, u)
                          | S x' =>
                              match u with
                              | 0%nat => divmod x' y1 (S q) y1
                              | S u' => divmod x' y1 q u'
                              end
                          end) y0 0%nat 0%nat 0%nat in
                     x1) in
                y1) *
               (let (x1, _) :=
                  f0 n'
                    match
                      (let (_, y1) :=
                         (fix divmod (x1 y1 q u : nat) {struct x1} :
                              nat * nat :=
                            match x1 with
                            | 0%nat => (q, u)
                            | S x' =>
                                match u with
                                | 0%nat => divmod x' y1 (S q) y1
                                | S u' => divmod x' y1 q u'
                                end
                            end) x0 1%nat 0%nat 1%nat in
                       y1)
                    with
                    | 0%nat => 1%nat
                    | S _ => 0%nat
                    end 0%nat in
                x1))
           end) H2 f x y in
      y0)))%R,
  ((let (x0, _) :=
      (fix Cpow (c : R * R) (n : nat) {struct n} : R * R :=
         match n with
         | 0%nat => (R1, R0)
         | S n' =>
             ((let (x0, _) := c in x0) * (let (x0, _) := Cpow c n' in x0) +
              - ((let (_, y0) := c in y0) * (let (_, y0) := Cpow c n' in y0)),
             (let (x0, _) := c in x0) * (let (_, y0) := Cpow c n' in y0) +
             (let (_, y0) := c in y0) * (let (x0, _) := Cpow c n' in x0))
         end) l H2 in
    x0) *
   (let (_, y0) :=
      (fix vkron (n : nat) (f0 : nat -> nat -> nat -> R * R) {struct n} :
           nat -> nat -> R * R :=
         match n with
         | 0%nat =>
             fun x0 y0 : nat =>
             if
              if
               (fix eqb (n0 m : nat) {struct n0} : bool :=
                  match n0 with
                  | 0%nat => match m with
                             | 0%nat => true
                             | S _ => false
                             end
                  | S n' =>
                      match m with
                      | 0%nat => false
                      | S m' => eqb n' m'
                      end
                  end) x0 y0
              then
               (fix leb (n0 m : nat) {struct n0} : bool :=
                  match n0 with
                  | 0%nat => true
                  | S n' =>
                      match m with
                      | 0%nat => false
                      | S m' => leb n' m'
                      end
                  end) x0 0%nat
              else false
             then (R1, R0)
             else (R0, R0)
         | S n' =>
             fun x0 y0 : nat =>
             ((let (x1, _) :=
                 vkron n' f0
                   (let (x1, _) :=
                      (fix divmod (x1 y1 q u : nat) {struct x1} :
                           nat * nat :=
                         match x1 with
                         | 0%nat => (q, u)
                         | S x' =>
                             match u with
                             | 0%nat => divmod x' y1 (S q) y1
                             | S u' => divmod x' y1 q u'
                             end
                         end) x0 1%nat 0%nat 1%nat in
                    x1)
                   (let (x1, _) :=
                      (fix divmod (x1 y1 q u : nat) {struct x1} :
                           nat * nat :=
                         match x1 with
                         | 0%nat => (q, u)
                         | S x' =>
                             match u with
                             | 0%nat => divmod x' y1 (S q) y1
                             | S u' => divmod x' y1 q u'
                             end
                         end) y0 0%nat 0%nat 0%nat in
                    x1) in
               x1) *
              (let (x1, _) :=
                 f0 n'
                   match
                     (let (_, y1) :=
                        (fix divmod (x1 y1 q u : nat) {struct x1} :
                             nat * nat :=
                           match x1 with
                           | 0%nat => (q, u)
                           | S x' =>
                               match u with
                               | 0%nat => divmod x' y1 (S q) y1
                               | S u' => divmod x' y1 q u'
                               end
                           end) x0 1%nat 0%nat 1%nat in
                      y1)
                   with
                   | 0%nat => 1%nat
                   | S _ => 0%nat
                   end 0%nat in
               x1) +
              -
              ((let (_, y1) :=
                  vkron n' f0
                    (let (x1, _) :=
                       (fix divmod (x1 y1 q u : nat) {struct x1} :
                            nat * nat :=
                          match x1 with
                          | 0%nat => (q, u)
                          | S x' =>
                              match u with
                              | 0%nat => divmod x' y1 (S q) y1
                              | S u' => divmod x' y1 q u'
                              end
                          end) x0 1%nat 0%nat 1%nat in
                     x1)
                    (let (x1, _) :=
                       (fix divmod (x1 y1 q u : nat) {struct x1} :
                            nat * nat :=
                          match x1 with
                          | 0%nat => (q, u)
                          | S x' =>
                              match u with
                              | 0%nat => divmod x' y1 (S q) y1
                              | S u' => divmod x' y1 q u'
                              end
                          end) y0 0%nat 0%nat 0%nat in
                     x1) in
                y1) *
               (let (_, y1) :=
                  f0 n'
                    match
                      (let (_, y1) :=
                         (fix divmod (x1 y1 q u : nat) {struct x1} :
                              nat * nat :=
                            match x1 with
                            | 0%nat => (q, u)
                            | S x' =>
                                match u with
                                | 0%nat => divmod x' y1 (S q) y1
                                | S u' => divmod x' y1 q u'
                                end
                            end) x0 1%nat 0%nat 1%nat in
                       y1)
                    with
                    | 0%nat => 1%nat
                    | S _ => 0%nat
                    end 0%nat in
                y1)),
             (let (x1, _) :=
                vkron n' f0
                  (let (x1, _) :=
                     (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                        match x1 with
                        | 0%nat => (q, u)
                        | S x' =>
                            match u with
                            | 0%nat => divmod x' y1 (S q) y1
                            | S u' => divmod x' y1 q u'
                            end
                        end) x0 1%nat 0%nat 1%nat in
                   x1)
                  (let (x1, _) :=
                     (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                        match x1 with
                        | 0%nat => (q, u)
                        | S x' =>
                            match u with
                            | 0%nat => divmod x' y1 (S q) y1
                            | S u' => divmod x' y1 q u'
                            end
                        end) y0 0%nat 0%nat 0%nat in
                   x1) in
              x1) *
             (let (_, y1) :=
                f0 n'
                  match
                    (let (_, y1) :=
                       (fix divmod (x1 y1 q u : nat) {struct x1} :
                            nat * nat :=
                          match x1 with
                          | 0%nat => (q, u)
                          | S x' =>
                              match u with
                              | 0%nat => divmod x' y1 (S q) y1
                              | S u' => divmod x' y1 q u'
                              end
                          end) x0 1%nat 0%nat 1%nat in
                     y1)
                  with
                  | 0%nat => 1%nat
                  | S _ => 0%nat
                  end 0%nat in
              y1) +
             (let (_, y1) :=
                vkron n' f0
                  (let (x1, _) :=
                     (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                        match x1 with
                        | 0%nat => (q, u)
                        | S x' =>
                            match u with
                            | 0%nat => divmod x' y1 (S q) y1
                            | S u' => divmod x' y1 q u'
                            end
                        end) x0 1%nat 0%nat 1%nat in
                   x1)
                  (let (x1, _) :=
                     (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                        match x1 with
                        | 0%nat => (q, u)
                        | S x' =>
                            match u with
                            | 0%nat => divmod x' y1 (S q) y1
                            | S u' => divmod x' y1 q u'
                            end
                        end) y0 0%nat 0%nat 0%nat in
                   x1) in
              y1) *
             (let (x1, _) :=
                f0 n'
                  match
                    (let (_, y1) :=
                       (fix divmod (x1 y1 q u : nat) {struct x1} :
                            nat * nat :=
                          match x1 with
                          | 0%nat => (q, u)
                          | S x' =>
                              match u with
                              | 0%nat => divmod x' y1 (S q) y1
                              | S u' => divmod x' y1 q u'
                              end
                          end) x0 1%nat 0%nat 1%nat in
                     y1)
                  with
                  | 0%nat => 1%nat
                  | S _ => 0%nat
                  end 0%nat in
              x1))
         end) H2 f x y in
    y0) +
   (let (_, y0) :=
      (fix Cpow (c : R * R) (n : nat) {struct n} : R * R :=
         match n with
         | 0%nat => (R1, R0)
         | S n' =>
             ((let (x0, _) := c in x0) * (let (x0, _) := Cpow c n' in x0) +
              - ((let (_, y0) := c in y0) * (let (_, y0) := Cpow c n' in y0)),
             (let (x0, _) := c in x0) * (let (_, y0) := Cpow c n' in y0) +
             (let (_, y0) := c in y0) * (let (x0, _) := Cpow c n' in x0))
         end) l H2 in
    y0) *
   (let (x0, _) :=
      (fix vkron (n : nat) (f0 : nat -> nat -> nat -> R * R) {struct n} :
           nat -> nat -> R * R :=
         match n with
         | 0%nat =>
             fun x0 y0 : nat =>
             if
              if
               (fix eqb (n0 m : nat) {struct n0} : bool :=
                  match n0 with
                  | 0%nat => match m with
                             | 0%nat => true
                             | S _ => false
                             end
                  | S n' =>
                      match m with
                      | 0%nat => false
                      | S m' => eqb n' m'
                      end
                  end) x0 y0
              then
               (fix leb (n0 m : nat) {struct n0} : bool :=
                  match n0 with
                  | 0%nat => true
                  | S n' =>
                      match m with
                      | 0%nat => false
                      | S m' => leb n' m'
                      end
                  end) x0 0%nat
              else false
             then (R1, R0)
             else (R0, R0)
         | S n' =>
             fun x0 y0 : nat =>
             ((let (x1, _) :=
                 vkron n' f0
                   (let (x1, _) :=
                      (fix divmod (x1 y1 q u : nat) {struct x1} :
                           nat * nat :=
                         match x1 with
                         | 0%nat => (q, u)
                         | S x' =>
                             match u with
                             | 0%nat => divmod x' y1 (S q) y1
                             | S u' => divmod x' y1 q u'
                             end
                         end) x0 1%nat 0%nat 1%nat in
                    x1)
                   (let (x1, _) :=
                      (fix divmod (x1 y1 q u : nat) {struct x1} :
                           nat * nat :=
                         match x1 with
                         | 0%nat => (q, u)
                         | S x' =>
                             match u with
                             | 0%nat => divmod x' y1 (S q) y1
                             | S u' => divmod x' y1 q u'
                             end
                         end) y0 0%nat 0%nat 0%nat in
                    x1) in
               x1) *
              (let (x1, _) :=
                 f0 n'
                   match
                     (let (_, y1) :=
                        (fix divmod (x1 y1 q u : nat) {struct x1} :
                             nat * nat :=
                           match x1 with
                           | 0%nat => (q, u)
                           | S x' =>
                               match u with
                               | 0%nat => divmod x' y1 (S q) y1
                               | S u' => divmod x' y1 q u'
                               end
                           end) x0 1%nat 0%nat 1%nat in
                      y1)
                   with
                   | 0%nat => 1%nat
                   | S _ => 0%nat
                   end 0%nat in
               x1) +
              -
              ((let (_, y1) :=
                  vkron n' f0
                    (let (x1, _) :=
                       (fix divmod (x1 y1 q u : nat) {struct x1} :
                            nat * nat :=
                          match x1 with
                          | 0%nat => (q, u)
                          | S x' =>
                              match u with
                              | 0%nat => divmod x' y1 (S q) y1
                              | S u' => divmod x' y1 q u'
                              end
                          end) x0 1%nat 0%nat 1%nat in
                     x1)
                    (let (x1, _) :=
                       (fix divmod (x1 y1 q u : nat) {struct x1} :
                            nat * nat :=
                          match x1 with
                          | 0%nat => (q, u)
                          | S x' =>
                              match u with
                              | 0%nat => divmod x' y1 (S q) y1
                              | S u' => divmod x' y1 q u'
                              end
                          end) y0 0%nat 0%nat 0%nat in
                     x1) in
                y1) *
               (let (_, y1) :=
                  f0 n'
                    match
                      (let (_, y1) :=
                         (fix divmod (x1 y1 q u : nat) {struct x1} :
                              nat * nat :=
                            match x1 with
                            | 0%nat => (q, u)
                            | S x' =>
                                match u with
                                | 0%nat => divmod x' y1 (S q) y1
                                | S u' => divmod x' y1 q u'
                                end
                            end) x0 1%nat 0%nat 1%nat in
                       y1)
                    with
                    | 0%nat => 1%nat
                    | S _ => 0%nat
                    end 0%nat in
                y1)),
             (let (x1, _) :=
                vkron n' f0
                  (let (x1, _) :=
                     (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                        match x1 with
                        | 0%nat => (q, u)
                        | S x' =>
                            match u with
                            | 0%nat => divmod x' y1 (S q) y1
                            | S u' => divmod x' y1 q u'
                            end
                        end) x0 1%nat 0%nat 1%nat in
                   x1)
                  (let (x1, _) :=
                     (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                        match x1 with
                        | 0%nat => (q, u)
                        | S x' =>
                            match u with
                            | 0%nat => divmod x' y1 (S q) y1
                            | S u' => divmod x' y1 q u'
                            end
                        end) y0 0%nat 0%nat 0%nat in
                   x1) in
              x1) *
             (let (_, y1) :=
                f0 n'
                  match
                    (let (_, y1) :=
                       (fix divmod (x1 y1 q u : nat) {struct x1} :
                            nat * nat :=
                          match x1 with
                          | 0%nat => (q, u)
                          | S x' =>
                              match u with
                              | 0%nat => divmod x' y1 (S q) y1
                              | S u' => divmod x' y1 q u'
                              end
                          end) x0 1%nat 0%nat 1%nat in
                     y1)
                  with
                  | 0%nat => 1%nat
                  | S _ => 0%nat
                  end 0%nat in
              y1) +
             (let (_, y1) :=
                vkron n' f0
                  (let (x1, _) :=
                     (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                        match x1 with
                        | 0%nat => (q, u)
                        | S x' =>
                            match u with
                            | 0%nat => divmod x' y1 (S q) y1
                            | S u' => divmod x' y1 q u'
                            end
                        end) x0 1%nat 0%nat 1%nat in
                   x1)
                  (let (x1, _) :=
                     (fix divmod (x1 y1 q u : nat) {struct x1} : nat * nat :=
                        match x1 with
                        | 0%nat => (q, u)
                        | S x' =>
                            match u with
                            | 0%nat => divmod x' y1 (S q) y1
                            | S u' => divmod x' y1 q u'
                            end
                        end) y0 0%nat 0%nat 0%nat in
                   x1) in
              y1) *
             (let (x1, _) :=
                f0 n'
                  match
                    (let (_, y1) :=
                       (fix divmod (x1 y1 q u : nat) {struct x1} :
                            nat * nat :=
                          match x1 with
                          | 0%nat => (q, u)
                          | S x' =>
                              match u with
                              | 0%nat => divmod x' y1 (S q) y1
                              | S u' => divmod x' y1 q u'
                              end
                          end) x0 1%nat 0%nat 1%nat in
                     y1)
                  with
                  | 0%nat => 1%nat
                  | S _ => 0%nat
                  end 0%nat in
              x1))
         end) H2 f x y in
    x0))%R)))
Debug:
In environment
x : rat
le0i : 0 <= x
rhs := delta (x + 1) - delta x : rat_numDomainType
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: rhs; x]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             (add
                match match l with
                      | [::] => [::]
                      | _ :: x0 => x0
                      end with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 2)) zero))
       (negb_
          (Feqb
             (add
                match match l with
                      | [::] => [::]
                      | _ :: x0 => x0
                      end with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 3)) zero)))" (cannot unify 
"false" and "true").
Debug:
In environment
x : rat
le0i : 0 <= x
rhs := delta (x + 1) - delta x : rat_numDomainType
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: delta (x + 1); delta x; x]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             (add
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 2)) zero))
       (negb_
          (Feqb
             (add
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 3)) zero)))" (cannot unify 
"false" and "true").
Debug:
In environment
v : int -> int -> rat
v_ann : v.Ann v
v_Sn2 := v.Sn2_ v_ann : v.Sn2 v
v_SnSk := v.SnSk_ v_ann : v.SnSk v
v_Sk2 := v.Sk2_ v_ann : v.Sk2 v
b := fun n : int => \sum_(0 <= k < n + 1 :> int) v n k : int -> rat
n : int
sAB : (2 : int) <= n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: v.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
v : int -> int -> rat
v_ann : v.Ann v
v_Sn2 := v.Sn2_ v_ann : v.Sn2 v
v_SnSk := v.SnSk_ v_ann : v.SnSk v
v_Sk2 := v.Sk2_ v_ann : v.Sk2 v
b := fun n : int => \sum_(0 <= k < n + 1 :> int) v n k : int -> rat
n : int
sAB : (2 : int) <= n
notD : ?Goal
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: v.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
v : int -> int -> rat
v_ann : v.Ann v
v_Sn2 := v.Sn2_ v_ann : v.Sn2 v
v_SnSk := v.SnSk_ v_ann : v.SnSk v
v_Sk2 := v.Sk2_ v_ann : v.Sk2 v
b := fun n : int => \sum_(0 <= k < n + 1 :> int) v n k : int -> rat
n : int
sAB : (2 : int) <= n
p_prime : ?Goal
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: v.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
x : rat
le0x : 0 <= x
rhs := delta (x + 1) - delta x : rat_numDomainType
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: delta (x + 1); delta x; x]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             (add
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 2)) zero))
       (negb_
          (Feqb
             (add
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 3)) zero)))" (cannot unify 
"false" and "true").
Debug:
In environment
x : rat
le0x : 0 <= x
rhs := delta (x + 1) - delta x : rat_numDomainType
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: delta (x + 1); delta x; x]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             (add
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 2)) zero))
       (negb_
          (Feqb
             (add
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 3)) zero)))" (cannot unify 
"false" and "true").
Debug:
In environment
v : int -> int -> rat
v_ann : v.Ann v
v_Sn2 := v.Sn2_ v_ann : v.Sn2 v
v_SnSk := v.SnSk_ v_ann : v.SnSk v
v_Sk2 := v.Sk2_ v_ann : v.Sk2 v
b := fun n : int => \sum_(0 <= k < n + 1 :> int) v n k : int -> rat
n : int
H : (2 : int) <= n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: v.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
v : int -> int -> rat
v_ann : v.Ann v
v_Sn2 := v.Sn2_ v_ann : v.Sn2 v
v_SnSk := v.SnSk_ v_ann : v.SnSk v
v_Sk2 := v.Sk2_ v_ann : v.Sk2 v
b := fun n : int => \sum_(0 <= k < n + 1 :> int) v n k : int -> rat
n : int
H : (2 : int) <= n
notD : ?Goal
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: v.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
v : int -> int -> rat
v_ann : v.Ann v
v_Sn2 := v.Sn2_ v_ann : v.Sn2 v
v_SnSk := v.SnSk_ v_ann : v.SnSk v
v_Sk2 := v.Sk2_ v_ann : v.Sk2 v
b := fun n : int => \sum_(0 <= k < n + 1 :> int) v n k : int -> rat
n : int
H : (2 : int) <= n
p_prime : ?Goal
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: v.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
x : rat
n : 0 <= x
rhs := delta (x + 1) - delta x : rat_numDomainType
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: delta (x + 1); delta x; x]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             (add
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 2)) zero))
       (negb_
          (Feqb
             (add
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 3)) zero)))" (cannot unify 
"false" and "true").
Debug:
In environment
x : rat
n : 0 <= x
rhs := delta (x + 1) - delta x : rat_numDomainType
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: rhs; x]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             (add
                match match l with
                      | [::] => [::]
                      | _ :: x0 => x0
                      end with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 2)) zero))
       (negb_
          (Feqb
             (add
                match match l with
                      | [::] => [::]
                      | _ :: x0 => x0
                      end with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 3)) zero)))" (cannot unify 
"false" and "true").
Debug:
In environment
x : rat
n : 0 <= x
rhs := delta (x + 1) - delta x : rat_numDomainType
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: delta (x + 1); delta x; x]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             (add
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 2)) zero))
       (negb_
          (Feqb
             (add
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 3)) zero)))" (cannot unify 
"false" and "true").
Debug:
In environment
v : int -> int -> rat
v_ann : v.Ann v
v_Sn2 := v.Sn2_ v_ann : v.Sn2 v
v_SnSk := v.SnSk_ v_ann : v.SnSk v
v_Sk2 := v.Sk2_ v_ann : v.Sk2 v
b := fun n : int => \sum_(0 <= k < n + 1 :> int) v n k : int -> rat
n : int
P : (2 : int) <= n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: v.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
x : rat
n : 0 <= x
rhs := delta (x + 1) - delta x : rat_numDomainType
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: rhs; x]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             (add
                match match l with
                      | [::] => [::]
                      | _ :: x0 => x0
                      end with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 2)) zero))
       (negb_
          (Feqb
             (add
                match match l with
                      | [::] => [::]
                      | _ :: x0 => x0
                      end with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 3)) zero)))" (cannot unify 
"false" and "true").
Debug:
In environment
v : int -> int -> rat
v_ann : v.Ann v
v_Sn2 := v.Sn2_ v_ann : v.Sn2 v
v_SnSk := v.SnSk_ v_ann : v.SnSk v
v_Sk2 := v.Sk2_ v_ann : v.Sk2 v
b := fun n : int => \sum_(0 <= k < n + 1 :> int) v n k : int -> rat
n : int
P : (2 : int) <= n
notD : ?Goal
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: v.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
x : rat
n : 0 <= x
rhs := delta (x + 1) - delta x : rat_numDomainType
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: delta (x + 1); delta x; x]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             (add
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 2)) zero))
       (negb_
          (Feqb
             (add
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 3)) zero)))" (cannot unify 
"false" and "true").
Debug:
In environment
A, B : int
c : 0 <= B
Hc : B < A
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: s (int.shift 1 A) (int.shift 1 B); annotated_recs_s.SnSk_cf0_0 A B;
         s A B; s (int.shift 1 A) B; annotated_recs_s.SnSk_cf0_1 A B;
         s A (int.shift 1 B)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
x : rat
le0i : 0 <= x
rhs := delta (x + 1) - delta x : rat_numDomainType
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: delta (x + 1); delta x; x]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             (add
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 2)) zero))
       (negb_
          (Feqb
             (add
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 3)) zero)))" (cannot unify 
"false" and "true").
Debug:
In environment
x : rat
le0i : 0 <= x
rhs := delta (x + 1) - delta x : rat_numDomainType
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: rhs; x]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             (add
                match match l with
                      | [::] => [::]
                      | _ :: x0 => x0
                      end with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 2)) zero))
       (negb_
          (Feqb
             (add
                match match l with
                      | [::] => [::]
                      | _ :: x0 => x0
                      end with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 3)) zero)))" (cannot unify 
"false" and "true").
Debug:
In environment
x : rat
le0i : 0 <= x
rhs := delta (x + 1) - delta x : rat_numDomainType
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: delta (x + 1); delta x; x]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             (add
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 2)) zero))
       (negb_
          (Feqb
             (add
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 3)) zero)))" (cannot unify 
"false" and "true").
Debug:
In environment
x : rat
le0i : 0 <= x
rhs := delta (x + 1) - delta x : rat_numDomainType
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: delta (x + 1); delta x; x]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             (add
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 2)) zero))
       (negb_
          (Feqb
             (add
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 3)) zero)))" (cannot unify 
"false" and "true").
Debug:
In environment
x : rat
le0i : 0 <= x
rhs := delta (x + 1) - delta x : rat_numDomainType
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: delta (x + 1); delta x; x]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             (add
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 2)) zero))
       (negb_
          (Feqb
             (add
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 3)) zero)))" (cannot unify 
"false" and "true").
Debug:
In environment
x : rat
le0i : 0 <= x
rhs := delta (x + 1) - delta x : rat_numDomainType
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: delta (x + 1); delta x; x]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             (add
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 2)) zero))
       (negb_
          (Feqb
             (add
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 3)) zero)))" (cannot unify 
"false" and "true").
Debug:
In environment
HP, HIS : int
nilG : annotated_recs_s.precond.Sk2 HP HIS
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: s HP (int.shift 2 HIS); annotated_recs_s.Sk2_cf0_0 HP HIS; 
        s HP HIS; annotated_recs_s.Sk2_cf0_1 HP HIS; 
        s HP (int.shift 1 HIS)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
x : rat
le0i : 0 <= x
rhs := delta (x + 1) - delta x : rat_numDomainType
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: rhs; x]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             (add
                match match l with
                      | [::] => [::]
                      | _ :: x0 => x0
                      end with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 2)) zero))
       (negb_
          (Feqb
             (add
                match match l with
                      | [::] => [::]
                      | _ :: x0 => x0
                      end with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 3)) zero)))" (cannot unify 
"false" and "true").
Debug:
In environment
HP, HIS : int
qev : annotated_recs_s.precond.Sk2 HP HIS
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: s HP (int.shift 2 HIS); annotated_recs_s.Sk2_cf0_0 HP HIS; 
        s HP HIS; annotated_recs_s.Sk2_cf0_1 HP HIS; 
        s HP (int.shift 1 HIS)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
x : rat
le0i : 0 <= x
rhs := delta (x + 1) - delta x : rat_numDomainType
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: delta (x + 1); delta x; x]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             (add
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 2)) zero))
       (negb_
          (Feqb
             (add
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 3)) zero)))" (cannot unify 
"false" and "true").
Debug:
In environment
x : rat
le0i : 0 <= x
rhs := delta (x + 1) - delta x : rat_numDomainType
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: rhs; x]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             (add
                match match l with
                      | [::] => [::]
                      | _ :: x0 => x0
                      end with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 2)) zero))
       (negb_
          (Feqb
             (add
                match match l with
                      | [::] => [::]
                      | _ :: x0 => x0
                      end with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 3)) zero)))" (cannot unify 
"false" and "true").
Debug:
In environment
HP, HIS : int
nilG : annotated_recs_s.precond.Sk2 HP HIS
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: s HP (int.shift 2 HIS); annotated_recs_s.Sk2_cf0_0 HP HIS; 
        s HP HIS; annotated_recs_s.Sk2_cf0_1 HP HIS; 
        s HP (int.shift 1 HIS)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
HP, HIS : int
p : annotated_recs_s.precond.Sk2 HP HIS
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: s HP (int.shift 2 HIS); annotated_recs_s.Sk2_cf0_0 HP HIS; 
        s HP HIS; annotated_recs_s.Sk2_cf0_1 HP HIS; 
        s HP (int.shift 1 HIS)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
x : rat
le0x : 0 <= x
rhs := delta (x + 1) - delta x : rat_numDomainType
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: delta (x + 1); delta x; x]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             (add
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 2)) zero))
       (negb_
          (Feqb
             (add
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 3)) zero)))" (cannot unify 
"false" and "true").
Debug:
In environment
x : rat
le0x : 0 <= x
rhs := delta (x + 1) - delta x : rat_numDomainType
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: rhs; x]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             (add
                match match l with
                      | [::] => [::]
                      | _ :: x0 => x0
                      end with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 2)) zero))
       (negb_
          (Feqb
             (add
                match match l with
                      | [::] => [::]
                      | _ :: x0 => x0
                      end with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 3)) zero)))" (cannot unify 
"false" and "true").
Debug:
In environment
HP, HIS : int
qev : annotated_recs_s.precond.Sk2 HP HIS
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: s HP (int.shift 2 HIS); annotated_recs_s.Sk2_cf0_0 HP HIS; 
        s HP HIS; annotated_recs_s.Sk2_cf0_1 HP HIS; 
        s HP (int.shift 1 HIS)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
x : rat
le0x : 0 <= x
rhs := delta (x + 1) - delta x : rat_numDomainType
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: delta (x + 1); delta x; x]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             (add
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 2)) zero))
       (negb_
          (Feqb
             (add
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 3)) zero)))" (cannot unify 
"false" and "true").
Debug:
In environment
x : rat
le0x : 0 <= x
rhs := delta (x + 1) - delta x : rat_numDomainType
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: rhs; x]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             (add
                match match l with
                      | [::] => [::]
                      | _ :: x0 => x0
                      end with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 2)) zero))
       (negb_
          (Feqb
             (add
                match match l with
                      | [::] => [::]
                      | _ :: x0 => x0
                      end with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 3)) zero)))" (cannot unify 
"false" and "true").
Debug:
In environment
x : rat
le0x : 0 <= x
rhs := delta (x + 1) - delta x : rat_numDomainType
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: delta (x + 1); delta x; x]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             (add
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 2)) zero))
       (negb_
          (Feqb
             (add
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 3)) zero)))" (cannot unify 
"false" and "true").
Crunching: False
Crunching: False
Debug:
In environment
x : rat
n : 0 <= x
rhs := delta (x + 1) - delta x : rat_numDomainType
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: delta (x + 1); delta x; x]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             (add
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 2)) zero))
       (negb_
          (Feqb
             (add
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 3)) zero)))" (cannot unify 
"false" and "true").
Debug:
In environment
x : rat
n : 0 <= x
rhs := delta (x + 1) - delta x : rat_numDomainType
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: rhs; x]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             (add
                match match l with
                      | [::] => [::]
                      | _ :: x0 => x0
                      end with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 2)) zero))
       (negb_
          (Feqb
             (add
                match match l with
                      | [::] => [::]
                      | _ :: x0 => x0
                      end with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 3)) zero)))" (cannot unify 
"false" and "true").
Debug:
In environment
a, k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: s a (int.shift 2 k); annotated_recs_s.Sk2_cf0_0 a k; 
        s a k; annotated_recs_s.Sk2_cf0_1 a k; s a (int.shift 1 k)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
x : rat
n : 0 <= x
rhs := delta (x + 1) - delta x : rat_numDomainType
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: delta (x + 1); delta x; x]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             (add
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 2)) zero))
       (negb_
          (Feqb
             (add
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 3)) zero)))" (cannot unify 
"false" and "true").
Debug:
In environment
x : rat
n : 0 <= x
rhs := delta (x + 1) - delta x : rat_numDomainType
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: delta (x + 1); delta x; x]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             (add
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 2)) zero))
       (negb_
          (Feqb
             (add
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 3)) zero)))" (cannot unify 
"false" and "true").
Debug:
In environment
HP, HIS : int
l2 : annotated_recs_s.precond.Sk2 HP HIS
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: s HP (int.shift 2 HIS); annotated_recs_s.Sk2_cf0_0 HP HIS; 
        s HP HIS; annotated_recs_s.Sk2_cf0_1 HP HIS; 
        s HP (int.shift 1 HIS)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
x : rat
n : 0 <= x
rhs := delta (x + 1) - delta x : rat_numDomainType
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: delta (x + 1); delta x; x]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             (add
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 2)) zero))
       (negb_
          (Feqb
             (add
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 3)) zero)))" (cannot unify 
"false" and "true").
Debug:
In environment
HP, HIS : int
nilG : annotated_recs_s.precond.Sk2 HP HIS
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: s HP (int.shift 2 HIS); annotated_recs_s.Sk2_cf0_0 HP HIS; 
        s HP HIS; annotated_recs_s.Sk2_cf0_1 HP HIS; 
        s HP (int.shift 1 HIS)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
HP, HIS : int
p : annotated_recs_s.precond.Sk2 HP HIS
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: s HP (int.shift 2 HIS); annotated_recs_s.Sk2_cf0_0 HP HIS; 
        s HP HIS; annotated_recs_s.Sk2_cf0_1 HP HIS; 
        s HP (int.shift 1 HIS)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
x : rat
n : 0 <= x
rhs := delta (x + 1) - delta x : rat_numDomainType
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: delta (x + 1); delta x; x]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             (add
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 2)) zero))
       (negb_
          (Feqb
             (add
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 3)) zero)))" (cannot unify 
"false" and "true").
Debug:
In environment
x : rat
n : 0 <= x
rhs := delta (x + 1) - delta x : rat_numDomainType
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: rhs; x]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             (add
                match match l with
                      | [::] => [::]
                      | _ :: x0 => x0
                      end with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 2)) zero))
       (negb_
          (Feqb
             (add
                match match l with
                      | [::] => [::]
                      | _ :: x0 => x0
                      end with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 3)) zero)))" (cannot unify 
"false" and "true").
Debug:
In environment
x : rat
n : 0 <= x
rhs := delta (x + 1) - delta x : rat_numDomainType
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: delta (x + 1); delta x; x]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             (add
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 2)) zero))
       (negb_
          (Feqb
             (add
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 3)) zero)))" (cannot unify 
"false" and "true").
Debug:
In environment
x : rat
n : 0 <= x
rhs := delta (x + 1) - delta x : rat_numDomainType
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: rhs; x]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             (add
                match match l with
                      | [::] => [::]
                      | _ :: x0 => x0
                      end with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 2)) zero))
       (negb_
          (Feqb
             (add
                match match l with
                      | [::] => [::]
                      | _ :: x0 => x0
                      end with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 3)) zero)))" (cannot unify 
"false" and "true").
Debug:
In environment
HP, HIS : int
qev : annotated_recs_s.precond.Sk2 HP HIS
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: s HP (int.shift 2 HIS); annotated_recs_s.Sk2_cf0_0 HP HIS; 
        s HP HIS; annotated_recs_s.Sk2_cf0_1 HP HIS; 
        s HP (int.shift 1 HIS)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
x : rat
n : 0 <= x
rhs := delta (x + 1) - delta x : rat_numDomainType
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: delta (x + 1); delta x; x]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             (add
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 2)) zero))
       (negb_
          (Feqb
             (add
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 3)) zero)))" (cannot unify 
"false" and "true").
Debug:
In environment
x : rat
n : 0 <= x
rhs := delta (x + 1) - delta x : rat_numDomainType
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: delta (x + 1); delta x; x]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             (add
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 2)) zero))
       (negb_
          (Feqb
             (add
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 3)) zero)))" (cannot unify 
"false" and "true").
Debug:
In environment
x : rat
a : 0 <= x
rhs := delta (x + 1) - delta x : rat_numDomainType
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: delta (x + 1); delta x; x]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             (add
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 2)) zero))
       (negb_
          (Feqb
             (add
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 3)) zero)))" (cannot unify 
"false" and "true").
Debug:
In environment
x : rat
a : 0 <= x
rhs := delta (x + 1) - delta x : rat_numDomainType
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: delta (x + 1); delta x; x]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             (add
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 2)) zero))
       (negb_
          (Feqb
             (add
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 3)) zero)))" (cannot unify 
"false" and "true").
Debug:
In environment
x : rat
le0i : 0 <= x
rhs := delta (x + 1) - delta x : rat_numDomainType
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: delta (x + 1); delta x; x]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             (add
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 2)) zero))
       (negb_
          (Feqb
             (add
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 3)) zero)))" (cannot unify 
"false" and "true").
Debug:
In environment
x : rat
le0i : 0 <= x
rhs := delta (x + 1) - delta x : rat_numDomainType
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: rhs; x]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             (add
                match match l with
                      | [::] => [::]
                      | _ :: x0 => x0
                      end with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 2)) zero))
       (negb_
          (Feqb
             (add
                match match l with
                      | [::] => [::]
                      | _ :: x0 => x0
                      end with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 3)) zero)))" (cannot unify 
"false" and "true").
Debug:
In environment
a, k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: s a (int.shift 2 k); annotated_recs_s.Sk2_cf0_0 a k; 
        s a k; annotated_recs_s.Sk2_cf0_1 a k; s a (int.shift 1 k)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
x : rat
le0i : 0 <= x
rhs := delta (x + 1) - delta x : rat_numDomainType
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: delta (x + 1); delta x; x]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             (add
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 2)) zero))
       (negb_
          (Feqb
             (add
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 3)) zero)))" (cannot unify 
"false" and "true").
Debug:
In environment
x : rat
le0i : 0 <= x
rhs := delta (x + 1) - delta x : rat_numDomainType
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: delta (x + 1); delta x; x]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             (add
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 2)) zero))
       (negb_
          (Feqb
             (add
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 3)) zero)))" (cannot unify 
"false" and "true").
Debug:
In environment
x : rat
le0i : 0 <= x
rhs := delta (x + 1) - delta x : rat_numDomainType
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: delta (x + 1); delta x; x]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             (add
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 2)) zero))
       (negb_
          (Feqb
             (add
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 3)) zero)))" (cannot unify 
"false" and "true").
Debug:
In environment
HP, HIS : int
l2 : annotated_recs_s.precond.Sk2 HP HIS
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: s HP (int.shift 2 HIS); annotated_recs_s.Sk2_cf0_0 HP HIS; 
        s HP HIS; annotated_recs_s.Sk2_cf0_1 HP HIS; 
        s HP (int.shift 1 HIS)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
x : rat
le0i : 0 <= x
rhs := delta (x + 1) - delta x : rat_numDomainType
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: delta (x + 1); delta x; x]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             (add
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 2)) zero))
       (negb_
          (Feqb
             (add
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 3)) zero)))" (cannot unify 
"false" and "true").
Debug:
In environment
HP, HIS : int
nilG : annotated_recs_s.precond.Sk2 HP HIS
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: s HP (int.shift 2 HIS); annotated_recs_s.Sk2_cf0_0 HP HIS; 
        s HP HIS; annotated_recs_s.Sk2_cf0_1 HP HIS; 
        s HP (int.shift 1 HIS)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
HP, HIS : int
p : annotated_recs_s.precond.Sk2 HP HIS
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: s HP (int.shift 2 HIS); annotated_recs_s.Sk2_cf0_0 HP HIS; 
        s HP HIS; annotated_recs_s.Sk2_cf0_1 HP HIS; 
        s HP (int.shift 1 HIS)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
x : rat
le0i : 0 <= x
rhs := delta (x + 1) - delta x : rat_numDomainType
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: delta (x + 1); delta x; x]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             (add
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 2)) zero))
       (negb_
          (Feqb
             (add
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 3)) zero)))" (cannot unify 
"false" and "true").
Debug:
In environment
x : rat
le0i : 0 <= x
rhs := delta (x + 1) - delta x : rat_numDomainType
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: rhs; x]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             (add
                match match l with
                      | [::] => [::]
                      | _ :: x0 => x0
                      end with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 2)) zero))
       (negb_
          (Feqb
             (add
                match match l with
                      | [::] => [::]
                      | _ :: x0 => x0
                      end with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 3)) zero)))" (cannot unify 
"false" and "true").
Debug:
In environment
x : rat
le0i : 0 <= x
rhs := delta (x + 1) - delta x : rat_numDomainType
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: delta (x + 1); delta x; x]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             (add
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 2)) zero))
       (negb_
          (Feqb
             (add
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 3)) zero)))" (cannot unify 
"false" and "true").
Debug:
In environment
HP, HIS : int
qev : annotated_recs_s.precond.Sk2 HP HIS
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: s HP (int.shift 2 HIS); annotated_recs_s.Sk2_cf0_0 HP HIS; 
        s HP HIS; annotated_recs_s.Sk2_cf0_1 HP HIS; 
        s HP (int.shift 1 HIS)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching: False
Debug:
In environment
x : rat
le0i : 0 <= x
rhs := delta (x + 1) - delta x : rat_numDomainType
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: delta (x + 1); delta x; x]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             (add
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 2)) zero))
       (negb_
          (Feqb
             (add
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 3)) zero)))" (cannot unify 
"false" and "true").
Crunching: False
Debug:
In environment
x : rat
le0i : 0 <= x
rhs := delta (x + 1) - delta x : rat_numDomainType
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: rhs; x]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             (add
                match match l with
                      | [::] => [::]
                      | _ :: x0 => x0
                      end with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 2)) zero))
       (negb_
          (Feqb
             (add
                match match l with
                      | [::] => [::]
                      | _ :: x0 => x0
                      end with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 3)) zero)))" (cannot unify 
"false" and "true").
Debug:
In environment
x : rat
le0i : 0 <= x
rhs := delta (x + 1) - delta x : rat_numDomainType
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: delta (x + 1); delta x; x]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             (add
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 2)) zero))
       (negb_
          (Feqb
             (add
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 3)) zero)))" (cannot unify 
"false" and "true").
Debug:
In environment
x : rat
le0i : 0 <= x
rhs := delta (x + 1) - delta x : rat_numDomainType
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: rhs; x]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             (add
                match match l with
                      | [::] => [::]
                      | _ :: x0 => x0
                      end with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 2)) zero))
       (negb_
          (Feqb
             (add
                match match l with
                      | [::] => [::]
                      | _ :: x0 => x0
                      end with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 3)) zero)))" (cannot unify 
"false" and "true").
Debug:
In environment
a, k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: s a (int.shift 2 k); annotated_recs_s.Sk2_cf0_0 a k; 
        s a k; annotated_recs_s.Sk2_cf0_1 a k; s a (int.shift 1 k)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
HP, HIS : int
l2 : annotated_recs_s.precond.Sk2 HP HIS
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: s HP (int.shift 2 HIS); annotated_recs_s.Sk2_cf0_0 HP HIS; 
        s HP HIS; annotated_recs_s.Sk2_cf0_1 HP HIS; 
        s HP (int.shift 1 HIS)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
HP, HIS : int
nilG : annotated_recs_s.precond.Sk2 HP HIS
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: s HP (int.shift 2 HIS); annotated_recs_s.Sk2_cf0_0 HP HIS; 
        s HP HIS; annotated_recs_s.Sk2_cf0_1 HP HIS; 
        s HP (int.shift 1 HIS)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching: (∣0⟩ = basis_vector 2 0)
Debug:
In environment
LT : int
valq : int * int
i : (0 < valq.2) && coprime `|valq.1| `|valq.2|
w : annotated_recs_z.precond.Sn2 LT
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: ghn3 (int.shift 2 LT); annotated_recs_z.Sn2_cf0 LT; 
        ghn3 LT; annotated_recs_z.Sn2_cf1 LT; ghn3 (int.shift 1 LT)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
LT : int
valq : int * int
i : (0 < valq.2) && coprime `|valq.1| `|valq.2|
IHP' : annotated_recs_z.precond.Sn2 LT
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: ghn3 (int.shift 2 LT); annotated_recs_z.Sn2_cf0 LT; 
        ghn3 LT; annotated_recs_z.Sn2_cf1 LT; ghn3 (int.shift 1 LT)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching: (nat -> ∣0⟩ ⊗ basis_vector n k = basis_vector (n + n) k)
Debug:
In environment
LT : int
valq : int * int
i : (0 < valq.2) && coprime `|valq.1| `|valq.2|
d : int * int
co_mn : annotated_recs_z.precond.Sn2 LT
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: ghn3 (int.shift 2 LT); annotated_recs_z.Sn2_cf0 LT; 
        ghn3 LT; annotated_recs_z.Sn2_cf1 LT; ghn3 (int.shift 1 LT)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
LT : int
valq : int * int
i : (0 < valq.2) && coprime `|valq.1| `|valq.2|
w : annotated_recs_z.precond.Sn2 LT
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: ghn3 (int.shift 2 LT); annotated_recs_z.Sn2_cf0 LT; 
        ghn3 LT; annotated_recs_z.Sn2_cf1 LT; ghn3 (int.shift 1 LT)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
LT : int
valq : int * int
i : (0 < valq.2) && coprime `|valq.1| `|valq.2|
IHP' : annotated_recs_z.precond.Sn2 LT
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: ghn3 (int.shift 2 LT); annotated_recs_z.Sn2_cf0 LT; 
        ghn3 LT; annotated_recs_z.Sn2_cf1 LT; ghn3 (int.shift 1 LT)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
"~~~~~~~~~~~~~~~~~~"
"Translating Coq.Init.Logic.eq"
"Coq.Init.Logic.eq was already translated"
"Translating MetaCoq.Translations.MiniHoTT.paths"
"MetaCoq.Translations.MiniHoTT.paths was already translated"
"Translating MetaCoq.Translations.times_bool_fun.wFunext"
"wFunext has been translated as wFunextᵗ"
"Translating Coq.Init.Logic.False"
"Coq.Init.Logic.False was already translated"
Debug:
In environment
injf : int
U : injf != - 2%:~R
V : injf != -1
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: ghn3 (int.shift 2 injf); annotated_recs_z.Sn2_cf0 injf; 
        ghn3 injf; annotated_recs_z.Sn2_cf1 injf; 
        ghn3 (int.shift 1 injf)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching:
(forall (n : nat) (body : R -> option cond) (r : R),
 pr_P (fun rnd : R => isNone (body rnd) = true) r ->
 pr_Ps (fun rnds : list R => isNone (iterate rnds body) = true) n (r ^ n))
Debug:
In environment
LT : int
valq : int * int
i : (0 < valq.2) && coprime `|valq.1| `|valq.2|
d : int * int
co_mn : annotated_recs_z.precond.Sn2 LT
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: ghn3 (int.shift 2 LT); annotated_recs_z.Sn2_cf0 LT; 
        ghn3 LT; annotated_recs_z.Sn2_cf1 LT; ghn3 (int.shift 1 LT)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
LT : int
valq : int * int
i : (0 < valq.2) && coprime `|valq.1| `|valq.2|
w : annotated_recs_z.precond.Sn2 LT
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: ghn3 (int.shift 2 LT); annotated_recs_z.Sn2_cf0 LT; 
        ghn3 LT; annotated_recs_z.Sn2_cf1 LT; ghn3 (int.shift 1 LT)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
LT : int
valq : int * int
i : (0 < valq.2) && coprime `|valq.1| `|valq.2|
IHP' : annotated_recs_z.precond.Sn2 LT
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: ghn3 (int.shift 2 LT); annotated_recs_z.Sn2_cf0 LT; 
        ghn3 LT; annotated_recs_z.Sn2_cf1 LT; ghn3 (int.shift 1 LT)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching: (∣1⟩ = basis_vector 2 1)
Debug:
In environment
injf : int
H : injf != - 2%:~R
H0 : injf != -1
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: ghn3 (int.shift 2 injf); annotated_recs_z.Sn2_cf0 injf; 
        ghn3 injf; annotated_recs_z.Sn2_cf1 injf; 
        ghn3 (int.shift 1 injf)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
injf : int
U : injf != - 2%:~R
V : injf != -1
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: ghn3 (int.shift 2 injf); annotated_recs_z.Sn2_cf0 injf; 
        ghn3 injf; annotated_recs_z.Sn2_cf1 injf; 
        ghn3 (int.shift 1 injf)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
injf : int
U : injf != - 2%:~R
V : injf != -1
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: annotated_recs_z.Sn2_cf0 injf; ghn3 injf;
         annotated_recs_z.Sn2_cf1 injf; ghn3 (int.shift 1 injf);
         ghn3 (int.shift 2 injf)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching:
(∣0⟩ ⊗ (fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) =
 (fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R))
Crunching:
(∣1⟩ ⊗ (fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) =
 (fun i j : nat => if (i =? k + n) && (j =? 0) then C1 else 0%R))
Crunching: (∣1⟩ = basis_vector 2 1)
Debug:
In environment
transG, Su : int
le_nm : annotated_recs_s.precond.Sn2 transG Su
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: (ghn3 (intZmod.addz (intZmod.addz transG 1) 1) +
          s (intZmod.addz (intZmod.addz transG 1) 1) Su)%Q;
         ((((((((((((((((((- rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q +
                          ((- rat_of_Z (BinNums.Zpos (BinNums.xI (...))))%Q *
                           (match transG with
                            | Posz n => iterop n addq 1 0
                            | Negz n =>
                                (- match ... with
                                   | ... 1%Q
                                   | ... ...%Q
                                   end)%Q
                            end *
                            match transG with
                            | Posz n => iterop n addq 1 0
                            | Negz n =>
                                (- match ... with
                                   | ... 1%Q
                                   | ... ...%Q
                                   end)%Q
                            end)%Q)%Q)%Q +
                         ((rat_of_Z (BinNums.Zpos (BinNums.xI 1%AC)) *
                           match Su with
                           | Posz n => iterop n addq 1 0
                           | Negz n =>
                               (-
                                match n with
                                | 0 => 1%Q
                                | _.+1 => (1%Q + ...)%Q
                                end)%Q
                           end)%Q *
                          match transG with
                          | Posz n => iterop n addq 1 0
                          | Negz n =>
                              (-
                               match n with
                               | 0 => 1%Q
                               | _.+1 => (1%Q + (...) n)%Q
                               end)%Q
                          end)%Q)%Q +
                        ((-
                          rat_of_Z
                            (BinNums.Zpos (BinNums.xO (BinNums.xI 1%AC))))%Q *
                         (match Su with
                          | Posz n => iterop n addq 1 0
                          | Negz n =>
                              (-
                               match n with
                               | 0 => 1%Q
                               | _.+1 => (1%Q + (...) n)%Q
                               end)%Q
                          end *
                          match Su with
                          | Posz n => iterop n addq 1 0
                          | Negz n =>
                              (-
                               match n with
                               | 0 => 1%Q
                               | _.+1 => (1%Q + (...) n)%Q
                               end)%Q
                          end)%Q)%Q)%Q +
                       (-
                        (match transG with
                         | Posz n => iterop n addq 1 0
                         | Negz n =>
                             (-
                              match n with
                              | 0 => 1%Q
                              | _.+1 =>
                                  (1%Q +
                                   (fix loop ... : rat := ...
                                                 ...
                                                 ...
                                                 ...
                                                 end) n)%Q
                              end)%Q
                         end *
                         (match transG with
                          | Posz n => iterop n addq 1 0
                          | Negz n =>
                              (-
                               match n with
                               | 0 => 1%Q
                               | _.+1 => (1%Q + (...) n)%Q
                               end)%Q
                          end *
                          (match transG with
                           | Posz n => iterop n addq 1 0
                           | Negz n =>
                               (-
                                match n with
                                | 0 => 1%Q
                                | _.+1 => (1%Q + ...)%Q
                                end)%Q
                           end *
                           match transG with
                           | Posz n => iterop n addq 1 0
                           | Negz n =>
                               (-
                                match n with
                                | 0 => 1%Q
                                | _.+1 => (1%Q + ...)%Q
                                end)%Q
                           end)%Q)%Q)%Q)%Q)%Q +
                      ((-
                        rat_of_Z
                          (BinNums.Zpos (BinNums.xI (BinNums.xO 1%AC))))%Q *
                       (match transG with
                        | Posz n => iterop n addq 1 0
                        | Negz n =>
                            (-
                             match n with
                             | 0 => 1%Q
                             | _.+1 =>
                                 (1%Q +
                                  (fix loop (m : nat) : rat :=
                                     match ... with
                                     | ... => 0
                                     | ... => 1
                                     | ... => 1%Q + ...
                                     end) n)%Q
                             end)%Q
                        end *
                        (match transG with
                         | Posz n => iterop n addq 1 0
                         | Negz n =>
                             (-
                              match n with
                              | 0 => 1%Q
                              | _.+1 =>
                                  (1%Q +
                                   (fix loop ... : rat := ...
                                                 ...
                                                 ...
                                                 ...
                                                 end) n)%Q
                              end)%Q
                         end *
                         match transG with
                         | Posz n => iterop n addq 1 0
                         | Negz n =>
                             (-
                              match n with
                              | 0 => 1%Q
                              | _.+1 =>
                                  (1%Q +
                                   (fix loop ... : rat := ...
                                                 ...
                                                 ...
                                                 ...
                                                 end) n)%Q
                              end)%Q
                         end)%Q)%Q)%Q)%Q +
                     ((-
                       rat_of_Z (BinNums.Zpos (BinNums.xO (BinNums.xI 1%AC))))%Q *
                      (match Su with
                       | Posz n => iterop n addq 1 0
                       | Negz n =>
                           (-
                            match n with
                            | 0 => 1%Q
                            | _.+1 =>
                                (1%Q +
                                 (fix loop (m : nat) : rat :=
                                    match m with
                                    | 0 => 0
                                    | 1 => 1
                                    | (_.+1 as i).+1 => 1%Q + loop i
                                    end) n)%Q
                            end)%Q
                       end *
                       (match Su with
                        | Posz n => iterop n addq 1 0
                        | Negz n =>
                            (-
                             match n with
                             | 0 => 1%Q
                             | _.+1 =>
                                 (1%Q +
                                  (fix loop (m : nat) : rat :=
                                     match ... with
                                     | ... => 0
                                     | ... => 1
                                     | ... => 1%Q + ...
                                     end) n)%Q
                             end)%Q
                        end *
                        match Su with
                        | Posz n => iterop n addq 1 0
                        | Negz n =>
                            (-
                             match n with
                             | 0 => 1%Q
                             | _.+1 =>
                                 (1%Q +
                                  (fix loop (m : nat) : rat :=
                                     match ... with
                                     | ... => 0
                                     | ... => 1
                                     | ... => 1%Q + ...
                                     end) n)%Q
                             end)%Q
                        end)%Q)%Q)%Q)%Q +
                    ((-
                      match Su with
                      | Posz n => iterop n addq 1 0
                      | Negz n =>
                          (-
                           match n with
                           | 0 => 1%Q
                           | _.+1 =>
                               (1%Q +
                                (fix loop (m : nat) : rat :=
                                   match m with
                                   | 0 => 0
                                   | 1 => 1
                                   | (_.+1 as i).+1 => 1%Q + loop i
                                   end) n)%Q
                           end)%Q
                      end)%Q *
                     (match transG with
                      | Posz n => iterop n addq 1 0
                      | Negz n =>
                          (-
                           match n with
                           | 0 => 1%Q
                           | _.+1 =>
                               (1%Q +
                                (fix loop (m : nat) : rat :=
                                   match m with
                                   | 0 => 0
                                   | 1 => 1
                                   | (_.+1 as i).+1 => 1%Q + loop i
                                   end) n)%Q
                           end)%Q
                      end *
                      (match transG with
                       | Posz n => iterop n addq 1 0
                       | Negz n =>
                           (-
                            match n with
                            | 0 => 1%Q
                            | _.+1 =>
                                (1%Q +
                                 (fix loop (m : nat) : rat :=
                                    match m with
                                    | 0 => 0
                                    | 1 => 1
                                    | (_.+1 as i).+1 => 1%Q + loop i
                                    end) n)%Q
                            end)%Q
                       end *
                       match transG with
                       | Posz n => iterop n addq 1 0
                       | Negz n =>
                           (-
                            match n with
                            | 0 => 1%Q
                            | _.+1 =>
                                (1%Q +
                                 (fix loop (m : nat) : rat :=
                                    match m with
                                    | 0 => 0
                                    | 1 => 1
                                    | (_.+1 as i).+1 => 1%Q + loop i
                                    end) n)%Q
                            end)%Q
                       end)%Q)%Q)%Q)%Q +
                   (match Su with
                    | Posz n => iterop n addq 1 0
                    | Negz n =>
                        (-
                         match n with
                         | 0 => 1%Q
                         | _.+1 =>
                             (1%Q +
                              (fix loop (m : nat) : rat :=
                                 match m with
                                 | 0 => 0
                                 | 1 => 1
                                 | (_.+1 as i).+1 => 1%Q + loop i
                                 end) n)%Q
                         end)%Q
                    end *
                    (match transG with
                     | Posz n => iterop n addq 1 0
                     | Negz n =>
                         (-
                          match n with
                          | 0 => 1%Q
                          | _.+1 =>
                              (1%Q +
                               (fix loop (m : nat) : rat :=
                                  match m with
                                  | 0 => 0
                                  | 1 => 1
                                  | (_.+1 as i).+1 => 1%Q + loop i
                                  end) n)%Q
                          end)%Q
                     end *
                     match transG with
                     | Posz n => iterop n addq 1 0
                     | Negz n =>
                         (-
                          match n with
                          | 0 => 1%Q
                          | _.+1 =>
                              (1%Q +
                               (fix loop (m : nat) : rat :=
                                  match m with
                                  | 0 => 0
                                  | 1 => 1
                                  | (_.+1 as i).+1 => 1%Q + loop i
                                  end) n)%Q
                          end)%Q
                     end)%Q)%Q)%Q +
                  ((rat_of_Z (BinNums.Zpos (BinNums.xO (BinNums.xO 1%AC))) *
                    (match Su with
                     | Posz n => iterop n addq 1 0
                     | Negz n =>
                         (-
                          match n with
                          | 0 => 1%Q
                          | _.+1 =>
                              (1%Q +
                               (fix loop (m : nat) : rat :=
                                  match m with
                                  | 0 => 0
                                  | 1 => 1
                                  | (_.+1 as i).+1 => 1%Q + loop i
                                  end) n)%Q
                          end)%Q
                     end *
                     match Su with
                     | Posz n => iterop n addq 1 0
                     | Negz n =>
                         (-
                          match n with
                          | 0 => 1%Q
                          | _.+1 =>
                              (1%Q +
                               (fix loop (m : nat) : rat :=
                                  match m with
                                  | 0 => 0
                                  | 1 => 1
                                  | (_.+1 as i).+1 => 1%Q + loop i
                                  end) n)%Q
                          end)%Q
                     end)%Q)%Q *
                   (match transG with
                    | Posz n => iterop n addq 1 0
                    | Negz n =>
                        (-
                         match n with
                         | 0 => 1%Q
                         | _.+1 =>
                             (1%Q +
                              (fix loop (m : nat) : rat :=
                                 match m with
                                 | 0 => 0
                                 | 1 => 1
                                 | (_.+1 as i).+1 => 1%Q + loop i
                                 end) n)%Q
                         end)%Q
                    end *
                    match transG with
                    | Posz n => iterop n addq 1 0
                    | Negz n =>
                        (-
                         match n with
                         | 0 => 1%Q
                         | _.+1 =>
                             (1%Q +
                              (fix loop (m : nat) : rat :=
                                 match m with
                                 | 0 => 0
                                 | 1 => 1
                                 | (_.+1 as i).+1 => 1%Q + loop i
                                 end) n)%Q
                         end)%Q
                    end)%Q)%Q)%Q +
                 ((rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)) *
                   (match Su with
                    | Posz n => iterop n addq 1 0
                    | Negz n =>
                        (-
                         match n with
                         | 0 => 1%Q
                         | _.+1 =>
                             (1%Q +
                              (fix loop (m : nat) : rat :=
                                 match m with
                                 | 0 => 0
                                 | 1 => 1
                                 | (_.+1 as i).+1 => 1%Q + loop i
                                 end) n)%Q
                         end)%Q
                    end *
                    match Su with
                    | Posz n => iterop n addq 1 0
                    | Negz n =>
                        (-
                         match n with
                         | 0 => 1%Q
                         | _.+1 =>
                             (1%Q +
                              (fix loop (m : nat) : rat :=
                                 match m with
                                 | 0 => 0
                                 | 1 => 1
                                 | (_.+1 as i).+1 => 1%Q + loop i
                                 end) n)%Q
                         end)%Q
                    end)%Q)%Q *
                  match transG with
                  | Posz n => iterop n addq 1 0
                  | Negz n =>
                      (-
                       match n with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as i).+1 => 1%Q + loop i
                               end) n)%Q
                       end)%Q
                  end)%Q)%Q +
                (((- rat_of_Z (BinNums.Zpos (BinNums.xO (BinNums.xO 1%AC))))%Q *
                  (match Su with
                   | Posz n => iterop n addq 1 0
                   | Negz n =>
                       (-
                        match n with
                        | 0 => 1%Q
                        | _.+1 =>
                            (1%Q +
                             (fix loop (m : nat) : rat :=
                                match m with
                                | 0 => 0
                                | 1 => 1
                                | (_.+1 as i).+1 => 1%Q + loop i
                                end) n)%Q
                        end)%Q
                   end *
                   (match Su with
                    | Posz n => iterop n addq 1 0
                    | Negz n =>
                        (-
                         match n with
                         | 0 => 1%Q
                         | _.+1 =>
                             (1%Q +
                              (fix loop (m : nat) : rat :=
                                 match m with
                                 | 0 => 0
                                 | 1 => 1
                                 | (_.+1 as i).+1 => 1%Q + loop i
                                 end) n)%Q
                         end)%Q
                    end *
                    match Su with
                    | Posz n => iterop n addq 1 0
                    | Negz n =>
                        (-
                         match n with
                         | 0 => 1%Q
                         | _.+1 =>
                             (1%Q +
                              (fix loop (m : nat) : rat :=
                                 match m with
                                 | 0 => 0
                                 | 1 => 1
                                 | (_.+1 as i).+1 => 1%Q + loop i
                                 end) n)%Q
                         end)%Q
                    end)%Q)%Q)%Q *
                 match transG with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end)%Q)%Q +
               (-
                match Su with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 => 1%Q + loop i
                             end) n)%Q
                     end)%Q
                end)%Q)%Q +
              ((- rat_of_Z (BinNums.Zpos (BinNums.xI (BinNums.xI 1%AC))))%Q *
               match transG with
               | Posz n => iterop n addq 1 0
               | Negz n =>
                   (-
                    match n with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 => 1%Q + loop i
                            end) n)%Q
                    end)%Q
               end)%Q)%Q *
             ((((match transG with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q *
                ((match transG with
                  | Posz n => iterop n addq 1 0
                  | Negz n =>
                      (-
                       match n with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as i).+1 => 1%Q + loop i
                               end) n)%Q
                       end)%Q
                  end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q *
                 (match transG with
                  | Posz n => iterop n addq 1 0
                  | Negz n =>
                      (-
                       match n with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as i).+1 => 1%Q + loop i
                               end) n)%Q
                       end)%Q
                  end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q)%Q)%Q *
               ((match transG with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q +
                match Su with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 => 1%Q + loop i
                             end) n)%Q
                     end)%Q
                end)%Q)%Q^-1)%Q)%Q * (ghn3 transG + s transG Su)%Q)%Q +
           (((((rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)) *
                match transG with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 => 1%Q + loop i
                             end) n)%Q
                     end)%Q
                end)%Q + rat_of_Z (BinNums.Zpos (BinNums.xI 1%AC)))%Q *
              (((match transG with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end *
                 match transG with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end)%Q +
                (rat_of_Z (BinNums.Zpos (BinNums.xI 1%AC)) *
                 match transG with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end)%Q)%Q + rat_of_Z (BinNums.Zpos (BinNums.xI 1%AC)))%Q)%Q *
             (((match transG with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 => 1%Q + loop i
                             end) n)%Q
                     end)%Q
                end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q *
               ((match transG with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q *
                (match transG with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q)%Q)%Q^-1)%Q)%Q *
            (ghn3 (intZmod.addz transG 1) + s (intZmod.addz transG 1) Su)%Q)%Q)%Q +
          ((((((rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)) *
                match Su with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 => 1%Q + loop i
                             end) n)%Q
                     end)%Q
                end)%Q *
               ((rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)) *
                 match transG with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end)%Q + rat_of_Z (BinNums.Zpos (BinNums.xI 1%AC)))%Q)%Q *
              (match Su with
               | Posz n => iterop n addq 1 0
               | Negz n =>
                   (-
                    match n with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 => 1%Q + loop i
                            end) n)%Q
                    end)%Q
               end + rat_of_Z (BinNums.Zpos 1%AC))%Q)%Q *
             ((-
               match transG with
               | Posz n => iterop n addq 1 0
               | Negz n =>
                   (-
                    match n with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 => 1%Q + loop i
                            end) n)%Q
                    end)%Q
               end)%Q +
              match Su with
              | Posz n => iterop n addq 1 0
              | Negz n =>
                  (-
                   match n with
                   | 0 => 1%Q
                   | _.+1 =>
                       (1%Q +
                        (fix loop (m : nat) : rat :=
                           match m with
                           | 0 => 0
                           | 1 => 1
                           | (_.+1 as i).+1 => 1%Q + loop i
                           end) n)%Q
                   end)%Q
              end)%Q)%Q *
            ((((match transG with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 => 1%Q + loop i
                             end) n)%Q
                     end)%Q
                end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q *
               ((match transG with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q *
                (match transG with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q)%Q)%Q *
              ((match transG with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 => 1%Q + loop i
                             end) n)%Q
                     end)%Q
                end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q +
               match Su with
               | Posz n => iterop n addq 1 0
               | Negz n =>
                   (-
                    match n with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 => 1%Q + loop i
                            end) n)%Q
                    end)%Q
               end)%Q)%Q^-1)%Q)%Q *
           (ghn3 transG + s transG (intZmod.addz Su 1))%Q)%Q)%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
transG, Su : int
i : annotated_recs_s.precond.Sn2 transG Su
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: (ghn3 (intZmod.addz (intZmod.addz transG 1) 1) +
          s (intZmod.addz (intZmod.addz transG 1) 1) Su)%Q;
         ((((((((((((((((((- rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q +
                          ((- rat_of_Z (BinNums.Zpos (BinNums.xI (...))))%Q *
                           (match transG with
                            | Posz n => iterop n addq 1 0
                            | Negz n =>
                                (- match ... with
                                   | ... 1%Q
                                   | ... ...%Q
                                   end)%Q
                            end *
                            match transG with
                            | Posz n => iterop n addq 1 0
                            | Negz n =>
                                (- match ... with
                                   | ... 1%Q
                                   | ... ...%Q
                                   end)%Q
                            end)%Q)%Q)%Q +
                         ((rat_of_Z (BinNums.Zpos (BinNums.xI 1%AC)) *
                           match Su with
                           | Posz n => iterop n addq 1 0
                           | Negz n =>
                               (-
                                match n with
                                | 0 => 1%Q
                                | _.+1 => (1%Q + ...)%Q
                                end)%Q
                           end)%Q *
                          match transG with
                          | Posz n => iterop n addq 1 0
                          | Negz n =>
                              (-
                               match n with
                               | 0 => 1%Q
                               | _.+1 => (1%Q + (...) n)%Q
                               end)%Q
                          end)%Q)%Q +
                        ((-
                          rat_of_Z
                            (BinNums.Zpos (BinNums.xO (BinNums.xI 1%AC))))%Q *
                         (match Su with
                          | Posz n => iterop n addq 1 0
                          | Negz n =>
                              (-
                               match n with
                               | 0 => 1%Q
                               | _.+1 => (1%Q + (...) n)%Q
                               end)%Q
                          end *
                          match Su with
                          | Posz n => iterop n addq 1 0
                          | Negz n =>
                              (-
                               match n with
                               | 0 => 1%Q
                               | _.+1 => (1%Q + (...) n)%Q
                               end)%Q
                          end)%Q)%Q)%Q +
                       (-
                        (match transG with
                         | Posz n => iterop n addq 1 0
                         | Negz n =>
                             (-
                              match n with
                              | 0 => 1%Q
                              | _.+1 =>
                                  (1%Q +
                                   (fix loop ... : rat := ...
                                                 ...
                                                 ...
                                                 ...
                                                 end) n)%Q
                              end)%Q
                         end *
                         (match transG with
                          | Posz n => iterop n addq 1 0
                          | Negz n =>
                              (-
                               match n with
                               | 0 => 1%Q
                               | _.+1 => (1%Q + (...) n)%Q
                               end)%Q
                          end *
                          (match transG with
                           | Posz n => iterop n addq 1 0
                           | Negz n =>
                               (-
                                match n with
                                | 0 => 1%Q
                                | _.+1 => (1%Q + ...)%Q
                                end)%Q
                           end *
                           match transG with
                           | Posz n => iterop n addq 1 0
                           | Negz n =>
                               (-
                                match n with
                                | 0 => 1%Q
                                | _.+1 => (1%Q + ...)%Q
                                end)%Q
                           end)%Q)%Q)%Q)%Q)%Q +
                      ((-
                        rat_of_Z
                          (BinNums.Zpos (BinNums.xI (BinNums.xO 1%AC))))%Q *
                       (match transG with
                        | Posz n => iterop n addq 1 0
                        | Negz n =>
                            (-
                             match n with
                             | 0 => 1%Q
                             | _.+1 =>
                                 (1%Q +
                                  (fix loop (m : nat) : rat :=
                                     match ... with
                                     | ... => 0
                                     | ... => 1
                                     | ... => 1%Q + ...
                                     end) n)%Q
                             end)%Q
                        end *
                        (match transG with
                         | Posz n => iterop n addq 1 0
                         | Negz n =>
                             (-
                              match n with
                              | 0 => 1%Q
                              | _.+1 =>
                                  (1%Q +
                                   (fix loop ... : rat := ...
                                                 ...
                                                 ...
                                                 ...
                                                 end) n)%Q
                              end)%Q
                         end *
                         match transG with
                         | Posz n => iterop n addq 1 0
                         | Negz n =>
                             (-
                              match n with
                              | 0 => 1%Q
                              | _.+1 =>
                                  (1%Q +
                                   (fix loop ... : rat := ...
                                                 ...
                                                 ...
                                                 ...
                                                 end) n)%Q
                              end)%Q
                         end)%Q)%Q)%Q)%Q +
                     ((-
                       rat_of_Z (BinNums.Zpos (BinNums.xO (BinNums.xI 1%AC))))%Q *
                      (match Su with
                       | Posz n => iterop n addq 1 0
                       | Negz n =>
                           (-
                            match n with
                            | 0 => 1%Q
                            | _.+1 =>
                                (1%Q +
                                 (fix loop (m : nat) : rat :=
                                    match m with
                                    | 0 => 0
                                    | 1 => 1
                                    | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                        1%Q + loop elpi_ctx_entry_7_
                                    end) n)%Q
                            end)%Q
                       end *
                       (match Su with
                        | Posz n => iterop n addq 1 0
                        | Negz n =>
                            (-
                             match n with
                             | 0 => 1%Q
                             | _.+1 =>
                                 (1%Q +
                                  (fix loop (m : nat) : rat :=
                                     match ... with
                                     | ... => 0
                                     | ... => 1
                                     | ... => 1%Q + ...
                                     end) n)%Q
                             end)%Q
                        end *
                        match Su with
                        | Posz n => iterop n addq 1 0
                        | Negz n =>
                            (-
                             match n with
                             | 0 => 1%Q
                             | _.+1 =>
                                 (1%Q +
                                  (fix loop (m : nat) : rat :=
                                     match ... with
                                     | ... => 0
                                     | ... => 1
                                     | ... => 1%Q + ...
                                     end) n)%Q
                             end)%Q
                        end)%Q)%Q)%Q)%Q +
                    ((-
                      match Su with
                      | Posz n => iterop n addq 1 0
                      | Negz n =>
                          (-
                           match n with
                           | 0 => 1%Q
                           | _.+1 =>
                               (1%Q +
                                (fix loop (m : nat) : rat :=
                                   match m with
                                   | 0 => 0
                                   | 1 => 1
                                   | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                       1%Q + loop elpi_ctx_entry_7_
                                   end) n)%Q
                           end)%Q
                      end)%Q *
                     (match transG with
                      | Posz n => iterop n addq 1 0
                      | Negz n =>
                          (-
                           match n with
                           | 0 => 1%Q
                           | _.+1 =>
                               (1%Q +
                                (fix loop (m : nat) : rat :=
                                   match m with
                                   | 0 => 0
                                   | 1 => 1
                                   | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                       1%Q + loop elpi_ctx_entry_7_
                                   end) n)%Q
                           end)%Q
                      end *
                      (match transG with
                       | Posz n => iterop n addq 1 0
                       | Negz n =>
                           (-
                            match n with
                            | 0 => 1%Q
                            | _.+1 =>
                                (1%Q +
                                 (fix loop (m : nat) : rat :=
                                    match m with
                                    | 0 => 0
                                    | 1 => 1
                                    | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                        1%Q + loop elpi_ctx_entry_7_
                                    end) n)%Q
                            end)%Q
                       end *
                       match transG with
                       | Posz n => iterop n addq 1 0
                       | Negz n =>
                           (-
                            match n with
                            | 0 => 1%Q
                            | _.+1 =>
                                (1%Q +
                                 (fix loop (m : nat) : rat :=
                                    match m with
                                    | 0 => 0
                                    | 1 => 1
                                    | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                        1%Q + loop elpi_ctx_entry_7_
                                    end) n)%Q
                            end)%Q
                       end)%Q)%Q)%Q)%Q +
                   (match Su with
                    | Posz n => iterop n addq 1 0
                    | Negz n =>
                        (-
                         match n with
                         | 0 => 1%Q
                         | _.+1 =>
                             (1%Q +
                              (fix loop (m : nat) : rat :=
                                 match m with
                                 | 0 => 0
                                 | 1 => 1
                                 | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                     1%Q + loop elpi_ctx_entry_7_
                                 end) n)%Q
                         end)%Q
                    end *
                    (match transG with
                     | Posz n => iterop n addq 1 0
                     | Negz n =>
                         (-
                          match n with
                          | 0 => 1%Q
                          | _.+1 =>
                              (1%Q +
                               (fix loop (m : nat) : rat :=
                                  match m with
                                  | 0 => 0
                                  | 1 => 1
                                  | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                      1%Q + loop elpi_ctx_entry_7_
                                  end) n)%Q
                          end)%Q
                     end *
                     match transG with
                     | Posz n => iterop n addq 1 0
                     | Negz n =>
                         (-
                          match n with
                          | 0 => 1%Q
                          | _.+1 =>
                              (1%Q +
                               (fix loop (m : nat) : rat :=
                                  match m with
                                  | 0 => 0
                                  | 1 => 1
                                  | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                      1%Q + loop elpi_ctx_entry_7_
                                  end) n)%Q
                          end)%Q
                     end)%Q)%Q)%Q +
                  ((rat_of_Z (BinNums.Zpos (BinNums.xO (BinNums.xO 1%AC))) *
                    (match Su with
                     | Posz n => iterop n addq 1 0
                     | Negz n =>
                         (-
                          match n with
                          | 0 => 1%Q
                          | _.+1 =>
                              (1%Q +
                               (fix loop (m : nat) : rat :=
                                  match m with
                                  | 0 => 0
                                  | 1 => 1
                                  | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                      1%Q + loop elpi_ctx_entry_7_
                                  end) n)%Q
                          end)%Q
                     end *
                     match Su with
                     | Posz n => iterop n addq 1 0
                     | Negz n =>
                         (-
                          match n with
                          | 0 => 1%Q
                          | _.+1 =>
                              (1%Q +
                               (fix loop (m : nat) : rat :=
                                  match m with
                                  | 0 => 0
                                  | 1 => 1
                                  | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                      1%Q + loop elpi_ctx_entry_7_
                                  end) n)%Q
                          end)%Q
                     end)%Q)%Q *
                   (match transG with
                    | Posz n => iterop n addq 1 0
                    | Negz n =>
                        (-
                         match n with
                         | 0 => 1%Q
                         | _.+1 =>
                             (1%Q +
                              (fix loop (m : nat) : rat :=
                                 match m with
                                 | 0 => 0
                                 | 1 => 1
                                 | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                     1%Q + loop elpi_ctx_entry_7_
                                 end) n)%Q
                         end)%Q
                    end *
                    match transG with
                    | Posz n => iterop n addq 1 0
                    | Negz n =>
                        (-
                         match n with
                         | 0 => 1%Q
                         | _.+1 =>
                             (1%Q +
                              (fix loop (m : nat) : rat :=
                                 match m with
                                 | 0 => 0
                                 | 1 => 1
                                 | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                     1%Q + loop elpi_ctx_entry_7_
                                 end) n)%Q
                         end)%Q
                    end)%Q)%Q)%Q +
                 ((rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)) *
                   (match Su with
                    | Posz n => iterop n addq 1 0
                    | Negz n =>
                        (-
                         match n with
                         | 0 => 1%Q
                         | _.+1 =>
                             (1%Q +
                              (fix loop (m : nat) : rat :=
                                 match m with
                                 | 0 => 0
                                 | 1 => 1
                                 | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                     1%Q + loop elpi_ctx_entry_7_
                                 end) n)%Q
                         end)%Q
                    end *
                    match Su with
                    | Posz n => iterop n addq 1 0
                    | Negz n =>
                        (-
                         match n with
                         | 0 => 1%Q
                         | _.+1 =>
                             (1%Q +
                              (fix loop (m : nat) : rat :=
                                 match m with
                                 | 0 => 0
                                 | 1 => 1
                                 | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                     1%Q + loop elpi_ctx_entry_7_
                                 end) n)%Q
                         end)%Q
                    end)%Q)%Q *
                  match transG with
                  | Posz n => iterop n addq 1 0
                  | Negz n =>
                      (-
                       match n with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                   1%Q + loop elpi_ctx_entry_7_
                               end) n)%Q
                       end)%Q
                  end)%Q)%Q +
                (((- rat_of_Z (BinNums.Zpos (BinNums.xO (BinNums.xO 1%AC))))%Q *
                  (match Su with
                   | Posz n => iterop n addq 1 0
                   | Negz n =>
                       (-
                        match n with
                        | 0 => 1%Q
                        | _.+1 =>
                            (1%Q +
                             (fix loop (m : nat) : rat :=
                                match m with
                                | 0 => 0
                                | 1 => 1
                                | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                    1%Q + loop elpi_ctx_entry_7_
                                end) n)%Q
                        end)%Q
                   end *
                   (match Su with
                    | Posz n => iterop n addq 1 0
                    | Negz n =>
                        (-
                         match n with
                         | 0 => 1%Q
                         | _.+1 =>
                             (1%Q +
                              (fix loop (m : nat) : rat :=
                                 match m with
                                 | 0 => 0
                                 | 1 => 1
                                 | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                     1%Q + loop elpi_ctx_entry_7_
                                 end) n)%Q
                         end)%Q
                    end *
                    match Su with
                    | Posz n => iterop n addq 1 0
                    | Negz n =>
                        (-
                         match n with
                         | 0 => 1%Q
                         | _.+1 =>
                             (1%Q +
                              (fix loop (m : nat) : rat :=
                                 match m with
                                 | 0 => 0
                                 | 1 => 1
                                 | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                     1%Q + loop elpi_ctx_entry_7_
                                 end) n)%Q
                         end)%Q
                    end)%Q)%Q)%Q *
                 match transG with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                  1%Q + loop elpi_ctx_entry_7_
                              end) n)%Q
                      end)%Q
                 end)%Q)%Q +
               (-
                match Su with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                 1%Q + loop elpi_ctx_entry_7_
                             end) n)%Q
                     end)%Q
                end)%Q)%Q +
              ((- rat_of_Z (BinNums.Zpos (BinNums.xI (BinNums.xI 1%AC))))%Q *
               match transG with
               | Posz n => iterop n addq 1 0
               | Negz n =>
                   (-
                    match n with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                1%Q + loop elpi_ctx_entry_7_
                            end) n)%Q
                    end)%Q
               end)%Q)%Q *
             ((((match transG with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                  1%Q + loop elpi_ctx_entry_7_
                              end) n)%Q
                      end)%Q
                 end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q *
                ((match transG with
                  | Posz n => iterop n addq 1 0
                  | Negz n =>
                      (-
                       match n with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                   1%Q + loop elpi_ctx_entry_7_
                               end) n)%Q
                       end)%Q
                  end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q *
                 (match transG with
                  | Posz n => iterop n addq 1 0
                  | Negz n =>
                      (-
                       match n with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                   1%Q + loop elpi_ctx_entry_7_
                               end) n)%Q
                       end)%Q
                  end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q)%Q)%Q *
               ((match transG with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                  1%Q + loop elpi_ctx_entry_7_
                              end) n)%Q
                      end)%Q
                 end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q +
                match Su with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                 1%Q + loop elpi_ctx_entry_7_
                             end) n)%Q
                     end)%Q
                end)%Q)%Q^-1)%Q)%Q * (ghn3 transG + s transG Su)%Q)%Q +
           (((((rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)) *
                match transG with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                 1%Q + loop elpi_ctx_entry_7_
                             end) n)%Q
                     end)%Q
                end)%Q + rat_of_Z (BinNums.Zpos (BinNums.xI 1%AC)))%Q *
              (((match transG with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                  1%Q + loop elpi_ctx_entry_7_
                              end) n)%Q
                      end)%Q
                 end *
                 match transG with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                  1%Q + loop elpi_ctx_entry_7_
                              end) n)%Q
                      end)%Q
                 end)%Q +
                (rat_of_Z (BinNums.Zpos (BinNums.xI 1%AC)) *
                 match transG with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                  1%Q + loop elpi_ctx_entry_7_
                              end) n)%Q
                      end)%Q
                 end)%Q)%Q + rat_of_Z (BinNums.Zpos (BinNums.xI 1%AC)))%Q)%Q *
             (((match transG with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                 1%Q + loop elpi_ctx_entry_7_
                             end) n)%Q
                     end)%Q
                end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q *
               ((match transG with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                  1%Q + loop elpi_ctx_entry_7_
                              end) n)%Q
                      end)%Q
                 end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q *
                (match transG with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                  1%Q + loop elpi_ctx_entry_7_
                              end) n)%Q
                      end)%Q
                 end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q)%Q)%Q^-1)%Q)%Q *
            (ghn3 (intZmod.addz transG 1) + s (intZmod.addz transG 1) Su)%Q)%Q)%Q +
          ((((((rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)) *
                match Su with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                 1%Q + loop elpi_ctx_entry_7_
                             end) n)%Q
                     end)%Q
                end)%Q *
               ((rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)) *
                 match transG with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                  1%Q + loop elpi_ctx_entry_7_
                              end) n)%Q
                      end)%Q
                 end)%Q + rat_of_Z (BinNums.Zpos (BinNums.xI 1%AC)))%Q)%Q *
              (match Su with
               | Posz n => iterop n addq 1 0
               | Negz n =>
                   (-
                    match n with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                1%Q + loop elpi_ctx_entry_7_
                            end) n)%Q
                    end)%Q
               end + rat_of_Z (BinNums.Zpos 1%AC))%Q)%Q *
             ((-
               match transG with
               | Posz n => iterop n addq 1 0
               | Negz n =>
                   (-
                    match n with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                1%Q + loop elpi_ctx_entry_7_
                            end) n)%Q
                    end)%Q
               end)%Q +
              match Su with
              | Posz n => iterop n addq 1 0
              | Negz n =>
                  (-
                   match n with
                   | 0 => 1%Q
                   | _.+1 =>
                       (1%Q +
                        (fix loop (m : nat) : rat :=
                           match m with
                           | 0 => 0
                           | 1 => 1
                           | (_.+1 as elpi_ctx_entry_7_).+1 =>
                               1%Q + loop elpi_ctx_entry_7_
                           end) n)%Q
                   end)%Q
              end)%Q)%Q *
            ((((match transG with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                 1%Q + loop elpi_ctx_entry_7_
                             end) n)%Q
                     end)%Q
                end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q *
               ((match transG with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                  1%Q + loop elpi_ctx_entry_7_
                              end) n)%Q
                      end)%Q
                 end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q *
                (match transG with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                  1%Q + loop elpi_ctx_entry_7_
                              end) n)%Q
                      end)%Q
                 end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q)%Q)%Q *
              ((match transG with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                 1%Q + loop elpi_ctx_entry_7_
                             end) n)%Q
                     end)%Q
                end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q +
               match Su with
               | Posz n => iterop n addq 1 0
               | Negz n =>
                   (-
                    match n with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                1%Q + loop elpi_ctx_entry_7_
                            end) n)%Q
                    end)%Q
               end)%Q)%Q^-1)%Q)%Q *
           (ghn3 transG + s transG (intZmod.addz Su 1))%Q)%Q)%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching:
(∣1⟩ ⊗ (fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) =
 (fun i j : nat => if (i =? k + n) && (j =? 0) then C1 else 0%R))
Crunching:
(0 < INR 2 ->
 0 < INR 2 ->
 pr_P (fun rnd : R => isNone (H1 rnd) = true) x ->
 pr_Ps (fun rnds : list R => isNone (iterate rnds H1) = true) H (x ^ H))
Crunching: (∣1⟩ ⊗ basis_vector n k = basis_vector (2 * n) (k + n))
Debug:
In environment
transG, Su : int
RS' : annotated_recs_s.precond.Sn2 transG Su
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: (ghn3 (intZmod.addz (intZmod.addz transG 1) 1) +
          s (intZmod.addz (intZmod.addz transG 1) 1) Su)%Q;
         ((((((((((((((((((- rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q +
                          ((- rat_of_Z (BinNums.Zpos (BinNums.xI (...))))%Q *
                           (match transG with
                            | Posz n => iterop n addq 1 0
                            | Negz n =>
                                (- match ... with
                                   | ... 1%Q
                                   | ... ...%Q
                                   end)%Q
                            end *
                            match transG with
                            | Posz n => iterop n addq 1 0
                            | Negz n =>
                                (- match ... with
                                   | ... 1%Q
                                   | ... ...%Q
                                   end)%Q
                            end)%Q)%Q)%Q +
                         ((rat_of_Z (BinNums.Zpos (BinNums.xI 1%AC)) *
                           match Su with
                           | Posz n => iterop n addq 1 0
                           | Negz n =>
                               (-
                                match n with
                                | 0 => 1%Q
                                | _.+1 => (1%Q + ...)%Q
                                end)%Q
                           end)%Q *
                          match transG with
                          | Posz n => iterop n addq 1 0
                          | Negz n =>
                              (-
                               match n with
                               | 0 => 1%Q
                               | _.+1 => (1%Q + (...) n)%Q
                               end)%Q
                          end)%Q)%Q +
                        ((-
                          rat_of_Z
                            (BinNums.Zpos (BinNums.xO (BinNums.xI 1%AC))))%Q *
                         (match Su with
                          | Posz n => iterop n addq 1 0
                          | Negz n =>
                              (-
                               match n with
                               | 0 => 1%Q
                               | _.+1 => (1%Q + (...) n)%Q
                               end)%Q
                          end *
                          match Su with
                          | Posz n => iterop n addq 1 0
                          | Negz n =>
                              (-
                               match n with
                               | 0 => 1%Q
                               | _.+1 => (1%Q + (...) n)%Q
                               end)%Q
                          end)%Q)%Q)%Q +
                       (-
                        (match transG with
                         | Posz n => iterop n addq 1 0
                         | Negz n =>
                             (-
                              match n with
                              | 0 => 1%Q
                              | _.+1 =>
                                  (1%Q +
                                   (fix loop ... : rat := ...
                                                 ...
                                                 ...
                                                 ...
                                                 end) n)%Q
                              end)%Q
                         end *
                         (match transG with
                          | Posz n => iterop n addq 1 0
                          | Negz n =>
                              (-
                               match n with
                               | 0 => 1%Q
                               | _.+1 => (1%Q + (...) n)%Q
                               end)%Q
                          end *
                          (match transG with
                           | Posz n => iterop n addq 1 0
                           | Negz n =>
                               (-
                                match n with
                                | 0 => 1%Q
                                | _.+1 => (1%Q + ...)%Q
                                end)%Q
                           end *
                           match transG with
                           | Posz n => iterop n addq 1 0
                           | Negz n =>
                               (-
                                match n with
                                | 0 => 1%Q
                                | _.+1 => (1%Q + ...)%Q
                                end)%Q
                           end)%Q)%Q)%Q)%Q)%Q +
                      ((-
                        rat_of_Z
                          (BinNums.Zpos (BinNums.xI (BinNums.xO 1%AC))))%Q *
                       (match transG with
                        | Posz n => iterop n addq 1 0
                        | Negz n =>
                            (-
                             match n with
                             | 0 => 1%Q
                             | _.+1 =>
                                 (1%Q +
                                  (fix loop (m : nat) : rat :=
                                     match ... with
                                     | ... => 0
                                     | ... => 1
                                     | ... => 1%Q + ...
                                     end) n)%Q
                             end)%Q
                        end *
                        (match transG with
                         | Posz n => iterop n addq 1 0
                         | Negz n =>
                             (-
                              match n with
                              | 0 => 1%Q
                              | _.+1 =>
                                  (1%Q +
                                   (fix loop ... : rat := ...
                                                 ...
                                                 ...
                                                 ...
                                                 end) n)%Q
                              end)%Q
                         end *
                         match transG with
                         | Posz n => iterop n addq 1 0
                         | Negz n =>
                             (-
                              match n with
                              | 0 => 1%Q
                              | _.+1 =>
                                  (1%Q +
                                   (fix loop ... : rat := ...
                                                 ...
                                                 ...
                                                 ...
                                                 end) n)%Q
                              end)%Q
                         end)%Q)%Q)%Q)%Q +
                     ((-
                       rat_of_Z (BinNums.Zpos (BinNums.xO (BinNums.xI 1%AC))))%Q *
                      (match Su with
                       | Posz n => iterop n addq 1 0
                       | Negz n =>
                           (-
                            match n with
                            | 0 => 1%Q
                            | _.+1 =>
                                (1%Q +
                                 (fix loop (m : nat) : rat :=
                                    match m with
                                    | 0 => 0
                                    | 1 => 1
                                    | (_.+1 as i).+1 => 1%Q + loop i
                                    end) n)%Q
                            end)%Q
                       end *
                       (match Su with
                        | Posz n => iterop n addq 1 0
                        | Negz n =>
                            (-
                             match n with
                             | 0 => 1%Q
                             | _.+1 =>
                                 (1%Q +
                                  (fix loop (m : nat) : rat :=
                                     match ... with
                                     | ... => 0
                                     | ... => 1
                                     | ... => 1%Q + ...
                                     end) n)%Q
                             end)%Q
                        end *
                        match Su with
                        | Posz n => iterop n addq 1 0
                        | Negz n =>
                            (-
                             match n with
                             | 0 => 1%Q
                             | _.+1 =>
                                 (1%Q +
                                  (fix loop (m : nat) : rat :=
                                     match ... with
                                     | ... => 0
                                     | ... => 1
                                     | ... => 1%Q + ...
                                     end) n)%Q
                             end)%Q
                        end)%Q)%Q)%Q)%Q +
                    ((-
                      match Su with
                      | Posz n => iterop n addq 1 0
                      | Negz n =>
                          (-
                           match n with
                           | 0 => 1%Q
                           | _.+1 =>
                               (1%Q +
                                (fix loop (m : nat) : rat :=
                                   match m with
                                   | 0 => 0
                                   | 1 => 1
                                   | (_.+1 as i).+1 => 1%Q + loop i
                                   end) n)%Q
                           end)%Q
                      end)%Q *
                     (match transG with
                      | Posz n => iterop n addq 1 0
                      | Negz n =>
                          (-
                           match n with
                           | 0 => 1%Q
                           | _.+1 =>
                               (1%Q +
                                (fix loop (m : nat) : rat :=
                                   match m with
                                   | 0 => 0
                                   | 1 => 1
                                   | (_.+1 as i).+1 => 1%Q + loop i
                                   end) n)%Q
                           end)%Q
                      end *
                      (match transG with
                       | Posz n => iterop n addq 1 0
                       | Negz n =>
                           (-
                            match n with
                            | 0 => 1%Q
                            | _.+1 =>
                                (1%Q +
                                 (fix loop (m : nat) : rat :=
                                    match m with
                                    | 0 => 0
                                    | 1 => 1
                                    | (_.+1 as i).+1 => 1%Q + loop i
                                    end) n)%Q
                            end)%Q
                       end *
                       match transG with
                       | Posz n => iterop n addq 1 0
                       | Negz n =>
                           (-
                            match n with
                            | 0 => 1%Q
                            | _.+1 =>
                                (1%Q +
                                 (fix loop (m : nat) : rat :=
                                    match m with
                                    | 0 => 0
                                    | 1 => 1
                                    | (_.+1 as i).+1 => 1%Q + loop i
                                    end) n)%Q
                            end)%Q
                       end)%Q)%Q)%Q)%Q +
                   (match Su with
                    | Posz n => iterop n addq 1 0
                    | Negz n =>
                        (-
                         match n with
                         | 0 => 1%Q
                         | _.+1 =>
                             (1%Q +
                              (fix loop (m : nat) : rat :=
                                 match m with
                                 | 0 => 0
                                 | 1 => 1
                                 | (_.+1 as i).+1 => 1%Q + loop i
                                 end) n)%Q
                         end)%Q
                    end *
                    (match transG with
                     | Posz n => iterop n addq 1 0
                     | Negz n =>
                         (-
                          match n with
                          | 0 => 1%Q
                          | _.+1 =>
                              (1%Q +
                               (fix loop (m : nat) : rat :=
                                  match m with
                                  | 0 => 0
                                  | 1 => 1
                                  | (_.+1 as i).+1 => 1%Q + loop i
                                  end) n)%Q
                          end)%Q
                     end *
                     match transG with
                     | Posz n => iterop n addq 1 0
                     | Negz n =>
                         (-
                          match n with
                          | 0 => 1%Q
                          | _.+1 =>
                              (1%Q +
                               (fix loop (m : nat) : rat :=
                                  match m with
                                  | 0 => 0
                                  | 1 => 1
                                  | (_.+1 as i).+1 => 1%Q + loop i
                                  end) n)%Q
                          end)%Q
                     end)%Q)%Q)%Q +
                  ((rat_of_Z (BinNums.Zpos (BinNums.xO (BinNums.xO 1%AC))) *
                    (match Su with
                     | Posz n => iterop n addq 1 0
                     | Negz n =>
                         (-
                          match n with
                          | 0 => 1%Q
                          | _.+1 =>
                              (1%Q +
                               (fix loop (m : nat) : rat :=
                                  match m with
                                  | 0 => 0
                                  | 1 => 1
                                  | (_.+1 as i).+1 => 1%Q + loop i
                                  end) n)%Q
                          end)%Q
                     end *
                     match Su with
                     | Posz n => iterop n addq 1 0
                     | Negz n =>
                         (-
                          match n with
                          | 0 => 1%Q
                          | _.+1 =>
                              (1%Q +
                               (fix loop (m : nat) : rat :=
                                  match m with
                                  | 0 => 0
                                  | 1 => 1
                                  | (_.+1 as i).+1 => 1%Q + loop i
                                  end) n)%Q
                          end)%Q
                     end)%Q)%Q *
                   (match transG with
                    | Posz n => iterop n addq 1 0
                    | Negz n =>
                        (-
                         match n with
                         | 0 => 1%Q
                         | _.+1 =>
                             (1%Q +
                              (fix loop (m : nat) : rat :=
                                 match m with
                                 | 0 => 0
                                 | 1 => 1
                                 | (_.+1 as i).+1 => 1%Q + loop i
                                 end) n)%Q
                         end)%Q
                    end *
                    match transG with
                    | Posz n => iterop n addq 1 0
                    | Negz n =>
                        (-
                         match n with
                         | 0 => 1%Q
                         | _.+1 =>
                             (1%Q +
                              (fix loop (m : nat) : rat :=
                                 match m with
                                 | 0 => 0
                                 | 1 => 1
                                 | (_.+1 as i).+1 => 1%Q + loop i
                                 end) n)%Q
                         end)%Q
                    end)%Q)%Q)%Q +
                 ((rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)) *
                   (match Su with
                    | Posz n => iterop n addq 1 0
                    | Negz n =>
                        (-
                         match n with
                         | 0 => 1%Q
                         | _.+1 =>
                             (1%Q +
                              (fix loop (m : nat) : rat :=
                                 match m with
                                 | 0 => 0
                                 | 1 => 1
                                 | (_.+1 as i).+1 => 1%Q + loop i
                                 end) n)%Q
                         end)%Q
                    end *
                    match Su with
                    | Posz n => iterop n addq 1 0
                    | Negz n =>
                        (-
                         match n with
                         | 0 => 1%Q
                         | _.+1 =>
                             (1%Q +
                              (fix loop (m : nat) : rat :=
                                 match m with
                                 | 0 => 0
                                 | 1 => 1
                                 | (_.+1 as i).+1 => 1%Q + loop i
                                 end) n)%Q
                         end)%Q
                    end)%Q)%Q *
                  match transG with
                  | Posz n => iterop n addq 1 0
                  | Negz n =>
                      (-
                       match n with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as i).+1 => 1%Q + loop i
                               end) n)%Q
                       end)%Q
                  end)%Q)%Q +
                (((- rat_of_Z (BinNums.Zpos (BinNums.xO (BinNums.xO 1%AC))))%Q *
                  (match Su with
                   | Posz n => iterop n addq 1 0
                   | Negz n =>
                       (-
                        match n with
                        | 0 => 1%Q
                        | _.+1 =>
                            (1%Q +
                             (fix loop (m : nat) : rat :=
                                match m with
                                | 0 => 0
                                | 1 => 1
                                | (_.+1 as i).+1 => 1%Q + loop i
                                end) n)%Q
                        end)%Q
                   end *
                   (match Su with
                    | Posz n => iterop n addq 1 0
                    | Negz n =>
                        (-
                         match n with
                         | 0 => 1%Q
                         | _.+1 =>
                             (1%Q +
                              (fix loop (m : nat) : rat :=
                                 match m with
                                 | 0 => 0
                                 | 1 => 1
                                 | (_.+1 as i).+1 => 1%Q + loop i
                                 end) n)%Q
                         end)%Q
                    end *
                    match Su with
                    | Posz n => iterop n addq 1 0
                    | Negz n =>
                        (-
                         match n with
                         | 0 => 1%Q
                         | _.+1 =>
                             (1%Q +
                              (fix loop (m : nat) : rat :=
                                 match m with
                                 | 0 => 0
                                 | 1 => 1
                                 | (_.+1 as i).+1 => 1%Q + loop i
                                 end) n)%Q
                         end)%Q
                    end)%Q)%Q)%Q *
                 match transG with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end)%Q)%Q +
               (-
                match Su with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 => 1%Q + loop i
                             end) n)%Q
                     end)%Q
                end)%Q)%Q +
              ((- rat_of_Z (BinNums.Zpos (BinNums.xI (BinNums.xI 1%AC))))%Q *
               match transG with
               | Posz n => iterop n addq 1 0
               | Negz n =>
                   (-
                    match n with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 => 1%Q + loop i
                            end) n)%Q
                    end)%Q
               end)%Q)%Q *
             ((((match transG with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q *
                ((match transG with
                  | Posz n => iterop n addq 1 0
                  | Negz n =>
                      (-
                       match n with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as i).+1 => 1%Q + loop i
                               end) n)%Q
                       end)%Q
                  end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q *
                 (match transG with
                  | Posz n => iterop n addq 1 0
                  | Negz n =>
                      (-
                       match n with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as i).+1 => 1%Q + loop i
                               end) n)%Q
                       end)%Q
                  end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q)%Q)%Q *
               ((match transG with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q +
                match Su with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 => 1%Q + loop i
                             end) n)%Q
                     end)%Q
                end)%Q)%Q^-1)%Q)%Q * (ghn3 transG + s transG Su)%Q)%Q +
           (((((rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)) *
                match transG with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 => 1%Q + loop i
                             end) n)%Q
                     end)%Q
                end)%Q + rat_of_Z (BinNums.Zpos (BinNums.xI 1%AC)))%Q *
              (((match transG with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end *
                 match transG with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end)%Q +
                (rat_of_Z (BinNums.Zpos (BinNums.xI 1%AC)) *
                 match transG with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end)%Q)%Q + rat_of_Z (BinNums.Zpos (BinNums.xI 1%AC)))%Q)%Q *
             (((match transG with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 => 1%Q + loop i
                             end) n)%Q
                     end)%Q
                end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q *
               ((match transG with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q *
                (match transG with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q)%Q)%Q^-1)%Q)%Q *
            (ghn3 (intZmod.addz transG 1) + s (intZmod.addz transG 1) Su)%Q)%Q)%Q +
          ((((((rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)) *
                match Su with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 => 1%Q + loop i
                             end) n)%Q
                     end)%Q
                end)%Q *
               ((rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)) *
                 match transG with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end)%Q + rat_of_Z (BinNums.Zpos (BinNums.xI 1%AC)))%Q)%Q *
              (match Su with
               | Posz n => iterop n addq 1 0
               | Negz n =>
                   (-
                    match n with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 => 1%Q + loop i
                            end) n)%Q
                    end)%Q
               end + rat_of_Z (BinNums.Zpos 1%AC))%Q)%Q *
             ((-
               match transG with
               | Posz n => iterop n addq 1 0
               | Negz n =>
                   (-
                    match n with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 => 1%Q + loop i
                            end) n)%Q
                    end)%Q
               end)%Q +
              match Su with
              | Posz n => iterop n addq 1 0
              | Negz n =>
                  (-
                   match n with
                   | 0 => 1%Q
                   | _.+1 =>
                       (1%Q +
                        (fix loop (m : nat) : rat :=
                           match m with
                           | 0 => 0
                           | 1 => 1
                           | (_.+1 as i).+1 => 1%Q + loop i
                           end) n)%Q
                   end)%Q
              end)%Q)%Q *
            ((((match transG with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 => 1%Q + loop i
                             end) n)%Q
                     end)%Q
                end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q *
               ((match transG with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q *
                (match transG with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q)%Q)%Q *
              ((match transG with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 => 1%Q + loop i
                             end) n)%Q
                     end)%Q
                end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q +
               match Su with
               | Posz n => iterop n addq 1 0
               | Negz n =>
                   (-
                    match n with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 => 1%Q + loop i
                            end) n)%Q
                    end)%Q
               end)%Q)%Q^-1)%Q)%Q *
           (ghn3 transG + s transG (intZmod.addz Su 1))%Q)%Q)%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching:
(pr_Ps (fun rnds : list R => isNone (iterate rnds H1) = true) H (Hf ^ H))
Crunching:
(∣1⟩ ⊗ (fun i j : nat => if (i =? n) && (j =? 0) then C1 else 0%R) =
 (fun i j : nat => if (i =? n + a) && (j =? 0) then C1 else 0%R))
Crunching:
(∣1⟩ ⊗ (fun i j : nat => if (i =? n) && (j =? 0) then C1 else 0%R) =
 (fun i j : nat => if (i =? n + a) && (j =? 0) then C1 else 0%R))
Crunching:
(∣1⟩ ⊗ (fun i j : nat => if (i =? H) && (j =? 0) then C1 else 0%R) =
 (fun i j : nat => if (i =? H + r) && (j =? 0) then C1 else 0%R))
Crunching:
(∣1⟩ ⊗ (fun i j : nat => if (i =? H) && (j =? 0) then C1 else 0%R) =
 (fun i j : nat => if (i =? H + r) && (j =? 0) then C1 else 0%R))
Crunching:
(∣1⟩ ⊗ (fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) =
 (fun i j : nat => if (i =? k + n) && (j =? 0) then C1 else 0%R))
Crunching:
((0%R * (if x mod n =? k then C1 else 0%R))%C =
 (if x =? k + n then C1 else 0%R))
Debug:
In environment
transG, Su : int
le_nm : annotated_recs_s.precond.Sn2 transG Su
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: (ghn3 (intZmod.addz (intZmod.addz transG 1) 1) +
          s (intZmod.addz (intZmod.addz transG 1) 1) Su)%Q;
         ((((((((((((((((((- rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q +
                          ((- rat_of_Z (BinNums.Zpos (BinNums.xI (...))))%Q *
                           (match transG with
                            | Posz n => iterop n addq 1 0
                            | Negz n =>
                                (- match ... with
                                   | ... 1%Q
                                   | ... ...%Q
                                   end)%Q
                            end *
                            match transG with
                            | Posz n => iterop n addq 1 0
                            | Negz n =>
                                (- match ... with
                                   | ... 1%Q
                                   | ... ...%Q
                                   end)%Q
                            end)%Q)%Q)%Q +
                         ((rat_of_Z (BinNums.Zpos (BinNums.xI 1%AC)) *
                           match Su with
                           | Posz n => iterop n addq 1 0
                           | Negz n =>
                               (-
                                match n with
                                | 0 => 1%Q
                                | _.+1 => (1%Q + ...)%Q
                                end)%Q
                           end)%Q *
                          match transG with
                          | Posz n => iterop n addq 1 0
                          | Negz n =>
                              (-
                               match n with
                               | 0 => 1%Q
                               | _.+1 => (1%Q + (...) n)%Q
                               end)%Q
                          end)%Q)%Q +
                        ((-
                          rat_of_Z
                            (BinNums.Zpos (BinNums.xO (BinNums.xI 1%AC))))%Q *
                         (match Su with
                          | Posz n => iterop n addq 1 0
                          | Negz n =>
                              (-
                               match n with
                               | 0 => 1%Q
                               | _.+1 => (1%Q + (...) n)%Q
                               end)%Q
                          end *
                          match Su with
                          | Posz n => iterop n addq 1 0
                          | Negz n =>
                              (-
                               match n with
                               | 0 => 1%Q
                               | _.+1 => (1%Q + (...) n)%Q
                               end)%Q
                          end)%Q)%Q)%Q +
                       (-
                        (match transG with
                         | Posz n => iterop n addq 1 0
                         | Negz n =>
                             (-
                              match n with
                              | 0 => 1%Q
                              | _.+1 =>
                                  (1%Q +
                                   (fix loop ... : rat := ...
                                                 ...
                                                 ...
                                                 ...
                                                 end) n)%Q
                              end)%Q
                         end *
                         (match transG with
                          | Posz n => iterop n addq 1 0
                          | Negz n =>
                              (-
                               match n with
                               | 0 => 1%Q
                               | _.+1 => (1%Q + (...) n)%Q
                               end)%Q
                          end *
                          (match transG with
                           | Posz n => iterop n addq 1 0
                           | Negz n =>
                               (-
                                match n with
                                | 0 => 1%Q
                                | _.+1 => (1%Q + ...)%Q
                                end)%Q
                           end *
                           match transG with
                           | Posz n => iterop n addq 1 0
                           | Negz n =>
                               (-
                                match n with
                                | 0 => 1%Q
                                | _.+1 => (1%Q + ...)%Q
                                end)%Q
                           end)%Q)%Q)%Q)%Q)%Q +
                      ((-
                        rat_of_Z
                          (BinNums.Zpos (BinNums.xI (BinNums.xO 1%AC))))%Q *
                       (match transG with
                        | Posz n => iterop n addq 1 0
                        | Negz n =>
                            (-
                             match n with
                             | 0 => 1%Q
                             | _.+1 =>
                                 (1%Q +
                                  (fix loop (m : nat) : rat :=
                                     match ... with
                                     | ... => 0
                                     | ... => 1
                                     | ... => 1%Q + ...
                                     end) n)%Q
                             end)%Q
                        end *
                        (match transG with
                         | Posz n => iterop n addq 1 0
                         | Negz n =>
                             (-
                              match n with
                              | 0 => 1%Q
                              | _.+1 =>
                                  (1%Q +
                                   (fix loop ... : rat := ...
                                                 ...
                                                 ...
                                                 ...
                                                 end) n)%Q
                              end)%Q
                         end *
                         match transG with
                         | Posz n => iterop n addq 1 0
                         | Negz n =>
                             (-
                              match n with
                              | 0 => 1%Q
                              | _.+1 =>
                                  (1%Q +
                                   (fix loop ... : rat := ...
                                                 ...
                                                 ...
                                                 ...
                                                 end) n)%Q
                              end)%Q
                         end)%Q)%Q)%Q)%Q +
                     ((-
                       rat_of_Z (BinNums.Zpos (BinNums.xO (BinNums.xI 1%AC))))%Q *
                      (match Su with
                       | Posz n => iterop n addq 1 0
                       | Negz n =>
                           (-
                            match n with
                            | 0 => 1%Q
                            | _.+1 =>
                                (1%Q +
                                 (fix loop (m : nat) : rat :=
                                    match m with
                                    | 0 => 0
                                    | 1 => 1
                                    | (_.+1 as i).+1 => 1%Q + loop i
                                    end) n)%Q
                            end)%Q
                       end *
                       (match Su with
                        | Posz n => iterop n addq 1 0
                        | Negz n =>
                            (-
                             match n with
                             | 0 => 1%Q
                             | _.+1 =>
                                 (1%Q +
                                  (fix loop (m : nat) : rat :=
                                     match ... with
                                     | ... => 0
                                     | ... => 1
                                     | ... => 1%Q + ...
                                     end) n)%Q
                             end)%Q
                        end *
                        match Su with
                        | Posz n => iterop n addq 1 0
                        | Negz n =>
                            (-
                             match n with
                             | 0 => 1%Q
                             | _.+1 =>
                                 (1%Q +
                                  (fix loop (m : nat) : rat :=
                                     match ... with
                                     | ... => 0
                                     | ... => 1
                                     | ... => 1%Q + ...
                                     end) n)%Q
                             end)%Q
                        end)%Q)%Q)%Q)%Q +
                    ((-
                      match Su with
                      | Posz n => iterop n addq 1 0
                      | Negz n =>
                          (-
                           match n with
                           | 0 => 1%Q
                           | _.+1 =>
                               (1%Q +
                                (fix loop (m : nat) : rat :=
                                   match m with
                                   | 0 => 0
                                   | 1 => 1
                                   | (_.+1 as i).+1 => 1%Q + loop i
                                   end) n)%Q
                           end)%Q
                      end)%Q *
                     (match transG with
                      | Posz n => iterop n addq 1 0
                      | Negz n =>
                          (-
                           match n with
                           | 0 => 1%Q
                           | _.+1 =>
                               (1%Q +
                                (fix loop (m : nat) : rat :=
                                   match m with
                                   | 0 => 0
                                   | 1 => 1
                                   | (_.+1 as i).+1 => 1%Q + loop i
                                   end) n)%Q
                           end)%Q
                      end *
                      (match transG with
                       | Posz n => iterop n addq 1 0
                       | Negz n =>
                           (-
                            match n with
                            | 0 => 1%Q
                            | _.+1 =>
                                (1%Q +
                                 (fix loop (m : nat) : rat :=
                                    match m with
                                    | 0 => 0
                                    | 1 => 1
                                    | (_.+1 as i).+1 => 1%Q + loop i
                                    end) n)%Q
                            end)%Q
                       end *
                       match transG with
                       | Posz n => iterop n addq 1 0
                       | Negz n =>
                           (-
                            match n with
                            | 0 => 1%Q
                            | _.+1 =>
                                (1%Q +
                                 (fix loop (m : nat) : rat :=
                                    match m with
                                    | 0 => 0
                                    | 1 => 1
                                    | (_.+1 as i).+1 => 1%Q + loop i
                                    end) n)%Q
                            end)%Q
                       end)%Q)%Q)%Q)%Q +
                   (match Su with
                    | Posz n => iterop n addq 1 0
                    | Negz n =>
                        (-
                         match n with
                         | 0 => 1%Q
                         | _.+1 =>
                             (1%Q +
                              (fix loop (m : nat) : rat :=
                                 match m with
                                 | 0 => 0
                                 | 1 => 1
                                 | (_.+1 as i).+1 => 1%Q + loop i
                                 end) n)%Q
                         end)%Q
                    end *
                    (match transG with
                     | Posz n => iterop n addq 1 0
                     | Negz n =>
                         (-
                          match n with
                          | 0 => 1%Q
                          | _.+1 =>
                              (1%Q +
                               (fix loop (m : nat) : rat :=
                                  match m with
                                  | 0 => 0
                                  | 1 => 1
                                  | (_.+1 as i).+1 => 1%Q + loop i
                                  end) n)%Q
                          end)%Q
                     end *
                     match transG with
                     | Posz n => iterop n addq 1 0
                     | Negz n =>
                         (-
                          match n with
                          | 0 => 1%Q
                          | _.+1 =>
                              (1%Q +
                               (fix loop (m : nat) : rat :=
                                  match m with
                                  | 0 => 0
                                  | 1 => 1
                                  | (_.+1 as i).+1 => 1%Q + loop i
                                  end) n)%Q
                          end)%Q
                     end)%Q)%Q)%Q +
                  ((rat_of_Z (BinNums.Zpos (BinNums.xO (BinNums.xO 1%AC))) *
                    (match Su with
                     | Posz n => iterop n addq 1 0
                     | Negz n =>
                         (-
                          match n with
                          | 0 => 1%Q
                          | _.+1 =>
                              (1%Q +
                               (fix loop (m : nat) : rat :=
                                  match m with
                                  | 0 => 0
                                  | 1 => 1
                                  | (_.+1 as i).+1 => 1%Q + loop i
                                  end) n)%Q
                          end)%Q
                     end *
                     match Su with
                     | Posz n => iterop n addq 1 0
                     | Negz n =>
                         (-
                          match n with
                          | 0 => 1%Q
                          | _.+1 =>
                              (1%Q +
                               (fix loop (m : nat) : rat :=
                                  match m with
                                  | 0 => 0
                                  | 1 => 1
                                  | (_.+1 as i).+1 => 1%Q + loop i
                                  end) n)%Q
                          end)%Q
                     end)%Q)%Q *
                   (match transG with
                    | Posz n => iterop n addq 1 0
                    | Negz n =>
                        (-
                         match n with
                         | 0 => 1%Q
                         | _.+1 =>
                             (1%Q +
                              (fix loop (m : nat) : rat :=
                                 match m with
                                 | 0 => 0
                                 | 1 => 1
                                 | (_.+1 as i).+1 => 1%Q + loop i
                                 end) n)%Q
                         end)%Q
                    end *
                    match transG with
                    | Posz n => iterop n addq 1 0
                    | Negz n =>
                        (-
                         match n with
                         | 0 => 1%Q
                         | _.+1 =>
                             (1%Q +
                              (fix loop (m : nat) : rat :=
                                 match m with
                                 | 0 => 0
                                 | 1 => 1
                                 | (_.+1 as i).+1 => 1%Q + loop i
                                 end) n)%Q
                         end)%Q
                    end)%Q)%Q)%Q +
                 ((rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)) *
                   (match Su with
                    | Posz n => iterop n addq 1 0
                    | Negz n =>
                        (-
                         match n with
                         | 0 => 1%Q
                         | _.+1 =>
                             (1%Q +
                              (fix loop (m : nat) : rat :=
                                 match m with
                                 | 0 => 0
                                 | 1 => 1
                                 | (_.+1 as i).+1 => 1%Q + loop i
                                 end) n)%Q
                         end)%Q
                    end *
                    match Su with
                    | Posz n => iterop n addq 1 0
                    | Negz n =>
                        (-
                         match n with
                         | 0 => 1%Q
                         | _.+1 =>
                             (1%Q +
                              (fix loop (m : nat) : rat :=
                                 match m with
                                 | 0 => 0
                                 | 1 => 1
                                 | (_.+1 as i).+1 => 1%Q + loop i
                                 end) n)%Q
                         end)%Q
                    end)%Q)%Q *
                  match transG with
                  | Posz n => iterop n addq 1 0
                  | Negz n =>
                      (-
                       match n with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as i).+1 => 1%Q + loop i
                               end) n)%Q
                       end)%Q
                  end)%Q)%Q +
                (((- rat_of_Z (BinNums.Zpos (BinNums.xO (BinNums.xO 1%AC))))%Q *
                  (match Su with
                   | Posz n => iterop n addq 1 0
                   | Negz n =>
                       (-
                        match n with
                        | 0 => 1%Q
                        | _.+1 =>
                            (1%Q +
                             (fix loop (m : nat) : rat :=
                                match m with
                                | 0 => 0
                                | 1 => 1
                                | (_.+1 as i).+1 => 1%Q + loop i
                                end) n)%Q
                        end)%Q
                   end *
                   (match Su with
                    | Posz n => iterop n addq 1 0
                    | Negz n =>
                        (-
                         match n with
                         | 0 => 1%Q
                         | _.+1 =>
                             (1%Q +
                              (fix loop (m : nat) : rat :=
                                 match m with
                                 | 0 => 0
                                 | 1 => 1
                                 | (_.+1 as i).+1 => 1%Q + loop i
                                 end) n)%Q
                         end)%Q
                    end *
                    match Su with
                    | Posz n => iterop n addq 1 0
                    | Negz n =>
                        (-
                         match n with
                         | 0 => 1%Q
                         | _.+1 =>
                             (1%Q +
                              (fix loop (m : nat) : rat :=
                                 match m with
                                 | 0 => 0
                                 | 1 => 1
                                 | (_.+1 as i).+1 => 1%Q + loop i
                                 end) n)%Q
                         end)%Q
                    end)%Q)%Q)%Q *
                 match transG with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end)%Q)%Q +
               (-
                match Su with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 => 1%Q + loop i
                             end) n)%Q
                     end)%Q
                end)%Q)%Q +
              ((- rat_of_Z (BinNums.Zpos (BinNums.xI (BinNums.xI 1%AC))))%Q *
               match transG with
               | Posz n => iterop n addq 1 0
               | Negz n =>
                   (-
                    match n with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 => 1%Q + loop i
                            end) n)%Q
                    end)%Q
               end)%Q)%Q *
             ((((match transG with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q *
                ((match transG with
                  | Posz n => iterop n addq 1 0
                  | Negz n =>
                      (-
                       match n with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as i).+1 => 1%Q + loop i
                               end) n)%Q
                       end)%Q
                  end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q *
                 (match transG with
                  | Posz n => iterop n addq 1 0
                  | Negz n =>
                      (-
                       match n with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as i).+1 => 1%Q + loop i
                               end) n)%Q
                       end)%Q
                  end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q)%Q)%Q *
               ((match transG with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q +
                match Su with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 => 1%Q + loop i
                             end) n)%Q
                     end)%Q
                end)%Q)%Q^-1)%Q)%Q * (ghn3 transG + s transG Su)%Q)%Q +
           (((((rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)) *
                match transG with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 => 1%Q + loop i
                             end) n)%Q
                     end)%Q
                end)%Q + rat_of_Z (BinNums.Zpos (BinNums.xI 1%AC)))%Q *
              (((match transG with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end *
                 match transG with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end)%Q +
                (rat_of_Z (BinNums.Zpos (BinNums.xI 1%AC)) *
                 match transG with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end)%Q)%Q + rat_of_Z (BinNums.Zpos (BinNums.xI 1%AC)))%Q)%Q *
             (((match transG with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 => 1%Q + loop i
                             end) n)%Q
                     end)%Q
                end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q *
               ((match transG with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q *
                (match transG with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q)%Q)%Q^-1)%Q)%Q *
            (ghn3 (intZmod.addz transG 1) + s (intZmod.addz transG 1) Su)%Q)%Q)%Q +
          ((((((rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)) *
                match Su with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 => 1%Q + loop i
                             end) n)%Q
                     end)%Q
                end)%Q *
               ((rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)) *
                 match transG with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end)%Q + rat_of_Z (BinNums.Zpos (BinNums.xI 1%AC)))%Q)%Q *
              (match Su with
               | Posz n => iterop n addq 1 0
               | Negz n =>
                   (-
                    match n with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 => 1%Q + loop i
                            end) n)%Q
                    end)%Q
               end + rat_of_Z (BinNums.Zpos 1%AC))%Q)%Q *
             ((-
               match transG with
               | Posz n => iterop n addq 1 0
               | Negz n =>
                   (-
                    match n with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 => 1%Q + loop i
                            end) n)%Q
                    end)%Q
               end)%Q +
              match Su with
              | Posz n => iterop n addq 1 0
              | Negz n =>
                  (-
                   match n with
                   | 0 => 1%Q
                   | _.+1 =>
                       (1%Q +
                        (fix loop (m : nat) : rat :=
                           match m with
                           | 0 => 0
                           | 1 => 1
                           | (_.+1 as i).+1 => 1%Q + loop i
                           end) n)%Q
                   end)%Q
              end)%Q)%Q *
            ((((match transG with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 => 1%Q + loop i
                             end) n)%Q
                     end)%Q
                end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q *
               ((match transG with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q *
                (match transG with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q)%Q)%Q *
              ((match transG with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 => 1%Q + loop i
                             end) n)%Q
                     end)%Q
                end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q +
               match Su with
               | Posz n => iterop n addq 1 0
               | Negz n =>
                   (-
                    match n with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 => 1%Q + loop i
                            end) n)%Q
                    end)%Q
               end)%Q)%Q^-1)%Q)%Q *
           (ghn3 transG + s transG (intZmod.addz Su 1))%Q)%Q)%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
"notwFunext has been translated as notwFunextᵗ"
"idpath has been translated as idpathᵗ"
Crunching:
((match (0 / n)%nat with
  | 1 => C1
  | _ => 0%R
  end * (if 0 mod n =? k then C1 else 0%R))%C =
 (if 0 =? k + n then C1 else 0%R))
Debug:
In environment
transG, Su : int
i : annotated_recs_s.precond.Sn2 transG Su
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: (ghn3 (intZmod.addz (intZmod.addz transG 1) 1) +
          s (intZmod.addz (intZmod.addz transG 1) 1) Su)%Q;
         ((((((((((((((((((- rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q +
                          ((- rat_of_Z (BinNums.Zpos (BinNums.xI (...))))%Q *
                           (match transG with
                            | Posz n => iterop n addq 1 0
                            | Negz n =>
                                (- match ... with
                                   | ... 1%Q
                                   | ... ...%Q
                                   end)%Q
                            end *
                            match transG with
                            | Posz n => iterop n addq 1 0
                            | Negz n =>
                                (- match ... with
                                   | ... 1%Q
                                   | ... ...%Q
                                   end)%Q
                            end)%Q)%Q)%Q +
                         ((rat_of_Z (BinNums.Zpos (BinNums.xI 1%AC)) *
                           match Su with
                           | Posz n => iterop n addq 1 0
                           | Negz n =>
                               (-
                                match n with
                                | 0 => 1%Q
                                | _.+1 => (1%Q + ...)%Q
                                end)%Q
                           end)%Q *
                          match transG with
                          | Posz n => iterop n addq 1 0
                          | Negz n =>
                              (-
                               match n with
                               | 0 => 1%Q
                               | _.+1 => (1%Q + (...) n)%Q
                               end)%Q
                          end)%Q)%Q +
                        ((-
                          rat_of_Z
                            (BinNums.Zpos (BinNums.xO (BinNums.xI 1%AC))))%Q *
                         (match Su with
                          | Posz n => iterop n addq 1 0
                          | Negz n =>
                              (-
                               match n with
                               | 0 => 1%Q
                               | _.+1 => (1%Q + (...) n)%Q
                               end)%Q
                          end *
                          match Su with
                          | Posz n => iterop n addq 1 0
                          | Negz n =>
                              (-
                               match n with
                               | 0 => 1%Q
                               | _.+1 => (1%Q + (...) n)%Q
                               end)%Q
                          end)%Q)%Q)%Q +
                       (-
                        (match transG with
                         | Posz n => iterop n addq 1 0
                         | Negz n =>
                             (-
                              match n with
                              | 0 => 1%Q
                              | _.+1 =>
                                  (1%Q +
                                   (fix loop ... : rat := ...
                                                 ...
                                                 ...
                                                 ...
                                                 end) n)%Q
                              end)%Q
                         end *
                         (match transG with
                          | Posz n => iterop n addq 1 0
                          | Negz n =>
                              (-
                               match n with
                               | 0 => 1%Q
                               | _.+1 => (1%Q + (...) n)%Q
                               end)%Q
                          end *
                          (match transG with
                           | Posz n => iterop n addq 1 0
                           | Negz n =>
                               (-
                                match n with
                                | 0 => 1%Q
                                | _.+1 => (1%Q + ...)%Q
                                end)%Q
                           end *
                           match transG with
                           | Posz n => iterop n addq 1 0
                           | Negz n =>
                               (-
                                match n with
                                | 0 => 1%Q
                                | _.+1 => (1%Q + ...)%Q
                                end)%Q
                           end)%Q)%Q)%Q)%Q)%Q +
                      ((-
                        rat_of_Z
                          (BinNums.Zpos (BinNums.xI (BinNums.xO 1%AC))))%Q *
                       (match transG with
                        | Posz n => iterop n addq 1 0
                        | Negz n =>
                            (-
                             match n with
                             | 0 => 1%Q
                             | _.+1 =>
                                 (1%Q +
                                  (fix loop (m : nat) : rat :=
                                     match ... with
                                     | ... => 0
                                     | ... => 1
                                     | ... => 1%Q + ...
                                     end) n)%Q
                             end)%Q
                        end *
                        (match transG with
                         | Posz n => iterop n addq 1 0
                         | Negz n =>
                             (-
                              match n with
                              | 0 => 1%Q
                              | _.+1 =>
                                  (1%Q +
                                   (fix loop ... : rat := ...
                                                 ...
                                                 ...
                                                 ...
                                                 end) n)%Q
                              end)%Q
                         end *
                         match transG with
                         | Posz n => iterop n addq 1 0
                         | Negz n =>
                             (-
                              match n with
                              | 0 => 1%Q
                              | _.+1 =>
                                  (1%Q +
                                   (fix loop ... : rat := ...
                                                 ...
                                                 ...
                                                 ...
                                                 end) n)%Q
                              end)%Q
                         end)%Q)%Q)%Q)%Q +
                     ((-
                       rat_of_Z (BinNums.Zpos (BinNums.xO (BinNums.xI 1%AC))))%Q *
                      (match Su with
                       | Posz n => iterop n addq 1 0
                       | Negz n =>
                           (-
                            match n with
                            | 0 => 1%Q
                            | _.+1 =>
                                (1%Q +
                                 (fix loop (m : nat) : rat :=
                                    match m with
                                    | 0 => 0
                                    | 1 => 1
                                    | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                        1%Q + loop elpi_ctx_entry_7_
                                    end) n)%Q
                            end)%Q
                       end *
                       (match Su with
                        | Posz n => iterop n addq 1 0
                        | Negz n =>
                            (-
                             match n with
                             | 0 => 1%Q
                             | _.+1 =>
                                 (1%Q +
                                  (fix loop (m : nat) : rat :=
                                     match ... with
                                     | ... => 0
                                     | ... => 1
                                     | ... => 1%Q + ...
                                     end) n)%Q
                             end)%Q
                        end *
                        match Su with
                        | Posz n => iterop n addq 1 0
                        | Negz n =>
                            (-
                             match n with
                             | 0 => 1%Q
                             | _.+1 =>
                                 (1%Q +
                                  (fix loop (m : nat) : rat :=
                                     match ... with
                                     | ... => 0
                                     | ... => 1
                                     | ... => 1%Q + ...
                                     end) n)%Q
                             end)%Q
                        end)%Q)%Q)%Q)%Q +
                    ((-
                      match Su with
                      | Posz n => iterop n addq 1 0
                      | Negz n =>
                          (-
                           match n with
                           | 0 => 1%Q
                           | _.+1 =>
                               (1%Q +
                                (fix loop (m : nat) : rat :=
                                   match m with
                                   | 0 => 0
                                   | 1 => 1
                                   | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                       1%Q + loop elpi_ctx_entry_7_
                                   end) n)%Q
                           end)%Q
                      end)%Q *
                     (match transG with
                      | Posz n => iterop n addq 1 0
                      | Negz n =>
                          (-
                           match n with
                           | 0 => 1%Q
                           | _.+1 =>
                               (1%Q +
                                (fix loop (m : nat) : rat :=
                                   match m with
                                   | 0 => 0
                                   | 1 => 1
                                   | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                       1%Q + loop elpi_ctx_entry_7_
                                   end) n)%Q
                           end)%Q
                      end *
                      (match transG with
                       | Posz n => iterop n addq 1 0
                       | Negz n =>
                           (-
                            match n with
                            | 0 => 1%Q
                            | _.+1 =>
                                (1%Q +
                                 (fix loop (m : nat) : rat :=
                                    match m with
                                    | 0 => 0
                                    | 1 => 1
                                    | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                        1%Q + loop elpi_ctx_entry_7_
                                    end) n)%Q
                            end)%Q
                       end *
                       match transG with
                       | Posz n => iterop n addq 1 0
                       | Negz n =>
                           (-
                            match n with
                            | 0 => 1%Q
                            | _.+1 =>
                                (1%Q +
                                 (fix loop (m : nat) : rat :=
                                    match m with
                                    | 0 => 0
                                    | 1 => 1
                                    | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                        1%Q + loop elpi_ctx_entry_7_
                                    end) n)%Q
                            end)%Q
                       end)%Q)%Q)%Q)%Q +
                   (match Su with
                    | Posz n => iterop n addq 1 0
                    | Negz n =>
                        (-
                         match n with
                         | 0 => 1%Q
                         | _.+1 =>
                             (1%Q +
                              (fix loop (m : nat) : rat :=
                                 match m with
                                 | 0 => 0
                                 | 1 => 1
                                 | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                     1%Q + loop elpi_ctx_entry_7_
                                 end) n)%Q
                         end)%Q
                    end *
                    (match transG with
                     | Posz n => iterop n addq 1 0
                     | Negz n =>
                         (-
                          match n with
                          | 0 => 1%Q
                          | _.+1 =>
                              (1%Q +
                               (fix loop (m : nat) : rat :=
                                  match m with
                                  | 0 => 0
                                  | 1 => 1
                                  | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                      1%Q + loop elpi_ctx_entry_7_
                                  end) n)%Q
                          end)%Q
                     end *
                     match transG with
                     | Posz n => iterop n addq 1 0
                     | Negz n =>
                         (-
                          match n with
                          | 0 => 1%Q
                          | _.+1 =>
                              (1%Q +
                               (fix loop (m : nat) : rat :=
                                  match m with
                                  | 0 => 0
                                  | 1 => 1
                                  | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                      1%Q + loop elpi_ctx_entry_7_
                                  end) n)%Q
                          end)%Q
                     end)%Q)%Q)%Q +
                  ((rat_of_Z (BinNums.Zpos (BinNums.xO (BinNums.xO 1%AC))) *
                    (match Su with
                     | Posz n => iterop n addq 1 0
                     | Negz n =>
                         (-
                          match n with
                          | 0 => 1%Q
                          | _.+1 =>
                              (1%Q +
                               (fix loop (m : nat) : rat :=
                                  match m with
                                  | 0 => 0
                                  | 1 => 1
                                  | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                      1%Q + loop elpi_ctx_entry_7_
                                  end) n)%Q
                          end)%Q
                     end *
                     match Su with
                     | Posz n => iterop n addq 1 0
                     | Negz n =>
                         (-
                          match n with
                          | 0 => 1%Q
                          | _.+1 =>
                              (1%Q +
                               (fix loop (m : nat) : rat :=
                                  match m with
                                  | 0 => 0
                                  | 1 => 1
                                  | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                      1%Q + loop elpi_ctx_entry_7_
                                  end) n)%Q
                          end)%Q
                     end)%Q)%Q *
                   (match transG with
                    | Posz n => iterop n addq 1 0
                    | Negz n =>
                        (-
                         match n with
                         | 0 => 1%Q
                         | _.+1 =>
                             (1%Q +
                              (fix loop (m : nat) : rat :=
                                 match m with
                                 | 0 => 0
                                 | 1 => 1
                                 | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                     1%Q + loop elpi_ctx_entry_7_
                                 end) n)%Q
                         end)%Q
                    end *
                    match transG with
                    | Posz n => iterop n addq 1 0
                    | Negz n =>
                        (-
                         match n with
                         | 0 => 1%Q
                         | _.+1 =>
                             (1%Q +
                              (fix loop (m : nat) : rat :=
                                 match m with
                                 | 0 => 0
                                 | 1 => 1
                                 | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                     1%Q + loop elpi_ctx_entry_7_
                                 end) n)%Q
                         end)%Q
                    end)%Q)%Q)%Q +
                 ((rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)) *
                   (match Su with
                    | Posz n => iterop n addq 1 0
                    | Negz n =>
                        (-
                         match n with
                         | 0 => 1%Q
                         | _.+1 =>
                             (1%Q +
                              (fix loop (m : nat) : rat :=
                                 match m with
                                 | 0 => 0
                                 | 1 => 1
                                 | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                     1%Q + loop elpi_ctx_entry_7_
                                 end) n)%Q
                         end)%Q
                    end *
                    match Su with
                    | Posz n => iterop n addq 1 0
                    | Negz n =>
                        (-
                         match n with
                         | 0 => 1%Q
                         | _.+1 =>
                             (1%Q +
                              (fix loop (m : nat) : rat :=
                                 match m with
                                 | 0 => 0
                                 | 1 => 1
                                 | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                     1%Q + loop elpi_ctx_entry_7_
                                 end) n)%Q
                         end)%Q
                    end)%Q)%Q *
                  match transG with
                  | Posz n => iterop n addq 1 0
                  | Negz n =>
                      (-
                       match n with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                   1%Q + loop elpi_ctx_entry_7_
                               end) n)%Q
                       end)%Q
                  end)%Q)%Q +
                (((- rat_of_Z (BinNums.Zpos (BinNums.xO (BinNums.xO 1%AC))))%Q *
                  (match Su with
                   | Posz n => iterop n addq 1 0
                   | Negz n =>
                       (-
                        match n with
                        | 0 => 1%Q
                        | _.+1 =>
                            (1%Q +
                             (fix loop (m : nat) : rat :=
                                match m with
                                | 0 => 0
                                | 1 => 1
                                | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                    1%Q + loop elpi_ctx_entry_7_
                                end) n)%Q
                        end)%Q
                   end *
                   (match Su with
                    | Posz n => iterop n addq 1 0
                    | Negz n =>
                        (-
                         match n with
                         | 0 => 1%Q
                         | _.+1 =>
                             (1%Q +
                              (fix loop (m : nat) : rat :=
                                 match m with
                                 | 0 => 0
                                 | 1 => 1
                                 | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                     1%Q + loop elpi_ctx_entry_7_
                                 end) n)%Q
                         end)%Q
                    end *
                    match Su with
                    | Posz n => iterop n addq 1 0
                    | Negz n =>
                        (-
                         match n with
                         | 0 => 1%Q
                         | _.+1 =>
                             (1%Q +
                              (fix loop (m : nat) : rat :=
                                 match m with
                                 | 0 => 0
                                 | 1 => 1
                                 | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                     1%Q + loop elpi_ctx_entry_7_
                                 end) n)%Q
                         end)%Q
                    end)%Q)%Q)%Q *
                 match transG with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                  1%Q + loop elpi_ctx_entry_7_
                              end) n)%Q
                      end)%Q
                 end)%Q)%Q +
               (-
                match Su with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                 1%Q + loop elpi_ctx_entry_7_
                             end) n)%Q
                     end)%Q
                end)%Q)%Q +
              ((- rat_of_Z (BinNums.Zpos (BinNums.xI (BinNums.xI 1%AC))))%Q *
               match transG with
               | Posz n => iterop n addq 1 0
               | Negz n =>
                   (-
                    match n with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                1%Q + loop elpi_ctx_entry_7_
                            end) n)%Q
                    end)%Q
               end)%Q)%Q *
             ((((match transG with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                  1%Q + loop elpi_ctx_entry_7_
                              end) n)%Q
                      end)%Q
                 end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q *
                ((match transG with
                  | Posz n => iterop n addq 1 0
                  | Negz n =>
                      (-
                       match n with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                   1%Q + loop elpi_ctx_entry_7_
                               end) n)%Q
                       end)%Q
                  end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q *
                 (match transG with
                  | Posz n => iterop n addq 1 0
                  | Negz n =>
                      (-
                       match n with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                   1%Q + loop elpi_ctx_entry_7_
                               end) n)%Q
                       end)%Q
                  end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q)%Q)%Q *
               ((match transG with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                  1%Q + loop elpi_ctx_entry_7_
                              end) n)%Q
                      end)%Q
                 end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q +
                match Su with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                 1%Q + loop elpi_ctx_entry_7_
                             end) n)%Q
                     end)%Q
                end)%Q)%Q^-1)%Q)%Q * (ghn3 transG + s transG Su)%Q)%Q +
           (((((rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)) *
                match transG with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                 1%Q + loop elpi_ctx_entry_7_
                             end) n)%Q
                     end)%Q
                end)%Q + rat_of_Z (BinNums.Zpos (BinNums.xI 1%AC)))%Q *
              (((match transG with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                  1%Q + loop elpi_ctx_entry_7_
                              end) n)%Q
                      end)%Q
                 end *
                 match transG with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                  1%Q + loop elpi_ctx_entry_7_
                              end) n)%Q
                      end)%Q
                 end)%Q +
                (rat_of_Z (BinNums.Zpos (BinNums.xI 1%AC)) *
                 match transG with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                  1%Q + loop elpi_ctx_entry_7_
                              end) n)%Q
                      end)%Q
                 end)%Q)%Q + rat_of_Z (BinNums.Zpos (BinNums.xI 1%AC)))%Q)%Q *
             (((match transG with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                 1%Q + loop elpi_ctx_entry_7_
                             end) n)%Q
                     end)%Q
                end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q *
               ((match transG with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                  1%Q + loop elpi_ctx_entry_7_
                              end) n)%Q
                      end)%Q
                 end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q *
                (match transG with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                  1%Q + loop elpi_ctx_entry_7_
                              end) n)%Q
                      end)%Q
                 end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q)%Q)%Q^-1)%Q)%Q *
            (ghn3 (intZmod.addz transG 1) + s (intZmod.addz transG 1) Su)%Q)%Q)%Q +
          ((((((rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)) *
                match Su with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                 1%Q + loop elpi_ctx_entry_7_
                             end) n)%Q
                     end)%Q
                end)%Q *
               ((rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)) *
                 match transG with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                  1%Q + loop elpi_ctx_entry_7_
                              end) n)%Q
                      end)%Q
                 end)%Q + rat_of_Z (BinNums.Zpos (BinNums.xI 1%AC)))%Q)%Q *
              (match Su with
               | Posz n => iterop n addq 1 0
               | Negz n =>
                   (-
                    match n with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                1%Q + loop elpi_ctx_entry_7_
                            end) n)%Q
                    end)%Q
               end + rat_of_Z (BinNums.Zpos 1%AC))%Q)%Q *
             ((-
               match transG with
               | Posz n => iterop n addq 1 0
               | Negz n =>
                   (-
                    match n with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                1%Q + loop elpi_ctx_entry_7_
                            end) n)%Q
                    end)%Q
               end)%Q +
              match Su with
              | Posz n => iterop n addq 1 0
              | Negz n =>
                  (-
                   match n with
                   | 0 => 1%Q
                   | _.+1 =>
                       (1%Q +
                        (fix loop (m : nat) : rat :=
                           match m with
                           | 0 => 0
                           | 1 => 1
                           | (_.+1 as elpi_ctx_entry_7_).+1 =>
                               1%Q + loop elpi_ctx_entry_7_
                           end) n)%Q
                   end)%Q
              end)%Q)%Q *
            ((((match transG with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                 1%Q + loop elpi_ctx_entry_7_
                             end) n)%Q
                     end)%Q
                end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q *
               ((match transG with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                  1%Q + loop elpi_ctx_entry_7_
                              end) n)%Q
                      end)%Q
                 end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q *
                (match transG with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                  1%Q + loop elpi_ctx_entry_7_
                              end) n)%Q
                      end)%Q
                 end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q)%Q)%Q *
              ((match transG with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                 1%Q + loop elpi_ctx_entry_7_
                             end) n)%Q
                     end)%Q
                end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q +
               match Su with
               | Posz n => iterop n addq 1 0
               | Negz n =>
                   (-
                    match n with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                1%Q + loop elpi_ctx_entry_7_
                            end) n)%Q
                    end)%Q
               end)%Q)%Q^-1)%Q)%Q *
           (ghn3 transG + s transG (intZmod.addz Su 1))%Q)%Q)%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
transG, Su : int
RS' : annotated_recs_s.precond.Sn2 transG Su
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: u (int.shift 2 transG) Su; annotated_recs_s.Sn2_cf0_0 transG Su;
         u transG Su; annotated_recs_s.Sn2_cf1_0 transG Su;
         u (int.shift 1 transG) Su; annotated_recs_s.Sn2_cf0_1 transG Su;
         u transG (int.shift 1 Su)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
transG, Su : int
RS' : annotated_recs_s.precond.Sn2 transG Su
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: (ghn3 (intZmod.addz (intZmod.addz transG 1) 1) +
          s (intZmod.addz (intZmod.addz transG 1) 1) Su)%Q;
         ((((((((((((((((((- rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q +
                          ((- rat_of_Z (BinNums.Zpos (BinNums.xI (...))))%Q *
                           (match transG with
                            | Posz n => iterop n addq 1 0
                            | Negz n =>
                                (- match ... with
                                   | ... 1%Q
                                   | ... ...%Q
                                   end)%Q
                            end *
                            match transG with
                            | Posz n => iterop n addq 1 0
                            | Negz n =>
                                (- match ... with
                                   | ... 1%Q
                                   | ... ...%Q
                                   end)%Q
                            end)%Q)%Q)%Q +
                         ((rat_of_Z (BinNums.Zpos (BinNums.xI 1%AC)) *
                           match Su with
                           | Posz n => iterop n addq 1 0
                           | Negz n =>
                               (-
                                match n with
                                | 0 => 1%Q
                                | _.+1 => (1%Q + ...)%Q
                                end)%Q
                           end)%Q *
                          match transG with
                          | Posz n => iterop n addq 1 0
                          | Negz n =>
                              (-
                               match n with
                               | 0 => 1%Q
                               | _.+1 => (1%Q + (...) n)%Q
                               end)%Q
                          end)%Q)%Q +
                        ((-
                          rat_of_Z
                            (BinNums.Zpos (BinNums.xO (BinNums.xI 1%AC))))%Q *
                         (match Su with
                          | Posz n => iterop n addq 1 0
                          | Negz n =>
                              (-
                               match n with
                               | 0 => 1%Q
                               | _.+1 => (1%Q + (...) n)%Q
                               end)%Q
                          end *
                          match Su with
                          | Posz n => iterop n addq 1 0
                          | Negz n =>
                              (-
                               match n with
                               | 0 => 1%Q
                               | _.+1 => (1%Q + (...) n)%Q
                               end)%Q
                          end)%Q)%Q)%Q +
                       (-
                        (match transG with
                         | Posz n => iterop n addq 1 0
                         | Negz n =>
                             (-
                              match n with
                              | 0 => 1%Q
                              | _.+1 =>
                                  (1%Q +
                                   (fix loop ... : rat := ...
                                                 ...
                                                 ...
                                                 ...
                                                 end) n)%Q
                              end)%Q
                         end *
                         (match transG with
                          | Posz n => iterop n addq 1 0
                          | Negz n =>
                              (-
                               match n with
                               | 0 => 1%Q
                               | _.+1 => (1%Q + (...) n)%Q
                               end)%Q
                          end *
                          (match transG with
                           | Posz n => iterop n addq 1 0
                           | Negz n =>
                               (-
                                match n with
                                | 0 => 1%Q
                                | _.+1 => (1%Q + ...)%Q
                                end)%Q
                           end *
                           match transG with
                           | Posz n => iterop n addq 1 0
                           | Negz n =>
                               (-
                                match n with
                                | 0 => 1%Q
                                | _.+1 => (1%Q + ...)%Q
                                end)%Q
                           end)%Q)%Q)%Q)%Q)%Q +
                      ((-
                        rat_of_Z
                          (BinNums.Zpos (BinNums.xI (BinNums.xO 1%AC))))%Q *
                       (match transG with
                        | Posz n => iterop n addq 1 0
                        | Negz n =>
                            (-
                             match n with
                             | 0 => 1%Q
                             | _.+1 =>
                                 (1%Q +
                                  (fix loop (m : nat) : rat :=
                                     match ... with
                                     | ... => 0
                                     | ... => 1
                                     | ... => 1%Q + ...
                                     end) n)%Q
                             end)%Q
                        end *
                        (match transG with
                         | Posz n => iterop n addq 1 0
                         | Negz n =>
                             (-
                              match n with
                              | 0 => 1%Q
                              | _.+1 =>
                                  (1%Q +
                                   (fix loop ... : rat := ...
                                                 ...
                                                 ...
                                                 ...
                                                 end) n)%Q
                              end)%Q
                         end *
                         match transG with
                         | Posz n => iterop n addq 1 0
                         | Negz n =>
                             (-
                              match n with
                              | 0 => 1%Q
                              | _.+1 =>
                                  (1%Q +
                                   (fix loop ... : rat := ...
                                                 ...
                                                 ...
                                                 ...
                                                 end) n)%Q
                              end)%Q
                         end)%Q)%Q)%Q)%Q +
                     ((-
                       rat_of_Z (BinNums.Zpos (BinNums.xO (BinNums.xI 1%AC))))%Q *
                      (match Su with
                       | Posz n => iterop n addq 1 0
                       | Negz n =>
                           (-
                            match n with
                            | 0 => 1%Q
                            | _.+1 =>
                                (1%Q +
                                 (fix loop (m : nat) : rat :=
                                    match m with
                                    | 0 => 0
                                    | 1 => 1
                                    | (_.+1 as i).+1 => 1%Q + loop i
                                    end) n)%Q
                            end)%Q
                       end *
                       (match Su with
                        | Posz n => iterop n addq 1 0
                        | Negz n =>
                            (-
                             match n with
                             | 0 => 1%Q
                             | _.+1 =>
                                 (1%Q +
                                  (fix loop (m : nat) : rat :=
                                     match ... with
                                     | ... => 0
                                     | ... => 1
                                     | ... => 1%Q + ...
                                     end) n)%Q
                             end)%Q
                        end *
                        match Su with
                        | Posz n => iterop n addq 1 0
                        | Negz n =>
                            (-
                             match n with
                             | 0 => 1%Q
                             | _.+1 =>
                                 (1%Q +
                                  (fix loop (m : nat) : rat :=
                                     match ... with
                                     | ... => 0
                                     | ... => 1
                                     | ... => 1%Q + ...
                                     end) n)%Q
                             end)%Q
                        end)%Q)%Q)%Q)%Q +
                    ((-
                      match Su with
                      | Posz n => iterop n addq 1 0
                      | Negz n =>
                          (-
                           match n with
                           | 0 => 1%Q
                           | _.+1 =>
                               (1%Q +
                                (fix loop (m : nat) : rat :=
                                   match m with
                                   | 0 => 0
                                   | 1 => 1
                                   | (_.+1 as i).+1 => 1%Q + loop i
                                   end) n)%Q
                           end)%Q
                      end)%Q *
                     (match transG with
                      | Posz n => iterop n addq 1 0
                      | Negz n =>
                          (-
                           match n with
                           | 0 => 1%Q
                           | _.+1 =>
                               (1%Q +
                                (fix loop (m : nat) : rat :=
                                   match m with
                                   | 0 => 0
                                   | 1 => 1
                                   | (_.+1 as i).+1 => 1%Q + loop i
                                   end) n)%Q
                           end)%Q
                      end *
                      (match transG with
                       | Posz n => iterop n addq 1 0
                       | Negz n =>
                           (-
                            match n with
                            | 0 => 1%Q
                            | _.+1 =>
                                (1%Q +
                                 (fix loop (m : nat) : rat :=
                                    match m with
                                    | 0 => 0
                                    | 1 => 1
                                    | (_.+1 as i).+1 => 1%Q + loop i
                                    end) n)%Q
                            end)%Q
                       end *
                       match transG with
                       | Posz n => iterop n addq 1 0
                       | Negz n =>
                           (-
                            match n with
                            | 0 => 1%Q
                            | _.+1 =>
                                (1%Q +
                                 (fix loop (m : nat) : rat :=
                                    match m with
                                    | 0 => 0
                                    | 1 => 1
                                    | (_.+1 as i).+1 => 1%Q + loop i
                                    end) n)%Q
                            end)%Q
                       end)%Q)%Q)%Q)%Q +
                   (match Su with
                    | Posz n => iterop n addq 1 0
                    | Negz n =>
                        (-
                         match n with
                         | 0 => 1%Q
                         | _.+1 =>
                             (1%Q +
                              (fix loop (m : nat) : rat :=
                                 match m with
                                 | 0 => 0
                                 | 1 => 1
                                 | (_.+1 as i).+1 => 1%Q + loop i
                                 end) n)%Q
                         end)%Q
                    end *
                    (match transG with
                     | Posz n => iterop n addq 1 0
                     | Negz n =>
                         (-
                          match n with
                          | 0 => 1%Q
                          | _.+1 =>
                              (1%Q +
                               (fix loop (m : nat) : rat :=
                                  match m with
                                  | 0 => 0
                                  | 1 => 1
                                  | (_.+1 as i).+1 => 1%Q + loop i
                                  end) n)%Q
                          end)%Q
                     end *
                     match transG with
                     | Posz n => iterop n addq 1 0
                     | Negz n =>
                         (-
                          match n with
                          | 0 => 1%Q
                          | _.+1 =>
                              (1%Q +
                               (fix loop (m : nat) : rat :=
                                  match m with
                                  | 0 => 0
                                  | 1 => 1
                                  | (_.+1 as i).+1 => 1%Q + loop i
                                  end) n)%Q
                          end)%Q
                     end)%Q)%Q)%Q +
                  ((rat_of_Z (BinNums.Zpos (BinNums.xO (BinNums.xO 1%AC))) *
                    (match Su with
                     | Posz n => iterop n addq 1 0
                     | Negz n =>
                         (-
                          match n with
                          | 0 => 1%Q
                          | _.+1 =>
                              (1%Q +
                               (fix loop (m : nat) : rat :=
                                  match m with
                                  | 0 => 0
                                  | 1 => 1
                                  | (_.+1 as i).+1 => 1%Q + loop i
                                  end) n)%Q
                          end)%Q
                     end *
                     match Su with
                     | Posz n => iterop n addq 1 0
                     | Negz n =>
                         (-
                          match n with
                          | 0 => 1%Q
                          | _.+1 =>
                              (1%Q +
                               (fix loop (m : nat) : rat :=
                                  match m with
                                  | 0 => 0
                                  | 1 => 1
                                  | (_.+1 as i).+1 => 1%Q + loop i
                                  end) n)%Q
                          end)%Q
                     end)%Q)%Q *
                   (match transG with
                    | Posz n => iterop n addq 1 0
                    | Negz n =>
                        (-
                         match n with
                         | 0 => 1%Q
                         | _.+1 =>
                             (1%Q +
                              (fix loop (m : nat) : rat :=
                                 match m with
                                 | 0 => 0
                                 | 1 => 1
                                 | (_.+1 as i).+1 => 1%Q + loop i
                                 end) n)%Q
                         end)%Q
                    end *
                    match transG with
                    | Posz n => iterop n addq 1 0
                    | Negz n =>
                        (-
                         match n with
                         | 0 => 1%Q
                         | _.+1 =>
                             (1%Q +
                              (fix loop (m : nat) : rat :=
                                 match m with
                                 | 0 => 0
                                 | 1 => 1
                                 | (_.+1 as i).+1 => 1%Q + loop i
                                 end) n)%Q
                         end)%Q
                    end)%Q)%Q)%Q +
                 ((rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)) *
                   (match Su with
                    | Posz n => iterop n addq 1 0
                    | Negz n =>
                        (-
                         match n with
                         | 0 => 1%Q
                         | _.+1 =>
                             (1%Q +
                              (fix loop (m : nat) : rat :=
                                 match m with
                                 | 0 => 0
                                 | 1 => 1
                                 | (_.+1 as i).+1 => 1%Q + loop i
                                 end) n)%Q
                         end)%Q
                    end *
                    match Su with
                    | Posz n => iterop n addq 1 0
                    | Negz n =>
                        (-
                         match n with
                         | 0 => 1%Q
                         | _.+1 =>
                             (1%Q +
                              (fix loop (m : nat) : rat :=
                                 match m with
                                 | 0 => 0
                                 | 1 => 1
                                 | (_.+1 as i).+1 => 1%Q + loop i
                                 end) n)%Q
                         end)%Q
                    end)%Q)%Q *
                  match transG with
                  | Posz n => iterop n addq 1 0
                  | Negz n =>
                      (-
                       match n with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as i).+1 => 1%Q + loop i
                               end) n)%Q
                       end)%Q
                  end)%Q)%Q +
                (((- rat_of_Z (BinNums.Zpos (BinNums.xO (BinNums.xO 1%AC))))%Q *
                  (match Su with
                   | Posz n => iterop n addq 1 0
                   | Negz n =>
                       (-
                        match n with
                        | 0 => 1%Q
                        | _.+1 =>
                            (1%Q +
                             (fix loop (m : nat) : rat :=
                                match m with
                                | 0 => 0
                                | 1 => 1
                                | (_.+1 as i).+1 => 1%Q + loop i
                                end) n)%Q
                        end)%Q
                   end *
                   (match Su with
                    | Posz n => iterop n addq 1 0
                    | Negz n =>
                        (-
                         match n with
                         | 0 => 1%Q
                         | _.+1 =>
                             (1%Q +
                              (fix loop (m : nat) : rat :=
                                 match m with
                                 | 0 => 0
                                 | 1 => 1
                                 | (_.+1 as i).+1 => 1%Q + loop i
                                 end) n)%Q
                         end)%Q
                    end *
                    match Su with
                    | Posz n => iterop n addq 1 0
                    | Negz n =>
                        (-
                         match n with
                         | 0 => 1%Q
                         | _.+1 =>
                             (1%Q +
                              (fix loop (m : nat) : rat :=
                                 match m with
                                 | 0 => 0
                                 | 1 => 1
                                 | (_.+1 as i).+1 => 1%Q + loop i
                                 end) n)%Q
                         end)%Q
                    end)%Q)%Q)%Q *
                 match transG with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end)%Q)%Q +
               (-
                match Su with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 => 1%Q + loop i
                             end) n)%Q
                     end)%Q
                end)%Q)%Q +
              ((- rat_of_Z (BinNums.Zpos (BinNums.xI (BinNums.xI 1%AC))))%Q *
               match transG with
               | Posz n => iterop n addq 1 0
               | Negz n =>
                   (-
                    match n with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 => 1%Q + loop i
                            end) n)%Q
                    end)%Q
               end)%Q)%Q *
             ((((match transG with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q *
                ((match transG with
                  | Posz n => iterop n addq 1 0
                  | Negz n =>
                      (-
                       match n with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as i).+1 => 1%Q + loop i
                               end) n)%Q
                       end)%Q
                  end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q *
                 (match transG with
                  | Posz n => iterop n addq 1 0
                  | Negz n =>
                      (-
                       match n with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as i).+1 => 1%Q + loop i
                               end) n)%Q
                       end)%Q
                  end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q)%Q)%Q *
               ((match transG with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q +
                match Su with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 => 1%Q + loop i
                             end) n)%Q
                     end)%Q
                end)%Q)%Q^-1)%Q)%Q * (ghn3 transG + s transG Su)%Q)%Q +
           (((((rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)) *
                match transG with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 => 1%Q + loop i
                             end) n)%Q
                     end)%Q
                end)%Q + rat_of_Z (BinNums.Zpos (BinNums.xI 1%AC)))%Q *
              (((match transG with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end *
                 match transG with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end)%Q +
                (rat_of_Z (BinNums.Zpos (BinNums.xI 1%AC)) *
                 match transG with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end)%Q)%Q + rat_of_Z (BinNums.Zpos (BinNums.xI 1%AC)))%Q)%Q *
             (((match transG with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 => 1%Q + loop i
                             end) n)%Q
                     end)%Q
                end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q *
               ((match transG with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q *
                (match transG with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q)%Q)%Q^-1)%Q)%Q *
            (ghn3 (intZmod.addz transG 1) + s (intZmod.addz transG 1) Su)%Q)%Q)%Q +
          ((((((rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)) *
                match Su with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 => 1%Q + loop i
                             end) n)%Q
                     end)%Q
                end)%Q *
               ((rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)) *
                 match transG with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end)%Q + rat_of_Z (BinNums.Zpos (BinNums.xI 1%AC)))%Q)%Q *
              (match Su with
               | Posz n => iterop n addq 1 0
               | Negz n =>
                   (-
                    match n with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 => 1%Q + loop i
                            end) n)%Q
                    end)%Q
               end + rat_of_Z (BinNums.Zpos 1%AC))%Q)%Q *
             ((-
               match transG with
               | Posz n => iterop n addq 1 0
               | Negz n =>
                   (-
                    match n with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 => 1%Q + loop i
                            end) n)%Q
                    end)%Q
               end)%Q +
              match Su with
              | Posz n => iterop n addq 1 0
              | Negz n =>
                  (-
                   match n with
                   | 0 => 1%Q
                   | _.+1 =>
                       (1%Q +
                        (fix loop (m : nat) : rat :=
                           match m with
                           | 0 => 0
                           | 1 => 1
                           | (_.+1 as i).+1 => 1%Q + loop i
                           end) n)%Q
                   end)%Q
              end)%Q)%Q *
            ((((match transG with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 => 1%Q + loop i
                             end) n)%Q
                     end)%Q
                end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q *
               ((match transG with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q *
                (match transG with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q)%Q)%Q *
              ((match transG with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 => 1%Q + loop i
                             end) n)%Q
                     end)%Q
                end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q +
               match Su with
               | Posz n => iterop n addq 1 0
               | Negz n =>
                   (-
                    match n with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 => 1%Q + loop i
                            end) n)%Q
                    end)%Q
               end)%Q)%Q^-1)%Q)%Q *
           (ghn3 transG + s transG (intZmod.addz Su 1))%Q)%Q)%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching:
(∣1⟩ ⊗ (fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) =
 (fun i j : nat => if (i =? k + n) && (j =? 0) then C1 else 0%R))
Crunching:
((fun i j : nat => if (i =? b) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩ =
 (fun i j : nat => if (i =? 2 * b) && (j =? 0) then C1 else 0%R))
Crunching:
((fun i j : nat => if (i =? b) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩ =
 (fun i j : nat => if (i =? 2 * b) && (j =? 0) then C1 else 0%R))
Crunching: (basis_vector a b ⊗ ∣0⟩ = basis_vector (2 * a) (2 * b))
Crunching:
((fun i j : nat => if (i =? b) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩ =
 (fun i j : nat => if (i =? 2 * b) && (j =? 0) then C1 else 0%R))
Crunching:
((fun i j : nat => if (i =? b) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩ =
 (fun i j : nat => if (i =? 2 * b) && (j =? 0) then C1 else 0%R))
Crunching:
((fun i j : nat => if (i =? b) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩ =
 (fun i j : nat => if (i =? 2 * b) && (j =? 0) then C1 else 0%R))
Crunching:
((fun i j : nat => if (i =? b) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩ =
 (fun i j : nat => if (i =? 2 * b) && (j =? 0) then C1 else 0%R))
Crunching:
((fun i j : nat => if (i =? b) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩ =
 (fun i j : nat => if (i =? 2 * b) && (j =? 0) then C1 else 0%R))
Crunching:
((fun i j : nat => if (i =? b) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩ =
 (fun i j : nat => if (i =? 2 * b) && (j =? 0) then C1 else 0%R))
Crunching:
(((fun i j : nat => if (i =? b) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩) x y =
 (if (x =? 2 * b) && (y =? 0) then C1 else 0%R))
Crunching: (basis_vector a b ⊗ ∣0⟩ = basis_vector (2 * a) (2 * b))
Crunching:
(basis_vector a b ⊗ ∣0⟩ .+ Zero = basis_vector (2 * a) (2 * b) .+ Zero)
Crunching:
((fun i j : nat => if (i =? m) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩ =
 (fun i j : nat => if (i =? 2 * m) && (j =? 0) then C1 else 0%R))
Crunching:
((fun i j : nat => if (i =? m) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩ =
 (fun i j : nat => if (i =? 2 * m) && (j =? 0) then C1 else 0%R))
Crunching: (m < n -> basis_vector n m ⊗ ∣0⟩ = basis_vector (2 * n) (2 * m))
Crunching:
(S m <= n ->
 (fun x0 x1 : nat =>
  (((let (H, _) :=
       if
        if
         (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
            match x2 with
            | 0%nat => match x3 with
                       | 0%nat => true
                       | S _ => false
                       end
            | S x4 => match x3 with
                      | 0%nat => false
                      | S x5 => Ffix x4 x5
                      end
            end)
           (let (H, _) :=
              (fix Ffix (x2 x3 x4 x5 : nat) {struct x2} : nat * nat :=
                 match x2 with
                 | 0%nat => (x4, x5)
                 | S x6 =>
                     match x5 with
                     | 0%nat => Ffix x6 x3 (S x4) x3
                     | S x7 => Ffix x6 x3 x4 x7
                     end
                 end) x0 1%nat 0%nat 1%nat in
            H) m
        then
         (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
            match x2 with
            | 0%nat => match x3 with
                       | 0%nat => true
                       | S _ => false
                       end
            | S x4 => match x3 with
                      | 0%nat => false
                      | S x5 => Ffix x4 x5
                      end
            end)
           (let (H, _) :=
              (fix Ffix (x2 x3 x4 x5 : nat) {struct x2} : nat * nat :=
                 match x2 with
                 | 0%nat => (x4, x5)
                 | S x6 =>
                     match x5 with
                     | 0%nat => Ffix x6 x3 (S x4) x3
                     | S x7 => Ffix x6 x3 x4 x7
                     end
                 end) x1 0%nat 0%nat 0%nat in
            H) 0%nat
        else false
       then (R1, R0)
       else (R0, R0) in
     H) *
    (let (H, _) :=
       match
         match
           (let (_, H) :=
              (fix Ffix (x2 x3 x4 x5 : nat) {struct x2} : nat * nat :=
                 match x2 with
                 | 0%nat => (x4, x5)
                 | S x6 =>
                     match x5 with
                     | 0%nat => Ffix x6 x3 (S x4) x3
                     | S x7 => Ffix x6 x3 x4 x7
                     end
                 end) x0 1%nat 0%nat 1%nat in
            H)
         with
         | 0%nat => 1%nat
         | S _ => 0%nat
         end
       with
       | 0%nat => (R1, R0)
       | _ => (R0, R0)
       end in
     H) +
    -
    ((let (_, H) :=
        if
         if
          (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
             match x2 with
             | 0%nat => match x3 with
                        | 0%nat => true
                        | S _ => false
                        end
             | S x4 =>
                 match x3 with
                 | 0%nat => false
                 | S x5 => Ffix x4 x5
                 end
             end)
            (let (H, _) :=
               (fix Ffix (x2 x3 x4 x5 : nat) {struct x2} : nat * nat :=
                  match x2 with
                  | 0%nat => (x4, x5)
                  | S x6 =>
                      match x5 with
                      | 0%nat => Ffix x6 x3 (S x4) x3
                      | S x7 => Ffix x6 x3 x4 x7
                      end
                  end) x0 1%nat 0%nat 1%nat in
             H) m
         then
          (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
             match x2 with
             | 0%nat => match x3 with
                        | 0%nat => true
                        | S _ => false
                        end
             | S x4 =>
                 match x3 with
                 | 0%nat => false
                 | S x5 => Ffix x4 x5
                 end
             end)
            (let (H, _) :=
               (fix Ffix (x2 x3 x4 x5 : nat) {struct x2} : nat * nat :=
                  match x2 with
                  | 0%nat => (x4, x5)
                  | S x6 =>
                      match x5 with
                      | 0%nat => Ffix x6 x3 (S x4) x3
                      | S x7 => Ffix x6 x3 x4 x7
                      end
                  end) x1 0%nat 0%nat 0%nat in
             H) 0%nat
         else false
        then (R1, R0)
        else (R0, R0) in
      H) *
     (let (_, H) :=
        match
          match
            (let (_, H) :=
               (fix Ffix (x2 x3 x4 x5 : nat) {struct x2} : nat * nat :=
                  match x2 with
                  | 0%nat => (x4, x5)
                  | S x6 =>
                      match x5 with
                      | 0%nat => Ffix x6 x3 (S x4) x3
                      | S x7 => Ffix x6 x3 x4 x7
                      end
                  end) x0 1%nat 0%nat 1%nat in
             H)
          with
          | 0%nat => 1%nat
          | S _ => 0%nat
          end
        with
        | 0%nat => (R1, R0)
        | _ => (R0, R0)
        end in
      H)))%R,
  ((let (H, _) :=
      if
       if
        (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
           match x2 with
           | 0%nat => match x3 with
                      | 0%nat => true
                      | S _ => false
                      end
           | S x4 => match x3 with
                     | 0%nat => false
                     | S x5 => Ffix x4 x5
                     end
           end)
          (let (H, _) :=
             (fix Ffix (x2 x3 x4 x5 : nat) {struct x2} : nat * nat :=
                match x2 with
                | 0%nat => (x4, x5)
                | S x6 =>
                    match x5 with
                    | 0%nat => Ffix x6 x3 (S x4) x3
                    | S x7 => Ffix x6 x3 x4 x7
                    end
                end) x0 1%nat 0%nat 1%nat in
           H) m
       then
        (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
           match x2 with
           | 0%nat => match x3 with
                      | 0%nat => true
                      | S _ => false
                      end
           | S x4 => match x3 with
                     | 0%nat => false
                     | S x5 => Ffix x4 x5
                     end
           end)
          (let (H, _) :=
             (fix Ffix (x2 x3 x4 x5 : nat) {struct x2} : nat * nat :=
                match x2 with
                | 0%nat => (x4, x5)
                | S x6 =>
                    match x5 with
                    | 0%nat => Ffix x6 x3 (S x4) x3
                    | S x7 => Ffix x6 x3 x4 x7
                    end
                end) x1 0%nat 0%nat 0%nat in
           H) 0%nat
       else false
      then (R1, R0)
      else (R0, R0) in
    H) *
   (let (_, H) :=
      match
        match
          (let (_, H) :=
             (fix Ffix (x2 x3 x4 x5 : nat) {struct x2} : nat * nat :=
                match x2 with
                | 0%nat => (x4, x5)
                | S x6 =>
                    match x5 with
                    | 0%nat => Ffix x6 x3 (S x4) x3
                    | S x7 => Ffix x6 x3 x4 x7
                    end
                end) x0 1%nat 0%nat 1%nat in
           H)
        with
        | 0%nat => 1%nat
        | S _ => 0%nat
        end
      with
      | 0%nat => (R1, R0)
      | _ => (R0, R0)
      end in
    H) +
   (let (_, H) :=
      if
       if
        (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
           match x2 with
           | 0%nat => match x3 with
                      | 0%nat => true
                      | S _ => false
                      end
           | S x4 => match x3 with
                     | 0%nat => false
                     | S x5 => Ffix x4 x5
                     end
           end)
          (let (H, _) :=
             (fix Ffix (x2 x3 x4 x5 : nat) {struct x2} : nat * nat :=
                match x2 with
                | 0%nat => (x4, x5)
                | S x6 =>
                    match x5 with
                    | 0%nat => Ffix x6 x3 (S x4) x3
                    | S x7 => Ffix x6 x3 x4 x7
                    end
                end) x0 1%nat 0%nat 1%nat in
           H) m
       then
        (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
           match x2 with
           | 0%nat => match x3 with
                      | 0%nat => true
                      | S _ => false
                      end
           | S x4 => match x3 with
                     | 0%nat => false
                     | S x5 => Ffix x4 x5
                     end
           end)
          (let (H, _) :=
             (fix Ffix (x2 x3 x4 x5 : nat) {struct x2} : nat * nat :=
                match x2 with
                | 0%nat => (x4, x5)
                | S x6 =>
                    match x5 with
                    | 0%nat => Ffix x6 x3 (S x4) x3
                    | S x7 => Ffix x6 x3 x4 x7
                    end
                end) x1 0%nat 0%nat 0%nat in
           H) 0%nat
       else false
      then (R1, R0)
      else (R0, R0) in
    H) *
   (let (H, _) :=
      match
        match
          (let (_, H) :=
             (fix Ffix (x2 x3 x4 x5 : nat) {struct x2} : nat * nat :=
                match x2 with
                | 0%nat => (x4, x5)
                | S x6 =>
                    match x5 with
                    | 0%nat => Ffix x6 x3 (S x4) x3
                    | S x7 => Ffix x6 x3 x4 x7
                    end
                end) x0 1%nat 0%nat 1%nat in
           H)
        with
        | 0%nat => 1%nat
        | S _ => 0%nat
        end
      with
      | 0%nat => (R1, R0)
      | _ => (R0, R0)
      end in
    H))%R)) =
 (fun x0 x1 : nat =>
  if
   if
    (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
       match x2 with
       | 0 => match x3 with
              | 0 => true
              | S _ => false
              end
       | S x4 => match x3 with
                 | 0 => false
                 | S x5 => Ffix x4 x5
                 end
       end) x0
      ((fix Ffix (x2 x3 : nat) {struct x2} : nat :=
          match x2 with
          | 0 => x3
          | S x4 => S (Ffix x4 x3)
          end) m
         ((fix Ffix (x2 x3 : nat) {struct x2} : nat :=
             match x2 with
             | 0 => x3
             | S x4 => S (Ffix x4 x3)
             end) m 0))
   then
    (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
       match x2 with
       | 0 => match x3 with
              | 0 => true
              | S _ => false
              end
       | S x4 => match x3 with
                 | 0 => false
                 | S x5 => Ffix x4 x5
                 end
       end) x1 0
   else false
  then (R1, R0)
  else (R0, R0)))
Crunching:
((fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩ =
 (fun i j : nat => if (i =? 2 * k) && (j =? 0) then C1 else 0%R))
Crunching: (basis_vector n k ⊗ ∣0⟩ = basis_vector (2 * n) (2 * k))
Crunching:
((fun i j : nat => if (i =? a) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩ =
 (fun i j : nat => if (i =? 2 * a) && (j =? 0) then C1 else 0%R))
Crunching: (basis_vector n a ⊗ ∣0⟩ = basis_vector (2 * n) (2 * a))
Crunching:
((fun i j : nat => if (i =? 2 * N) && (j =? 0) then C1 else 0%R) =
 (fun i j : nat => if (i =? N) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩)
Crunching: (basis_vector (2 * y) (2 * N) = basis_vector y N ⊗ ∣0⟩)
"paths_ind has been translated as paths_indᵗ"
"~~~~~~~~~~~~~~~~~~"
"Translating Coq.Init.Logic.eq"
"Coq.Init.Logic.eq was already translated"
"Translating MetaCoq.Translations.MiniHoTT.paths"
"MetaCoq.Translations.MiniHoTT.paths was already translated"
"Translating MetaCoq.Translations.MiniHoTT.Sect"
"Sect has been translated as Sectᵗ"
"Translating MetaCoq.Translations.MiniHoTT.idpath"
"MetaCoq.Translations.MiniHoTT.idpath was already translated"
"Translating MetaCoq.Translations.MiniHoTT.paths_ind"
"MetaCoq.Translations.MiniHoTT.paths_ind was already translated"
"Translating MetaCoq.Translations.MiniHoTT.transport"
"transport has been translated as transportᵗ"
"Translating MetaCoq.Translations.MiniHoTT.ap"
Crunching:
(forall k : nat,
 NP <> 0 ->
 k < NP ->
 (fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩ =
 (fun i j : nat => if (i =? 2 * k) && (j =? 0) then C1 else 0%R))
"ap has been translated as apᵗ"
"Translating MetaCoq.Translations.MiniHoTT.IsEquiv"
"MetaCoq.Translations.MiniHoTT.IsEquiv has been translated."
"Translating MetaCoq.Translations.MiniHoTT.Equiv"
"MetaCoq.Translations.MiniHoTT.Equiv has been translated."
     = @^~ 8
     : M nat
Crunching:
(forall k : nat,
 NP <> 0 -> k < NP -> basis_vector NP k ⊗ ∣0⟩ = basis_vector (2 * NP) (2 * k))
"Translating MetaCoq.Translations.times_bool_fun.wUnivalence"
"wUnivalence has been translated as wUnivalenceᵗ"
     = tt
     : [the monad of idfun] unit
     = @^~ None
     : [the contMonad of ContMonad.acto bool] (option nat)
     = @^~ (Some 3)
     : [the contMonad of ContMonad.acto bool] (option nat)
Crunching:
((fun x y : nat =>
  (((let (x0, _) :=
       if
        if
         (fix eqb (n m : nat) {struct n} : bool :=
            match n with
            | 0%nat => match m with
                       | 0%nat => true
                       | S _ => false
                       end
            | S n' => match m with
                      | 0%nat => false
                      | S m' => eqb n' m'
                      end
            end) (x / 2)%nat k
        then
         (fix eqb (n m : nat) {struct n} : bool :=
            match n with
            | 0%nat => match m with
                       | 0%nat => true
                       | S _ => false
                       end
            | S n' => match m with
                      | 0%nat => false
                      | S m' => eqb n' m'
                      end
            end) (y / 1)%nat 0%nat
        else false
       then (R1, R0)
       else (R0, R0) in
     x0) *
    (let (x0, _) :=
       match x mod 2 with
       | 0%nat =>
           match y mod 1 with
           | 0%nat => (R1, R0)
           | S _ => (R0, R0)
           end
       | 1%nat => match y mod 1 with
                  | 0%nat | _ => (R0, R0)
                  end
       | S (S _) => (R0, R0)
       end in
     x0) +
    -
    ((let (_, y0) :=
        if
         if
          (fix eqb (n m : nat) {struct n} : bool :=
             match n with
             | 0%nat => match m with
                        | 0%nat => true
                        | S _ => false
                        end
             | S n' => match m with
                       | 0%nat => false
                       | S m' => eqb n' m'
                       end
             end) (x / 2)%nat k
         then
          (fix eqb (n m : nat) {struct n} : bool :=
             match n with
             | 0%nat => match m with
                        | 0%nat => true
                        | S _ => false
                        end
             | S n' => match m with
                       | 0%nat => false
                       | S m' => eqb n' m'
                       end
             end) (y / 1)%nat 0%nat
         else false
        then (R1, R0)
        else (R0, R0) in
      y0) *
     (let (_, y0) :=
        match x mod 2 with
        | 0%nat =>
            match y mod 1 with
            | 0%nat => (R1, R0)
            | S _ => (R0, R0)
            end
        | 1%nat => match y mod 1 with
                   | 0%nat | _ => (R0, R0)
                   end
        | S (S _) => (R0, R0)
        end in
      y0)))%R,
  ((let (x0, _) :=
      if
       if
        (fix eqb (n m : nat) {struct n} : bool :=
           match n with
           | 0%nat => match m with
                      | 0%nat => true
                      | S _ => false
                      end
           | S n' => match m with
                     | 0%nat => false
                     | S m' => eqb n' m'
                     end
           end) (x / 2)%nat k
       then
        (fix eqb (n m : nat) {struct n} : bool :=
           match n with
           | 0%nat => match m with
                      | 0%nat => true
                      | S _ => false
                      end
           | S n' => match m with
                     | 0%nat => false
                     | S m' => eqb n' m'
                     end
           end) (y / 1)%nat 0%nat
       else false
      then (R1, R0)
      else (R0, R0) in
    x0) *
   (let (_, y0) :=
      match x mod 2 with
      | 0%nat => match y mod 1 with
                 | 0%nat => (R1, R0)
                 | S _ => (R0, R0)
                 end
      | 1%nat => match y mod 1 with
                 | 0%nat | _ => (R0, R0)
                 end
      | S (S _) => (R0, R0)
      end in
    y0) +
   (let (_, y0) :=
      if
       if
        (fix eqb (n m : nat) {struct n} : bool :=
           match n with
           | 0%nat => match m with
                      | 0%nat => true
                      | S _ => false
                      end
           | S n' => match m with
                     | 0%nat => false
                     | S m' => eqb n' m'
                     end
           end) (x / 2)%nat k
       then
        (fix eqb (n m : nat) {struct n} : bool :=
           match n with
           | 0%nat => match m with
                      | 0%nat => true
                      | S _ => false
                      end
           | S n' => match m with
                     | 0%nat => false
                     | S m' => eqb n' m'
                     end
           end) (y / 1)%nat 0%nat
       else false
      then (R1, R0)
      else (R0, R0) in
    y0) *
   (let (x0, _) :=
      match x mod 2 with
      | 0%nat => match y mod 1 with
                 | 0%nat => (R1, R0)
                 | S _ => (R0, R0)
                 end
      | 1%nat => match y mod 1 with
                 | 0%nat | _ => (R0, R0)
                 end
      | S (S _) => (R0, R0)
      end in
    x0))%R)) =
 (fun i j : nat =>
  if
   if
    (fix eqb (n m : nat) {struct n} : bool :=
       match n with
       | 0 => match m with
              | 0 => true
              | S _ => false
              end
       | S n' => match m with
                 | 0 => false
                 | S m' => eqb n' m'
                 end
       end) i (2 * k)
   then
    (fix eqb (n m : nat) {struct n} : bool :=
       match n with
       | 0 => match m with
              | 0 => true
              | S _ => false
              end
       | S n' => match m with
                 | 0 => false
                 | S m' => eqb n' m'
                 end
       end) j 0
   else false
  then (R1, R0)
  else (R0, R0)))
Crunching:
((fun x y : nat =>
  (((let (x0, _) :=
       if
        if
         (fix eqb (n m : nat) {struct n} : bool :=
            match n with
            | 0%nat => match m with
                       | 0%nat => true
                       | S _ => false
                       end
            | S n' => match m with
                      | 0%nat => false
                      | S m' => eqb n' m'
                      end
            end) (x / 2)%nat k
        then
         (fix eqb (n m : nat) {struct n} : bool :=
            match n with
            | 0%nat => match m with
                       | 0%nat => true
                       | S _ => false
                       end
            | S n' => match m with
                      | 0%nat => false
                      | S m' => eqb n' m'
                      end
            end) (y / 1)%nat 0%nat
        else false
       then (R1, R0)
       else (R0, R0) in
     x0) *
    (let (x0, _) :=
       match x mod 2 with
       | 0%nat =>
           match y mod 1 with
           | 0%nat => (R1, R0)
           | S _ => (R0, R0)
           end
       | 1%nat => match y mod 1 with
                  | 0%nat | _ => (R0, R0)
                  end
       | S (S _) => (R0, R0)
       end in
     x0) +
    -
    ((let (_, y0) :=
        if
         if
          (fix eqb (n m : nat) {struct n} : bool :=
             match n with
             | 0%nat => match m with
                        | 0%nat => true
                        | S _ => false
                        end
             | S n' => match m with
                       | 0%nat => false
                       | S m' => eqb n' m'
                       end
             end) (x / 2)%nat k
         then
          (fix eqb (n m : nat) {struct n} : bool :=
             match n with
             | 0%nat => match m with
                        | 0%nat => true
                        | S _ => false
                        end
             | S n' => match m with
                       | 0%nat => false
                       | S m' => eqb n' m'
                       end
             end) (y / 1)%nat 0%nat
         else false
        then (R1, R0)
        else (R0, R0) in
      y0) *
     (let (_, y0) :=
        match x mod 2 with
        | 0%nat =>
            match y mod 1 with
            | 0%nat => (R1, R0)
            | S _ => (R0, R0)
            end
        | 1%nat => match y mod 1 with
                   | 0%nat | _ => (R0, R0)
                   end
        | S (S _) => (R0, R0)
        end in
      y0)))%R,
  ((let (x0, _) :=
      if
       if
        (fix eqb (n m : nat) {struct n} : bool :=
           match n with
           | 0%nat => match m with
                      | 0%nat => true
                      | S _ => false
                      end
           | S n' => match m with
                     | 0%nat => false
                     | S m' => eqb n' m'
                     end
           end) (x / 2)%nat k
       then
        (fix eqb (n m : nat) {struct n} : bool :=
           match n with
           | 0%nat => match m with
                      | 0%nat => true
                      | S _ => false
                      end
           | S n' => match m with
                     | 0%nat => false
                     | S m' => eqb n' m'
                     end
           end) (y / 1)%nat 0%nat
       else false
      then (R1, R0)
      else (R0, R0) in
    x0) *
   (let (_, y0) :=
      match x mod 2 with
      | 0%nat => match y mod 1 with
                 | 0%nat => (R1, R0)
                 | S _ => (R0, R0)
                 end
      | 1%nat => match y mod 1 with
                 | 0%nat | _ => (R0, R0)
                 end
      | S (S _) => (R0, R0)
      end in
    y0) +
   (let (_, y0) :=
      if
       if
        (fix eqb (n m : nat) {struct n} : bool :=
           match n with
           | 0%nat => match m with
                      | 0%nat => true
                      | S _ => false
                      end
           | S n' => match m with
                     | 0%nat => false
                     | S m' => eqb n' m'
                     end
           end) (x / 2)%nat k
       then
        (fix eqb (n m : nat) {struct n} : bool :=
           match n with
           | 0%nat => match m with
                      | 0%nat => true
                      | S _ => false
                      end
           | S n' => match m with
                     | 0%nat => false
                     | S m' => eqb n' m'
                     end
           end) (y / 1)%nat 0%nat
       else false
      then (R1, R0)
      else (R0, R0) in
    y0) *
   (let (x0, _) :=
      match x mod 2 with
      | 0%nat => match y mod 1 with
                 | 0%nat => (R1, R0)
                 | S _ => (R0, R0)
                 end
      | 1%nat => match y mod 1 with
                 | 0%nat | _ => (R0, R0)
                 end
      | S (S _) => (R0, R0)
      end in
    x0))%R)) =
 (fun i j : nat =>
  if
   if
    (fix eqb (n m : nat) {struct n} : bool :=
       match n with
       | 0 => match m with
              | 0 => true
              | S _ => false
              end
       | S n' => match m with
                 | 0 => false
                 | S m' => eqb n' m'
                 end
       end) i (k + k)
   then
    (fix eqb (n m : nat) {struct n} : bool :=
       match n with
       | 0 => match m with
              | 0 => true
              | S _ => false
              end
       | S n' => match m with
                 | 0 => false
                 | S m' => eqb n' m'
                 end
       end) j 0
   else false
  then (R1, R0)
  else (R0, R0)))
Crunching:
((fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩ =
 (fun i j : nat => if (i =? 2 * k) && (j =? 0) then C1 else 0%R))
Crunching:
(forall k : nat,
 H8 <> 0 ->
 k < H8 ->
 (fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩ =
 (fun i j : nat => if (i =? 2 * k) && (j =? 0) then C1 else 0%R))
Crunching:
(Heq < H8 ->
 (fun i j : nat => if (i =? Heq) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩ =
 (fun i j : nat => if (i =? 2 * Heq) && (j =? 0) then C1 else 0%R))
Crunching:
(Heq < 0 ->
 (fun i j : nat => if (i =? Heq) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩ =
 (fun i j : nat => if (i =? 2 * Heq) && (j =? 0) then C1 else 0%R))
Crunching:
((fun i j : nat => if (i =? Heq) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩ =
 (fun i j : nat => if (i =? 2 * Heq) && (j =? 0) then C1 else 0%R))
Crunching:
((fun i j : nat => if (i =? Heq) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩ =
 (fun i j : nat => if (i =? 2 * Heq) && (j =? 0) then C1 else 0%R))
Crunching:
((fun i j : nat => if (i =? Heq) && (j =? 0) then C1 else (√ 0)%R) ⊗ ∣0⟩ =
 (fun i j : nat => if (i =? 2 * Heq) && (j =? 0) then C1 else (√ 0)%R))
Crunching:
(Heq < H8 ->
 (fun i j : nat => if (i =? Heq) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩ =
 (fun i j : nat => if (i =? 2 * Heq) && (j =? 0) then C1 else 0%R))
Crunching:
((fun i j : nat => if (i =? Heq) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩ =
 (fun i j : nat => if (i =? 2 * Heq) && (j =? 0) then C1 else 0%R))
Crunching:
((fun i j : nat => if (i =? Heq) && (j =? 0) then C1 else (√ 0)%R) ⊗ ∣0⟩ =
 (fun i j : nat => if (i =? 2 * Heq) && (j =? 0) then C1 else (√ 0)%R))
Crunching:
(b < a ->
 (fun i j : nat => if (i =? b) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩ =
 (fun i j : nat => if (i =? 2 * b) && (j =? 0) then C1 else 0%R))
Crunching:
((fun i j : nat => if (i =? b) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩ =
 (fun i j : nat => if (i =? 2 * b) && (j =? 0) then C1 else 0%R))
Crunching:
((fun i j : nat => if (i =? b) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩ =
 (fun i j : nat => if (i =? 2 * b) && (j =? 0) then C1 else 0%R))
Crunching:
((fun i j : nat => if (i =? b) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩ =
 (fun i j : nat => if (i =? b + b) && (j =? 0) then C1 else 0%R))
Crunching:
((fun i j : nat => if (i =? b) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩ =
 (fun i j : nat => if (i =? 2 * b) && (j =? 0) then C1 else 0%R))
Crunching:
((fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩ =
 (fun i j : nat => if (i =? 2 * k) && (j =? 0) then C1 else 0%R))
Crunching:
((fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) ⊗ ∣1⟩ =
 (fun i j : nat => if (i =? 2 * k + 1) && (j =? 0) then C1 else 0%R))
Debug:
In environment
p, H : int
odd_n : annotated_recs_s.precond.Sk2 p H
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: ghn3 p; s p (int.shift 2 H); annotated_recs_s.Sk2_cf0_0 p H; 
        s p H; annotated_recs_s.Sk2_cf0_1 p H; s p (int.shift 1 H)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
p, H : int
p0 : annotated_recs_s.precond.Sk2 p H
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: ghn3 p; s p (int.shift 2 H); annotated_recs_s.Sk2_cf0_0 p H; 
        s p H; annotated_recs_s.Sk2_cf0_1 p H; s p (int.shift 1 H)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching:
((fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) ⊗ ∣1⟩ =
 (fun i j : nat => if (i =? 2 * k + 1) && (j =? 0) then C1 else 0%R))
Crunching:
((fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) ⊗ ∣1⟩ =
 (fun i j : nat => if (i =? 2 * k + 1) && (j =? 0) then C1 else 0%R))
Debug:
In environment
p, H : int
odd_n : annotated_recs_s.precond.Sk2 p H
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: ghn3 p; s p (int.shift 2 H); annotated_recs_s.Sk2_cf0_0 p H; 
        s p H; annotated_recs_s.Sk2_cf0_1 p H; s p (int.shift 1 H)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
p, H : int
p0 : annotated_recs_s.precond.Sk2 p H
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: ghn3 p; s p (int.shift 2 H); annotated_recs_s.Sk2_cf0_0 p H; 
        s p H; annotated_recs_s.Sk2_cf0_1 p H; s p (int.shift 1 H)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching:
(x < y ->
 ((if (x / 2 =? k) && (y =? 0) then C1 else 0%R) *
  match x mod 2 with
  | 0 => match y mod 1 with
         | 0 | _ => 0%R
         end
  | 1 => match y mod 1 with
         | 0 => C1
         | S _ => 0%R
         end
  | S (S _) => 0%R
  end)%C = (if (x =? 2 * k + 1) && (y =? 0) then C1 else 0%R))
Crunching:
((fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) ⊗ ∣1⟩ =
 (fun i j : nat => if (i =? 2 * k + 1) && (j =? 0) then C1 else 0%R))
Crunching:
(((if (x / 2 =? k) && (y / 1 =? 0) then C1 else 0%R) *
  match x mod 2 with
  | 0 => match y mod 1 with
         | 0 | _ => 0%R
         end
  | 1 => match y mod 1 with
         | 0 => C1
         | S _ => 0%R
         end
  | S (S _) => 0%R
  end)%C = (if (x =? 2 * k + 1) && (y =? 0) then C1 else 0%R))
Crunching:
((fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) ⊗ ∣1⟩ =
 (fun i j : nat => if (i =? 2 * k + 1) && (j =? 0) then C1 else 0%R))
Crunching: (basis_vector n k ⊗ ∣1⟩ = basis_vector (2 * n) (2 * k + 1))
Crunching:
((fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) ⊗ ∣1⟩ =
 (fun i j : nat => if (i =? 2 * k + 1) && (j =? 0) then C1 else 0%R))
Crunching:
((fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) ⊗ ∣1⟩ =
 (fun i j : nat => if (i =? 2 * k + 1) && (j =? 0) then C1 else 0%R))
Debug:
In environment
p, H : int
odd_n : annotated_recs_s.precond.Sk2 p H
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: ghn3 p; s p (int.shift 2 H); annotated_recs_s.Sk2_cf0_0 p H; 
        s p H; annotated_recs_s.Sk2_cf0_1 p H; s p (int.shift 1 H)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching:
((fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) ⊗ ∣1⟩ =
 (fun i j : nat => if (i =? 2 * k + 1) && (j =? 0) then C1 else 0%R))
Debug:
In environment
p, H : int
p0 : annotated_recs_s.precond.Sk2 p H
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: ghn3 p; s p (int.shift 2 H); annotated_recs_s.Sk2_cf0_0 p H; 
        s p H; annotated_recs_s.Sk2_cf0_1 p H; s p (int.shift 1 H)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching:
((fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) ⊗ ∣1⟩ =
 (fun i j : nat => if (i =? 2 * k + 1) && (j =? 0) then C1 else 0%R))
Crunching:
(((if (x / 2 =? k) && (y / 1 =? 0) then C1 else 0%R) *
  match x mod 2 with
  | 0 => match y mod 1 with
         | 0 | _ => 0%R
         end
  | 1 => match y mod 1 with
         | 0 => C1
         | S _ => 0%R
         end
  | S (S _) => 0%R
  end)%C = (if (x =? 2 * k + 1) && (y =? 0) then C1 else 0%R))
Crunching:
((fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) ⊗ ∣1⟩ =
 (fun i j : nat => if (i =? 2 * k + 1) && (j =? 0) then C1 else 0%R))
Crunching:
((fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) ⊗ ∣1⟩ =
 (fun i j : nat => if (i =? 2 * k + 1) && (j =? 0) then C1 else 0%R))
Crunching:
((fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) ⊗ ∣1⟩ =
 (fun i j : nat => if (i =? 2 * k + 1) && (j =? 0) then C1 else 0%R))
Crunching: (basis_vector n k ⊗ ∣1⟩ = basis_vector (2 * n) (2 * k + 1))
Crunching:
((fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) ⊗ ∣1⟩ =
 (fun i j : nat => if (i =? 2 * k + 1) && (j =? 0) then C1 else 0%R))
Crunching:
((fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) ⊗ ∣1⟩ =
 (fun i j : nat => if (i =? 2 * k + 1) && (j =? 0) then C1 else 0%R))
Crunching:
((fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) ⊗ ∣1⟩ =
 (fun i j : nat => if (i =? 2 * k + 1) && (j =? 0) then C1 else 0%R))
"isequiv_idmap has been translated as isequiv_idmapᵗ"
Crunching:
((fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) ⊗ ∣1⟩ =
 (fun i j : nat => if (i =? 2 * k + 1) && (j =? 0) then C1 else 0%R))
Crunching: (basis_vector n k ⊗ ∣1⟩ = basis_vector (n * 2) (2 * k + 1))
Crunching:
((fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) ⊗ ∣1⟩ =
 (fun i j : nat => if (i =? 2 * k + 1) && (j =? 0) then C1 else 0%R))
Crunching:
((fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) ⊗ ∣1⟩ =
 (fun i j : nat => if (i =? 2 * k + 1) && (j =? 0) then C1 else 0%R))
"equiv_idmap has been translated as equiv_idmapᵗ"
Crunching:
((fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) ⊗ ∣1⟩ =
 (fun i j : nat => if (i =? 2 * k + 1) && (j =? 0) then C1 else 0%R))
Crunching:
((fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) ⊗ ∣1⟩ =
 (fun i j : nat => if (i =? 2 * k + 1) && (j =? 0) then C1 else 0%R))
"UA has been translated as UAᵗ"
Crunching:
((fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) ⊗ ∣1⟩ =
 (fun i j : nat => if (i =? 2 * k + 1) && (j =? 0) then C1 else 0%R))
Crunching:
((fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) ⊗ ∣1⟩ =
 (fun i j : nat => if (i =? 2 * k + 1) && (j =? 0) then C1 else 0%R))
Crunching: (basis_vector n k ⊗ ∣1⟩ = basis_vector (2 * n) (2 * k + 1))
Crunching:
((fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) ⊗ ∣1⟩ =
 (fun i j : nat => if (i =? 2 * k + 1) && (j =? 0) then C1 else 0%R))
Crunching:
((fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) ⊗ ∣1⟩ =
 (fun i j : nat => if (i =? 2 * k + 1) && (j =? 0) then C1 else 0%R))
Crunching:
((fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) ⊗ ∣1⟩ =
 (fun i j : nat => if (i =? 2 * k + 1) && (j =? 0) then C1 else 0%R))
Crunching: (basis_vector n k ⊗ ∣1⟩ = basis_vector (n * 2) (2 * k + 1))
Crunching:
((fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) ⊗ ∣1⟩ =
 (fun i j : nat => if (i =? 2 * k + 1) && (j =? 0) then C1 else 0%R))
Crunching: (basis_vector n k ⊗ ∣1⟩ = basis_vector (2 * n) (2 * k + 1))
Debug:
In environment
p, H : int
odd_n : annotated_recs_s.precond.Sk2 p H
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: ghn3 p; s p (int.shift 2 H); annotated_recs_s.Sk2_cf0_0 p H; 
        s p H; annotated_recs_s.Sk2_cf0_1 p H; s p (int.shift 1 H)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
p, H : int
odd_n : annotated_recs_s.precond.Sk2 p H
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: u p (int.shift 2 H); annotated_recs_s.Sk2_cf0_0 p H; 
        u p H; annotated_recs_s.Sk2_cf0_1 p H; u p (int.shift 1 H)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching:
((fun i j : nat => if (i =? m) && (j =? 0) then C1 else 0%R) ⊗ ∣1⟩ =
 (fun i j : nat => if (i =? 2 * m + 1) && (j =? 0) then C1 else 0%R))
Crunching: (basis_vector n m ⊗ ∣1⟩ = basis_vector (2 * n) (2 * m + 1))
Crunching:
((fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) ⊗ ∣1⟩ =
 (fun i j : nat => if (i =? 2 * k + 1) && (j =? 0) then C1 else 0%R))
Debug:
In environment
p, H : int
p0 : annotated_recs_s.precond.Sk2 p H
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: ghn3 p; s p (int.shift 2 H); annotated_recs_s.Sk2_cf0_0 p H; 
        s p H; annotated_recs_s.Sk2_cf0_1 p H; s p (int.shift 1 H)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
p, H : int
p0 : annotated_recs_s.precond.Sk2 p H
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: u p (int.shift 2 H); annotated_recs_s.Sk2_cf0_0 p H; 
        u p H; annotated_recs_s.Sk2_cf0_1 p H; u p (int.shift 1 H)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching:
((fun i j : nat => if (i =? env) && (j =? 0) then C1 else 0%R) ⊗ ∣1⟩ =
 (fun i j : nat => if (i =? 2 * env + 1) && (j =? 0) then C1 else 0%R))
Crunching:
((fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) ⊗ ∣1⟩ =
 (fun i j : nat => if (i =? 2 * k + 1) && (j =? 0) then C1 else 0%R))
Crunching:
((fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) ⊗ ∣1⟩ =
 (fun i j : nat => if (i =? 2 * k + 1) && (j =? 0) then C1 else 0%R))
Crunching:
((fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) ⊗ ∣1⟩ =
 (fun i j : nat => if (i =? 2 * k + 1) && (j =? 0) then C1 else 0%R))
Crunching:
((fun x y : nat =>
  ((if (x / 2 =? H3) && (y / 1 =? 0) then C1 else 0%R) *
   ∣1⟩ (x mod 2) (y mod 1))%C) =
 (fun i j : nat => if (i =? 2 * H3 + 1) && (j =? 0) then C1 else 0%R))
Debug:
In environment
EQ, q1 : int
q2 : annotated_recs_s.precond.Sk2 EQ q1
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: ghn3 EQ; s EQ (int.shift 2 q1);
         fracq
           (mulq_subdef (valq (annotated_recs_s.Sk2_cf0_0 EQ q1))
              (valq (ghn3 EQ + s EQ q1))); annotated_recs_s.Sk2_cf0_1 EQ q1;
         s EQ (int.shift 1 q1)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching:
((fun i j : nat => if (i =? H3) && (j =? 0) then C1 else 0%R) ⊗ ∣1⟩ = ?y)
Crunching:
((fun x y : nat =>
  ((if (x / 2 =? H3) && (y / 1 =? 0) then C1 else 0%R) *
   ∣1⟩ (x mod 2) (y mod 1))%C) =
 (fun i j : nat => if (i =? 2 * H3 + 1) && (j =? 0) then C1 else 0%R))
Crunching:
((fun i j : nat => if (i =? 2 * H3 + 1) && (j =? 0) then C1 else 0%R) =
 (fun x y : nat =>
  ((if (x / 2 =? H3) && (y / 1 =? 0) then C1 else 0%R) *
   ∣1⟩ (x mod 2) (y mod 1))%C))
Crunching:
((fun x y : nat =>
  ((if (x / 2 =? H3) && (y / 1 =? 0) then C1 else 0%R) *
   ∣1⟩ (x mod 2) (y mod 1))%C) =
 (fun i j : nat => if (i =? 2 * H3 + 1) && (j =? 0) then C1 else 0%R))
Crunching:
((fun i j : nat => if (i =? 2 * H3 + 1) && (j =? 0) then C1 else 0%R) =
 (fun x y : nat =>
  ((if (x / 2 =? H3) && (y / 1 =? 0) then C1 else 0%R) *
   ∣1⟩ (x mod 2) (y mod 1))%C))
Crunching:
((fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) ⊗ ∣1⟩ =
 (fun i j : nat => if (i =? 2 * k + 1) && (j =? 0) then C1 else 0%R))
Crunching: (forall n : nat, n ⨂ ∣0⟩ = basis_vector (2 ^ n) 0)
Crunching: (forall n : nat, n ⨂ ∣0⟩ = basis_vector (2 ^ n) 0)
Crunching: (forall n : nat, n ⨂ ∣0⟩ = basis_vector (2 ^ n) 0)
Crunching: (0 ⨂ ∣0⟩ = basis_vector 1 0)
Crunching: (forall n : nat, n ⨂ ∣0⟩ = basis_vector (2 ^ n) 0)
Crunching: (0 ⨂ ∣0⟩ = basis_vector 1 0)
Crunching: (I 1 = basis_vector 1 0)
Crunching: (forall n : nat, n ⨂ ∣0⟩ = basis_vector (2 ^ n) 0)
Crunching: (0 ⨂ ∣0⟩ = basis_vector 1 0)
Crunching:
((if (x =? y) && (x <? 1) then C1 else 0%R) =
 (if (x =? 0) && (y =? 0) then C1 else 0%R))
Crunching: (I 1 = basis_vector 1 0)
Crunching: (0 ⨂ ∣0⟩ = basis_vector 1 0)
Debug:
In environment
H1, A : int
l : annotated_recs_v.precond.Sn2 H1 A
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l0 : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l0 =
     [:: (((match binomialz (intZmod.addz (intZmod.addz H1 1) 1) A with
            | Posz n => iterop n addq 1 0
            | Negz n =>
                (-
                 match n with
                 | 0 => 1%Q
                 | _.+1 =>
                     (1%Q +
                      (fix loop (m : nat) : rat :=
                         match m with
                         | 0 => 0
                         | 1 => 1
                         | (_.+1 as i).+1 => 1%Q + loop i
                         end) n)%Q
                 end)%Q
            end *
            match binomialz (intZmod.addz (intZmod.addz H1 1) 1) A with
            | Posz n => iterop n addq 1 0
            | Negz n =>
                (-
                 match n with
                 | 0 => 1%Q
                 | _.+1 =>
                     (1%Q +
                      (fix loop (m : nat) : rat :=
                         match m with
                         | 0 => 0
                         | 1 => 1
                         | (_.+1 as i).+1 => 1%Q + loop i
                         end) n)%Q
                 end)%Q
            end)%Q *
           (match
              binomialz (intZmod.addz (intZmod.addz (intZmod.addz H1 1) 1) A)
                A
            with
            | Posz n => iterop n addq 1 0
            | Negz n =>
                (-
                 match n with
                 | 0 => 1%Q
                 | _.+1 =>
                     (1%Q +
                      (fix loop (m : nat) : rat :=
                         match m with
                         | 0 => 0
                         | 1 => 1
                         | (_.+1 as i).+1 => 1%Q + loop i
                         end) n)%Q
                 end)%Q
            end *
            match
              binomialz (intZmod.addz (intZmod.addz (intZmod.addz H1 1) 1) A)
                A
            with
            | Posz n => iterop n addq 1 0
            | Negz n =>
                (-
                 match n with
                 | 0 => 1%Q
                 | _.+1 =>
                     (1%Q +
                      (fix loop (m : nat) : rat :=
                         match m with
                         | 0 => 0
                         | 1 => 1
                         | (_.+1 as i).+1 => 1%Q + loop i
                         end) n)%Q
                 end)%Q
            end)%Q)%Q *
          (ghn3 (intZmod.addz (intZmod.addz H1 1) 1) +
           s (intZmod.addz (intZmod.addz H1 1) 1) A)%Q)%Q;
         ((((((((- rat_of_Z (BinNums.Zpos 1%AC))%Q *
                ((match H1 with
                  | Posz n => iterop n addq 1 0
                  | Negz n =>
                      (-
                       match n with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as i).+1 => 1%Q + loop i
                               end) n)%Q
                       end)%Q
                  end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q +
                 match A with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end)%Q)%Q *
               (((((((((((((rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)) +
                            (rat_of_Z (BinNums.Zpos (...)) *
                             (match ... with
                              | ... ...
                              | ... ...%Q
                              end * match ... with
                                    | ... ...
                                    | ... ...%Q
                                    end)%Q)%Q)%Q +
                           (((- rat_of_Z (...))%Q *
                             match A with
                             | Posz n => iterop n addq 1 0
                             | Negz n => (- ...)%Q
                             end)%Q *
                            match H1 with
                            | Posz n => iterop n addq 1 0
                            | Negz n =>
                                (- match ... with
                                   | ... 1%Q
                                   | ... ...%Q
                                   end)%Q
                            end)%Q)%Q +
                          (rat_of_Z
                             (BinNums.Zpos (BinNums.xO (BinNums.xI 1%AC))) *
                           (match A with
                            | Posz n => iterop n addq 1 0
                            | Negz n =>
                                (- match ... with
                                   | ... 1%Q
                                   | ... ...%Q
                                   end)%Q
                            end *
                            match A with
                            | Posz n => iterop n addq 1 0
                            | Negz n =>
                                (- match ... with
                                   | ... 1%Q
                                   | ... ...%Q
                                   end)%Q
                            end)%Q)%Q)%Q +
                         (match H1 with
                          | Posz n => iterop n addq 1 0
                          | Negz n =>
                              (-
                               match n with
                               | 0 => 1%Q
                               | _.+1 => (1%Q + (...) n)%Q
                               end)%Q
                          end *
                          (match H1 with
                           | Posz n => iterop n addq 1 0
                           | Negz n =>
                               (-
                                match n with
                                | 0 => 1%Q
                                | _.+1 => (1%Q + ...)%Q
                                end)%Q
                           end *
                           (match H1 with
                            | Posz n => iterop n addq 1 0
                            | Negz n =>
                                (- match ... with
                                   | ... 1%Q
                                   | ... ...%Q
                                   end)%Q
                            end *
                            match H1 with
                            | Posz n => iterop n addq 1 0
                            | Negz n =>
                                (- match ... with
                                   | ... 1%Q
                                   | ... ...%Q
                                   end)%Q
                            end)%Q)%Q)%Q)%Q +
                        (rat_of_Z
                           (BinNums.Zpos (BinNums.xI (BinNums.xO 1%AC))) *
                         (match H1 with
                          | Posz n => iterop n addq 1 0
                          | Negz n =>
                              (-
                               match n with
                               | 0 => 1%Q
                               | _.+1 => (1%Q + (...) n)%Q
                               end)%Q
                          end *
                          (match H1 with
                           | Posz n => iterop n addq 1 0
                           | Negz n =>
                               (-
                                match n with
                                | 0 => 1%Q
                                | _.+1 => (1%Q + ...)%Q
                                end)%Q
                           end *
                           match H1 with
                           | Posz n => iterop n addq 1 0
                           | Negz n =>
                               (-
                                match n with
                                | 0 => 1%Q
                                | _.+1 => (1%Q + ...)%Q
                                end)%Q
                           end)%Q)%Q)%Q)%Q +
                       (rat_of_Z
                          (BinNums.Zpos (BinNums.xO (BinNums.xI 1%AC))) *
                        (match A with
                         | Posz n => iterop n addq 1 0
                         | Negz n =>
                             (-
                              match n with
                              | 0 => 1%Q
                              | _.+1 =>
                                  (1%Q +
                                   (fix loop ... : rat := ...
                                                 ...
                                                 ...
                                                 ...
                                                 end) n)%Q
                              end)%Q
                         end *
                         (match A with
                          | Posz n => iterop n addq 1 0
                          | Negz n =>
                              (-
                               match n with
                               | 0 => 1%Q
                               | _.+1 => (1%Q + (...) n)%Q
                               end)%Q
                          end *
                          match A with
                          | Posz n => iterop n addq 1 0
                          | Negz n =>
                              (-
                               match n with
                               | 0 => 1%Q
                               | _.+1 => (1%Q + (...) n)%Q
                               end)%Q
                          end)%Q)%Q)%Q)%Q +
                      (match A with
                       | Posz n => iterop n addq 1 0
                       | Negz n =>
                           (-
                            match n with
                            | 0 => 1%Q
                            | _.+1 =>
                                (1%Q +
                                 (fix loop (m : nat) : rat :=
                                    match m with
                                    | 0 => 0
                                    | 1 => 1
                                    | (_.+1 as i).+1 => 1%Q + loop i
                                    end) n)%Q
                            end)%Q
                       end *
                       (match H1 with
                        | Posz n => iterop n addq 1 0
                        | Negz n =>
                            (-
                             match n with
                             | 0 => 1%Q
                             | _.+1 =>
                                 (1%Q +
                                  (fix loop (m : nat) : rat :=
                                     match ... with
                                     | ... => 0
                                     | ... => 1
                                     | ... => 1%Q + ...
                                     end) n)%Q
                             end)%Q
                        end *
                        (match H1 with
                         | Posz n => iterop n addq 1 0
                         | Negz n =>
                             (-
                              match n with
                              | 0 => 1%Q
                              | _.+1 =>
                                  (1%Q +
                                   (fix loop ... : rat := ...
                                                 ...
                                                 ...
                                                 ...
                                                 end) n)%Q
                              end)%Q
                         end *
                         match H1 with
                         | Posz n => iterop n addq 1 0
                         | Negz n =>
                             (-
                              match n with
                              | 0 => 1%Q
                              | _.+1 =>
                                  (1%Q +
                                   (fix loop ... : rat := ...
                                                 ...
                                                 ...
                                                 ...
                                                 end) n)%Q
                              end)%Q
                         end)%Q)%Q)%Q)%Q +
                     ((-
                       match A with
                       | Posz n => iterop n addq 1 0
                       | Negz n =>
                           (-
                            match n with
                            | 0 => 1%Q
                            | _.+1 =>
                                (1%Q +
                                 (fix loop (m : nat) : rat :=
                                    match m with
                                    | 0 => 0
                                    | 1 => 1
                                    | (_.+1 as i).+1 => 1%Q + loop i
                                    end) n)%Q
                            end)%Q
                       end)%Q *
                      (match H1 with
                       | Posz n => iterop n addq 1 0
                       | Negz n =>
                           (-
                            match n with
                            | 0 => 1%Q
                            | _.+1 =>
                                (1%Q +
                                 (fix loop (m : nat) : rat :=
                                    match m with
                                    | 0 => 0
                                    | 1 => 1
                                    | (_.+1 as i).+1 => 1%Q + loop i
                                    end) n)%Q
                            end)%Q
                       end *
                       match H1 with
                       | Posz n => iterop n addq 1 0
                       | Negz n =>
                           (-
                            match n with
                            | 0 => 1%Q
                            | _.+1 =>
                                (1%Q +
                                 (fix loop (m : nat) : rat :=
                                    match m with
                                    | 0 => 0
                                    | 1 => 1
                                    | (_.+1 as i).+1 => 1%Q + loop i
                                    end) n)%Q
                            end)%Q
                       end)%Q)%Q)%Q +
                    (((-
                       rat_of_Z (BinNums.Zpos (BinNums.xO (BinNums.xO 1%AC))))%Q *
                      (match A with
                       | Posz n => iterop n addq 1 0
                       | Negz n =>
                           (-
                            match n with
                            | 0 => 1%Q
                            | _.+1 =>
                                (1%Q +
                                 (fix loop (m : nat) : rat :=
                                    match m with
                                    | 0 => 0
                                    | 1 => 1
                                    | (_.+1 as i).+1 => 1%Q + loop i
                                    end) n)%Q
                            end)%Q
                       end *
                       match A with
                       | Posz n => iterop n addq 1 0
                       | Negz n =>
                           (-
                            match n with
                            | 0 => 1%Q
                            | _.+1 =>
                                (1%Q +
                                 (fix loop (m : nat) : rat :=
                                    match m with
                                    | 0 => 0
                                    | 1 => 1
                                    | (_.+1 as i).+1 => 1%Q + loop i
                                    end) n)%Q
                            end)%Q
                       end)%Q)%Q *
                     (match H1 with
                      | Posz n => iterop n addq 1 0
                      | Negz n =>
                          (-
                           match n with
                           | 0 => 1%Q
                           | _.+1 =>
                               (1%Q +
                                (fix loop (m : nat) : rat :=
                                   match m with
                                   | 0 => 0
                                   | 1 => 1
                                   | (_.+1 as i).+1 => 1%Q + loop i
                                   end) n)%Q
                           end)%Q
                      end *
                      match H1 with
                      | Posz n => iterop n addq 1 0
                      | Negz n =>
                          (-
                           match n with
                           | 0 => 1%Q
                           | _.+1 =>
                               (1%Q +
                                (fix loop (m : nat) : rat :=
                                   match m with
                                   | 0 => 0
                                   | 1 => 1
                                   | (_.+1 as i).+1 => 1%Q + loop i
                                   end) n)%Q
                           end)%Q
                      end)%Q)%Q)%Q +
                   (((- rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q *
                     (match A with
                      | Posz n => iterop n addq 1 0
                      | Negz n =>
                          (-
                           match n with
                           | 0 => 1%Q
                           | _.+1 =>
                               (1%Q +
                                (fix loop (m : nat) : rat :=
                                   match m with
                                   | 0 => 0
                                   | 1 => 1
                                   | (_.+1 as i).+1 => 1%Q + loop i
                                   end) n)%Q
                           end)%Q
                      end *
                      match A with
                      | Posz n => iterop n addq 1 0
                      | Negz n =>
                          (-
                           match n with
                           | 0 => 1%Q
                           | _.+1 =>
                               (1%Q +
                                (fix loop (m : nat) : rat :=
                                   match m with
                                   | 0 => 0
                                   | 1 => 1
                                   | (_.+1 as i).+1 => 1%Q + loop i
                                   end) n)%Q
                           end)%Q
                      end)%Q)%Q *
                    match H1 with
                    | Posz n => iterop n addq 1 0
                    | Negz n =>
                        (-
                         match n with
                         | 0 => 1%Q
                         | _.+1 =>
                             (1%Q +
                              (fix loop (m : nat) : rat :=
                                 match m with
                                 | 0 => 0
                                 | 1 => 1
                                 | (_.+1 as i).+1 => 1%Q + loop i
                                 end) n)%Q
                         end)%Q
                    end)%Q)%Q +
                  ((rat_of_Z (BinNums.Zpos (BinNums.xO (BinNums.xO 1%AC))) *
                    (match A with
                     | Posz n => iterop n addq 1 0
                     | Negz n =>
                         (-
                          match n with
                          | 0 => 1%Q
                          | _.+1 =>
                              (1%Q +
                               (fix loop (m : nat) : rat :=
                                  match m with
                                  | 0 => 0
                                  | 1 => 1
                                  | (_.+1 as i).+1 => 1%Q + loop i
                                  end) n)%Q
                          end)%Q
                     end *
                     (match A with
                      | Posz n => iterop n addq 1 0
                      | Negz n =>
                          (-
                           match n with
                           | 0 => 1%Q
                           | _.+1 =>
                               (1%Q +
                                (fix loop (m : nat) : rat :=
                                   match m with
                                   | 0 => 0
                                   | 1 => 1
                                   | (_.+1 as i).+1 => 1%Q + loop i
                                   end) n)%Q
                           end)%Q
                      end *
                      match A with
                      | Posz n => iterop n addq 1 0
                      | Negz n =>
                          (-
                           match n with
                           | 0 => 1%Q
                           | _.+1 =>
                               (1%Q +
                                (fix loop (m : nat) : rat :=
                                   match m with
                                   | 0 => 0
                                   | 1 => 1
                                   | (_.+1 as i).+1 => 1%Q + loop i
                                   end) n)%Q
                           end)%Q
                      end)%Q)%Q)%Q *
                   match H1 with
                   | Posz n => iterop n addq 1 0
                   | Negz n =>
                       (-
                        match n with
                        | 0 => 1%Q
                        | _.+1 =>
                            (1%Q +
                             (fix loop (m : nat) : rat :=
                                match m with
                                | 0 => 0
                                | 1 => 1
                                | (_.+1 as i).+1 => 1%Q + loop i
                                end) n)%Q
                        end)%Q
                   end)%Q)%Q +
                 match A with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end)%Q +
                (rat_of_Z (BinNums.Zpos (BinNums.xI (BinNums.xI 1%AC))) *
                 match H1 with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end)%Q)%Q)%Q *
              (((match H1 with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end + rat_of_Z (BinNums.Zpos 1%AC))%Q +
                match A with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 => 1%Q + loop i
                             end) n)%Q
                     end)%Q
                end)%Q *
               ((match H1 with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end + rat_of_Z (BinNums.Zpos 1%AC))%Q +
                match A with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 => 1%Q + loop i
                             end) n)%Q
                     end)%Q
                end)%Q)%Q)%Q *
             (((((match H1 with
                  | Posz n => iterop n addq 1 0
                  | Negz n =>
                      (-
                       match n with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as i).+1 => 1%Q + loop i
                               end) n)%Q
                       end)%Q
                  end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q *
                 ((match H1 with
                   | Posz n => iterop n addq 1 0
                   | Negz n =>
                       (-
                        match n with
                        | 0 => 1%Q
                        | _.+1 =>
                            (1%Q +
                             (fix loop (m : nat) : rat :=
                                match m with
                                | 0 => 0
                                | 1 => 1
                                | (_.+1 as i).+1 => 1%Q + loop i
                                end) n)%Q
                        end)%Q
                   end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q *
                  (match H1 with
                   | Posz n => iterop n addq 1 0
                   | Negz n =>
                       (-
                        match n with
                        | 0 => 1%Q
                        | _.+1 =>
                            (1%Q +
                             (fix loop (m : nat) : rat :=
                                match m with
                                | 0 => 0
                                | 1 => 1
                                | (_.+1 as i).+1 => 1%Q + loop i
                                end) n)%Q
                        end)%Q
                   end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q)%Q)%Q *
                ((((-
                    match H1 with
                    | Posz n => iterop n addq 1 0
                    | Negz n =>
                        (-
                         match n with
                         | 0 => 1%Q
                         | _.+1 =>
                             (1%Q +
                              (fix loop (m : nat) : rat :=
                                 match m with
                                 | 0 => 0
                                 | 1 => 1
                                 | (_.+1 as i).+1 => 1%Q + loop i
                                 end) n)%Q
                         end)%Q
                    end)%Q + (- rat_of_Z (BinNums.Zpos 1%AC))%Q)%Q +
                  match A with
                  | Posz n => iterop n addq 1 0
                  | Negz n =>
                      (-
                       match n with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as i).+1 => 1%Q + loop i
                               end) n)%Q
                       end)%Q
                  end)%Q *
                 (((-
                    match H1 with
                    | Posz n => iterop n addq 1 0
                    | Negz n =>
                        (-
                         match n with
                         | 0 => 1%Q
                         | _.+1 =>
                             (1%Q +
                              (fix loop (m : nat) : rat :=
                                 match m with
                                 | 0 => 0
                                 | 1 => 1
                                 | (_.+1 as i).+1 => 1%Q + loop i
                                 end) n)%Q
                         end)%Q
                    end)%Q + (- rat_of_Z (BinNums.Zpos 1%AC))%Q)%Q +
                  match A with
                  | Posz n => iterop n addq 1 0
                  | Negz n =>
                      (-
                       match n with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as i).+1 => 1%Q + loop i
                               end) n)%Q
                       end)%Q
                  end)%Q)%Q)%Q *
               (((match A with
                  | Posz n => iterop n addq 1 0
                  | Negz n =>
                      (-
                       match n with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as i).+1 => 1%Q + loop i
                               end) n)%Q
                       end)%Q
                  end +
                  (-
                   match H1 with
                   | Posz n => iterop n addq 1 0
                   | Negz n =>
                       (-
                        match n with
                        | 0 => 1%Q
                        | _.+1 =>
                            (1%Q +
                             (fix loop (m : nat) : rat :=
                                match m with
                                | 0 => 0
                                | 1 => 1
                                | (_.+1 as i).+1 => 1%Q + loop i
                                end) n)%Q
                        end)%Q
                   end)%Q)%Q +
                 (- rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q)%Q *
                ((match A with
                  | Posz n => iterop n addq 1 0
                  | Negz n =>
                      (-
                       match n with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as i).+1 => 1%Q + loop i
                               end) n)%Q
                       end)%Q
                  end +
                  (-
                   match H1 with
                   | Posz n => iterop n addq 1 0
                   | Negz n =>
                       (-
                        match n with
                        | 0 => 1%Q
                        | _.+1 =>
                            (1%Q +
                             (fix loop (m : nat) : rat :=
                                match m with
                                | 0 => 0
                                | 1 => 1
                                | (_.+1 as i).+1 => 1%Q + loop i
                                end) n)%Q
                        end)%Q
                   end)%Q)%Q +
                 (- rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q)%Q)%Q)%Q^-1)%Q)%Q *
            (((match binomialz H1 A with
               | Posz n => iterop n addq 1 0
               | Negz n =>
                   (-
                    match n with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 => 1%Q + loop i
                            end) n)%Q
                    end)%Q
               end *
               match binomialz H1 A with
               | Posz n => iterop n addq 1 0
               | Negz n =>
                   (-
                    match n with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 => 1%Q + loop i
                            end) n)%Q
                    end)%Q
               end)%Q *
              (match binomialz (intZmod.addz H1 A) A with
               | Posz n => iterop n addq 1 0
               | Negz n =>
                   (-
                    match n with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 => 1%Q + loop i
                            end) n)%Q
                    end)%Q
               end *
               match binomialz (intZmod.addz H1 A) A with
               | Posz n => iterop n addq 1 0
               | Negz n =>
                   (-
                    match n with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 => 1%Q + loop i
                            end) n)%Q
                    end)%Q
               end)%Q)%Q * (ghn3 H1 + s H1 A)%Q)%Q)%Q +
           ((((((rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)) *
                 match H1 with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end)%Q + rat_of_Z (BinNums.Zpos (BinNums.xI 1%AC)))%Q *
               (((match H1 with
                  | Posz n => iterop n addq 1 0
                  | Negz n =>
                      (-
                       match n with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as i).+1 => 1%Q + loop i
                               end) n)%Q
                       end)%Q
                  end *
                  match H1 with
                  | Posz n => iterop n addq 1 0
                  | Negz n =>
                      (-
                       match n with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as i).+1 => 1%Q + loop i
                               end) n)%Q
                       end)%Q
                  end)%Q +
                 (rat_of_Z (BinNums.Zpos (BinNums.xI 1%AC)) *
                  match H1 with
                  | Posz n => iterop n addq 1 0
                  | Negz n =>
                      (-
                       match n with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as i).+1 => 1%Q + loop i
                               end) n)%Q
                       end)%Q
                  end)%Q)%Q + rat_of_Z (BinNums.Zpos (BinNums.xI 1%AC)))%Q)%Q *
              (((match H1 with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q +
                match A with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 => 1%Q + loop i
                             end) n)%Q
                     end)%Q
                end)%Q *
               ((match H1 with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q +
                match A with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 => 1%Q + loop i
                             end) n)%Q
                     end)%Q
                end)%Q)%Q)%Q *
             ((((match H1 with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q *
                ((match H1 with
                  | Posz n => iterop n addq 1 0
                  | Negz n =>
                      (-
                       match n with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as i).+1 => 1%Q + loop i
                               end) n)%Q
                       end)%Q
                  end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q *
                 (match H1 with
                  | Posz n => iterop n addq 1 0
                  | Negz n =>
                      (-
                       match n with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as i).+1 => 1%Q + loop i
                               end) n)%Q
                       end)%Q
                  end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q)%Q)%Q *
               (((match A with
                  | Posz n => iterop n addq 1 0
                  | Negz n =>
                      (-
                       match n with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as i).+1 => 1%Q + loop i
                               end) n)%Q
                       end)%Q
                  end +
                  (-
                   match H1 with
                   | Posz n => iterop n addq 1 0
                   | Negz n =>
                       (-
                        match n with
                        | 0 => 1%Q
                        | _.+1 =>
                            (1%Q +
                             (fix loop (m : nat) : rat :=
                                match m with
                                | 0 => 0
                                | 1 => 1
                                | (_.+1 as i).+1 => 1%Q + loop i
                                end) n)%Q
                        end)%Q
                   end)%Q)%Q +
                 (- rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q)%Q *
                ((match A with
                  | Posz n => iterop n addq 1 0
                  | Negz n =>
                      (-
                       match n with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as i).+1 => 1%Q + loop i
                               end) n)%Q
                       end)%Q
                  end +
                  (-
                   match H1 with
                   | Posz n => iterop n addq 1 0
                   | Negz n =>
                       (-
                        match n with
                        | 0 => 1%Q
                        | _.+1 =>
                            (1%Q +
                             (fix loop (m : nat) : rat :=
                                match m with
                                | 0 => 0
                                | 1 => 1
                                | (_.+1 as i).+1 => 1%Q + loop i
                                end) n)%Q
                        end)%Q
                   end)%Q)%Q +
                 (- rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q)%Q)%Q)%Q^-1)%Q)%Q *
            (((match binomialz (intZmod.addz H1 1) A with
               | Posz n => iterop n addq 1 0
               | Negz n =>
                   (-
                    match n with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 => 1%Q + loop i
                            end) n)%Q
                    end)%Q
               end *
               match binomialz (intZmod.addz H1 1) A with
               | Posz n => iterop n addq 1 0
               | Negz n =>
                   (-
                    match n with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 => 1%Q + loop i
                            end) n)%Q
                    end)%Q
               end)%Q *
              (match binomialz (intZmod.addz (intZmod.addz H1 1) A) A with
               | Posz n => iterop n addq 1 0
               | Negz n =>
                   (-
                    match n with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 => 1%Q + loop i
                            end) n)%Q
                    end)%Q
               end *
               match binomialz (intZmod.addz (intZmod.addz H1 1) A) A with
               | Posz n => iterop n addq 1 0
               | Negz n =>
                   (-
                    match n with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 => 1%Q + loop i
                            end) n)%Q
                    end)%Q
               end)%Q)%Q *
             (ghn3 (intZmod.addz H1 1) + s (intZmod.addz H1 1) A)%Q)%Q)%Q)%Q +
          ((((((rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)) *
                match A with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 => 1%Q + loop i
                             end) n)%Q
                     end)%Q
                end)%Q *
               ((rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)) *
                 match H1 with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end)%Q + rat_of_Z (BinNums.Zpos (BinNums.xI 1%AC)))%Q)%Q *
              ((match A with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 => 1%Q + loop i
                             end) n)%Q
                     end)%Q
                end + rat_of_Z (BinNums.Zpos 1%AC))%Q *
               ((match A with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end + rat_of_Z (BinNums.Zpos 1%AC))%Q *
                ((match A with
                  | Posz n => iterop n addq 1 0
                  | Negz n =>
                      (-
                       match n with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as i).+1 => 1%Q + loop i
                               end) n)%Q
                       end)%Q
                  end + rat_of_Z (BinNums.Zpos 1%AC))%Q *
                 ((match A with
                   | Posz n => iterop n addq 1 0
                   | Negz n =>
                       (-
                        match n with
                        | 0 => 1%Q
                        | _.+1 =>
                            (1%Q +
                             (fix loop (m : nat) : rat :=
                                match m with
                                | 0 => 0
                                | 1 => 1
                                | (_.+1 as i).+1 => 1%Q + loop i
                                end) n)%Q
                        end)%Q
                   end + rat_of_Z (BinNums.Zpos 1%AC))%Q *
                  (match A with
                   | Posz n => iterop n addq 1 0
                   | Negz n =>
                       (-
                        match n with
                        | 0 => 1%Q
                        | _.+1 =>
                            (1%Q +
                             (fix loop (m : nat) : rat :=
                                match m with
                                | 0 => 0
                                | 1 => 1
                                | (_.+1 as i).+1 => 1%Q + loop i
                                end) n)%Q
                        end)%Q
                   end + rat_of_Z (BinNums.Zpos 1%AC))%Q)%Q)%Q)%Q)%Q)%Q *
             ((match H1 with
               | Posz n => iterop n addq 1 0
               | Negz n =>
                   (-
                    match n with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 => 1%Q + loop i
                            end) n)%Q
                    end)%Q
               end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q +
              match A with
              | Posz n => iterop n addq 1 0
              | Negz n =>
                  (-
                   match n with
                   | 0 => 1%Q
                   | _.+1 =>
                       (1%Q +
                        (fix loop (m : nat) : rat :=
                           match m with
                           | 0 => 0
                           | 1 => 1
                           | (_.+1 as i).+1 => 1%Q + loop i
                           end) n)%Q
                   end)%Q
              end)%Q)%Q *
            ((((((match H1 with
                  | Posz n => iterop n addq 1 0
                  | Negz n =>
                      (-
                       match n with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as i).+1 => 1%Q + loop i
                               end) n)%Q
                       end)%Q
                  end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q *
                 ((match H1 with
                   | Posz n => iterop n addq 1 0
                   | Negz n =>
                       (-
                        match n with
                        | 0 => 1%Q
                        | _.+1 =>
                            (1%Q +
                             (fix loop (m : nat) : rat :=
                                match m with
                                | 0 => 0
                                | 1 => 1
                                | (_.+1 as i).+1 => 1%Q + loop i
                                end) n)%Q
                        end)%Q
                   end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q *
                  (match H1 with
                   | Posz n => iterop n addq 1 0
                   | Negz n =>
                       (-
                        match n with
                        | 0 => 1%Q
                        | _.+1 =>
                            (1%Q +
                             (fix loop (m : nat) : rat :=
                                match m with
                                | 0 => 0
                                | 1 => 1
                                | (_.+1 as i).+1 => 1%Q + loop i
                                end) n)%Q
                        end)%Q
                   end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q)%Q)%Q *
                ((-
                  match H1 with
                  | Posz n => iterop n addq 1 0
                  | Negz n =>
                      (-
                       match n with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as i).+1 => 1%Q + loop i
                               end) n)%Q
                       end)%Q
                  end)%Q +
                 match A with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end)%Q)%Q *
               ((((-
                   match H1 with
                   | Posz n => iterop n addq 1 0
                   | Negz n =>
                       (-
                        match n with
                        | 0 => 1%Q
                        | _.+1 =>
                            (1%Q +
                             (fix loop (m : nat) : rat :=
                                match m with
                                | 0 => 0
                                | 1 => 1
                                | (_.+1 as i).+1 => 1%Q + loop i
                                end) n)%Q
                        end)%Q
                   end)%Q + (- rat_of_Z (BinNums.Zpos 1%AC))%Q)%Q +
                 match A with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end)%Q *
                (((-
                   match H1 with
                   | Posz n => iterop n addq 1 0
                   | Negz n =>
                       (-
                        match n with
                        | 0 => 1%Q
                        | _.+1 =>
                            (1%Q +
                             (fix loop (m : nat) : rat :=
                                match m with
                                | 0 => 0
                                | 1 => 1
                                | (_.+1 as i).+1 => 1%Q + loop i
                                end) n)%Q
                        end)%Q
                   end)%Q + (- rat_of_Z (BinNums.Zpos 1%AC))%Q)%Q +
                 match A with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end)%Q)%Q)%Q *
              (((match A with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end +
                 (-
                  match H1 with
                  | Posz n => iterop n addq 1 0
                  | Negz n =>
                      (-
                       match n with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as i).+1 => 1%Q + loop i
                               end) n)%Q
                       end)%Q
                  end)%Q)%Q + (- rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q)%Q *
               ((match A with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end +
                 (-
                  match H1 with
                  | Posz n => iterop n addq 1 0
                  | Negz n =>
                      (-
                       match n with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as i).+1 => 1%Q + loop i
                               end) n)%Q
                       end)%Q
                  end)%Q)%Q + (- rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q)%Q)%Q)%Q^-1)%Q)%Q *
           (((match binomialz H1 (intZmod.addz A 1) with
              | Posz n => iterop n addq 1 0
              | Negz n =>
                  (-
                   match n with
                   | 0 => 1%Q
                   | _.+1 =>
                       (1%Q +
                        (fix loop (m : nat) : rat :=
                           match m with
                           | 0 => 0
                           | 1 => 1
                           | (_.+1 as i).+1 => 1%Q + loop i
                           end) n)%Q
                   end)%Q
              end *
              match binomialz H1 (intZmod.addz A 1) with
              | Posz n => iterop n addq 1 0
              | Negz n =>
                  (-
                   match n with
                   | 0 => 1%Q
                   | _.+1 =>
                       (1%Q +
                        (fix loop (m : nat) : rat :=
                           match m with
                           | 0 => 0
                           | 1 => 1
                           | (_.+1 as i).+1 => 1%Q + loop i
                           end) n)%Q
                   end)%Q
              end)%Q *
             (match
                binomialz (intZmod.addz H1 (intZmod.addz A 1))
                  (intZmod.addz A 1)
              with
              | Posz n => iterop n addq 1 0
              | Negz n =>
                  (-
                   match n with
                   | 0 => 1%Q
                   | _.+1 =>
                       (1%Q +
                        (fix loop (m : nat) : rat :=
                           match m with
                           | 0 => 0
                           | 1 => 1
                           | (_.+1 as i).+1 => 1%Q + loop i
                           end) n)%Q
                   end)%Q
              end *
              match
                binomialz (intZmod.addz H1 (intZmod.addz A 1))
                  (intZmod.addz A 1)
              with
              | Posz n => iterop n addq 1 0
              | Negz n =>
                  (-
                   match n with
                   | 0 => 1%Q
                   | _.+1 =>
                       (1%Q +
                        (fix loop (m : nat) : rat :=
                           match m with
                           | 0 => 0
                           | 1 => 1
                           | (_.+1 as i).+1 => 1%Q + loop i
                           end) n)%Q
                   end)%Q
              end)%Q)%Q * (ghn3 H1 + s H1 (intZmod.addz A 1))%Q)%Q)%Q)%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching: (I 1 = basis_vector 1 0)
Crunching: (forall n : nat, n ⨂ ∣0⟩ = basis_vector (2 ^ n) 0)
Crunching: (0 ⨂ ∣0⟩ = basis_vector 1 0)
Crunching: (I 1 = basis_vector 1 0)
Crunching: False
Crunching: (forall a b : nat, 0 <= a <= b -> b * a + a * b <= a * a + b * b)
"notUA has been translated as notUAᵗ"
Debug:
In environment
n, m : int
Ha : annotated_recs_v.precond.SnSk n m
valq : int * int
i : (0 < valq.2) && coprime `|valq.1| `|valq.2|
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: Rat i; annotated_recs_v.SnSk_cf0_0 n m; v n m;
         annotated_recs_v.SnSk_cf1_0 n m; v (int.shift 1 n) m;
         annotated_recs_v.SnSk_cf0_1 n m; v n (int.shift 1 m)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching:
(list2D_to_matrix [[e]] = Zero .+ Cexp (c * 0) .* basis_vector 1 0)
Crunching: (I 1 = list2D_to_matrix [[Cexp (c * 0)]])
Crunching:
(list2D_to_matrix [[e]] = Zero .+ Cexp (0 * c) .* basis_vector 1 0)
Crunching: (I 1 = list2D_to_matrix [[Cexp (0 * c)]])
Crunching:
(list2D_to_matrix [[e]] = Zero .+ Cexp (c * 0) .* basis_vector 1 0)
Crunching: (I 1 = list2D_to_matrix [[Cexp (c * 0)]])
Crunching:
(list2D_to_matrix [[e]] = Zero .+ Cexp (0 * c) .* basis_vector 1 0)
Crunching: (I 1 = list2D_to_matrix [[Cexp (0 * c)]])
Crunching:
(list2D_to_matrix [[e]] = Zero .+ Cexp (c * 0) .* basis_vector 1 0)
Crunching: (list2D_to_matrix [[Cexp (c * 0)]] = I 1)
Crunching:
(list2D_to_matrix [[e]] = Zero .+ Cexp (c * 0) .* basis_vector 1 0)
Crunching: (list2D_to_matrix [[Cexp (c * 0)]] = I 1)
Crunching:
(list2D_to_matrix [[e]] = Zero .+ Cexp (c * 0) .* basis_vector 1 0)
Crunching: (I 1 = list2D_to_matrix [[Cexp (c * 0)]])
Crunching:
(list2D_to_matrix [[e]] = Zero .+ Cexp (c * 0) .* basis_vector 1 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣1⟩ = basis_vector 2 1)
Debug:
In environment
H, k_ : int
H0 : annotated_recs_v.precond.Sk2 H k_
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: v H (int.shift 2 k_); annotated_recs_v.Sk2_cf0_0 H k_; 
        v H k_; annotated_recs_v.Sk2_cf0_1 H k_; v H (int.shift 1 k_)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
H, HF : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: v H (int.shift 2 HF); annotated_recs_v.Sk2_cf0_0 H HF; 
        v H HF; annotated_recs_v.Sk2_cf0_1 H HF; v H (int.shift 1 HF)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
H, k_ : int
H0 : annotated_recs_v.precond.Sk2 H k_
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: v H (int.shift 2 k_); annotated_recs_v.Sk2_cf0_0 H k_; 
        v H k_; annotated_recs_v.Sk2_cf0_1 H k_; v H (int.shift 1 k_)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
H, HF : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: v H (int.shift 2 HF); annotated_recs_v.Sk2_cf0_0 H HF; 
        v H HF; annotated_recs_v.Sk2_cf0_1 H HF; v H (int.shift 1 HF)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
H, HF : int
p : annotated_recs_v.precond.Sk2 H HF
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: v H (int.shift 2 HF); annotated_recs_v.Sk2_cf0_0 H HF; 
        v H HF; annotated_recs_v.Sk2_cf0_1 H HF; v H (int.shift 1 HF)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
H, HF : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: v H (int.shift 2 HF); annotated_recs_v.Sk2_cf0_0 H HF; 
        v H HF; annotated_recs_v.Sk2_cf0_1 H HF; v H (int.shift 1 HF)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
b, Hb : int
IH : annotated_recs_v.precond.Sk2 b Hb
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: v b (int.shift 2 Hb); annotated_recs_v.Sk2_cf0_0 b Hb; 
        v b Hb; annotated_recs_v.Sk2_cf0_1 b Hb; v b (int.shift 1 Hb)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
H, k_ : int
H0 : annotated_recs_v.precond.Sk2 H k_
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: v H (int.shift 2 k_); annotated_recs_v.Sk2_cf0_0 H k_; 
        v H k_; annotated_recs_v.Sk2_cf0_1 H k_; v H (int.shift 1 k_)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
H, HF : int
a : annotated_recs_v.precond.Sk2 H HF
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: v H (int.shift 2 HF); annotated_recs_v.Sk2_cf0_0 H HF; 
        v H HF; annotated_recs_v.Sk2_cf0_1 H HF; v H (int.shift 1 HF)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
H, HF : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: v H (int.shift 2 HF); annotated_recs_v.Sk2_cf0_0 H HF; 
        v H HF; annotated_recs_v.Sk2_cf0_1 H HF; v H (int.shift 1 HF)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
H, HF : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: v H (int.shift 2 HF); annotated_recs_v.Sk2_cf0_0 H HF; 
        v H HF; annotated_recs_v.Sk2_cf0_1 H HF; v H (int.shift 1 HF)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
H, HF : int
p : annotated_recs_v.precond.Sk2 H HF
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: v H (int.shift 2 HF); annotated_recs_v.Sk2_cf0_0 H HF; 
        v H HF; annotated_recs_v.Sk2_cf0_1 H HF; v H (int.shift 1 HF)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
H, HF : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: v H (int.shift 2 HF); annotated_recs_v.Sk2_cf0_0 H HF; 
        v H HF; annotated_recs_v.Sk2_cf0_1 H HF; v H (int.shift 1 HF)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
b, Hb : int
IH : annotated_recs_v.precond.Sk2 b Hb
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: v b (int.shift 2 Hb); annotated_recs_v.Sk2_cf0_0 b Hb; 
        v b Hb; annotated_recs_v.Sk2_cf0_1 b Hb; v b (int.shift 1 Hb)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching: (product A eval l = product eval A l)
Debug:
In environment
n : int
i : (2 : int) <= (n : int)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: (((((((((rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)) *
                  match n with
                  | Posz elpi_ctx_entry_2_ =>
                      iterop elpi_ctx_entry_2_ addq 1 0
                  | Negz elpi_ctx_entry_2_ =>
                      (-
                       match elpi_ctx_entry_2_ with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                   1%Q + loop elpi_ctx_entry_6_
                               end) elpi_ctx_entry_2_)%Q
                       end)%Q
                  end)%Q + rat_of_Z (BinNums.Zpos (BinNums.xI 1%AC)))%Q *
                (((((rat_of_Z
                       (BinNums.Zpos
                          (BinNums.xO (BinNums.xO (BinNums.xI 1%AC)))) *
                     (match n with
                      | Posz elpi_ctx_entry_2_ =>
                          iterop elpi_ctx_entry_2_ addq 1 0
                      | Negz elpi_ctx_entry_2_ =>
                          (-
                           match elpi_ctx_entry_2_ with
                           | 0 => 1%Q
                           | _.+1 =>
                               (1%Q +
                                (fix loop (m : nat) : rat :=
                                   match m with
                                   | 0 => 0
                                   | 1 => 1
                                   | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                       1%Q + loop elpi_ctx_entry_6_
                                   end) elpi_ctx_entry_2_)%Q
                           end)%Q
                      end *
                      (match n with
                       | Posz elpi_ctx_entry_2_ =>
                           iterop elpi_ctx_entry_2_ addq 1 0
                       | Negz elpi_ctx_entry_2_ =>
                           (-
                            match elpi_ctx_entry_2_ with
                            | 0 => 1%Q
                            | _.+1 =>
                                (1%Q +
                                 (fix loop (m : nat) : rat :=
                                    match m with
                                    | 0 => 0
                                    | 1 => 1
                                    | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                        1%Q + loop elpi_ctx_entry_6_
                                    end) elpi_ctx_entry_2_)%Q
                            end)%Q
                       end *
                       (match n with
                        | Posz elpi_ctx_entry_2_ =>
                            iterop elpi_ctx_entry_2_ addq 1 0
                        | Negz elpi_ctx_entry_2_ =>
                            (-
                             match elpi_ctx_entry_2_ with
                             | 0 => 1%Q
                             | _.+1 =>
                                 (1%Q +
                                  (fix loop (m : nat) : rat :=
                                     match ... with
                                     | ... => 0
                                     | ... => 1
                                     | ... => 1%Q + ...
                                     end) elpi_ctx_entry_2_)%Q
                             end)%Q
                        end *
                        match n with
                        | Posz elpi_ctx_entry_2_ =>
                            iterop elpi_ctx_entry_2_ addq 1 0
                        | Negz elpi_ctx_entry_2_ =>
                            (-
                             match elpi_ctx_entry_2_ with
                             | 0 => 1%Q
                             | _.+1 =>
                                 (1%Q +
                                  (fix loop (m : nat) : rat :=
                                     match ... with
                                     | ... => 0
                                     | ... => 1
                                     | ... => 1%Q + ...
                                     end) elpi_ctx_entry_2_)%Q
                             end)%Q
                        end)%Q)%Q)%Q)%Q +
                    (rat_of_Z
                       (BinNums.Zpos
                          (BinNums.xO
                             (BinNums.xO
                                (BinNums.xO
                                   (BinNums.xO (BinNums.xO (BinNums.xI 1%AC))))))) *
                     (match n with
                      | Posz elpi_ctx_entry_2_ =>
                          iterop elpi_ctx_entry_2_ addq 1 0
                      | Negz elpi_ctx_entry_2_ =>
                          (-
                           match elpi_ctx_entry_2_ with
                           | 0 => 1%Q
                           | _.+1 =>
                               (1%Q +
                                (fix loop (m : nat) : rat :=
                                   match m with
                                   | 0 => 0
                                   | 1 => 1
                                   | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                       1%Q + loop elpi_ctx_entry_6_
                                   end) elpi_ctx_entry_2_)%Q
                           end)%Q
                      end *
                      (match n with
                       | Posz elpi_ctx_entry_2_ =>
                           iterop elpi_ctx_entry_2_ addq 1 0
                       | Negz elpi_ctx_entry_2_ =>
                           (-
                            match elpi_ctx_entry_2_ with
                            | 0 => 1%Q
                            | _.+1 =>
                                (1%Q +
                                 (fix loop (m : nat) : rat :=
                                    match m with
                                    | 0 => 0
                                    | 1 => 1
                                    | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                        1%Q + loop elpi_ctx_entry_6_
                                    end) elpi_ctx_entry_2_)%Q
                            end)%Q
                       end *
                       match n with
                       | Posz elpi_ctx_entry_2_ =>
                           iterop elpi_ctx_entry_2_ addq 1 0
                       | Negz elpi_ctx_entry_2_ =>
                           (-
                            match elpi_ctx_entry_2_ with
                            | 0 => 1%Q
                            | _.+1 =>
                                (1%Q +
                                 (fix loop (m : nat) : rat :=
                                    match m with
                                    | 0 => 0
                                    | 1 => 1
                                    | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                        1%Q + loop elpi_ctx_entry_6_
                                    end) elpi_ctx_entry_2_)%Q
                            end)%Q
                       end)%Q)%Q)%Q)%Q +
                   (rat_of_Z
                      (BinNums.Zpos
                         (BinNums.xI
                            (BinNums.xI
                               (BinNums.xO
                                  (BinNums.xI
                                     (BinNums.xI
                                        (BinNums.xO
                                           (BinNums.xO (BinNums.xO 1%AC))))))))) *
                    (match n with
                     | Posz elpi_ctx_entry_2_ =>
                         iterop elpi_ctx_entry_2_ addq 1 0
                     | Negz elpi_ctx_entry_2_ =>
                         (-
                          match elpi_ctx_entry_2_ with
                          | 0 => 1%Q
                          | _.+1 =>
                              (1%Q +
                               (fix loop (m : nat) : rat :=
                                  match m with
                                  | 0 => 0
                                  | 1 => 1
                                  | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                      1%Q + loop elpi_ctx_entry_6_
                                  end) elpi_ctx_entry_2_)%Q
                          end)%Q
                     end *
                     match n with
                     | Posz elpi_ctx_entry_2_ =>
                         iterop elpi_ctx_entry_2_ addq 1 0
                     | Negz elpi_ctx_entry_2_ =>
                         (-
                          match elpi_ctx_entry_2_ with
                          | 0 => 1%Q
                          | _.+1 =>
                              (1%Q +
                               (fix loop (m : nat) : rat :=
                                  match m with
                                  | 0 => 0
                                  | 1 => 1
                                  | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                      1%Q + loop elpi_ctx_entry_6_
                                  end) elpi_ctx_entry_2_)%Q
                          end)%Q
                     end)%Q)%Q)%Q +
                  (rat_of_Z
                     (BinNums.Zpos
                        (BinNums.xO
                           (BinNums.xO
                              (BinNums.xI
                                 (BinNums.xI
                                    (BinNums.xO
                                       (BinNums.xI
                                          (BinNums.xI (BinNums.xO 1%AC))))))))) *
                   match n with
                   | Posz elpi_ctx_entry_2_ =>
                       iterop elpi_ctx_entry_2_ addq 1 0
                   | Negz elpi_ctx_entry_2_ =>
                       (-
                        match elpi_ctx_entry_2_ with
                        | 0 => 1%Q
                        | _.+1 =>
                            (1%Q +
                             (fix loop (m : nat) : rat :=
                                match m with
                                | 0 => 0
                                | 1 => 1
                                | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                    1%Q + loop elpi_ctx_entry_6_
                                end) elpi_ctx_entry_2_)%Q
                        end)%Q
                   end)%Q)%Q +
                 rat_of_Z
                   (BinNums.Zpos
                      (BinNums.xI
                         (BinNums.xO
                            (BinNums.xI
                               (BinNums.xI
                                  (BinNums.xO (BinNums.xI (BinNums.xO 1%AC)))))))))%Q)%Q *
               ((match n with
                 | Posz elpi_ctx_entry_2_ =>
                     iterop elpi_ctx_entry_2_ addq 1 0
                 | Negz elpi_ctx_entry_2_ =>
                     (-
                      match elpi_ctx_entry_2_ with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                  1%Q + loop elpi_ctx_entry_6_
                              end) elpi_ctx_entry_2_)%Q
                      end)%Q
                 end + rat_of_Z (BinNums.Zpos (BinNums.xO (BinNums.xO 1%AC))))%Q *
                ((match n with
                  | Posz elpi_ctx_entry_2_ =>
                      iterop elpi_ctx_entry_2_ addq 1 0
                  | Negz elpi_ctx_entry_2_ =>
                      (-
                       match elpi_ctx_entry_2_ with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                   1%Q + loop elpi_ctx_entry_6_
                               end) elpi_ctx_entry_2_)%Q
                       end)%Q
                  end +
                  rat_of_Z (BinNums.Zpos (BinNums.xO (BinNums.xO 1%AC))))%Q *
                 ((match n with
                   | Posz elpi_ctx_entry_2_ =>
                       iterop elpi_ctx_entry_2_ addq 1 0
                   | Negz elpi_ctx_entry_2_ =>
                       (-
                        match elpi_ctx_entry_2_ with
                        | 0 => 1%Q
                        | _.+1 =>
                            (1%Q +
                             (fix loop (m : nat) : rat :=
                                match m with
                                | 0 => 0
                                | 1 => 1
                                | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                    1%Q + loop elpi_ctx_entry_6_
                                end) elpi_ctx_entry_2_)%Q
                        end)%Q
                   end +
                   rat_of_Z (BinNums.Zpos (BinNums.xO (BinNums.xO 1%AC))))%Q *
                  ((match n with
                    | Posz elpi_ctx_entry_2_ =>
                        iterop elpi_ctx_entry_2_ addq 1 0
                    | Negz elpi_ctx_entry_2_ =>
                        (-
                         match elpi_ctx_entry_2_ with
                         | 0 => 1%Q
                         | _.+1 =>
                             (1%Q +
                              (fix loop (m : nat) : rat :=
                                 match m with
                                 | 0 => 0
                                 | 1 => 1
                                 | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                     1%Q + loop elpi_ctx_entry_6_
                                 end) elpi_ctx_entry_2_)%Q
                         end)%Q
                    end +
                    rat_of_Z (BinNums.Zpos (BinNums.xO (BinNums.xO 1%AC))))%Q *
                   ((match n with
                     | Posz elpi_ctx_entry_2_ =>
                         iterop elpi_ctx_entry_2_ addq 1 0
                     | Negz elpi_ctx_entry_2_ =>
                         (-
                          match elpi_ctx_entry_2_ with
                          | 0 => 1%Q
                          | _.+1 =>
                              (1%Q +
                               (fix loop (m : nat) : rat :=
                                  match m with
                                  | 0 => 0
                                  | 1 => 1
                                  | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                      1%Q + loop elpi_ctx_entry_6_
                                  end) elpi_ctx_entry_2_)%Q
                          end)%Q
                     end +
                     rat_of_Z (BinNums.Zpos (BinNums.xO (BinNums.xO 1%AC))))%Q *
                    (match n with
                     | Posz elpi_ctx_entry_2_ =>
                         iterop elpi_ctx_entry_2_ addq 1 0
                     | Negz elpi_ctx_entry_2_ =>
                         (-
                          match elpi_ctx_entry_2_ with
                          | 0 => 1%Q
                          | _.+1 =>
                              (1%Q +
                               (fix loop (m : nat) : rat :=
                                  match m with
                                  | 0 => 0
                                  | 1 => 1
                                  | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                      1%Q + loop elpi_ctx_entry_6_
                                  end) elpi_ctx_entry_2_)%Q
                          end)%Q
                     end +
                     rat_of_Z (BinNums.Zpos (BinNums.xO (BinNums.xO 1%AC))))%Q)%Q)%Q)%Q)%Q)%Q)%Q *
              b
                (intZmod.addz
                   (intZmod.addz (intZmod.addz (intZmod.addz n 1) 1) 1) 1))%Q +
             (((((- rat_of_Z (BinNums.Zpos 1%AC))%Q *
                 ((rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)) *
                   match n with
                   | Posz elpi_ctx_entry_2_ =>
                       iterop elpi_ctx_entry_2_ addq 1 0
                   | Negz elpi_ctx_entry_2_ =>
                       (-
                        match elpi_ctx_entry_2_ with
                        | 0 => 1%Q
                        | _.+1 =>
                            (1%Q +
                             (fix loop (m : nat) : rat :=
                                match m with
                                | 0 => 0
                                | 1 => 1
                                | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                    1%Q + loop elpi_ctx_entry_6_
                                end) elpi_ctx_entry_2_)%Q
                        end)%Q
                   end)%Q + rat_of_Z (BinNums.Zpos (BinNums.xI 1%AC)))%Q)%Q *
                ((rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)) *
                  match n with
                  | Posz elpi_ctx_entry_2_ =>
                      iterop elpi_ctx_entry_2_ addq 1 0
                  | Negz elpi_ctx_entry_2_ =>
                      (-
                       match elpi_ctx_entry_2_ with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                   1%Q + loop elpi_ctx_entry_6_
                               end) elpi_ctx_entry_2_)%Q
                       end)%Q
                  end)%Q +
                 rat_of_Z (BinNums.Zpos (BinNums.xI (BinNums.xI 1%AC))))%Q)%Q *
               ((((((((((rat_of_Z
                           (BinNums.Zpos
                              (BinNums.xO
                                 (BinNums.xO (BinNums.xO (BinNums.xI (...)))))) *
                         (match n with
                          | Posz elpi_ctx_entry_2_ =>
                              iterop elpi_ctx_entry_2_ addq 1 0
                          | Negz elpi_ctx_entry_2_ =>
                              (-
                               match elpi_ctx_entry_2_ with
                               | 0 => 1%Q
                               | _.+1 => (1%Q + (...) elpi_ctx_entry_2_)%Q
                               end)%Q
                          end *
                          (match n with
                           | Posz elpi_ctx_entry_2_ =>
                               iterop elpi_ctx_entry_2_ addq 1 0
                           | Negz elpi_ctx_entry_2_ =>
                               (-
                                match elpi_ctx_entry_2_ with
                                | 0 => 1%Q
                                | _.+1 => (1%Q + ...)%Q
                                end)%Q
                           end *
                           (match n with
                            | Posz elpi_ctx_entry_2_ =>
                                iterop elpi_ctx_entry_2_ addq 1 0
                            | Negz elpi_ctx_entry_2_ =>
                                (- match ... with
                                   | ... 1%Q
                                   | ... ...%Q
                                   end)%Q
                            end *
                            (match n with
                             | Posz elpi_ctx_entry_2_ =>
                                 iterop elpi_ctx_entry_2_ addq 1 0
                             | Negz elpi_ctx_entry_2_ => (- ...)%Q
                             end *
                             (match ... with
                              | ... ...
                              | ... ...%Q
                              end * (... * ...%Q)%Q)%Q)%Q)%Q)%Q)%Q)%Q +
                        (rat_of_Z
                           (BinNums.Zpos
                              (BinNums.xO
                                 (BinNums.xO (BinNums.xI (BinNums.xO (...)))))) *
                         (match n with
                          | Posz elpi_ctx_entry_2_ =>
                              iterop elpi_ctx_entry_2_ addq 1 0
                          | Negz elpi_ctx_entry_2_ =>
                              (-
                               match elpi_ctx_entry_2_ with
                               | 0 => 1%Q
                               | _.+1 => (1%Q + (...) elpi_ctx_entry_2_)%Q
                               end)%Q
                          end *
                          (match n with
                           | Posz elpi_ctx_entry_2_ =>
                               iterop elpi_ctx_entry_2_ addq 1 0
                           | Negz elpi_ctx_entry_2_ =>
                               (-
                                match elpi_ctx_entry_2_ with
                                | 0 => 1%Q
                                | _.+1 => (1%Q + ...)%Q
                                end)%Q
                           end *
                           (match n with
                            | Posz elpi_ctx_entry_2_ =>
                                iterop elpi_ctx_entry_2_ addq 1 0
                            | Negz elpi_ctx_entry_2_ =>
                                (- match ... with
                                   | ... 1%Q
                                   | ... ...%Q
                                   end)%Q
                            end *
                            (match n with
                             | Posz elpi_ctx_entry_2_ =>
                                 iterop elpi_ctx_entry_2_ addq 1 0
                             | Negz elpi_ctx_entry_2_ => (- ...)%Q
                             end *
                             (match ... with
                              | ... ...
                              | ... ...%Q
                              end * (... * ...%Q)%Q)%Q)%Q)%Q)%Q)%Q)%Q)%Q +
                       (rat_of_Z
                          (BinNums.Zpos
                             (BinNums.xO
                                (BinNums.xI
                                   (BinNums.xI
                                      (BinNums.xO (BinNums.xI (...))))))) *
                        (match n with
                         | Posz elpi_ctx_entry_2_ =>
                             iterop elpi_ctx_entry_2_ addq 1 0
                         | Negz elpi_ctx_entry_2_ =>
                             (-
                              match elpi_ctx_entry_2_ with
                              | 0 => 1%Q
                              | _.+1 =>
                                  (1%Q +
                                   (fix loop ... : rat := ...
                                                 ...
                                                 ...
                                                 ...
                                                 end) elpi_ctx_entry_2_)%Q
                              end)%Q
                         end *
                         (match n with
                          | Posz elpi_ctx_entry_2_ =>
                              iterop elpi_ctx_entry_2_ addq 1 0
                          | Negz elpi_ctx_entry_2_ =>
                              (-
                               match elpi_ctx_entry_2_ with
                               | 0 => 1%Q
                               | _.+1 => (1%Q + (...) elpi_ctx_entry_2_)%Q
                               end)%Q
                          end *
                          (match n with
                           | Posz elpi_ctx_entry_2_ =>
                               iterop elpi_ctx_entry_2_ addq 1 0
                           | Negz elpi_ctx_entry_2_ =>
                               (-
                                match elpi_ctx_entry_2_ with
                                | 0 => 1%Q
                                | _.+1 => (1%Q + ...)%Q
                                end)%Q
                           end *
                           (match n with
                            | Posz elpi_ctx_entry_2_ =>
                                iterop elpi_ctx_entry_2_ addq 1 0
                            | Negz elpi_ctx_entry_2_ =>
                                (- match ... with
                                   | ... 1%Q
                                   | ... ...%Q
                                   end)%Q
                            end *
                            (match n with
                             | Posz elpi_ctx_entry_2_ =>
                                 iterop elpi_ctx_entry_2_ addq 1 0
                             | Negz elpi_ctx_entry_2_ => (- ...)%Q
                             end *
                             (match ... with
                              | ... ...
                              | ... ...%Q
                              end * match ... with
                                    | ... ...
                                    | ... ...%Q
                                    end)%Q)%Q)%Q)%Q)%Q)%Q)%Q)%Q +
                      (rat_of_Z
                         (BinNums.Zpos
                            (BinNums.xO
                               (BinNums.xI
                                  (BinNums.xI
                                     (BinNums.xO
                                        (BinNums.xI (BinNums.xI (...)))))))) *
                       (match n with
                        | Posz elpi_ctx_entry_2_ =>
                            iterop elpi_ctx_entry_2_ addq 1 0
                        | Negz elpi_ctx_entry_2_ =>
                            (-
                             match elpi_ctx_entry_2_ with
                             | 0 => 1%Q
                             | _.+1 =>
                                 (1%Q +
                                  (fix loop (m : nat) : rat :=
                                     match ... with
                                     | ... => 0
                                     | ... => 1
                                     | ... => 1%Q + ...
                                     end) elpi_ctx_entry_2_)%Q
                             end)%Q
                        end *
                        (match n with
                         | Posz elpi_ctx_entry_2_ =>
                             iterop elpi_ctx_entry_2_ addq 1 0
                         | Negz elpi_ctx_entry_2_ =>
                             (-
                              match elpi_ctx_entry_2_ with
                              | 0 => 1%Q
                              | _.+1 =>
                                  (1%Q +
                                   (fix loop ... : rat := ...
                                                 ...
                                                 ...
                                                 ...
                                                 end) elpi_ctx_entry_2_)%Q
                              end)%Q
                         end *
                         (match n with
                          | Posz elpi_ctx_entry_2_ =>
                              iterop elpi_ctx_entry_2_ addq 1 0
                          | Negz elpi_ctx_entry_2_ =>
                              (-
                               match elpi_ctx_entry_2_ with
                               | 0 => 1%Q
                               | _.+1 => (1%Q + (...) elpi_ctx_entry_2_)%Q
                               end)%Q
                          end *
                          (match n with
                           | Posz elpi_ctx_entry_2_ =>
                               iterop elpi_ctx_entry_2_ addq 1 0
                           | Negz elpi_ctx_entry_2_ =>
                               (-
                                match elpi_ctx_entry_2_ with
                                | 0 => 1%Q
                                | _.+1 => (1%Q + ...)%Q
                                end)%Q
                           end *
                           (match n with
                            | Posz elpi_ctx_entry_2_ =>
                                iterop elpi_ctx_entry_2_ addq 1 0
                            | Negz elpi_ctx_entry_2_ =>
                                (- match ... with
                                   | ... 1%Q
                                   | ... ...%Q
                                   end)%Q
                            end *
                            match n with
                            | Posz elpi_ctx_entry_2_ =>
                                iterop elpi_ctx_entry_2_ addq 1 0
                            | Negz elpi_ctx_entry_2_ =>
                                (- match ... with
                                   | ... 1%Q
                                   | ... ...%Q
                                   end)%Q
                            end)%Q)%Q)%Q)%Q)%Q)%Q)%Q +
                     (rat_of_Z
                        (BinNums.Zpos
                           (BinNums.xO
                              (BinNums.xO
                                 (BinNums.xO
                                    (BinNums.xO
                                       (BinNums.xI
                                          (BinNums.xI (BinNums.xI (...))))))))) *
                      (match n with
                       | Posz elpi_ctx_entry_2_ =>
                           iterop elpi_ctx_entry_2_ addq 1 0
                       | Negz elpi_ctx_entry_2_ =>
                           (-
                            match elpi_ctx_entry_2_ with
                            | 0 => 1%Q
                            | _.+1 =>
                                (1%Q +
                                 (fix loop (m : nat) : rat :=
                                    match m with
                                    | 0 => 0
                                    | 1 => 1
                                    | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                        1%Q + loop elpi_ctx_entry_6_
                                    end) elpi_ctx_entry_2_)%Q
                            end)%Q
                       end *
                       (match n with
                        | Posz elpi_ctx_entry_2_ =>
                            iterop elpi_ctx_entry_2_ addq 1 0
                        | Negz elpi_ctx_entry_2_ =>
                            (-
                             match elpi_ctx_entry_2_ with
                             | 0 => 1%Q
                             | _.+1 =>
                                 (1%Q +
                                  (fix loop (m : nat) : rat :=
                                     match ... with
                                     | ... => 0
                                     | ... => 1
                                     | ... => 1%Q + ...
                                     end) elpi_ctx_entry_2_)%Q
                             end)%Q
                        end *
                        (match n with
                         | Posz elpi_ctx_entry_2_ =>
                             iterop elpi_ctx_entry_2_ addq 1 0
                         | Negz elpi_ctx_entry_2_ =>
                             (-
                              match elpi_ctx_entry_2_ with
                              | 0 => 1%Q
                              | _.+1 =>
                                  (1%Q +
                                   (fix loop ... : rat := ...
                                                 ...
                                                 ...
                                                 ...
                                                 end) elpi_ctx_entry_2_)%Q
                              end)%Q
                         end *
                         (match n with
                          | Posz elpi_ctx_entry_2_ =>
                              iterop elpi_ctx_entry_2_ addq 1 0
                          | Negz elpi_ctx_entry_2_ =>
                              (-
                               match elpi_ctx_entry_2_ with
                               | 0 => 1%Q
                               | _.+1 => (1%Q + (...) elpi_ctx_entry_2_)%Q
                               end)%Q
                          end *
                          match n with
                          | Posz elpi_ctx_entry_2_ =>
                              iterop elpi_ctx_entry_2_ addq 1 0
                          | Negz elpi_ctx_entry_2_ =>
                              (-
                               match elpi_ctx_entry_2_ with
                               | 0 => 1%Q
                               | _.+1 => (1%Q + (...) elpi_ctx_entry_2_)%Q
                               end)%Q
                          end)%Q)%Q)%Q)%Q)%Q)%Q +
                    (rat_of_Z
                       (BinNums.Zpos
                          (BinNums.xI
                             (BinNums.xO
                                (BinNums.xO
                                   (BinNums.xO
                                      (BinNums.xO
                                         (BinNums.xO
                                            (BinNums.xO (BinNums.xO (...)))))))))) *
                     (match n with
                      | Posz elpi_ctx_entry_2_ =>
                          iterop elpi_ctx_entry_2_ addq 1 0
                      | Negz elpi_ctx_entry_2_ =>
                          (-
                           match elpi_ctx_entry_2_ with
                           | 0 => 1%Q
                           | _.+1 =>
                               (1%Q +
                                (fix loop (m : nat) : rat :=
                                   match m with
                                   | 0 => 0
                                   | 1 => 1
                                   | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                       1%Q + loop elpi_ctx_entry_6_
                                   end) elpi_ctx_entry_2_)%Q
                           end)%Q
                      end *
                      (match n with
                       | Posz elpi_ctx_entry_2_ =>
                           iterop elpi_ctx_entry_2_ addq 1 0
                       | Negz elpi_ctx_entry_2_ =>
                           (-
                            match elpi_ctx_entry_2_ with
                            | 0 => 1%Q
                            | _.+1 =>
                                (1%Q +
                                 (fix loop (m : nat) : rat :=
                                    match m with
                                    | 0 => 0
                                    | 1 => 1
                                    | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                        1%Q + loop elpi_ctx_entry_6_
                                    end) elpi_ctx_entry_2_)%Q
                            end)%Q
                       end *
                       (match n with
                        | Posz elpi_ctx_entry_2_ =>
                            iterop elpi_ctx_entry_2_ addq 1 0
                        | Negz elpi_ctx_entry_2_ =>
                            (-
                             match elpi_ctx_entry_2_ with
                             | 0 => 1%Q
                             | _.+1 =>
                                 (1%Q +
                                  (fix loop (m : nat) : rat :=
                                     match ... with
                                     | ... => 0
                                     | ... => 1
                                     | ... => 1%Q + ...
                                     end) elpi_ctx_entry_2_)%Q
                             end)%Q
                        end *
                        match n with
                        | Posz elpi_ctx_entry_2_ =>
                            iterop elpi_ctx_entry_2_ addq 1 0
                        | Negz elpi_ctx_entry_2_ =>
                            (-
                             match elpi_ctx_entry_2_ with
                             | 0 => 1%Q
                             | _.+1 =>
                                 (1%Q +
                                  (fix loop (m : nat) : rat :=
                                     match ... with
                                     | ... => 0
                                     | ... => 1
                                     | ... => 1%Q + ...
                                     end) elpi_ctx_entry_2_)%Q
                             end)%Q
                        end)%Q)%Q)%Q)%Q)%Q +
                   (rat_of_Z
                      (BinNums.Zpos
                         (BinNums.xO
                            (BinNums.xO
                               (BinNums.xO
                                  (BinNums.xO
                                     (BinNums.xI
                                        (BinNums.xI
                                           (BinNums.xI
                                              (BinNums.xI (BinNums.xO (...))))))))))) *
                    (match n with
                     | Posz elpi_ctx_entry_2_ =>
                         iterop elpi_ctx_entry_2_ addq 1 0
                     | Negz elpi_ctx_entry_2_ =>
                         (-
                          match elpi_ctx_entry_2_ with
                          | 0 => 1%Q
                          | _.+1 =>
                              (1%Q +
                               (fix loop (m : nat) : rat :=
                                  match m with
                                  | 0 => 0
                                  | 1 => 1
                                  | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                      1%Q + loop elpi_ctx_entry_6_
                                  end) elpi_ctx_entry_2_)%Q
                          end)%Q
                     end *
                     (match n with
                      | Posz elpi_ctx_entry_2_ =>
                          iterop elpi_ctx_entry_2_ addq 1 0
                      | Negz elpi_ctx_entry_2_ =>
                          (-
                           match elpi_ctx_entry_2_ with
                           | 0 => 1%Q
                           | _.+1 =>
                               (1%Q +
                                (fix loop (m : nat) : rat :=
                                   match m with
                                   | 0 => 0
                                   | 1 => 1
                                   | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                       1%Q + loop elpi_ctx_entry_6_
                                   end) elpi_ctx_entry_2_)%Q
                           end)%Q
                      end *
                      match n with
                      | Posz elpi_ctx_entry_2_ =>
                          iterop elpi_ctx_entry_2_ addq 1 0
                      | Negz elpi_ctx_entry_2_ =>
                          (-
                           match elpi_ctx_entry_2_ with
                           | 0 => 1%Q
                           | _.+1 =>
                               (1%Q +
                                (fix loop (m : nat) : rat :=
                                   match m with
                                   | 0 => 0
                                   | 1 => 1
                                   | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                       1%Q + loop elpi_ctx_entry_6_
                                   end) elpi_ctx_entry_2_)%Q
                           end)%Q
                      end)%Q)%Q)%Q)%Q +
                  (rat_of_Z
                     (BinNums.Zpos
                        (BinNums.xI
                           (BinNums.xO
                              (BinNums.xO
                                 (BinNums.xO
                                    (BinNums.xI
                                       (BinNums.xO
                                          (BinNums.xI
                                             (BinNums.xI
                                                (BinNums.xI
                                                 (BinNums.xO (...)))))))))))) *
                   (match n with
                    | Posz elpi_ctx_entry_2_ =>
                        iterop elpi_ctx_entry_2_ addq 1 0
                    | Negz elpi_ctx_entry_2_ =>
                        (-
                         match elpi_ctx_entry_2_ with
                         | 0 => 1%Q
                         | _.+1 =>
                             (1%Q +
                              (fix loop (m : nat) : rat :=
                                 match m with
                                 | 0 => 0
                                 | 1 => 1
                                 | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                     1%Q + loop elpi_ctx_entry_6_
                                 end) elpi_ctx_entry_2_)%Q
                         end)%Q
                    end *
                    match n with
                    | Posz elpi_ctx_entry_2_ =>
                        iterop elpi_ctx_entry_2_ addq 1 0
                    | Negz elpi_ctx_entry_2_ =>
                        (-
                         match elpi_ctx_entry_2_ with
                         | 0 => 1%Q
                         | _.+1 =>
                             (1%Q +
                              (fix loop (m : nat) : rat :=
                                 match m with
                                 | 0 => 0
                                 | 1 => 1
                                 | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                     1%Q + loop elpi_ctx_entry_6_
                                 end) elpi_ctx_entry_2_)%Q
                         end)%Q
                    end)%Q)%Q)%Q +
                 (rat_of_Z
                    (BinNums.Zpos
                       (BinNums.xO
                          (BinNums.xI
                             (BinNums.xI
                                (BinNums.xI
                                   (BinNums.xI
                                      (BinNums.xI
                                         (BinNums.xO
                                            (BinNums.xO
                                               (BinNums.xI
                                                 (BinNums.xI
                                                 (BinNums.xI (...))))))))))))) *
                  match n with
                  | Posz elpi_ctx_entry_2_ =>
                      iterop elpi_ctx_entry_2_ addq 1 0
                  | Negz elpi_ctx_entry_2_ =>
                      (-
                       match elpi_ctx_entry_2_ with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                   1%Q + loop elpi_ctx_entry_6_
                               end) elpi_ctx_entry_2_)%Q
                       end)%Q
                  end)%Q)%Q +
                rat_of_Z
                  (BinNums.Zpos
                     (BinNums.xO
                        (BinNums.xO
                           (BinNums.xO
                              (BinNums.xI
                                 (BinNums.xO
                                    (BinNums.xO
                                       (BinNums.xO
                                          (BinNums.xI
                                             (BinNums.xI
                                                (BinNums.xI
                                                 (BinNums.xI
                                                 (BinNums.xO
                                                 (BinNums.xI (...))))))))))))))))%Q)%Q *
              b (intZmod.addz (intZmod.addz (intZmod.addz n 1) 1) 1))%Q)%Q +
            ((((rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)) *
                match n with
                | Posz elpi_ctx_entry_2_ => iterop elpi_ctx_entry_2_ addq 1 0
                | Negz elpi_ctx_entry_2_ =>
                    (-
                     match elpi_ctx_entry_2_ with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                 1%Q + loop elpi_ctx_entry_6_
                             end) elpi_ctx_entry_2_)%Q
                     end)%Q
                end)%Q +
               rat_of_Z (BinNums.Zpos (BinNums.xI (BinNums.xO 1%AC))))%Q *
              (((((((((((rat_of_Z
                           (BinNums.Zpos
                              (BinNums.xO
                                 (BinNums.xO (BinNums.xO (BinNums.xI (...)))))) *
                         (match n with
                          | Posz elpi_ctx_entry_2_ =>
                              iterop elpi_ctx_entry_2_ addq 1 0
                          | Negz elpi_ctx_entry_2_ =>
                              (-
                               match elpi_ctx_entry_2_ with
                               | 0 => 1%Q
                               | _.+1 => (1%Q + (...) elpi_ctx_entry_2_)%Q
                               end)%Q
                          end *
                          (match n with
                           | Posz elpi_ctx_entry_2_ =>
                               iterop elpi_ctx_entry_2_ addq 1 0
                           | Negz elpi_ctx_entry_2_ =>
                               (-
                                match elpi_ctx_entry_2_ with
                                | 0 => 1%Q
                                | _.+1 => (1%Q + ...)%Q
                                end)%Q
                           end *
                           (match n with
                            | Posz elpi_ctx_entry_2_ =>
                                iterop elpi_ctx_entry_2_ addq 1 0
                            | Negz elpi_ctx_entry_2_ =>
                                (- match ... with
                                   | ... 1%Q
                                   | ... ...%Q
                                   end)%Q
                            end *
                            (match n with
                             | Posz elpi_ctx_entry_2_ =>
                                 iterop elpi_ctx_entry_2_ addq 1 0
                             | Negz elpi_ctx_entry_2_ => (- ...)%Q
                             end *
                             (match ... with
                              | ... ...
                              | ... ...%Q
                              end * (... * ...%Q)%Q)%Q)%Q)%Q)%Q)%Q)%Q +
                        (rat_of_Z
                           (BinNums.Zpos
                              (BinNums.xO
                                 (BinNums.xO (BinNums.xO (BinNums.xI (...)))))) *
                         (match n with
                          | Posz elpi_ctx_entry_2_ =>
                              iterop elpi_ctx_entry_2_ addq 1 0
                          | Negz elpi_ctx_entry_2_ =>
                              (-
                               match elpi_ctx_entry_2_ with
                               | 0 => 1%Q
                               | _.+1 => (1%Q + (...) elpi_ctx_entry_2_)%Q
                               end)%Q
                          end *
                          (match n with
                           | Posz elpi_ctx_entry_2_ =>
                               iterop elpi_ctx_entry_2_ addq 1 0
                           | Negz elpi_ctx_entry_2_ =>
                               (-
                                match elpi_ctx_entry_2_ with
                                | 0 => 1%Q
                                | _.+1 => (1%Q + ...)%Q
                                end)%Q
                           end *
                           (match n with
                            | Posz elpi_ctx_entry_2_ =>
                                iterop elpi_ctx_entry_2_ addq 1 0
                            | Negz elpi_ctx_entry_2_ =>
                                (- match ... with
                                   | ... 1%Q
                                   | ... ...%Q
                                   end)%Q
                            end *
                            (match n with
                             | Posz elpi_ctx_entry_2_ =>
                                 iterop elpi_ctx_entry_2_ addq 1 0
                             | Negz elpi_ctx_entry_2_ => (- ...)%Q
                             end *
                             (match ... with
                              | ... ...
                              | ... ...%Q
                              end * (... * ...%Q)%Q)%Q)%Q)%Q)%Q)%Q)%Q)%Q +
                       (rat_of_Z
                          (BinNums.Zpos
                             (BinNums.xO
                                (BinNums.xI
                                   (BinNums.xI
                                      (BinNums.xO (BinNums.xO (...))))))) *
                        (match n with
                         | Posz elpi_ctx_entry_2_ =>
                             iterop elpi_ctx_entry_2_ addq 1 0
                         | Negz elpi_ctx_entry_2_ =>
                             (-
                              match elpi_ctx_entry_2_ with
                              | 0 => 1%Q
                              | _.+1 =>
                                  (1%Q +
                                   (fix loop ... : rat := ...
                                                 ...
                                                 ...
                                                 ...
                                                 end) elpi_ctx_entry_2_)%Q
                              end)%Q
                         end *
                         (match n with
                          | Posz elpi_ctx_entry_2_ =>
                              iterop elpi_ctx_entry_2_ addq 1 0
                          | Negz elpi_ctx_entry_2_ =>
                              (-
                               match elpi_ctx_entry_2_ with
                               | 0 => 1%Q
                               | _.+1 => (1%Q + (...) elpi_ctx_entry_2_)%Q
                               end)%Q
                          end *
                          (match n with
                           | Posz elpi_ctx_entry_2_ =>
                               iterop elpi_ctx_entry_2_ addq 1 0
                           | Negz elpi_ctx_entry_2_ =>
                               (-
                                match elpi_ctx_entry_2_ with
                                | 0 => 1%Q
                                | _.+1 => (1%Q + ...)%Q
                                end)%Q
                           end *
                           (match n with
                            | Posz elpi_ctx_entry_2_ =>
                                iterop elpi_ctx_entry_2_ addq 1 0
                            | Negz elpi_ctx_entry_2_ =>
                                (- match ... with
                                   | ... 1%Q
                                   | ... ...%Q
                                   end)%Q
                            end *
                            (match n with
                             | Posz elpi_ctx_entry_2_ =>
                                 iterop elpi_ctx_entry_2_ addq 1 0
                             | Negz elpi_ctx_entry_2_ => (- ...)%Q
                             end *
                             (match ... with
                              | ... ...
                              | ... ...%Q
                              end * (... * ...)%Q)%Q)%Q)%Q)%Q)%Q)%Q)%Q)%Q +
                      (rat_of_Z
                         (BinNums.Zpos
                            (BinNums.xO
                               (BinNums.xO
                                  (BinNums.xO
                                     (BinNums.xI
                                        (BinNums.xO (BinNums.xO (...)))))))) *
                       (match n with
                        | Posz elpi_ctx_entry_2_ =>
                            iterop elpi_ctx_entry_2_ addq 1 0
                        | Negz elpi_ctx_entry_2_ =>
                            (-
                             match elpi_ctx_entry_2_ with
                             | 0 => 1%Q
                             | _.+1 =>
                                 (1%Q +
                                  (fix loop (m : nat) : rat :=
                                     match ... with
                                     | ... => 0
                                     | ... => 1
                                     | ... => 1%Q + ...
                                     end) elpi_ctx_entry_2_)%Q
                             end)%Q
                        end *
                        (match n with
                         | Posz elpi_ctx_entry_2_ =>
                             iterop elpi_ctx_entry_2_ addq 1 0
                         | Negz elpi_ctx_entry_2_ =>
                             (-
                              match elpi_ctx_entry_2_ with
                              | 0 => 1%Q
                              | _.+1 =>
                                  (1%Q +
                                   (fix loop ... : rat := ...
                                                 ...
                                                 ...
                                                 ...
                                                 end) elpi_ctx_entry_2_)%Q
                              end)%Q
                         end *
                         (match n with
                          | Posz elpi_ctx_entry_2_ =>
                              iterop elpi_ctx_entry_2_ addq 1 0
                          | Negz elpi_ctx_entry_2_ =>
                              (-
                               match elpi_ctx_entry_2_ with
                               | 0 => 1%Q
                               | _.+1 => (1%Q + (...) elpi_ctx_entry_2_)%Q
                               end)%Q
                          end *
                          (match n with
                           | Posz elpi_ctx_entry_2_ =>
                               iterop elpi_ctx_entry_2_ addq 1 0
                           | Negz elpi_ctx_entry_2_ =>
                               (-
                                match elpi_ctx_entry_2_ with
                                | 0 => 1%Q
                                | _.+1 => (1%Q + ...)%Q
                                end)%Q
                           end *
                           (match n with
                            | Posz elpi_ctx_entry_2_ =>
                                iterop elpi_ctx_entry_2_ addq 1 0
                            | Negz elpi_ctx_entry_2_ =>
                                (- match ... with
                                   | ... 1%Q
                                   | ... ...%Q
                                   end)%Q
                            end *
                            (match n with
                             | Posz elpi_ctx_entry_2_ =>
                                 iterop elpi_ctx_entry_2_ addq 1 0
                             | Negz elpi_ctx_entry_2_ => (- ...)%Q
                             end *
                             match n with
                             | Posz elpi_ctx_entry_2_ =>
                                 iterop elpi_ctx_entry_2_ addq 1 0
                             | Negz elpi_ctx_entry_2_ => (- ...)%Q
                             end)%Q)%Q)%Q)%Q)%Q)%Q)%Q)%Q +
                     (rat_of_Z
                        (BinNums.Zpos
                           (BinNums.xO
                              (BinNums.xO
                                 (BinNums.xI
                                    (BinNums.xI
                                       (BinNums.xO
                                          (BinNums.xI (BinNums.xO (...))))))))) *
                      (match n with
                       | Posz elpi_ctx_entry_2_ =>
                           iterop elpi_ctx_entry_2_ addq 1 0
                       | Negz elpi_ctx_entry_2_ =>
                           (-
                            match elpi_ctx_entry_2_ with
                            | 0 => 1%Q
                            | _.+1 =>
                                (1%Q +
                                 (fix loop (m : nat) : rat :=
                                    match m with
                                    | 0 => 0
                                    | 1 => 1
                                    | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                        1%Q + loop elpi_ctx_entry_6_
                                    end) elpi_ctx_entry_2_)%Q
                            end)%Q
                       end *
                       (match n with
                        | Posz elpi_ctx_entry_2_ =>
                            iterop elpi_ctx_entry_2_ addq 1 0
                        | Negz elpi_ctx_entry_2_ =>
                            (-
                             match elpi_ctx_entry_2_ with
                             | 0 => 1%Q
                             | _.+1 =>
                                 (1%Q +
                                  (fix loop (m : nat) : rat :=
                                     match ... with
                                     | ... => 0
                                     | ... => 1
                                     | ... => 1%Q + ...
                                     end) elpi_ctx_entry_2_)%Q
                             end)%Q
                        end *
                        (match n with
                         | Posz elpi_ctx_entry_2_ =>
                             iterop elpi_ctx_entry_2_ addq 1 0
                         | Negz elpi_ctx_entry_2_ =>
                             (-
                              match elpi_ctx_entry_2_ with
                              | 0 => 1%Q
                              | _.+1 =>
                                  (1%Q +
                                   (fix loop ... : rat := ...
                                                 ...
                                                 ...
                                                 ...
                                                 end) elpi_ctx_entry_2_)%Q
                              end)%Q
                         end *
                         (match n with
                          | Posz elpi_ctx_entry_2_ =>
                              iterop elpi_ctx_entry_2_ addq 1 0
                          | Negz elpi_ctx_entry_2_ =>
                              (-
                               match elpi_ctx_entry_2_ with
                               | 0 => 1%Q
                               | _.+1 => (1%Q + (...) elpi_ctx_entry_2_)%Q
                               end)%Q
                          end *
                          (match n with
                           | Posz elpi_ctx_entry_2_ =>
                               iterop elpi_ctx_entry_2_ addq 1 0
                           | Negz elpi_ctx_entry_2_ =>
                               (-
                                match elpi_ctx_entry_2_ with
                                | 0 => 1%Q
                                | _.+1 => (1%Q + ...)%Q
                                end)%Q
                           end *
                           match n with
                           | Posz elpi_ctx_entry_2_ =>
                               iterop elpi_ctx_entry_2_ addq 1 0
                           | Negz elpi_ctx_entry_2_ =>
                               (-
                                match elpi_ctx_entry_2_ with
                                | 0 => 1%Q
                                | _.+1 => (1%Q + ...)%Q
                                end)%Q
                           end)%Q)%Q)%Q)%Q)%Q)%Q)%Q +
                    (rat_of_Z
                       (BinNums.Zpos
                          (BinNums.xO
                             (BinNums.xO
                                (BinNums.xO
                                   (BinNums.xO
                                      (BinNums.xO
                                         (BinNums.xO
                                            (BinNums.xI (BinNums.xI (...)))))))))) *
                     (match n with
                      | Posz elpi_ctx_entry_2_ =>
                          iterop elpi_ctx_entry_2_ addq 1 0
                      | Negz elpi_ctx_entry_2_ =>
                          (-
                           match elpi_ctx_entry_2_ with
                           | 0 => 1%Q
                           | _.+1 =>
                               (1%Q +
                                (fix loop (m : nat) : rat :=
                                   match m with
                                   | 0 => 0
                                   | 1 => 1
                                   | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                       1%Q + loop elpi_ctx_entry_6_
                                   end) elpi_ctx_entry_2_)%Q
                           end)%Q
                      end *
                      (match n with
                       | Posz elpi_ctx_entry_2_ =>
                           iterop elpi_ctx_entry_2_ addq 1 0
                       | Negz elpi_ctx_entry_2_ =>
                           (-
                            match elpi_ctx_entry_2_ with
                            | 0 => 1%Q
                            | _.+1 =>
                                (1%Q +
                                 (fix loop (m : nat) : rat :=
                                    match m with
                                    | 0 => 0
                                    | 1 => 1
                                    | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                        1%Q + loop elpi_ctx_entry_6_
                                    end) elpi_ctx_entry_2_)%Q
                            end)%Q
                       end *
                       (match n with
                        | Posz elpi_ctx_entry_2_ =>
                            iterop elpi_ctx_entry_2_ addq 1 0
                        | Negz elpi_ctx_entry_2_ =>
                            (-
                             match elpi_ctx_entry_2_ with
                             | 0 => 1%Q
                             | _.+1 =>
                                 (1%Q +
                                  (fix loop (m : nat) : rat :=
                                     match ... with
                                     | ... => 0
                                     | ... => 1
                                     | ... => 1%Q + ...
                                     end) elpi_ctx_entry_2_)%Q
                             end)%Q
                        end *
                        (match n with
                         | Posz elpi_ctx_entry_2_ =>
                             iterop elpi_ctx_entry_2_ addq 1 0
                         | Negz elpi_ctx_entry_2_ =>
                             (-
                              match elpi_ctx_entry_2_ with
                              | 0 => 1%Q
                              | _.+1 =>
                                  (1%Q +
                                   (fix loop ... : rat := ...
                                                 ...
                                                 ...
                                                 ...
                                                 end) elpi_ctx_entry_2_)%Q
                              end)%Q
                         end *
                         match n with
                         | Posz elpi_ctx_entry_2_ =>
                             iterop elpi_ctx_entry_2_ addq 1 0
                         | Negz elpi_ctx_entry_2_ =>
                             (-
                              match elpi_ctx_entry_2_ with
                              | 0 => 1%Q
                              | _.+1 =>
                                  (1%Q +
                                   (fix loop ... : rat := ...
                                                 ...
                                                 ...
                                                 ...
                                                 end) elpi_ctx_entry_2_)%Q
                              end)%Q
                         end)%Q)%Q)%Q)%Q)%Q)%Q +
                   (rat_of_Z
                      (BinNums.Zpos
                         (BinNums.xI
                            (BinNums.xO
                               (BinNums.xO
                                  (BinNums.xO
                                     (BinNums.xO
                                        (BinNums.xI
                                           (BinNums.xI
                                              (BinNums.xO (BinNums.xI (...))))))))))) *
                    (match n with
                     | Posz elpi_ctx_entry_2_ =>
                         iterop elpi_ctx_entry_2_ addq 1 0
                     | Negz elpi_ctx_entry_2_ =>
                         (-
                          match elpi_ctx_entry_2_ with
                          | 0 => 1%Q
                          | _.+1 =>
                              (1%Q +
                               (fix loop (m : nat) : rat :=
                                  match m with
                                  | 0 => 0
                                  | 1 => 1
                                  | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                      1%Q + loop elpi_ctx_entry_6_
                                  end) elpi_ctx_entry_2_)%Q
                          end)%Q
                     end *
                     (match n with
                      | Posz elpi_ctx_entry_2_ =>
                          iterop elpi_ctx_entry_2_ addq 1 0
                      | Negz elpi_ctx_entry_2_ =>
                          (-
                           match elpi_ctx_entry_2_ with
                           | 0 => 1%Q
                           | _.+1 =>
                               (1%Q +
                                (fix loop (m : nat) : rat :=
                                   match m with
                                   | 0 => 0
                                   | 1 => 1
                                   | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                       1%Q + loop elpi_ctx_entry_6_
                                   end) elpi_ctx_entry_2_)%Q
                           end)%Q
                      end *
                      (match n with
                       | Posz elpi_ctx_entry_2_ =>
                           iterop elpi_ctx_entry_2_ addq 1 0
                       | Negz elpi_ctx_entry_2_ =>
                           (-
                            match elpi_ctx_entry_2_ with
                            | 0 => 1%Q
                            | _.+1 =>
                                (1%Q +
                                 (fix loop (m : nat) : rat :=
                                    match m with
                                    | 0 => 0
                                    | 1 => 1
                                    | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                        1%Q + loop elpi_ctx_entry_6_
                                    end) elpi_ctx_entry_2_)%Q
                            end)%Q
                       end *
                       match n with
                       | Posz elpi_ctx_entry_2_ =>
                           iterop elpi_ctx_entry_2_ addq 1 0
                       | Negz elpi_ctx_entry_2_ =>
                           (-
                            match elpi_ctx_entry_2_ with
                            | 0 => 1%Q
                            | _.+1 =>
                                (1%Q +
                                 (fix loop (m : nat) : rat :=
                                    match m with
                                    | 0 => 0
                                    | 1 => 1
                                    | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                        1%Q + loop elpi_ctx_entry_6_
                                    end) elpi_ctx_entry_2_)%Q
                            end)%Q
                       end)%Q)%Q)%Q)%Q)%Q +
                  (rat_of_Z
                     (BinNums.Zpos
                        (BinNums.xO
                           (BinNums.xI
                              (BinNums.xI
                                 (BinNums.xI
                                    (BinNums.xO
                                       (BinNums.xO
                                          (BinNums.xI
                                             (BinNums.xO
                                                (BinNums.xO
                                                 (BinNums.xI (...)))))))))))) *
                   (match n with
                    | Posz elpi_ctx_entry_2_ =>
                        iterop elpi_ctx_entry_2_ addq 1 0
                    | Negz elpi_ctx_entry_2_ =>
                        (-
                         match elpi_ctx_entry_2_ with
                         | 0 => 1%Q
                         | _.+1 =>
                             (1%Q +
                              (fix loop (m : nat) : rat :=
                                 match m with
                                 | 0 => 0
                                 | 1 => 1
                                 | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                     1%Q + loop elpi_ctx_entry_6_
                                 end) elpi_ctx_entry_2_)%Q
                         end)%Q
                    end *
                    (match n with
                     | Posz elpi_ctx_entry_2_ =>
                         iterop elpi_ctx_entry_2_ addq 1 0
                     | Negz elpi_ctx_entry_2_ =>
                         (-
                          match elpi_ctx_entry_2_ with
                          | 0 => 1%Q
                          | _.+1 =>
                              (1%Q +
                               (fix loop (m : nat) : rat :=
                                  match m with
                                  | 0 => 0
                                  | 1 => 1
                                  | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                      1%Q + loop elpi_ctx_entry_6_
                                  end) elpi_ctx_entry_2_)%Q
                          end)%Q
                     end *
                     match n with
                     | Posz elpi_ctx_entry_2_ =>
                         iterop elpi_ctx_entry_2_ addq 1 0
                     | Negz elpi_ctx_entry_2_ =>
                         (-
                          match elpi_ctx_entry_2_ with
                          | 0 => 1%Q
                          | _.+1 =>
                              (1%Q +
                               (fix loop (m : nat) : rat :=
                                  match m with
                                  | 0 => 0
                                  | 1 => 1
                                  | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                      1%Q + loop elpi_ctx_entry_6_
                                  end) elpi_ctx_entry_2_)%Q
                          end)%Q
                     end)%Q)%Q)%Q)%Q +
                 (rat_of_Z
                    (BinNums.Zpos
                       (BinNums.xI
                          (BinNums.xO
                             (BinNums.xO
                                (BinNums.xO
                                   (BinNums.xI
                                      (BinNums.xI
                                         (BinNums.xO
                                            (BinNums.xO
                                               (BinNums.xO
                                                 (BinNums.xO
                                                 (BinNums.xI (...))))))))))))) *
                  (match n with
                   | Posz elpi_ctx_entry_2_ =>
                       iterop elpi_ctx_entry_2_ addq 1 0
                   | Negz elpi_ctx_entry_2_ =>
                       (-
                        match elpi_ctx_entry_2_ with
                        | 0 => 1%Q
                        | _.+1 =>
                            (1%Q +
                             (fix loop (m : nat) : rat :=
                                match m with
                                | 0 => 0
                                | 1 => 1
                                | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                    1%Q + loop elpi_ctx_entry_6_
                                end) elpi_ctx_entry_2_)%Q
                        end)%Q
                   end *
                   match n with
                   | Posz elpi_ctx_entry_2_ =>
                       iterop elpi_ctx_entry_2_ addq 1 0
                   | Negz elpi_ctx_entry_2_ =>
                       (-
                        match elpi_ctx_entry_2_ with
                        | 0 => 1%Q
                        | _.+1 =>
                            (1%Q +
                             (fix loop (m : nat) : rat :=
                                match m with
                                | 0 => 0
                                | 1 => 1
                                | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                    1%Q + loop elpi_ctx_entry_6_
                                end) elpi_ctx_entry_2_)%Q
                        end)%Q
                   end)%Q)%Q)%Q +
                (rat_of_Z
                   (BinNums.Zpos
                      (BinNums.xO
                         (BinNums.xI
                            (BinNums.xI
                               (BinNums.xO
                                  (BinNums.xI
                                     (BinNums.xI
                                        (BinNums.xO
                                           (BinNums.xO
                                              (BinNums.xO
                                                 (BinNums.xO
                                                 (BinNums.xO
                                                 (BinNums.xO (...)))))))))))))) *
                 match n with
                 | Posz elpi_ctx_entry_2_ =>
                     iterop elpi_ctx_entry_2_ addq 1 0
                 | Negz elpi_ctx_entry_2_ =>
                     (-
                      match elpi_ctx_entry_2_ with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                  1%Q + loop elpi_ctx_entry_6_
                              end) elpi_ctx_entry_2_)%Q
                      end)%Q
                 end)%Q)%Q +
               rat_of_Z
                 (BinNums.Zpos
                    (BinNums.xO
                       (BinNums.xO
                          (BinNums.xO
                             (BinNums.xI
                                (BinNums.xO
                                   (BinNums.xI
                                      (BinNums.xO
                                         (BinNums.xI
                                            (BinNums.xO
                                               (BinNums.xO
                                                 (BinNums.xI
                                                 (BinNums.xO
                                                 (BinNums.xO
                                                 (BinNums.xO (...)))))))))))))))))%Q)%Q *
             b (intZmod.addz (intZmod.addz n 1) 1))%Q)%Q +
           (((((- rat_of_Z (BinNums.Zpos 1%AC))%Q *
               ((rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)) *
                 match n with
                 | Posz elpi_ctx_entry_2_ =>
                     iterop elpi_ctx_entry_2_ addq 1 0
                 | Negz elpi_ctx_entry_2_ =>
                     (-
                      match elpi_ctx_entry_2_ with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                  1%Q + loop elpi_ctx_entry_6_
                              end) elpi_ctx_entry_2_)%Q
                      end)%Q
                 end)%Q + rat_of_Z (BinNums.Zpos (BinNums.xI 1%AC)))%Q)%Q *
              ((rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)) *
                match n with
                | Posz elpi_ctx_entry_2_ => iterop elpi_ctx_entry_2_ addq 1 0
                | Negz elpi_ctx_entry_2_ =>
                    (-
                     match elpi_ctx_entry_2_ with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                 1%Q + loop elpi_ctx_entry_6_
                             end) elpi_ctx_entry_2_)%Q
                     end)%Q
                end)%Q +
               rat_of_Z (BinNums.Zpos (BinNums.xI (BinNums.xI 1%AC))))%Q)%Q *
             ((((((((((rat_of_Z
                         (BinNums.Zpos
                            (BinNums.xO
                               (BinNums.xO
                                  (BinNums.xO
                                     (BinNums.xI
                                        (BinNums.xI (BinNums.xO (...)))))))) *
                       (match n with
                        | Posz elpi_ctx_entry_2_ =>
                            iterop elpi_ctx_entry_2_ addq 1 0
                        | Negz elpi_ctx_entry_2_ =>
                            (-
                             match elpi_ctx_entry_2_ with
                             | 0 => 1%Q
                             | _.+1 =>
                                 (1%Q +
                                  (fix loop (m : nat) : rat :=
                                     match ... with
                                     | ... => 0
                                     | ... => 1
                                     | ... => 1%Q + ...
                                     end) elpi_ctx_entry_2_)%Q
                             end)%Q
                        end *
                        (match n with
                         | Posz elpi_ctx_entry_2_ =>
                             iterop elpi_ctx_entry_2_ addq 1 0
                         | Negz elpi_ctx_entry_2_ =>
                             (-
                              match elpi_ctx_entry_2_ with
                              | 0 => 1%Q
                              | _.+1 =>
                                  (1%Q +
                                   (fix loop ... : rat := ...
                                                 ...
                                                 ...
                                                 ...
                                                 end) elpi_ctx_entry_2_)%Q
                              end)%Q
                         end *
                         (match n with
                          | Posz elpi_ctx_entry_2_ =>
                              iterop elpi_ctx_entry_2_ addq 1 0
                          | Negz elpi_ctx_entry_2_ =>
                              (-
                               match elpi_ctx_entry_2_ with
                               | 0 => 1%Q
                               | _.+1 => (1%Q + (...) elpi_ctx_entry_2_)%Q
                               end)%Q
                          end *
                          (match n with
                           | Posz elpi_ctx_entry_2_ =>
                               iterop elpi_ctx_entry_2_ addq 1 0
                           | Negz elpi_ctx_entry_2_ =>
                               (-
                                match elpi_ctx_entry_2_ with
                                | 0 => 1%Q
                                | _.+1 => (1%Q + ...)%Q
                                end)%Q
                           end *
                           (match n with
                            | Posz elpi_ctx_entry_2_ =>
                                iterop elpi_ctx_entry_2_ addq 1 0
                            | Negz elpi_ctx_entry_2_ =>
                                (- match ... with
                                   | ... 1%Q
                                   | ... ...%Q
                                   end)%Q
                            end *
                            (match n with
                             | Posz elpi_ctx_entry_2_ =>
                                 iterop elpi_ctx_entry_2_ addq 1 0
                             | Negz elpi_ctx_entry_2_ => (- ...)%Q
                             end *
                             (match ... with
                              | ... ...
                              | ... ...%Q
                              end * (... * ...)%Q)%Q)%Q)%Q)%Q)%Q)%Q)%Q)%Q +
                      (rat_of_Z
                         (BinNums.Zpos
                            (BinNums.xO
                               (BinNums.xO
                                  (BinNums.xI
                                     (BinNums.xO
                                        (BinNums.xI (BinNums.xO (...)))))))) *
                       (match n with
                        | Posz elpi_ctx_entry_2_ =>
                            iterop elpi_ctx_entry_2_ addq 1 0
                        | Negz elpi_ctx_entry_2_ =>
                            (-
                             match elpi_ctx_entry_2_ with
                             | 0 => 1%Q
                             | _.+1 =>
                                 (1%Q +
                                  (fix loop (m : nat) : rat :=
                                     match ... with
                                     | ... => 0
                                     | ... => 1
                                     | ... => 1%Q + ...
                                     end) elpi_ctx_entry_2_)%Q
                             end)%Q
                        end *
                        (match n with
                         | Posz elpi_ctx_entry_2_ =>
                             iterop elpi_ctx_entry_2_ addq 1 0
                         | Negz elpi_ctx_entry_2_ =>
                             (-
                              match elpi_ctx_entry_2_ with
                              | 0 => 1%Q
                              | _.+1 =>
                                  (1%Q +
                                   (fix loop ... : rat := ...
                                                 ...
                                                 ...
                                                 ...
                                                 end) elpi_ctx_entry_2_)%Q
                              end)%Q
                         end *
                         (match n with
                          | Posz elpi_ctx_entry_2_ =>
                              iterop elpi_ctx_entry_2_ addq 1 0
                          | Negz elpi_ctx_entry_2_ =>
                              (-
                               match elpi_ctx_entry_2_ with
                               | 0 => 1%Q
                               | _.+1 => (1%Q + (...) elpi_ctx_entry_2_)%Q
                               end)%Q
                          end *
                          (match n with
                           | Posz elpi_ctx_entry_2_ =>
                               iterop elpi_ctx_entry_2_ addq 1 0
                           | Negz elpi_ctx_entry_2_ =>
                               (-
                                match elpi_ctx_entry_2_ with
                                | 0 => 1%Q
                                | _.+1 => (1%Q + ...)%Q
                                end)%Q
                           end *
                           (match n with
                            | Posz elpi_ctx_entry_2_ =>
                                iterop elpi_ctx_entry_2_ addq 1 0
                            | Negz elpi_ctx_entry_2_ =>
                                (- match ... with
                                   | ... 1%Q
                                   | ... ...%Q
                                   end)%Q
                            end *
                            (match n with
                             | Posz elpi_ctx_entry_2_ =>
                                 iterop elpi_ctx_entry_2_ addq 1 0
                             | Negz elpi_ctx_entry_2_ => (- ...)%Q
                             end *
                             (match ... with
                              | ... ...
                              | ... ...%Q
                              end * match ... with
                                    | ... ...
                                    | ... ...%Q
                                    end)%Q)%Q)%Q)%Q)%Q)%Q)%Q)%Q)%Q +
                     (rat_of_Z
                        (BinNums.Zpos
                           (BinNums.xO
                              (BinNums.xI
                                 (BinNums.xI
                                    (BinNums.xO
                                       (BinNums.xI
                                          (BinNums.xI (BinNums.xI (...))))))))) *
                      (match n with
                       | Posz elpi_ctx_entry_2_ =>
                           iterop elpi_ctx_entry_2_ addq 1 0
                       | Negz elpi_ctx_entry_2_ =>
                           (-
                            match elpi_ctx_entry_2_ with
                            | 0 => 1%Q
                            | _.+1 =>
                                (1%Q +
                                 (fix loop (m : nat) : rat :=
                                    match m with
                                    | 0 => 0
                                    | 1 => 1
                                    | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                        1%Q + loop elpi_ctx_entry_6_
                                    end) elpi_ctx_entry_2_)%Q
                            end)%Q
                       end *
                       (match n with
                        | Posz elpi_ctx_entry_2_ =>
                            iterop elpi_ctx_entry_2_ addq 1 0
                        | Negz elpi_ctx_entry_2_ =>
                            (-
                             match elpi_ctx_entry_2_ with
                             | 0 => 1%Q
                             | _.+1 =>
                                 (1%Q +
                                  (fix loop (m : nat) : rat :=
                                     match ... with
                                     | ... => 0
                                     | ... => 1
                                     | ... => 1%Q + ...
                                     end) elpi_ctx_entry_2_)%Q
                             end)%Q
                        end *
                        (match n with
                         | Posz elpi_ctx_entry_2_ =>
                             iterop elpi_ctx_entry_2_ addq 1 0
                         | Negz elpi_ctx_entry_2_ =>
                             (-
                              match elpi_ctx_entry_2_ with
                              | 0 => 1%Q
                              | _.+1 =>
                                  (1%Q +
                                   (fix loop ... : rat := ...
                                                 ...
                                                 ...
                                                 ...
                                                 end) elpi_ctx_entry_2_)%Q
                              end)%Q
                         end *
                         (match n with
                          | Posz elpi_ctx_entry_2_ =>
                              iterop elpi_ctx_entry_2_ addq 1 0
                          | Negz elpi_ctx_entry_2_ =>
                              (-
                               match elpi_ctx_entry_2_ with
                               | 0 => 1%Q
                               | _.+1 => (1%Q + (...) elpi_ctx_entry_2_)%Q
                               end)%Q
                          end *
                          (match n with
                           | Posz elpi_ctx_entry_2_ =>
                               iterop elpi_ctx_entry_2_ addq 1 0
                           | Negz elpi_ctx_entry_2_ =>
                               (-
                                match elpi_ctx_entry_2_ with
                                | 0 => 1%Q
                                | _.+1 => (1%Q + ...)%Q
                                end)%Q
                           end *
                           (match n with
                            | Posz elpi_ctx_entry_2_ =>
                                iterop elpi_ctx_entry_2_ addq 1 0
                            | Negz elpi_ctx_entry_2_ =>
                                (- match ... with
                                   | ... 1%Q
                                   | ... ...%Q
                                   end)%Q
                            end *
                            match n with
                            | Posz elpi_ctx_entry_2_ =>
                                iterop elpi_ctx_entry_2_ addq 1 0
                            | Negz elpi_ctx_entry_2_ =>
                                (- match ... with
                                   | ... 1%Q
                                   | ... ...%Q
                                   end)%Q
                            end)%Q)%Q)%Q)%Q)%Q)%Q)%Q)%Q +
                    (rat_of_Z
                       (BinNums.Zpos
                          (BinNums.xO
                             (BinNums.xO
                                (BinNums.xI
                                   (BinNums.xI
                                      (BinNums.xI
                                         (BinNums.xO
                                            (BinNums.xO (BinNums.xI (...)))))))))) *
                     (match n with
                      | Posz elpi_ctx_entry_2_ =>
                          iterop elpi_ctx_entry_2_ addq 1 0
                      | Negz elpi_ctx_entry_2_ =>
                          (-
                           match elpi_ctx_entry_2_ with
                           | 0 => 1%Q
                           | _.+1 =>
                               (1%Q +
                                (fix loop (m : nat) : rat :=
                                   match m with
                                   | 0 => 0
                                   | 1 => 1
                                   | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                       1%Q + loop elpi_ctx_entry_6_
                                   end) elpi_ctx_entry_2_)%Q
                           end)%Q
                      end *
                      (match n with
                       | Posz elpi_ctx_entry_2_ =>
                           iterop elpi_ctx_entry_2_ addq 1 0
                       | Negz elpi_ctx_entry_2_ =>
                           (-
                            match elpi_ctx_entry_2_ with
                            | 0 => 1%Q
                            | _.+1 =>
                                (1%Q +
                                 (fix loop (m : nat) : rat :=
                                    match m with
                                    | 0 => 0
                                    | 1 => 1
                                    | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                        1%Q + loop elpi_ctx_entry_6_
                                    end) elpi_ctx_entry_2_)%Q
                            end)%Q
                       end *
                       (match n with
                        | Posz elpi_ctx_entry_2_ =>
                            iterop elpi_ctx_entry_2_ addq 1 0
                        | Negz elpi_ctx_entry_2_ =>
                            (-
                             match elpi_ctx_entry_2_ with
                             | 0 => 1%Q
                             | _.+1 =>
                                 (1%Q +
                                  (fix loop (m : nat) : rat :=
                                     match ... with
                                     | ... => 0
                                     | ... => 1
                                     | ... => 1%Q + ...
                                     end) elpi_ctx_entry_2_)%Q
                             end)%Q
                        end *
                        (match n with
                         | Posz elpi_ctx_entry_2_ =>
                             iterop elpi_ctx_entry_2_ addq 1 0
                         | Negz elpi_ctx_entry_2_ =>
                             (-
                              match elpi_ctx_entry_2_ with
                              | 0 => 1%Q
                              | _.+1 =>
                                  (1%Q +
                                   (fix loop ... : rat := ...
                                                 ...
                                                 ...
                                                 ...
                                                 end) elpi_ctx_entry_2_)%Q
                              end)%Q
                         end *
                         (match n with
                          | Posz elpi_ctx_entry_2_ =>
                              iterop elpi_ctx_entry_2_ addq 1 0
                          | Negz elpi_ctx_entry_2_ =>
                              (-
                               match elpi_ctx_entry_2_ with
                               | 0 => 1%Q
                               | _.+1 => (1%Q + (...) elpi_ctx_entry_2_)%Q
                               end)%Q
                          end *
                          match n with
                          | Posz elpi_ctx_entry_2_ =>
                              iterop elpi_ctx_entry_2_ addq 1 0
                          | Negz elpi_ctx_entry_2_ =>
                              (-
                               match elpi_ctx_entry_2_ with
                               | 0 => 1%Q
                               | _.+1 => (1%Q + (...) elpi_ctx_entry_2_)%Q
                               end)%Q
                          end)%Q)%Q)%Q)%Q)%Q)%Q)%Q +
                   (rat_of_Z
                      (BinNums.Zpos
                         (BinNums.xO
                            (BinNums.xI
                               (BinNums.xO
                                  (BinNums.xI
                                     (BinNums.xO
                                        (BinNums.xO
                                           (BinNums.xI
                                              (BinNums.xO (BinNums.xO (...))))))))))) *
                    (match n with
                     | Posz elpi_ctx_entry_2_ =>
                         iterop elpi_ctx_entry_2_ addq 1 0
                     | Negz elpi_ctx_entry_2_ =>
                         (-
                          match elpi_ctx_entry_2_ with
                          | 0 => 1%Q
                          | _.+1 =>
                              (1%Q +
                               (fix loop (m : nat) : rat :=
                                  match m with
                                  | 0 => 0
                                  | 1 => 1
                                  | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                      1%Q + loop elpi_ctx_entry_6_
                                  end) elpi_ctx_entry_2_)%Q
                          end)%Q
                     end *
                     (match n with
                      | Posz elpi_ctx_entry_2_ =>
                          iterop elpi_ctx_entry_2_ addq 1 0
                      | Negz elpi_ctx_entry_2_ =>
                          (-
                           match elpi_ctx_entry_2_ with
                           | 0 => 1%Q
                           | _.+1 =>
                               (1%Q +
                                (fix loop (m : nat) : rat :=
                                   match m with
                                   | 0 => 0
                                   | 1 => 1
                                   | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                       1%Q + loop elpi_ctx_entry_6_
                                   end) elpi_ctx_entry_2_)%Q
                           end)%Q
                      end *
                      (match n with
                       | Posz elpi_ctx_entry_2_ =>
                           iterop elpi_ctx_entry_2_ addq 1 0
                       | Negz elpi_ctx_entry_2_ =>
                           (-
                            match elpi_ctx_entry_2_ with
                            | 0 => 1%Q
                            | _.+1 =>
                                (1%Q +
                                 (fix loop (m : nat) : rat :=
                                    match m with
                                    | 0 => 0
                                    | 1 => 1
                                    | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                        1%Q + loop elpi_ctx_entry_6_
                                    end) elpi_ctx_entry_2_)%Q
                            end)%Q
                       end *
                       (match n with
                        | Posz elpi_ctx_entry_2_ =>
                            iterop elpi_ctx_entry_2_ addq 1 0
                        | Negz elpi_ctx_entry_2_ =>
                            (-
                             match elpi_ctx_entry_2_ with
                             | 0 => 1%Q
                             | _.+1 =>
                                 (1%Q +
                                  (fix loop (m : nat) : rat :=
                                     match ... with
                                     | ... => 0
                                     | ... => 1
                                     | ... => 1%Q + ...
                                     end) elpi_ctx_entry_2_)%Q
                             end)%Q
                        end *
                        match n with
                        | Posz elpi_ctx_entry_2_ =>
                            iterop elpi_ctx_entry_2_ addq 1 0
                        | Negz elpi_ctx_entry_2_ =>
                            (-
                             match elpi_ctx_entry_2_ with
                             | 0 => 1%Q
                             | _.+1 =>
                                 (1%Q +
                                  (fix loop (m : nat) : rat :=
                                     match ... with
                                     | ... => 0
                                     | ... => 1
                                     | ... => 1%Q + ...
                                     end) elpi_ctx_entry_2_)%Q
                             end)%Q
                        end)%Q)%Q)%Q)%Q)%Q)%Q +
                  (rat_of_Z
                     (BinNums.Zpos
                        (BinNums.xI
                           (BinNums.xI
                              (BinNums.xI
                                 (BinNums.xO
                                    (BinNums.xO
                                       (BinNums.xI
                                          (BinNums.xI
                                             (BinNums.xI
                                                (BinNums.xI
                                                 (BinNums.xI (...)))))))))))) *
                   (match n with
                    | Posz elpi_ctx_entry_2_ =>
                        iterop elpi_ctx_entry_2_ addq 1 0
                    | Negz elpi_ctx_entry_2_ =>
                        (-
                         match elpi_ctx_entry_2_ with
                         | 0 => 1%Q
                         | _.+1 =>
                             (1%Q +
                              (fix loop (m : nat) : rat :=
                                 match m with
                                 | 0 => 0
                                 | 1 => 1
                                 | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                     1%Q + loop elpi_ctx_entry_6_
                                 end) elpi_ctx_entry_2_)%Q
                         end)%Q
                    end *
                    (match n with
                     | Posz elpi_ctx_entry_2_ =>
                         iterop elpi_ctx_entry_2_ addq 1 0
                     | Negz elpi_ctx_entry_2_ =>
                         (-
                          match elpi_ctx_entry_2_ with
                          | 0 => 1%Q
                          | _.+1 =>
                              (1%Q +
                               (fix loop (m : nat) : rat :=
                                  match m with
                                  | 0 => 0
                                  | 1 => 1
                                  | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                      1%Q + loop elpi_ctx_entry_6_
                                  end) elpi_ctx_entry_2_)%Q
                          end)%Q
                     end *
                     (match n with
                      | Posz elpi_ctx_entry_2_ =>
                          iterop elpi_ctx_entry_2_ addq 1 0
                      | Negz elpi_ctx_entry_2_ =>
                          (-
                           match elpi_ctx_entry_2_ with
                           | 0 => 1%Q
                           | _.+1 =>
                               (1%Q +
                                (fix loop (m : nat) : rat :=
                                   match m with
                                   | 0 => 0
                                   | 1 => 1
                                   | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                       1%Q + loop elpi_ctx_entry_6_
                                   end) elpi_ctx_entry_2_)%Q
                           end)%Q
                      end *
                      match n with
                      | Posz elpi_ctx_entry_2_ =>
                          iterop elpi_ctx_entry_2_ addq 1 0
                      | Negz elpi_ctx_entry_2_ =>
                          (-
                           match elpi_ctx_entry_2_ with
                           | 0 => 1%Q
                           | _.+1 =>
                               (1%Q +
                                (fix loop (m : nat) : rat :=
                                   match m with
                                   | 0 => 0
                                   | 1 => 1
                                   | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                       1%Q + loop elpi_ctx_entry_6_
                                   end) elpi_ctx_entry_2_)%Q
                           end)%Q
                      end)%Q)%Q)%Q)%Q)%Q +
                 (rat_of_Z
                    (BinNums.Zpos
                       (BinNums.xO
                          (BinNums.xI
                             (BinNums.xI
                                (BinNums.xO
                                   (BinNums.xO
                                      (BinNums.xI
                                         (BinNums.xO
                                            (BinNums.xI
                                               (BinNums.xI
                                                 (BinNums.xO
                                                 (BinNums.xI (...))))))))))))) *
                  (match n with
                   | Posz elpi_ctx_entry_2_ =>
                       iterop elpi_ctx_entry_2_ addq 1 0
                   | Negz elpi_ctx_entry_2_ =>
                       (-
                        match elpi_ctx_entry_2_ with
                        | 0 => 1%Q
                        | _.+1 =>
                            (1%Q +
                             (fix loop (m : nat) : rat :=
                                match m with
                                | 0 => 0
                                | 1 => 1
                                | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                    1%Q + loop elpi_ctx_entry_6_
                                end) elpi_ctx_entry_2_)%Q
                        end)%Q
                   end *
                   (match n with
                    | Posz elpi_ctx_entry_2_ =>
                        iterop elpi_ctx_entry_2_ addq 1 0
                    | Negz elpi_ctx_entry_2_ =>
                        (-
                         match elpi_ctx_entry_2_ with
                         | 0 => 1%Q
                         | _.+1 =>
                             (1%Q +
                              (fix loop (m : nat) : rat :=
                                 match m with
                                 | 0 => 0
                                 | 1 => 1
                                 | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                     1%Q + loop elpi_ctx_entry_6_
                                 end) elpi_ctx_entry_2_)%Q
                         end)%Q
                    end *
                    match n with
                    | Posz elpi_ctx_entry_2_ =>
                        iterop elpi_ctx_entry_2_ addq 1 0
                    | Negz elpi_ctx_entry_2_ =>
                        (-
                         match elpi_ctx_entry_2_ with
                         | 0 => 1%Q
                         | _.+1 =>
                             (1%Q +
                              (fix loop (m : nat) : rat :=
                                 match m with
                                 | 0 => 0
                                 | 1 => 1
                                 | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                     1%Q + loop elpi_ctx_entry_6_
                                 end) elpi_ctx_entry_2_)%Q
                         end)%Q
                    end)%Q)%Q)%Q)%Q +
                (rat_of_Z
                   (BinNums.Zpos
                      (BinNums.xI
                         (BinNums.xO
                            (BinNums.xI
                               (BinNums.xO
                                  (BinNums.xI
                                     (BinNums.xI
                                        (BinNums.xO
                                           (BinNums.xI
                                              (BinNums.xI
                                                 (BinNums.xI
                                                 (BinNums.xO
                                                 (BinNums.xO (...)))))))))))))) *
                 (match n with
                  | Posz elpi_ctx_entry_2_ =>
                      iterop elpi_ctx_entry_2_ addq 1 0
                  | Negz elpi_ctx_entry_2_ =>
                      (-
                       match elpi_ctx_entry_2_ with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                   1%Q + loop elpi_ctx_entry_6_
                               end) elpi_ctx_entry_2_)%Q
                       end)%Q
                  end *
                  match n with
                  | Posz elpi_ctx_entry_2_ =>
                      iterop elpi_ctx_entry_2_ addq 1 0
                  | Negz elpi_ctx_entry_2_ =>
                      (-
                       match elpi_ctx_entry_2_ with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                   1%Q + loop elpi_ctx_entry_6_
                               end) elpi_ctx_entry_2_)%Q
                       end)%Q
                  end)%Q)%Q)%Q +
               (rat_of_Z
                  (BinNums.Zpos
                     (BinNums.xO
                        (BinNums.xI
                           (BinNums.xI
                              (BinNums.xI
                                 (BinNums.xO
                                    (BinNums.xO
                                       (BinNums.xO
                                          (BinNums.xI
                                             (BinNums.xI
                                                (BinNums.xI
                                                 (BinNums.xI
                                                 (BinNums.xI
                                                 (BinNums.xO (...))))))))))))))) *
                match n with
                | Posz elpi_ctx_entry_2_ => iterop elpi_ctx_entry_2_ addq 1 0
                | Negz elpi_ctx_entry_2_ =>
                    (-
                     match elpi_ctx_entry_2_ with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                 1%Q + loop elpi_ctx_entry_6_
                             end) elpi_ctx_entry_2_)%Q
                     end)%Q
                end)%Q)%Q +
              rat_of_Z
                (BinNums.Zpos
                   (BinNums.xO
                      (BinNums.xO
                         (BinNums.xO
                            (BinNums.xO
                               (BinNums.xO
                                  (BinNums.xI
                                     (BinNums.xO
                                        (BinNums.xO
                                           (BinNums.xO
                                              (BinNums.xO
                                                 (BinNums.xO
                                                 (BinNums.xI
                                                 (BinNums.xI
                                                 (BinNums.xI
                                                 (BinNums.xI (...))))))))))))))))))%Q)%Q *
            b (intZmod.addz n 1))%Q)%Q +
          (((((rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)) *
               match n with
               | Posz elpi_ctx_entry_2_ => iterop elpi_ctx_entry_2_ addq 1 0
               | Negz elpi_ctx_entry_2_ =>
                   (-
                    match elpi_ctx_entry_2_ with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                1%Q + loop elpi_ctx_entry_6_
                            end) elpi_ctx_entry_2_)%Q
                    end)%Q
               end)%Q +
              rat_of_Z (BinNums.Zpos (BinNums.xI (BinNums.xI 1%AC))))%Q *
             ((((rat_of_Z
                   (BinNums.Zpos
                      (BinNums.xO
                         (BinNums.xO
                            (BinNums.xO
                               (BinNums.xO
                                  (BinNums.xO
                                     (BinNums.xI
                                        (BinNums.xO
                                           (BinNums.xI (BinNums.xI 1%AC)))))))))) +
                 (rat_of_Z
                    (BinNums.Zpos
                       (BinNums.xO
                          (BinNums.xI
                             (BinNums.xO
                                (BinNums.xO
                                   (BinNums.xI
                                      (BinNums.xI
                                         (BinNums.xI
                                            (BinNums.xI
                                               (BinNums.xO (BinNums.xO 1%AC))))))))))) *
                  match n with
                  | Posz elpi_ctx_entry_2_ =>
                      iterop elpi_ctx_entry_2_ addq 1 0
                  | Negz elpi_ctx_entry_2_ =>
                      (-
                       match elpi_ctx_entry_2_ with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                   1%Q + loop elpi_ctx_entry_6_
                               end) elpi_ctx_entry_2_)%Q
                       end)%Q
                  end)%Q)%Q +
                (rat_of_Z
                   (BinNums.Zpos
                      (BinNums.xI
                         (BinNums.xI
                            (BinNums.xO
                               (BinNums.xO
                                  (BinNums.xO
                                     (BinNums.xO
                                        (BinNums.xO
                                           (BinNums.xI (BinNums.xO 1%AC)))))))))) *
                 (match n with
                  | Posz elpi_ctx_entry_2_ =>
                      iterop elpi_ctx_entry_2_ addq 1 0
                  | Negz elpi_ctx_entry_2_ =>
                      (-
                       match elpi_ctx_entry_2_ with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                   1%Q + loop elpi_ctx_entry_6_
                               end) elpi_ctx_entry_2_)%Q
                       end)%Q
                  end *
                  match n with
                  | Posz elpi_ctx_entry_2_ =>
                      iterop elpi_ctx_entry_2_ addq 1 0
                  | Negz elpi_ctx_entry_2_ =>
                      (-
                       match elpi_ctx_entry_2_ with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                   1%Q + loop elpi_ctx_entry_6_
                               end) elpi_ctx_entry_2_)%Q
                       end)%Q
                  end)%Q)%Q)%Q +
               (rat_of_Z
                  (BinNums.Zpos
                     (BinNums.xO
                        (BinNums.xO
                           (BinNums.xO
                              (BinNums.xO
                                 (BinNums.xI (BinNums.xO (BinNums.xO 1%AC)))))))) *
                (match n with
                 | Posz elpi_ctx_entry_2_ =>
                     iterop elpi_ctx_entry_2_ addq 1 0
                 | Negz elpi_ctx_entry_2_ =>
                     (-
                      match elpi_ctx_entry_2_ with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                  1%Q + loop elpi_ctx_entry_6_
                              end) elpi_ctx_entry_2_)%Q
                      end)%Q
                 end *
                 (match n with
                  | Posz elpi_ctx_entry_2_ =>
                      iterop elpi_ctx_entry_2_ addq 1 0
                  | Negz elpi_ctx_entry_2_ =>
                      (-
                       match elpi_ctx_entry_2_ with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                   1%Q + loop elpi_ctx_entry_6_
                               end) elpi_ctx_entry_2_)%Q
                       end)%Q
                  end *
                  match n with
                  | Posz elpi_ctx_entry_2_ =>
                      iterop elpi_ctx_entry_2_ addq 1 0
                  | Negz elpi_ctx_entry_2_ =>
                      (-
                       match elpi_ctx_entry_2_ with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                   1%Q + loop elpi_ctx_entry_6_
                               end) elpi_ctx_entry_2_)%Q
                       end)%Q
                  end)%Q)%Q)%Q)%Q +
              (rat_of_Z
                 (BinNums.Zpos (BinNums.xO (BinNums.xO (BinNums.xI 1%AC)))) *
               (match n with
                | Posz elpi_ctx_entry_2_ => iterop elpi_ctx_entry_2_ addq 1 0
                | Negz elpi_ctx_entry_2_ =>
                    (-
                     match elpi_ctx_entry_2_ with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                 1%Q + loop elpi_ctx_entry_6_
                             end) elpi_ctx_entry_2_)%Q
                     end)%Q
                end *
                (match n with
                 | Posz elpi_ctx_entry_2_ =>
                     iterop elpi_ctx_entry_2_ addq 1 0
                 | Negz elpi_ctx_entry_2_ =>
                     (-
                      match elpi_ctx_entry_2_ with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                  1%Q + loop elpi_ctx_entry_6_
                              end) elpi_ctx_entry_2_)%Q
                      end)%Q
                 end *
                 (match n with
                  | Posz elpi_ctx_entry_2_ =>
                      iterop elpi_ctx_entry_2_ addq 1 0
                  | Negz elpi_ctx_entry_2_ =>
                      (-
                       match elpi_ctx_entry_2_ with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                   1%Q + loop elpi_ctx_entry_6_
                               end) elpi_ctx_entry_2_)%Q
                       end)%Q
                  end *
                  match n with
                  | Posz elpi_ctx_entry_2_ =>
                      iterop elpi_ctx_entry_2_ addq 1 0
                  | Negz elpi_ctx_entry_2_ =>
                      (-
                       match elpi_ctx_entry_2_ with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                   1%Q + loop elpi_ctx_entry_6_
                               end) elpi_ctx_entry_2_)%Q
                       end)%Q
                  end)%Q)%Q)%Q)%Q)%Q)%Q *
            ((match n with
              | Posz elpi_ctx_entry_2_ => iterop elpi_ctx_entry_2_ addq 1 0
              | Negz elpi_ctx_entry_2_ =>
                  (-
                   match elpi_ctx_entry_2_ with
                   | 0 => 1%Q
                   | _.+1 =>
                       (1%Q +
                        (fix loop (m : nat) : rat :=
                           match m with
                           | 0 => 0
                           | 1 => 1
                           | (_.+1 as elpi_ctx_entry_6_).+1 =>
                               1%Q + loop elpi_ctx_entry_6_
                           end) elpi_ctx_entry_2_)%Q
                   end)%Q
              end + rat_of_Z (BinNums.Zpos 1%AC))%Q *
             ((match n with
               | Posz elpi_ctx_entry_2_ => iterop elpi_ctx_entry_2_ addq 1 0
               | Negz elpi_ctx_entry_2_ =>
                   (-
                    match elpi_ctx_entry_2_ with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                1%Q + loop elpi_ctx_entry_6_
                            end) elpi_ctx_entry_2_)%Q
                    end)%Q
               end + rat_of_Z (BinNums.Zpos 1%AC))%Q *
              ((match n with
                | Posz elpi_ctx_entry_2_ => iterop elpi_ctx_entry_2_ addq 1 0
                | Negz elpi_ctx_entry_2_ =>
                    (-
                     match elpi_ctx_entry_2_ with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                 1%Q + loop elpi_ctx_entry_6_
                             end) elpi_ctx_entry_2_)%Q
                     end)%Q
                end + rat_of_Z (BinNums.Zpos 1%AC))%Q *
               ((match n with
                 | Posz elpi_ctx_entry_2_ =>
                     iterop elpi_ctx_entry_2_ addq 1 0
                 | Negz elpi_ctx_entry_2_ =>
                     (-
                      match elpi_ctx_entry_2_ with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                  1%Q + loop elpi_ctx_entry_6_
                              end) elpi_ctx_entry_2_)%Q
                      end)%Q
                 end + rat_of_Z (BinNums.Zpos 1%AC))%Q *
                ((match n with
                  | Posz elpi_ctx_entry_2_ =>
                      iterop elpi_ctx_entry_2_ addq 1 0
                  | Negz elpi_ctx_entry_2_ =>
                      (-
                       match elpi_ctx_entry_2_ with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                   1%Q + loop elpi_ctx_entry_6_
                               end) elpi_ctx_entry_2_)%Q
                       end)%Q
                  end + rat_of_Z (BinNums.Zpos 1%AC))%Q *
                 (match n with
                  | Posz elpi_ctx_entry_2_ =>
                      iterop elpi_ctx_entry_2_ addq 1 0
                  | Negz elpi_ctx_entry_2_ =>
                      (-
                       match elpi_ctx_entry_2_ with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                   1%Q + loop elpi_ctx_entry_6_
                               end) elpi_ctx_entry_2_)%Q
                       end)%Q
                  end + rat_of_Z (BinNums.Zpos 1%AC))%Q)%Q)%Q)%Q)%Q)%Q)%Q *
           b n)%Q)%Q; 0%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
i : (2 : int) <= (n : int)
p := n - 1 : int_ZmodType
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: (((((((((rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)) *
                  match n with
                  | Posz elpi_ctx_entry_3_ =>
                      iterop elpi_ctx_entry_3_ addq 1 0
                  | Negz elpi_ctx_entry_3_ =>
                      (-
                       match elpi_ctx_entry_3_ with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                   1%Q + loop elpi_ctx_entry_7_
                               end) elpi_ctx_entry_3_)%Q
                       end)%Q
                  end)%Q + rat_of_Z (BinNums.Zpos (BinNums.xI 1%AC)))%Q *
                (((((rat_of_Z
                       (BinNums.Zpos
                          (BinNums.xO (BinNums.xO (BinNums.xI 1%AC)))) *
                     (match n with
                      | Posz elpi_ctx_entry_3_ =>
                          iterop elpi_ctx_entry_3_ addq 1 0
                      | Negz elpi_ctx_entry_3_ =>
                          (-
                           match elpi_ctx_entry_3_ with
                           | 0 => 1%Q
                           | _.+1 =>
                               (1%Q +
                                (fix loop (m : nat) : rat :=
                                   match m with
                                   | 0 => 0
                                   | 1 => 1
                                   | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                       1%Q + loop elpi_ctx_entry_7_
                                   end) elpi_ctx_entry_3_)%Q
                           end)%Q
                      end *
                      (match n with
                       | Posz elpi_ctx_entry_3_ =>
                           iterop elpi_ctx_entry_3_ addq 1 0
                       | Negz elpi_ctx_entry_3_ =>
                           (-
                            match elpi_ctx_entry_3_ with
                            | 0 => 1%Q
                            | _.+1 =>
                                (1%Q +
                                 (fix loop (m : nat) : rat :=
                                    match m with
                                    | 0 => 0
                                    | 1 => 1
                                    | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                        1%Q + loop elpi_ctx_entry_7_
                                    end) elpi_ctx_entry_3_)%Q
                            end)%Q
                       end *
                       (match n with
                        | Posz elpi_ctx_entry_3_ =>
                            iterop elpi_ctx_entry_3_ addq 1 0
                        | Negz elpi_ctx_entry_3_ =>
                            (-
                             match elpi_ctx_entry_3_ with
                             | 0 => 1%Q
                             | _.+1 =>
                                 (1%Q +
                                  (fix loop (m : nat) : rat :=
                                     match ... with
                                     | ... => 0
                                     | ... => 1
                                     | ... => 1%Q + ...
                                     end) elpi_ctx_entry_3_)%Q
                             end)%Q
                        end *
                        match n with
                        | Posz elpi_ctx_entry_3_ =>
                            iterop elpi_ctx_entry_3_ addq 1 0
                        | Negz elpi_ctx_entry_3_ =>
                            (-
                             match elpi_ctx_entry_3_ with
                             | 0 => 1%Q
                             | _.+1 =>
                                 (1%Q +
                                  (fix loop (m : nat) : rat :=
                                     match ... with
                                     | ... => 0
                                     | ... => 1
                                     | ... => 1%Q + ...
                                     end) elpi_ctx_entry_3_)%Q
                             end)%Q
                        end)%Q)%Q)%Q)%Q +
                    (rat_of_Z
                       (BinNums.Zpos
                          (BinNums.xO
                             (BinNums.xO
                                (BinNums.xO
                                   (BinNums.xO (BinNums.xO (BinNums.xI 1%AC))))))) *
                     (match n with
                      | Posz elpi_ctx_entry_3_ =>
                          iterop elpi_ctx_entry_3_ addq 1 0
                      | Negz elpi_ctx_entry_3_ =>
                          (-
                           match elpi_ctx_entry_3_ with
                           | 0 => 1%Q
                           | _.+1 =>
                               (1%Q +
                                (fix loop (m : nat) : rat :=
                                   match m with
                                   | 0 => 0
                                   | 1 => 1
                                   | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                       1%Q + loop elpi_ctx_entry_7_
                                   end) elpi_ctx_entry_3_)%Q
                           end)%Q
                      end *
                      (match n with
                       | Posz elpi_ctx_entry_3_ =>
                           iterop elpi_ctx_entry_3_ addq 1 0
                       | Negz elpi_ctx_entry_3_ =>
                           (-
                            match elpi_ctx_entry_3_ with
                            | 0 => 1%Q
                            | _.+1 =>
                                (1%Q +
                                 (fix loop (m : nat) : rat :=
                                    match m with
                                    | 0 => 0
                                    | 1 => 1
                                    | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                        1%Q + loop elpi_ctx_entry_7_
                                    end) elpi_ctx_entry_3_)%Q
                            end)%Q
                       end *
                       match n with
                       | Posz elpi_ctx_entry_3_ =>
                           iterop elpi_ctx_entry_3_ addq 1 0
                       | Negz elpi_ctx_entry_3_ =>
                           (-
                            match elpi_ctx_entry_3_ with
                            | 0 => 1%Q
                            | _.+1 =>
                                (1%Q +
                                 (fix loop (m : nat) : rat :=
                                    match m with
                                    | 0 => 0
                                    | 1 => 1
                                    | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                        1%Q + loop elpi_ctx_entry_7_
                                    end) elpi_ctx_entry_3_)%Q
                            end)%Q
                       end)%Q)%Q)%Q)%Q +
                   (rat_of_Z
                      (BinNums.Zpos
                         (BinNums.xI
                            (BinNums.xI
                               (BinNums.xO
                                  (BinNums.xI
                                     (BinNums.xI
                                        (BinNums.xO
                                           (BinNums.xO (BinNums.xO 1%AC))))))))) *
                    (match n with
                     | Posz elpi_ctx_entry_3_ =>
                         iterop elpi_ctx_entry_3_ addq 1 0
                     | Negz elpi_ctx_entry_3_ =>
                         (-
                          match elpi_ctx_entry_3_ with
                          | 0 => 1%Q
                          | _.+1 =>
                              (1%Q +
                               (fix loop (m : nat) : rat :=
                                  match m with
                                  | 0 => 0
                                  | 1 => 1
                                  | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                      1%Q + loop elpi_ctx_entry_7_
                                  end) elpi_ctx_entry_3_)%Q
                          end)%Q
                     end *
                     match n with
                     | Posz elpi_ctx_entry_3_ =>
                         iterop elpi_ctx_entry_3_ addq 1 0
                     | Negz elpi_ctx_entry_3_ =>
                         (-
                          match elpi_ctx_entry_3_ with
                          | 0 => 1%Q
                          | _.+1 =>
                              (1%Q +
                               (fix loop (m : nat) : rat :=
                                  match m with
                                  | 0 => 0
                                  | 1 => 1
                                  | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                      1%Q + loop elpi_ctx_entry_7_
                                  end) elpi_ctx_entry_3_)%Q
                          end)%Q
                     end)%Q)%Q)%Q +
                  (rat_of_Z
                     (BinNums.Zpos
                        (BinNums.xO
                           (BinNums.xO
                              (BinNums.xI
                                 (BinNums.xI
                                    (BinNums.xO
                                       (BinNums.xI
                                          (BinNums.xI (BinNums.xO 1%AC))))))))) *
                   match n with
                   | Posz elpi_ctx_entry_3_ =>
                       iterop elpi_ctx_entry_3_ addq 1 0
                   | Negz elpi_ctx_entry_3_ =>
                       (-
                        match elpi_ctx_entry_3_ with
                        | 0 => 1%Q
                        | _.+1 =>
                            (1%Q +
                             (fix loop (m : nat) : rat :=
                                match m with
                                | 0 => 0
                                | 1 => 1
                                | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                    1%Q + loop elpi_ctx_entry_7_
                                end) elpi_ctx_entry_3_)%Q
                        end)%Q
                   end)%Q)%Q +
                 rat_of_Z
                   (BinNums.Zpos
                      (BinNums.xI
                         (BinNums.xO
                            (BinNums.xI
                               (BinNums.xI
                                  (BinNums.xO (BinNums.xI (BinNums.xO 1%AC)))))))))%Q)%Q *
               ((match n with
                 | Posz elpi_ctx_entry_3_ =>
                     iterop elpi_ctx_entry_3_ addq 1 0
                 | Negz elpi_ctx_entry_3_ =>
                     (-
                      match elpi_ctx_entry_3_ with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                  1%Q + loop elpi_ctx_entry_7_
                              end) elpi_ctx_entry_3_)%Q
                      end)%Q
                 end + rat_of_Z (BinNums.Zpos (BinNums.xO (BinNums.xO 1%AC))))%Q *
                ((match n with
                  | Posz elpi_ctx_entry_3_ =>
                      iterop elpi_ctx_entry_3_ addq 1 0
                  | Negz elpi_ctx_entry_3_ =>
                      (-
                       match elpi_ctx_entry_3_ with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                   1%Q + loop elpi_ctx_entry_7_
                               end) elpi_ctx_entry_3_)%Q
                       end)%Q
                  end +
                  rat_of_Z (BinNums.Zpos (BinNums.xO (BinNums.xO 1%AC))))%Q *
                 ((match n with
                   | Posz elpi_ctx_entry_3_ =>
                       iterop elpi_ctx_entry_3_ addq 1 0
                   | Negz elpi_ctx_entry_3_ =>
                       (-
                        match elpi_ctx_entry_3_ with
                        | 0 => 1%Q
                        | _.+1 =>
                            (1%Q +
                             (fix loop (m : nat) : rat :=
                                match m with
                                | 0 => 0
                                | 1 => 1
                                | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                    1%Q + loop elpi_ctx_entry_7_
                                end) elpi_ctx_entry_3_)%Q
                        end)%Q
                   end +
                   rat_of_Z (BinNums.Zpos (BinNums.xO (BinNums.xO 1%AC))))%Q *
                  ((match n with
                    | Posz elpi_ctx_entry_3_ =>
                        iterop elpi_ctx_entry_3_ addq 1 0
                    | Negz elpi_ctx_entry_3_ =>
                        (-
                         match elpi_ctx_entry_3_ with
                         | 0 => 1%Q
                         | _.+1 =>
                             (1%Q +
                              (fix loop (m : nat) : rat :=
                                 match m with
                                 | 0 => 0
                                 | 1 => 1
                                 | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                     1%Q + loop elpi_ctx_entry_7_
                                 end) elpi_ctx_entry_3_)%Q
                         end)%Q
                    end +
                    rat_of_Z (BinNums.Zpos (BinNums.xO (BinNums.xO 1%AC))))%Q *
                   ((match n with
                     | Posz elpi_ctx_entry_3_ =>
                         iterop elpi_ctx_entry_3_ addq 1 0
                     | Negz elpi_ctx_entry_3_ =>
                         (-
                          match elpi_ctx_entry_3_ with
                          | 0 => 1%Q
                          | _.+1 =>
                              (1%Q +
                               (fix loop (m : nat) : rat :=
                                  match m with
                                  | 0 => 0
                                  | 1 => 1
                                  | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                      1%Q + loop elpi_ctx_entry_7_
                                  end) elpi_ctx_entry_3_)%Q
                          end)%Q
                     end +
                     rat_of_Z (BinNums.Zpos (BinNums.xO (BinNums.xO 1%AC))))%Q *
                    (match n with
                     | Posz elpi_ctx_entry_3_ =>
                         iterop elpi_ctx_entry_3_ addq 1 0
                     | Negz elpi_ctx_entry_3_ =>
                         (-
                          match elpi_ctx_entry_3_ with
                          | 0 => 1%Q
                          | _.+1 =>
                              (1%Q +
                               (fix loop (m : nat) : rat :=
                                  match m with
                                  | 0 => 0
                                  | 1 => 1
                                  | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                      1%Q + loop elpi_ctx_entry_7_
                                  end) elpi_ctx_entry_3_)%Q
                          end)%Q
                     end +
                     rat_of_Z (BinNums.Zpos (BinNums.xO (BinNums.xO 1%AC))))%Q)%Q)%Q)%Q)%Q)%Q)%Q *
              b
                (intZmod.addz
                   (intZmod.addz (intZmod.addz (intZmod.addz n 1) 1) 1) 1))%Q +
             (((((- rat_of_Z (BinNums.Zpos 1%AC))%Q *
                 ((rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)) *
                   match n with
                   | Posz elpi_ctx_entry_3_ =>
                       iterop elpi_ctx_entry_3_ addq 1 0
                   | Negz elpi_ctx_entry_3_ =>
                       (-
                        match elpi_ctx_entry_3_ with
                        | 0 => 1%Q
                        | _.+1 =>
                            (1%Q +
                             (fix loop (m : nat) : rat :=
                                match m with
                                | 0 => 0
                                | 1 => 1
                                | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                    1%Q + loop elpi_ctx_entry_7_
                                end) elpi_ctx_entry_3_)%Q
                        end)%Q
                   end)%Q + rat_of_Z (BinNums.Zpos (BinNums.xI 1%AC)))%Q)%Q *
                ((rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)) *
                  match n with
                  | Posz elpi_ctx_entry_3_ =>
                      iterop elpi_ctx_entry_3_ addq 1 0
                  | Negz elpi_ctx_entry_3_ =>
                      (-
                       match elpi_ctx_entry_3_ with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                   1%Q + loop elpi_ctx_entry_7_
                               end) elpi_ctx_entry_3_)%Q
                       end)%Q
                  end)%Q +
                 rat_of_Z (BinNums.Zpos (BinNums.xI (BinNums.xI 1%AC))))%Q)%Q *
               ((((((((((rat_of_Z
                           (BinNums.Zpos
                              (BinNums.xO
                                 (BinNums.xO (BinNums.xO (BinNums.xI (...)))))) *
                         (match n with
                          | Posz elpi_ctx_entry_3_ =>
                              iterop elpi_ctx_entry_3_ addq 1 0
                          | Negz elpi_ctx_entry_3_ =>
                              (-
                               match elpi_ctx_entry_3_ with
                               | 0 => 1%Q
                               | _.+1 => (1%Q + (...) elpi_ctx_entry_3_)%Q
                               end)%Q
                          end *
                          (match n with
                           | Posz elpi_ctx_entry_3_ =>
                               iterop elpi_ctx_entry_3_ addq 1 0
                           | Negz elpi_ctx_entry_3_ =>
                               (-
                                match elpi_ctx_entry_3_ with
                                | 0 => 1%Q
                                | _.+1 => (1%Q + ...)%Q
                                end)%Q
                           end *
                           (match n with
                            | Posz elpi_ctx_entry_3_ =>
                                iterop elpi_ctx_entry_3_ addq 1 0
                            | Negz elpi_ctx_entry_3_ =>
                                (- match ... with
                                   | ... 1%Q
                                   | ... ...%Q
                                   end)%Q
                            end *
                            (match n with
                             | Posz elpi_ctx_entry_3_ =>
                                 iterop elpi_ctx_entry_3_ addq 1 0
                             | Negz elpi_ctx_entry_3_ => (- ...)%Q
                             end *
                             (match ... with
                              | ... ...
                              | ... ...%Q
                              end * (... * ...%Q)%Q)%Q)%Q)%Q)%Q)%Q)%Q +
                        (rat_of_Z
                           (BinNums.Zpos
                              (BinNums.xO
                                 (BinNums.xO (BinNums.xI (BinNums.xO (...)))))) *
                         (match n with
                          | Posz elpi_ctx_entry_3_ =>
                              iterop elpi_ctx_entry_3_ addq 1 0
                          | Negz elpi_ctx_entry_3_ =>
                              (-
                               match elpi_ctx_entry_3_ with
                               | 0 => 1%Q
                               | _.+1 => (1%Q + (...) elpi_ctx_entry_3_)%Q
                               end)%Q
                          end *
                          (match n with
                           | Posz elpi_ctx_entry_3_ =>
                               iterop elpi_ctx_entry_3_ addq 1 0
                           | Negz elpi_ctx_entry_3_ =>
                               (-
                                match elpi_ctx_entry_3_ with
                                | 0 => 1%Q
                                | _.+1 => (1%Q + ...)%Q
                                end)%Q
                           end *
                           (match n with
                            | Posz elpi_ctx_entry_3_ =>
                                iterop elpi_ctx_entry_3_ addq 1 0
                            | Negz elpi_ctx_entry_3_ =>
                                (- match ... with
                                   | ... 1%Q
                                   | ... ...%Q
                                   end)%Q
                            end *
                            (match n with
                             | Posz elpi_ctx_entry_3_ =>
                                 iterop elpi_ctx_entry_3_ addq 1 0
                             | Negz elpi_ctx_entry_3_ => (- ...)%Q
                             end *
                             (match ... with
                              | ... ...
                              | ... ...%Q
                              end * (... * ...%Q)%Q)%Q)%Q)%Q)%Q)%Q)%Q)%Q +
                       (rat_of_Z
                          (BinNums.Zpos
                             (BinNums.xO
                                (BinNums.xI
                                   (BinNums.xI
                                      (BinNums.xO (BinNums.xI (...))))))) *
                        (match n with
                         | Posz elpi_ctx_entry_3_ =>
                             iterop elpi_ctx_entry_3_ addq 1 0
                         | Negz elpi_ctx_entry_3_ =>
                             (-
                              match elpi_ctx_entry_3_ with
                              | 0 => 1%Q
                              | _.+1 =>
                                  (1%Q +
                                   (fix loop ... : rat := ...
                                                 ...
                                                 ...
                                                 ...
                                                 end) elpi_ctx_entry_3_)%Q
                              end)%Q
                         end *
                         (match n with
                          | Posz elpi_ctx_entry_3_ =>
                              iterop elpi_ctx_entry_3_ addq 1 0
                          | Negz elpi_ctx_entry_3_ =>
                              (-
                               match elpi_ctx_entry_3_ with
                               | 0 => 1%Q
                               | _.+1 => (1%Q + (...) elpi_ctx_entry_3_)%Q
                               end)%Q
                          end *
                          (match n with
                           | Posz elpi_ctx_entry_3_ =>
                               iterop elpi_ctx_entry_3_ addq 1 0
                           | Negz elpi_ctx_entry_3_ =>
                               (-
                                match elpi_ctx_entry_3_ with
                                | 0 => 1%Q
                                | _.+1 => (1%Q + ...)%Q
                                end)%Q
                           end *
                           (match n with
                            | Posz elpi_ctx_entry_3_ =>
                                iterop elpi_ctx_entry_3_ addq 1 0
                            | Negz elpi_ctx_entry_3_ =>
                                (- match ... with
                                   | ... 1%Q
                                   | ... ...%Q
                                   end)%Q
                            end *
                            (match n with
                             | Posz elpi_ctx_entry_3_ =>
                                 iterop elpi_ctx_entry_3_ addq 1 0
                             | Negz elpi_ctx_entry_3_ => (- ...)%Q
                             end *
                             (match ... with
                              | ... ...
                              | ... ...%Q
                              end * match ... with
                                    | ... ...
                                    | ... ...%Q
                                    end)%Q)%Q)%Q)%Q)%Q)%Q)%Q)%Q +
                      (rat_of_Z
                         (BinNums.Zpos
                            (BinNums.xO
                               (BinNums.xI
                                  (BinNums.xI
                                     (BinNums.xO
                                        (BinNums.xI (BinNums.xI (...)))))))) *
                       (match n with
                        | Posz elpi_ctx_entry_3_ =>
                            iterop elpi_ctx_entry_3_ addq 1 0
                        | Negz elpi_ctx_entry_3_ =>
                            (-
                             match elpi_ctx_entry_3_ with
                             | 0 => 1%Q
                             | _.+1 =>
                                 (1%Q +
                                  (fix loop (m : nat) : rat :=
                                     match ... with
                                     | ... => 0
                                     | ... => 1
                                     | ... => 1%Q + ...
                                     end) elpi_ctx_entry_3_)%Q
                             end)%Q
                        end *
                        (match n with
                         | Posz elpi_ctx_entry_3_ =>
                             iterop elpi_ctx_entry_3_ addq 1 0
                         | Negz elpi_ctx_entry_3_ =>
                             (-
                              match elpi_ctx_entry_3_ with
                              | 0 => 1%Q
                              | _.+1 =>
                                  (1%Q +
                                   (fix loop ... : rat := ...
                                                 ...
                                                 ...
                                                 ...
                                                 end) elpi_ctx_entry_3_)%Q
                              end)%Q
                         end *
                         (match n with
                          | Posz elpi_ctx_entry_3_ =>
                              iterop elpi_ctx_entry_3_ addq 1 0
                          | Negz elpi_ctx_entry_3_ =>
                              (-
                               match elpi_ctx_entry_3_ with
                               | 0 => 1%Q
                               | _.+1 => (1%Q + (...) elpi_ctx_entry_3_)%Q
                               end)%Q
                          end *
                          (match n with
                           | Posz elpi_ctx_entry_3_ =>
                               iterop elpi_ctx_entry_3_ addq 1 0
                           | Negz elpi_ctx_entry_3_ =>
                               (-
                                match elpi_ctx_entry_3_ with
                                | 0 => 1%Q
                                | _.+1 => (1%Q + ...)%Q
                                end)%Q
                           end *
                           (match n with
                            | Posz elpi_ctx_entry_3_ =>
                                iterop elpi_ctx_entry_3_ addq 1 0
                            | Negz elpi_ctx_entry_3_ =>
                                (- match ... with
                                   | ... 1%Q
                                   | ... ...%Q
                                   end)%Q
                            end *
                            match n with
                            | Posz elpi_ctx_entry_3_ =>
                                iterop elpi_ctx_entry_3_ addq 1 0
                            | Negz elpi_ctx_entry_3_ =>
                                (- match ... with
                                   | ... 1%Q
                                   | ... ...%Q
                                   end)%Q
                            end)%Q)%Q)%Q)%Q)%Q)%Q)%Q +
                     (rat_of_Z
                        (BinNums.Zpos
                           (BinNums.xO
                              (BinNums.xO
                                 (BinNums.xO
                                    (BinNums.xO
                                       (BinNums.xI
                                          (BinNums.xI (BinNums.xI (...))))))))) *
                      (match n with
                       | Posz elpi_ctx_entry_3_ =>
                           iterop elpi_ctx_entry_3_ addq 1 0
                       | Negz elpi_ctx_entry_3_ =>
                           (-
                            match elpi_ctx_entry_3_ with
                            | 0 => 1%Q
                            | _.+1 =>
                                (1%Q +
                                 (fix loop (m : nat) : rat :=
                                    match m with
                                    | 0 => 0
                                    | 1 => 1
                                    | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                        1%Q + loop elpi_ctx_entry_7_
                                    end) elpi_ctx_entry_3_)%Q
                            end)%Q
                       end *
                       (match n with
                        | Posz elpi_ctx_entry_3_ =>
                            iterop elpi_ctx_entry_3_ addq 1 0
                        | Negz elpi_ctx_entry_3_ =>
                            (-
                             match elpi_ctx_entry_3_ with
                             | 0 => 1%Q
                             | _.+1 =>
                                 (1%Q +
                                  (fix loop (m : nat) : rat :=
                                     match ... with
                                     | ... => 0
                                     | ... => 1
                                     | ... => 1%Q + ...
                                     end) elpi_ctx_entry_3_)%Q
                             end)%Q
                        end *
                        (match n with
                         | Posz elpi_ctx_entry_3_ =>
                             iterop elpi_ctx_entry_3_ addq 1 0
                         | Negz elpi_ctx_entry_3_ =>
                             (-
                              match elpi_ctx_entry_3_ with
                              | 0 => 1%Q
                              | _.+1 =>
                                  (1%Q +
                                   (fix loop ... : rat := ...
                                                 ...
                                                 ...
                                                 ...
                                                 end) elpi_ctx_entry_3_)%Q
                              end)%Q
                         end *
                         (match n with
                          | Posz elpi_ctx_entry_3_ =>
                              iterop elpi_ctx_entry_3_ addq 1 0
                          | Negz elpi_ctx_entry_3_ =>
                              (-
                               match elpi_ctx_entry_3_ with
                               | 0 => 1%Q
                               | _.+1 => (1%Q + (...) elpi_ctx_entry_3_)%Q
                               end)%Q
                          end *
                          match n with
                          | Posz elpi_ctx_entry_3_ =>
                              iterop elpi_ctx_entry_3_ addq 1 0
                          | Negz elpi_ctx_entry_3_ =>
                              (-
                               match elpi_ctx_entry_3_ with
                               | 0 => 1%Q
                               | _.+1 => (1%Q + (...) elpi_ctx_entry_3_)%Q
                               end)%Q
                          end)%Q)%Q)%Q)%Q)%Q)%Q +
                    (rat_of_Z
                       (BinNums.Zpos
                          (BinNums.xI
                             (BinNums.xO
                                (BinNums.xO
                                   (BinNums.xO
                                      (BinNums.xO
                                         (BinNums.xO
                                            (BinNums.xO (BinNums.xO (...)))))))))) *
                     (match n with
                      | Posz elpi_ctx_entry_3_ =>
                          iterop elpi_ctx_entry_3_ addq 1 0
                      | Negz elpi_ctx_entry_3_ =>
                          (-
                           match elpi_ctx_entry_3_ with
                           | 0 => 1%Q
                           | _.+1 =>
                               (1%Q +
                                (fix loop (m : nat) : rat :=
                                   match m with
                                   | 0 => 0
                                   | 1 => 1
                                   | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                       1%Q + loop elpi_ctx_entry_7_
                                   end) elpi_ctx_entry_3_)%Q
                           end)%Q
                      end *
                      (match n with
                       | Posz elpi_ctx_entry_3_ =>
                           iterop elpi_ctx_entry_3_ addq 1 0
                       | Negz elpi_ctx_entry_3_ =>
                           (-
                            match elpi_ctx_entry_3_ with
                            | 0 => 1%Q
                            | _.+1 =>
                                (1%Q +
                                 (fix loop (m : nat) : rat :=
                                    match m with
                                    | 0 => 0
                                    | 1 => 1
                                    | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                        1%Q + loop elpi_ctx_entry_7_
                                    end) elpi_ctx_entry_3_)%Q
                            end)%Q
                       end *
                       (match n with
                        | Posz elpi_ctx_entry_3_ =>
                            iterop elpi_ctx_entry_3_ addq 1 0
                        | Negz elpi_ctx_entry_3_ =>
                            (-
                             match elpi_ctx_entry_3_ with
                             | 0 => 1%Q
                             | _.+1 =>
                                 (1%Q +
                                  (fix loop (m : nat) : rat :=
                                     match ... with
                                     | ... => 0
                                     | ... => 1
                                     | ... => 1%Q + ...
                                     end) elpi_ctx_entry_3_)%Q
                             end)%Q
                        end *
                        match n with
                        | Posz elpi_ctx_entry_3_ =>
                            iterop elpi_ctx_entry_3_ addq 1 0
                        | Negz elpi_ctx_entry_3_ =>
                            (-
                             match elpi_ctx_entry_3_ with
                             | 0 => 1%Q
                             | _.+1 =>
                                 (1%Q +
                                  (fix loop (m : nat) : rat :=
                                     match ... with
                                     | ... => 0
                                     | ... => 1
                                     | ... => 1%Q + ...
                                     end) elpi_ctx_entry_3_)%Q
                             end)%Q
                        end)%Q)%Q)%Q)%Q)%Q +
                   (rat_of_Z
                      (BinNums.Zpos
                         (BinNums.xO
                            (BinNums.xO
                               (BinNums.xO
                                  (BinNums.xO
                                     (BinNums.xI
                                        (BinNums.xI
                                           (BinNums.xI
                                              (BinNums.xI (BinNums.xO (...))))))))))) *
                    (match n with
                     | Posz elpi_ctx_entry_3_ =>
                         iterop elpi_ctx_entry_3_ addq 1 0
                     | Negz elpi_ctx_entry_3_ =>
                         (-
                          match elpi_ctx_entry_3_ with
                          | 0 => 1%Q
                          | _.+1 =>
                              (1%Q +
                               (fix loop (m : nat) : rat :=
                                  match m with
                                  | 0 => 0
                                  | 1 => 1
                                  | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                      1%Q + loop elpi_ctx_entry_7_
                                  end) elpi_ctx_entry_3_)%Q
                          end)%Q
                     end *
                     (match n with
                      | Posz elpi_ctx_entry_3_ =>
                          iterop elpi_ctx_entry_3_ addq 1 0
                      | Negz elpi_ctx_entry_3_ =>
                          (-
                           match elpi_ctx_entry_3_ with
                           | 0 => 1%Q
                           | _.+1 =>
                               (1%Q +
                                (fix loop (m : nat) : rat :=
                                   match m with
                                   | 0 => 0
                                   | 1 => 1
                                   | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                       1%Q + loop elpi_ctx_entry_7_
                                   end) elpi_ctx_entry_3_)%Q
                           end)%Q
                      end *
                      match n with
                      | Posz elpi_ctx_entry_3_ =>
                          iterop elpi_ctx_entry_3_ addq 1 0
                      | Negz elpi_ctx_entry_3_ =>
                          (-
                           match elpi_ctx_entry_3_ with
                           | 0 => 1%Q
                           | _.+1 =>
                               (1%Q +
                                (fix loop (m : nat) : rat :=
                                   match m with
                                   | 0 => 0
                                   | 1 => 1
                                   | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                       1%Q + loop elpi_ctx_entry_7_
                                   end) elpi_ctx_entry_3_)%Q
                           end)%Q
                      end)%Q)%Q)%Q)%Q +
                  (rat_of_Z
                     (BinNums.Zpos
                        (BinNums.xI
                           (BinNums.xO
                              (BinNums.xO
                                 (BinNums.xO
                                    (BinNums.xI
                                       (BinNums.xO
                                          (BinNums.xI
                                             (BinNums.xI
                                                (BinNums.xI
                                                 (BinNums.xO (...)))))))))))) *
                   (match n with
                    | Posz elpi_ctx_entry_3_ =>
                        iterop elpi_ctx_entry_3_ addq 1 0
                    | Negz elpi_ctx_entry_3_ =>
                        (-
                         match elpi_ctx_entry_3_ with
                         | 0 => 1%Q
                         | _.+1 =>
                             (1%Q +
                              (fix loop (m : nat) : rat :=
                                 match m with
                                 | 0 => 0
                                 | 1 => 1
                                 | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                     1%Q + loop elpi_ctx_entry_7_
                                 end) elpi_ctx_entry_3_)%Q
                         end)%Q
                    end *
                    match n with
                    | Posz elpi_ctx_entry_3_ =>
                        iterop elpi_ctx_entry_3_ addq 1 0
                    | Negz elpi_ctx_entry_3_ =>
                        (-
                         match elpi_ctx_entry_3_ with
                         | 0 => 1%Q
                         | _.+1 =>
                             (1%Q +
                              (fix loop (m : nat) : rat :=
                                 match m with
                                 | 0 => 0
                                 | 1 => 1
                                 | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                     1%Q + loop elpi_ctx_entry_7_
                                 end) elpi_ctx_entry_3_)%Q
                         end)%Q
                    end)%Q)%Q)%Q +
                 (rat_of_Z
                    (BinNums.Zpos
                       (BinNums.xO
                          (BinNums.xI
                             (BinNums.xI
                                (BinNums.xI
                                   (BinNums.xI
                                      (BinNums.xI
                                         (BinNums.xO
                                            (BinNums.xO
                                               (BinNums.xI
                                                 (BinNums.xI
                                                 (BinNums.xI (...))))))))))))) *
                  match n with
                  | Posz elpi_ctx_entry_3_ =>
                      iterop elpi_ctx_entry_3_ addq 1 0
                  | Negz elpi_ctx_entry_3_ =>
                      (-
                       match elpi_ctx_entry_3_ with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                   1%Q + loop elpi_ctx_entry_7_
                               end) elpi_ctx_entry_3_)%Q
                       end)%Q
                  end)%Q)%Q +
                rat_of_Z
                  (BinNums.Zpos
                     (BinNums.xO
                        (BinNums.xO
                           (BinNums.xO
                              (BinNums.xI
                                 (BinNums.xO
                                    (BinNums.xO
                                       (BinNums.xO
                                          (BinNums.xI
                                             (BinNums.xI
                                                (BinNums.xI
                                                 (BinNums.xI
                                                 (BinNums.xO
                                                 (BinNums.xI (...))))))))))))))))%Q)%Q *
              b (intZmod.addz (intZmod.addz (intZmod.addz n 1) 1) 1))%Q)%Q +
            ((((rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)) *
                match n with
                | Posz elpi_ctx_entry_3_ => iterop elpi_ctx_entry_3_ addq 1 0
                | Negz elpi_ctx_entry_3_ =>
                    (-
                     match elpi_ctx_entry_3_ with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                 1%Q + loop elpi_ctx_entry_7_
                             end) elpi_ctx_entry_3_)%Q
                     end)%Q
                end)%Q +
               rat_of_Z (BinNums.Zpos (BinNums.xI (BinNums.xO 1%AC))))%Q *
              (((((((((((rat_of_Z
                           (BinNums.Zpos
                              (BinNums.xO
                                 (BinNums.xO (BinNums.xO (BinNums.xI (...)))))) *
                         (match n with
                          | Posz elpi_ctx_entry_3_ =>
                              iterop elpi_ctx_entry_3_ addq 1 0
                          | Negz elpi_ctx_entry_3_ =>
                              (-
                               match elpi_ctx_entry_3_ with
                               | 0 => 1%Q
                               | _.+1 => (1%Q + (...) elpi_ctx_entry_3_)%Q
                               end)%Q
                          end *
                          (match n with
                           | Posz elpi_ctx_entry_3_ =>
                               iterop elpi_ctx_entry_3_ addq 1 0
                           | Negz elpi_ctx_entry_3_ =>
                               (-
                                match elpi_ctx_entry_3_ with
                                | 0 => 1%Q
                                | _.+1 => (1%Q + ...)%Q
                                end)%Q
                           end *
                           (match n with
                            | Posz elpi_ctx_entry_3_ =>
                                iterop elpi_ctx_entry_3_ addq 1 0
                            | Negz elpi_ctx_entry_3_ =>
                                (- match ... with
                                   | ... 1%Q
                                   | ... ...%Q
                                   end)%Q
                            end *
                            (match n with
                             | Posz elpi_ctx_entry_3_ =>
                                 iterop elpi_ctx_entry_3_ addq 1 0
                             | Negz elpi_ctx_entry_3_ => (- ...)%Q
                             end *
                             (match ... with
                              | ... ...
                              | ... ...%Q
                              end * (... * ...%Q)%Q)%Q)%Q)%Q)%Q)%Q)%Q +
                        (rat_of_Z
                           (BinNums.Zpos
                              (BinNums.xO
                                 (BinNums.xO (BinNums.xO (BinNums.xI (...)))))) *
                         (match n with
                          | Posz elpi_ctx_entry_3_ =>
                              iterop elpi_ctx_entry_3_ addq 1 0
                          | Negz elpi_ctx_entry_3_ =>
                              (-
                               match elpi_ctx_entry_3_ with
                               | 0 => 1%Q
                               | _.+1 => (1%Q + (...) elpi_ctx_entry_3_)%Q
                               end)%Q
                          end *
                          (match n with
                           | Posz elpi_ctx_entry_3_ =>
                               iterop elpi_ctx_entry_3_ addq 1 0
                           | Negz elpi_ctx_entry_3_ =>
                               (-
                                match elpi_ctx_entry_3_ with
                                | 0 => 1%Q
                                | _.+1 => (1%Q + ...)%Q
                                end)%Q
                           end *
                           (match n with
                            | Posz elpi_ctx_entry_3_ =>
                                iterop elpi_ctx_entry_3_ addq 1 0
                            | Negz elpi_ctx_entry_3_ =>
                                (- match ... with
                                   | ... 1%Q
                                   | ... ...%Q
                                   end)%Q
                            end *
                            (match n with
                             | Posz elpi_ctx_entry_3_ =>
                                 iterop elpi_ctx_entry_3_ addq 1 0
                             | Negz elpi_ctx_entry_3_ => (- ...)%Q
                             end *
                             (match ... with
                              | ... ...
                              | ... ...%Q
                              end * (... * ...%Q)%Q)%Q)%Q)%Q)%Q)%Q)%Q)%Q +
                       (rat_of_Z
                          (BinNums.Zpos
                             (BinNums.xO
                                (BinNums.xI
                                   (BinNums.xI
                                      (BinNums.xO (BinNums.xO (...))))))) *
                        (match n with
                         | Posz elpi_ctx_entry_3_ =>
                             iterop elpi_ctx_entry_3_ addq 1 0
                         | Negz elpi_ctx_entry_3_ =>
                             (-
                              match elpi_ctx_entry_3_ with
                              | 0 => 1%Q
                              | _.+1 =>
                                  (1%Q +
                                   (fix loop ... : rat := ...
                                                 ...
                                                 ...
                                                 ...
                                                 end) elpi_ctx_entry_3_)%Q
                              end)%Q
                         end *
                         (match n with
                          | Posz elpi_ctx_entry_3_ =>
                              iterop elpi_ctx_entry_3_ addq 1 0
                          | Negz elpi_ctx_entry_3_ =>
                              (-
                               match elpi_ctx_entry_3_ with
                               | 0 => 1%Q
                               | _.+1 => (1%Q + (...) elpi_ctx_entry_3_)%Q
                               end)%Q
                          end *
                          (match n with
                           | Posz elpi_ctx_entry_3_ =>
                               iterop elpi_ctx_entry_3_ addq 1 0
                           | Negz elpi_ctx_entry_3_ =>
                               (-
                                match elpi_ctx_entry_3_ with
                                | 0 => 1%Q
                                | _.+1 => (1%Q + ...)%Q
                                end)%Q
                           end *
                           (match n with
                            | Posz elpi_ctx_entry_3_ =>
                                iterop elpi_ctx_entry_3_ addq 1 0
                            | Negz elpi_ctx_entry_3_ =>
                                (- match ... with
                                   | ... 1%Q
                                   | ... ...%Q
                                   end)%Q
                            end *
                            (match n with
                             | Posz elpi_ctx_entry_3_ =>
                                 iterop elpi_ctx_entry_3_ addq 1 0
                             | Negz elpi_ctx_entry_3_ => (- ...)%Q
                             end *
                             (match ... with
                              | ... ...
                              | ... ...%Q
                              end * (... * ...)%Q)%Q)%Q)%Q)%Q)%Q)%Q)%Q)%Q +
                      (rat_of_Z
                         (BinNums.Zpos
                            (BinNums.xO
                               (BinNums.xO
                                  (BinNums.xO
                                     (BinNums.xI
                                        (BinNums.xO (BinNums.xO (...)))))))) *
                       (match n with
                        | Posz elpi_ctx_entry_3_ =>
                            iterop elpi_ctx_entry_3_ addq 1 0
                        | Negz elpi_ctx_entry_3_ =>
                            (-
                             match elpi_ctx_entry_3_ with
                             | 0 => 1%Q
                             | _.+1 =>
                                 (1%Q +
                                  (fix loop (m : nat) : rat :=
                                     match ... with
                                     | ... => 0
                                     | ... => 1
                                     | ... => 1%Q + ...
                                     end) elpi_ctx_entry_3_)%Q
                             end)%Q
                        end *
                        (match n with
                         | Posz elpi_ctx_entry_3_ =>
                             iterop elpi_ctx_entry_3_ addq 1 0
                         | Negz elpi_ctx_entry_3_ =>
                             (-
                              match elpi_ctx_entry_3_ with
                              | 0 => 1%Q
                              | _.+1 =>
                                  (1%Q +
                                   (fix loop ... : rat := ...
                                                 ...
                                                 ...
                                                 ...
                                                 end) elpi_ctx_entry_3_)%Q
                              end)%Q
                         end *
                         (match n with
                          | Posz elpi_ctx_entry_3_ =>
                              iterop elpi_ctx_entry_3_ addq 1 0
                          | Negz elpi_ctx_entry_3_ =>
                              (-
                               match elpi_ctx_entry_3_ with
                               | 0 => 1%Q
                               | _.+1 => (1%Q + (...) elpi_ctx_entry_3_)%Q
                               end)%Q
                          end *
                          (match n with
                           | Posz elpi_ctx_entry_3_ =>
                               iterop elpi_ctx_entry_3_ addq 1 0
                           | Negz elpi_ctx_entry_3_ =>
                               (-
                                match elpi_ctx_entry_3_ with
                                | 0 => 1%Q
                                | _.+1 => (1%Q + ...)%Q
                                end)%Q
                           end *
                           (match n with
                            | Posz elpi_ctx_entry_3_ =>
                                iterop elpi_ctx_entry_3_ addq 1 0
                            | Negz elpi_ctx_entry_3_ =>
                                (- match ... with
                                   | ... 1%Q
                                   | ... ...%Q
                                   end)%Q
                            end *
                            (match n with
                             | Posz elpi_ctx_entry_3_ =>
                                 iterop elpi_ctx_entry_3_ addq 1 0
                             | Negz elpi_ctx_entry_3_ => (- ...)%Q
                             end *
                             match n with
                             | Posz elpi_ctx_entry_3_ =>
                                 iterop elpi_ctx_entry_3_ addq 1 0
                             | Negz elpi_ctx_entry_3_ => (- ...)%Q
                             end)%Q)%Q)%Q)%Q)%Q)%Q)%Q)%Q +
                     (rat_of_Z
                        (BinNums.Zpos
                           (BinNums.xO
                              (BinNums.xO
                                 (BinNums.xI
                                    (BinNums.xI
                                       (BinNums.xO
                                          (BinNums.xI (BinNums.xO (...))))))))) *
                      (match n with
                       | Posz elpi_ctx_entry_3_ =>
                           iterop elpi_ctx_entry_3_ addq 1 0
                       | Negz elpi_ctx_entry_3_ =>
                           (-
                            match elpi_ctx_entry_3_ with
                            | 0 => 1%Q
                            | _.+1 =>
                                (1%Q +
                                 (fix loop (m : nat) : rat :=
                                    match m with
                                    | 0 => 0
                                    | 1 => 1
                                    | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                        1%Q + loop elpi_ctx_entry_7_
                                    end) elpi_ctx_entry_3_)%Q
                            end)%Q
                       end *
                       (match n with
                        | Posz elpi_ctx_entry_3_ =>
                            iterop elpi_ctx_entry_3_ addq 1 0
                        | Negz elpi_ctx_entry_3_ =>
                            (-
                             match elpi_ctx_entry_3_ with
                             | 0 => 1%Q
                             | _.+1 =>
                                 (1%Q +
                                  (fix loop (m : nat) : rat :=
                                     match ... with
                                     | ... => 0
                                     | ... => 1
                                     | ... => 1%Q + ...
                                     end) elpi_ctx_entry_3_)%Q
                             end)%Q
                        end *
                        (match n with
                         | Posz elpi_ctx_entry_3_ =>
                             iterop elpi_ctx_entry_3_ addq 1 0
                         | Negz elpi_ctx_entry_3_ =>
                             (-
                              match elpi_ctx_entry_3_ with
                              | 0 => 1%Q
                              | _.+1 =>
                                  (1%Q +
                                   (fix loop ... : rat := ...
                                                 ...
                                                 ...
                                                 ...
                                                 end) elpi_ctx_entry_3_)%Q
                              end)%Q
                         end *
                         (match n with
                          | Posz elpi_ctx_entry_3_ =>
                              iterop elpi_ctx_entry_3_ addq 1 0
                          | Negz elpi_ctx_entry_3_ =>
                              (-
                               match elpi_ctx_entry_3_ with
                               | 0 => 1%Q
                               | _.+1 => (1%Q + (...) elpi_ctx_entry_3_)%Q
                               end)%Q
                          end *
                          (match n with
                           | Posz elpi_ctx_entry_3_ =>
                               iterop elpi_ctx_entry_3_ addq 1 0
                           | Negz elpi_ctx_entry_3_ =>
                               (-
                                match elpi_ctx_entry_3_ with
                                | 0 => 1%Q
                                | _.+1 => (1%Q + ...)%Q
                                end)%Q
                           end *
                           match n with
                           | Posz elpi_ctx_entry_3_ =>
                               iterop elpi_ctx_entry_3_ addq 1 0
                           | Negz elpi_ctx_entry_3_ =>
                               (-
                                match elpi_ctx_entry_3_ with
                                | 0 => 1%Q
                                | _.+1 => (1%Q + ...)%Q
                                end)%Q
                           end)%Q)%Q)%Q)%Q)%Q)%Q)%Q +
                    (rat_of_Z
                       (BinNums.Zpos
                          (BinNums.xO
                             (BinNums.xO
                                (BinNums.xO
                                   (BinNums.xO
                                      (BinNums.xO
                                         (BinNums.xO
                                            (BinNums.xI (BinNums.xI (...)))))))))) *
                     (match n with
                      | Posz elpi_ctx_entry_3_ =>
                          iterop elpi_ctx_entry_3_ addq 1 0
                      | Negz elpi_ctx_entry_3_ =>
                          (-
                           match elpi_ctx_entry_3_ with
                           | 0 => 1%Q
                           | _.+1 =>
                               (1%Q +
                                (fix loop (m : nat) : rat :=
                                   match m with
                                   | 0 => 0
                                   | 1 => 1
                                   | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                       1%Q + loop elpi_ctx_entry_7_
                                   end) elpi_ctx_entry_3_)%Q
                           end)%Q
                      end *
                      (match n with
                       | Posz elpi_ctx_entry_3_ =>
                           iterop elpi_ctx_entry_3_ addq 1 0
                       | Negz elpi_ctx_entry_3_ =>
                           (-
                            match elpi_ctx_entry_3_ with
                            | 0 => 1%Q
                            | _.+1 =>
                                (1%Q +
                                 (fix loop (m : nat) : rat :=
                                    match m with
                                    | 0 => 0
                                    | 1 => 1
                                    | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                        1%Q + loop elpi_ctx_entry_7_
                                    end) elpi_ctx_entry_3_)%Q
                            end)%Q
                       end *
                       (match n with
                        | Posz elpi_ctx_entry_3_ =>
                            iterop elpi_ctx_entry_3_ addq 1 0
                        | Negz elpi_ctx_entry_3_ =>
                            (-
                             match elpi_ctx_entry_3_ with
                             | 0 => 1%Q
                             | _.+1 =>
                                 (1%Q +
                                  (fix loop (m : nat) : rat :=
                                     match ... with
                                     | ... => 0
                                     | ... => 1
                                     | ... => 1%Q + ...
                                     end) elpi_ctx_entry_3_)%Q
                             end)%Q
                        end *
                        (match n with
                         | Posz elpi_ctx_entry_3_ =>
                             iterop elpi_ctx_entry_3_ addq 1 0
                         | Negz elpi_ctx_entry_3_ =>
                             (-
                              match elpi_ctx_entry_3_ with
                              | 0 => 1%Q
                              | _.+1 =>
                                  (1%Q +
                                   (fix loop ... : rat := ...
                                                 ...
                                                 ...
                                                 ...
                                                 end) elpi_ctx_entry_3_)%Q
                              end)%Q
                         end *
                         match n with
                         | Posz elpi_ctx_entry_3_ =>
                             iterop elpi_ctx_entry_3_ addq 1 0
                         | Negz elpi_ctx_entry_3_ =>
                             (-
                              match elpi_ctx_entry_3_ with
                              | 0 => 1%Q
                              | _.+1 =>
                                  (1%Q +
                                   (fix loop ... : rat := ...
                                                 ...
                                                 ...
                                                 ...
                                                 end) elpi_ctx_entry_3_)%Q
                              end)%Q
                         end)%Q)%Q)%Q)%Q)%Q)%Q +
                   (rat_of_Z
                      (BinNums.Zpos
                         (BinNums.xI
                            (BinNums.xO
                               (BinNums.xO
                                  (BinNums.xO
                                     (BinNums.xO
                                        (BinNums.xI
                                           (BinNums.xI
                                              (BinNums.xO (BinNums.xI (...))))))))))) *
                    (match n with
                     | Posz elpi_ctx_entry_3_ =>
                         iterop elpi_ctx_entry_3_ addq 1 0
                     | Negz elpi_ctx_entry_3_ =>
                         (-
                          match elpi_ctx_entry_3_ with
                          | 0 => 1%Q
                          | _.+1 =>
                              (1%Q +
                               (fix loop (m : nat) : rat :=
                                  match m with
                                  | 0 => 0
                                  | 1 => 1
                                  | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                      1%Q + loop elpi_ctx_entry_7_
                                  end) elpi_ctx_entry_3_)%Q
                          end)%Q
                     end *
                     (match n with
                      | Posz elpi_ctx_entry_3_ =>
                          iterop elpi_ctx_entry_3_ addq 1 0
                      | Negz elpi_ctx_entry_3_ =>
                          (-
                           match elpi_ctx_entry_3_ with
                           | 0 => 1%Q
                           | _.+1 =>
                               (1%Q +
                                (fix loop (m : nat) : rat :=
                                   match m with
                                   | 0 => 0
                                   | 1 => 1
                                   | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                       1%Q + loop elpi_ctx_entry_7_
                                   end) elpi_ctx_entry_3_)%Q
                           end)%Q
                      end *
                      (match n with
                       | Posz elpi_ctx_entry_3_ =>
                           iterop elpi_ctx_entry_3_ addq 1 0
                       | Negz elpi_ctx_entry_3_ =>
                           (-
                            match elpi_ctx_entry_3_ with
                            | 0 => 1%Q
                            | _.+1 =>
                                (1%Q +
                                 (fix loop (m : nat) : rat :=
                                    match m with
                                    | 0 => 0
                                    | 1 => 1
                                    | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                        1%Q + loop elpi_ctx_entry_7_
                                    end) elpi_ctx_entry_3_)%Q
                            end)%Q
                       end *
                       match n with
                       | Posz elpi_ctx_entry_3_ =>
                           iterop elpi_ctx_entry_3_ addq 1 0
                       | Negz elpi_ctx_entry_3_ =>
                           (-
                            match elpi_ctx_entry_3_ with
                            | 0 => 1%Q
                            | _.+1 =>
                                (1%Q +
                                 (fix loop (m : nat) : rat :=
                                    match m with
                                    | 0 => 0
                                    | 1 => 1
                                    | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                        1%Q + loop elpi_ctx_entry_7_
                                    end) elpi_ctx_entry_3_)%Q
                            end)%Q
                       end)%Q)%Q)%Q)%Q)%Q +
                  (rat_of_Z
                     (BinNums.Zpos
                        (BinNums.xO
                           (BinNums.xI
                              (BinNums.xI
                                 (BinNums.xI
                                    (BinNums.xO
                                       (BinNums.xO
                                          (BinNums.xI
                                             (BinNums.xO
                                                (BinNums.xO
                                                 (BinNums.xI (...)))))))))))) *
                   (match n with
                    | Posz elpi_ctx_entry_3_ =>
                        iterop elpi_ctx_entry_3_ addq 1 0
                    | Negz elpi_ctx_entry_3_ =>
                        (-
                         match elpi_ctx_entry_3_ with
                         | 0 => 1%Q
                         | _.+1 =>
                             (1%Q +
                              (fix loop (m : nat) : rat :=
                                 match m with
                                 | 0 => 0
                                 | 1 => 1
                                 | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                     1%Q + loop elpi_ctx_entry_7_
                                 end) elpi_ctx_entry_3_)%Q
                         end)%Q
                    end *
                    (match n with
                     | Posz elpi_ctx_entry_3_ =>
                         iterop elpi_ctx_entry_3_ addq 1 0
                     | Negz elpi_ctx_entry_3_ =>
                         (-
                          match elpi_ctx_entry_3_ with
                          | 0 => 1%Q
                          | _.+1 =>
                              (1%Q +
                               (fix loop (m : nat) : rat :=
                                  match m with
                                  | 0 => 0
                                  | 1 => 1
                                  | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                      1%Q + loop elpi_ctx_entry_7_
                                  end) elpi_ctx_entry_3_)%Q
                          end)%Q
                     end *
                     match n with
                     | Posz elpi_ctx_entry_3_ =>
                         iterop elpi_ctx_entry_3_ addq 1 0
                     | Negz elpi_ctx_entry_3_ =>
                         (-
                          match elpi_ctx_entry_3_ with
                          | 0 => 1%Q
                          | _.+1 =>
                              (1%Q +
                               (fix loop (m : nat) : rat :=
                                  match m with
                                  | 0 => 0
                                  | 1 => 1
                                  | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                      1%Q + loop elpi_ctx_entry_7_
                                  end) elpi_ctx_entry_3_)%Q
                          end)%Q
                     end)%Q)%Q)%Q)%Q +
                 (rat_of_Z
                    (BinNums.Zpos
                       (BinNums.xI
                          (BinNums.xO
                             (BinNums.xO
                                (BinNums.xO
                                   (BinNums.xI
                                      (BinNums.xI
                                         (BinNums.xO
                                            (BinNums.xO
                                               (BinNums.xO
                                                 (BinNums.xO
                                                 (BinNums.xI (...))))))))))))) *
                  (match n with
                   | Posz elpi_ctx_entry_3_ =>
                       iterop elpi_ctx_entry_3_ addq 1 0
                   | Negz elpi_ctx_entry_3_ =>
                       (-
                        match elpi_ctx_entry_3_ with
                        | 0 => 1%Q
                        | _.+1 =>
                            (1%Q +
                             (fix loop (m : nat) : rat :=
                                match m with
                                | 0 => 0
                                | 1 => 1
                                | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                    1%Q + loop elpi_ctx_entry_7_
                                end) elpi_ctx_entry_3_)%Q
                        end)%Q
                   end *
                   match n with
                   | Posz elpi_ctx_entry_3_ =>
                       iterop elpi_ctx_entry_3_ addq 1 0
                   | Negz elpi_ctx_entry_3_ =>
                       (-
                        match elpi_ctx_entry_3_ with
                        | 0 => 1%Q
                        | _.+1 =>
                            (1%Q +
                             (fix loop (m : nat) : rat :=
                                match m with
                                | 0 => 0
                                | 1 => 1
                                | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                    1%Q + loop elpi_ctx_entry_7_
                                end) elpi_ctx_entry_3_)%Q
                        end)%Q
                   end)%Q)%Q)%Q +
                (rat_of_Z
                   (BinNums.Zpos
                      (BinNums.xO
                         (BinNums.xI
                            (BinNums.xI
                               (BinNums.xO
                                  (BinNums.xI
                                     (BinNums.xI
                                        (BinNums.xO
                                           (BinNums.xO
                                              (BinNums.xO
                                                 (BinNums.xO
                                                 (BinNums.xO
                                                 (BinNums.xO (...)))))))))))))) *
                 match n with
                 | Posz elpi_ctx_entry_3_ =>
                     iterop elpi_ctx_entry_3_ addq 1 0
                 | Negz elpi_ctx_entry_3_ =>
                     (-
                      match elpi_ctx_entry_3_ with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                  1%Q + loop elpi_ctx_entry_7_
                              end) elpi_ctx_entry_3_)%Q
                      end)%Q
                 end)%Q)%Q +
               rat_of_Z
                 (BinNums.Zpos
                    (BinNums.xO
                       (BinNums.xO
                          (BinNums.xO
                             (BinNums.xI
                                (BinNums.xO
                                   (BinNums.xI
                                      (BinNums.xO
                                         (BinNums.xI
                                            (BinNums.xO
                                               (BinNums.xO
                                                 (BinNums.xI
                                                 (BinNums.xO
                                                 (BinNums.xO
                                                 (BinNums.xO (...)))))))))))))))))%Q)%Q *
             b (intZmod.addz (intZmod.addz n 1) 1))%Q)%Q +
           (((((- rat_of_Z (BinNums.Zpos 1%AC))%Q *
               ((rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)) *
                 match n with
                 | Posz elpi_ctx_entry_3_ =>
                     iterop elpi_ctx_entry_3_ addq 1 0
                 | Negz elpi_ctx_entry_3_ =>
                     (-
                      match elpi_ctx_entry_3_ with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                  1%Q + loop elpi_ctx_entry_7_
                              end) elpi_ctx_entry_3_)%Q
                      end)%Q
                 end)%Q + rat_of_Z (BinNums.Zpos (BinNums.xI 1%AC)))%Q)%Q *
              ((rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)) *
                match n with
                | Posz elpi_ctx_entry_3_ => iterop elpi_ctx_entry_3_ addq 1 0
                | Negz elpi_ctx_entry_3_ =>
                    (-
                     match elpi_ctx_entry_3_ with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                 1%Q + loop elpi_ctx_entry_7_
                             end) elpi_ctx_entry_3_)%Q
                     end)%Q
                end)%Q +
               rat_of_Z (BinNums.Zpos (BinNums.xI (BinNums.xI 1%AC))))%Q)%Q *
             ((((((((((rat_of_Z
                         (BinNums.Zpos
                            (BinNums.xO
                               (BinNums.xO
                                  (BinNums.xO
                                     (BinNums.xI
                                        (BinNums.xI (BinNums.xO (...)))))))) *
                       (match n with
                        | Posz elpi_ctx_entry_3_ =>
                            iterop elpi_ctx_entry_3_ addq 1 0
                        | Negz elpi_ctx_entry_3_ =>
                            (-
                             match elpi_ctx_entry_3_ with
                             | 0 => 1%Q
                             | _.+1 =>
                                 (1%Q +
                                  (fix loop (m : nat) : rat :=
                                     match ... with
                                     | ... => 0
                                     | ... => 1
                                     | ... => 1%Q + ...
                                     end) elpi_ctx_entry_3_)%Q
                             end)%Q
                        end *
                        (match n with
                         | Posz elpi_ctx_entry_3_ =>
                             iterop elpi_ctx_entry_3_ addq 1 0
                         | Negz elpi_ctx_entry_3_ =>
                             (-
                              match elpi_ctx_entry_3_ with
                              | 0 => 1%Q
                              | _.+1 =>
                                  (1%Q +
                                   (fix loop ... : rat := ...
                                                 ...
                                                 ...
                                                 ...
                                                 end) elpi_ctx_entry_3_)%Q
                              end)%Q
                         end *
                         (match n with
                          | Posz elpi_ctx_entry_3_ =>
                              iterop elpi_ctx_entry_3_ addq 1 0
                          | Negz elpi_ctx_entry_3_ =>
                              (-
                               match elpi_ctx_entry_3_ with
                               | 0 => 1%Q
                               | _.+1 => (1%Q + (...) elpi_ctx_entry_3_)%Q
                               end)%Q
                          end *
                          (match n with
                           | Posz elpi_ctx_entry_3_ =>
                               iterop elpi_ctx_entry_3_ addq 1 0
                           | Negz elpi_ctx_entry_3_ =>
                               (-
                                match elpi_ctx_entry_3_ with
                                | 0 => 1%Q
                                | _.+1 => (1%Q + ...)%Q
                                end)%Q
                           end *
                           (match n with
                            | Posz elpi_ctx_entry_3_ =>
                                iterop elpi_ctx_entry_3_ addq 1 0
                            | Negz elpi_ctx_entry_3_ =>
                                (- match ... with
                                   | ... 1%Q
                                   | ... ...%Q
                                   end)%Q
                            end *
                            (match n with
                             | Posz elpi_ctx_entry_3_ =>
                                 iterop elpi_ctx_entry_3_ addq 1 0
                             | Negz elpi_ctx_entry_3_ => (- ...)%Q
                             end *
                             (match ... with
                              | ... ...
                              | ... ...%Q
                              end * (... * ...)%Q)%Q)%Q)%Q)%Q)%Q)%Q)%Q)%Q +
                      (rat_of_Z
                         (BinNums.Zpos
                            (BinNums.xO
                               (BinNums.xO
                                  (BinNums.xI
                                     (BinNums.xO
                                        (BinNums.xI (BinNums.xO (...)))))))) *
                       (match n with
                        | Posz elpi_ctx_entry_3_ =>
                            iterop elpi_ctx_entry_3_ addq 1 0
                        | Negz elpi_ctx_entry_3_ =>
                            (-
                             match elpi_ctx_entry_3_ with
                             | 0 => 1%Q
                             | _.+1 =>
                                 (1%Q +
                                  (fix loop (m : nat) : rat :=
                                     match ... with
                                     | ... => 0
                                     | ... => 1
                                     | ... => 1%Q + ...
                                     end) elpi_ctx_entry_3_)%Q
                             end)%Q
                        end *
                        (match n with
                         | Posz elpi_ctx_entry_3_ =>
                             iterop elpi_ctx_entry_3_ addq 1 0
                         | Negz elpi_ctx_entry_3_ =>
                             (-
                              match elpi_ctx_entry_3_ with
                              | 0 => 1%Q
                              | _.+1 =>
                                  (1%Q +
                                   (fix loop ... : rat := ...
                                                 ...
                                                 ...
                                                 ...
                                                 end) elpi_ctx_entry_3_)%Q
                              end)%Q
                         end *
                         (match n with
                          | Posz elpi_ctx_entry_3_ =>
                              iterop elpi_ctx_entry_3_ addq 1 0
                          | Negz elpi_ctx_entry_3_ =>
                              (-
                               match elpi_ctx_entry_3_ with
                               | 0 => 1%Q
                               | _.+1 => (1%Q + (...) elpi_ctx_entry_3_)%Q
                               end)%Q
                          end *
                          (match n with
                           | Posz elpi_ctx_entry_3_ =>
                               iterop elpi_ctx_entry_3_ addq 1 0
                           | Negz elpi_ctx_entry_3_ =>
                               (-
                                match elpi_ctx_entry_3_ with
                                | 0 => 1%Q
                                | _.+1 => (1%Q + ...)%Q
                                end)%Q
                           end *
                           (match n with
                            | Posz elpi_ctx_entry_3_ =>
                                iterop elpi_ctx_entry_3_ addq 1 0
                            | Negz elpi_ctx_entry_3_ =>
                                (- match ... with
                                   | ... 1%Q
                                   | ... ...%Q
                                   end)%Q
                            end *
                            (match n with
                             | Posz elpi_ctx_entry_3_ =>
                                 iterop elpi_ctx_entry_3_ addq 1 0
                             | Negz elpi_ctx_entry_3_ => (- ...)%Q
                             end *
                             (match ... with
                              | ... ...
                              | ... ...%Q
                              end * match ... with
                                    | ... ...
                                    | ... ...%Q
                                    end)%Q)%Q)%Q)%Q)%Q)%Q)%Q)%Q)%Q +
                     (rat_of_Z
                        (BinNums.Zpos
                           (BinNums.xO
                              (BinNums.xI
                                 (BinNums.xI
                                    (BinNums.xO
                                       (BinNums.xI
                                          (BinNums.xI (BinNums.xI (...))))))))) *
                      (match n with
                       | Posz elpi_ctx_entry_3_ =>
                           iterop elpi_ctx_entry_3_ addq 1 0
                       | Negz elpi_ctx_entry_3_ =>
                           (-
                            match elpi_ctx_entry_3_ with
                            | 0 => 1%Q
                            | _.+1 =>
                                (1%Q +
                                 (fix loop (m : nat) : rat :=
                                    match m with
                                    | 0 => 0
                                    | 1 => 1
                                    | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                        1%Q + loop elpi_ctx_entry_7_
                                    end) elpi_ctx_entry_3_)%Q
                            end)%Q
                       end *
                       (match n with
                        | Posz elpi_ctx_entry_3_ =>
                            iterop elpi_ctx_entry_3_ addq 1 0
                        | Negz elpi_ctx_entry_3_ =>
                            (-
                             match elpi_ctx_entry_3_ with
                             | 0 => 1%Q
                             | _.+1 =>
                                 (1%Q +
                                  (fix loop (m : nat) : rat :=
                                     match ... with
                                     | ... => 0
                                     | ... => 1
                                     | ... => 1%Q + ...
                                     end) elpi_ctx_entry_3_)%Q
                             end)%Q
                        end *
                        (match n with
                         | Posz elpi_ctx_entry_3_ =>
                             iterop elpi_ctx_entry_3_ addq 1 0
                         | Negz elpi_ctx_entry_3_ =>
                             (-
                              match elpi_ctx_entry_3_ with
                              | 0 => 1%Q
                              | _.+1 =>
                                  (1%Q +
                                   (fix loop ... : rat := ...
                                                 ...
                                                 ...
                                                 ...
                                                 end) elpi_ctx_entry_3_)%Q
                              end)%Q
                         end *
                         (match n with
                          | Posz elpi_ctx_entry_3_ =>
                              iterop elpi_ctx_entry_3_ addq 1 0
                          | Negz elpi_ctx_entry_3_ =>
                              (-
                               match elpi_ctx_entry_3_ with
                               | 0 => 1%Q
                               | _.+1 => (1%Q + (...) elpi_ctx_entry_3_)%Q
                               end)%Q
                          end *
                          (match n with
                           | Posz elpi_ctx_entry_3_ =>
                               iterop elpi_ctx_entry_3_ addq 1 0
                           | Negz elpi_ctx_entry_3_ =>
                               (-
                                match elpi_ctx_entry_3_ with
                                | 0 => 1%Q
                                | _.+1 => (1%Q + ...)%Q
                                end)%Q
                           end *
                           (match n with
                            | Posz elpi_ctx_entry_3_ =>
                                iterop elpi_ctx_entry_3_ addq 1 0
                            | Negz elpi_ctx_entry_3_ =>
                                (- match ... with
                                   | ... 1%Q
                                   | ... ...%Q
                                   end)%Q
                            end *
                            match n with
                            | Posz elpi_ctx_entry_3_ =>
                                iterop elpi_ctx_entry_3_ addq 1 0
                            | Negz elpi_ctx_entry_3_ =>
                                (- match ... with
                                   | ... 1%Q
                                   | ... ...%Q
                                   end)%Q
                            end)%Q)%Q)%Q)%Q)%Q)%Q)%Q)%Q +
                    (rat_of_Z
                       (BinNums.Zpos
                          (BinNums.xO
                             (BinNums.xO
                                (BinNums.xI
                                   (BinNums.xI
                                      (BinNums.xI
                                         (BinNums.xO
                                            (BinNums.xO (BinNums.xI (...)))))))))) *
                     (match n with
                      | Posz elpi_ctx_entry_3_ =>
                          iterop elpi_ctx_entry_3_ addq 1 0
                      | Negz elpi_ctx_entry_3_ =>
                          (-
                           match elpi_ctx_entry_3_ with
                           | 0 => 1%Q
                           | _.+1 =>
                               (1%Q +
                                (fix loop (m : nat) : rat :=
                                   match m with
                                   | 0 => 0
                                   | 1 => 1
                                   | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                       1%Q + loop elpi_ctx_entry_7_
                                   end) elpi_ctx_entry_3_)%Q
                           end)%Q
                      end *
                      (match n with
                       | Posz elpi_ctx_entry_3_ =>
                           iterop elpi_ctx_entry_3_ addq 1 0
                       | Negz elpi_ctx_entry_3_ =>
                           (-
                            match elpi_ctx_entry_3_ with
                            | 0 => 1%Q
                            | _.+1 =>
                                (1%Q +
                                 (fix loop (m : nat) : rat :=
                                    match m with
                                    | 0 => 0
                                    | 1 => 1
                                    | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                        1%Q + loop elpi_ctx_entry_7_
                                    end) elpi_ctx_entry_3_)%Q
                            end)%Q
                       end *
                       (match n with
                        | Posz elpi_ctx_entry_3_ =>
                            iterop elpi_ctx_entry_3_ addq 1 0
                        | Negz elpi_ctx_entry_3_ =>
                            (-
                             match elpi_ctx_entry_3_ with
                             | 0 => 1%Q
                             | _.+1 =>
                                 (1%Q +
                                  (fix loop (m : nat) : rat :=
                                     match ... with
                                     | ... => 0
                                     | ... => 1
                                     | ... => 1%Q + ...
                                     end) elpi_ctx_entry_3_)%Q
                             end)%Q
                        end *
                        (match n with
                         | Posz elpi_ctx_entry_3_ =>
                             iterop elpi_ctx_entry_3_ addq 1 0
                         | Negz elpi_ctx_entry_3_ =>
                             (-
                              match elpi_ctx_entry_3_ with
                              | 0 => 1%Q
                              | _.+1 =>
                                  (1%Q +
                                   (fix loop ... : rat := ...
                                                 ...
                                                 ...
                                                 ...
                                                 end) elpi_ctx_entry_3_)%Q
                              end)%Q
                         end *
                         (match n with
                          | Posz elpi_ctx_entry_3_ =>
                              iterop elpi_ctx_entry_3_ addq 1 0
                          | Negz elpi_ctx_entry_3_ =>
                              (-
                               match elpi_ctx_entry_3_ with
                               | 0 => 1%Q
                               | _.+1 => (1%Q + (...) elpi_ctx_entry_3_)%Q
                               end)%Q
                          end *
                          match n with
                          | Posz elpi_ctx_entry_3_ =>
                              iterop elpi_ctx_entry_3_ addq 1 0
                          | Negz elpi_ctx_entry_3_ =>
                              (-
                               match elpi_ctx_entry_3_ with
                               | 0 => 1%Q
                               | _.+1 => (1%Q + (...) elpi_ctx_entry_3_)%Q
                               end)%Q
                          end)%Q)%Q)%Q)%Q)%Q)%Q)%Q +
                   (rat_of_Z
                      (BinNums.Zpos
                         (BinNums.xO
                            (BinNums.xI
                               (BinNums.xO
                                  (BinNums.xI
                                     (BinNums.xO
                                        (BinNums.xO
                                           (BinNums.xI
                                              (BinNums.xO (BinNums.xO (...))))))))))) *
                    (match n with
                     | Posz elpi_ctx_entry_3_ =>
                         iterop elpi_ctx_entry_3_ addq 1 0
                     | Negz elpi_ctx_entry_3_ =>
                         (-
                          match elpi_ctx_entry_3_ with
                          | 0 => 1%Q
                          | _.+1 =>
                              (1%Q +
                               (fix loop (m : nat) : rat :=
                                  match m with
                                  | 0 => 0
                                  | 1 => 1
                                  | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                      1%Q + loop elpi_ctx_entry_7_
                                  end) elpi_ctx_entry_3_)%Q
                          end)%Q
                     end *
                     (match n with
                      | Posz elpi_ctx_entry_3_ =>
                          iterop elpi_ctx_entry_3_ addq 1 0
                      | Negz elpi_ctx_entry_3_ =>
                          (-
                           match elpi_ctx_entry_3_ with
                           | 0 => 1%Q
                           | _.+1 =>
                               (1%Q +
                                (fix loop (m : nat) : rat :=
                                   match m with
                                   | 0 => 0
                                   | 1 => 1
                                   | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                       1%Q + loop elpi_ctx_entry_7_
                                   end) elpi_ctx_entry_3_)%Q
                           end)%Q
                      end *
                      (match n with
                       | Posz elpi_ctx_entry_3_ =>
                           iterop elpi_ctx_entry_3_ addq 1 0
                       | Negz elpi_ctx_entry_3_ =>
                           (-
                            match elpi_ctx_entry_3_ with
                            | 0 => 1%Q
                            | _.+1 =>
                                (1%Q +
                                 (fix loop (m : nat) : rat :=
                                    match m with
                                    | 0 => 0
                                    | 1 => 1
                                    | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                        1%Q + loop elpi_ctx_entry_7_
                                    end) elpi_ctx_entry_3_)%Q
                            end)%Q
                       end *
                       (match n with
                        | Posz elpi_ctx_entry_3_ =>
                            iterop elpi_ctx_entry_3_ addq 1 0
                        | Negz elpi_ctx_entry_3_ =>
                            (-
                             match elpi_ctx_entry_3_ with
                             | 0 => 1%Q
                             | _.+1 =>
                                 (1%Q +
                                  (fix loop (m : nat) : rat :=
                                     match ... with
                                     | ... => 0
                                     | ... => 1
                                     | ... => 1%Q + ...
                                     end) elpi_ctx_entry_3_)%Q
                             end)%Q
                        end *
                        match n with
                        | Posz elpi_ctx_entry_3_ =>
                            iterop elpi_ctx_entry_3_ addq 1 0
                        | Negz elpi_ctx_entry_3_ =>
                            (-
                             match elpi_ctx_entry_3_ with
                             | 0 => 1%Q
                             | _.+1 =>
                                 (1%Q +
                                  (fix loop (m : nat) : rat :=
                                     match ... with
                                     | ... => 0
                                     | ... => 1
                                     | ... => 1%Q + ...
                                     end) elpi_ctx_entry_3_)%Q
                             end)%Q
                        end)%Q)%Q)%Q)%Q)%Q)%Q +
                  (rat_of_Z
                     (BinNums.Zpos
                        (BinNums.xI
                           (BinNums.xI
                              (BinNums.xI
                                 (BinNums.xO
                                    (BinNums.xO
                                       (BinNums.xI
                                          (BinNums.xI
                                             (BinNums.xI
                                                (BinNums.xI
                                                 (BinNums.xI (...)))))))))))) *
                   (match n with
                    | Posz elpi_ctx_entry_3_ =>
                        iterop elpi_ctx_entry_3_ addq 1 0
                    | Negz elpi_ctx_entry_3_ =>
                        (-
                         match elpi_ctx_entry_3_ with
                         | 0 => 1%Q
                         | _.+1 =>
                             (1%Q +
                              (fix loop (m : nat) : rat :=
                                 match m with
                                 | 0 => 0
                                 | 1 => 1
                                 | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                     1%Q + loop elpi_ctx_entry_7_
                                 end) elpi_ctx_entry_3_)%Q
                         end)%Q
                    end *
                    (match n with
                     | Posz elpi_ctx_entry_3_ =>
                         iterop elpi_ctx_entry_3_ addq 1 0
                     | Negz elpi_ctx_entry_3_ =>
                         (-
                          match elpi_ctx_entry_3_ with
                          | 0 => 1%Q
                          | _.+1 =>
                              (1%Q +
                               (fix loop (m : nat) : rat :=
                                  match m with
                                  | 0 => 0
                                  | 1 => 1
                                  | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                      1%Q + loop elpi_ctx_entry_7_
                                  end) elpi_ctx_entry_3_)%Q
                          end)%Q
                     end *
                     (match n with
                      | Posz elpi_ctx_entry_3_ =>
                          iterop elpi_ctx_entry_3_ addq 1 0
                      | Negz elpi_ctx_entry_3_ =>
                          (-
                           match elpi_ctx_entry_3_ with
                           | 0 => 1%Q
                           | _.+1 =>
                               (1%Q +
                                (fix loop (m : nat) : rat :=
                                   match m with
                                   | 0 => 0
                                   | 1 => 1
                                   | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                       1%Q + loop elpi_ctx_entry_7_
                                   end) elpi_ctx_entry_3_)%Q
                           end)%Q
                      end *
                      match n with
                      | Posz elpi_ctx_entry_3_ =>
                          iterop elpi_ctx_entry_3_ addq 1 0
                      | Negz elpi_ctx_entry_3_ =>
                          (-
                           match elpi_ctx_entry_3_ with
                           | 0 => 1%Q
                           | _.+1 =>
                               (1%Q +
                                (fix loop (m : nat) : rat :=
                                   match m with
                                   | 0 => 0
                                   | 1 => 1
                                   | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                       1%Q + loop elpi_ctx_entry_7_
                                   end) elpi_ctx_entry_3_)%Q
                           end)%Q
                      end)%Q)%Q)%Q)%Q)%Q +
                 (rat_of_Z
                    (BinNums.Zpos
                       (BinNums.xO
                          (BinNums.xI
                             (BinNums.xI
                                (BinNums.xO
                                   (BinNums.xO
                                      (BinNums.xI
                                         (BinNums.xO
                                            (BinNums.xI
                                               (BinNums.xI
                                                 (BinNums.xO
                                                 (BinNums.xI (...))))))))))))) *
                  (match n with
                   | Posz elpi_ctx_entry_3_ =>
                       iterop elpi_ctx_entry_3_ addq 1 0
                   | Negz elpi_ctx_entry_3_ =>
                       (-
                        match elpi_ctx_entry_3_ with
                        | 0 => 1%Q
                        | _.+1 =>
                            (1%Q +
                             (fix loop (m : nat) : rat :=
                                match m with
                                | 0 => 0
                                | 1 => 1
                                | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                    1%Q + loop elpi_ctx_entry_7_
                                end) elpi_ctx_entry_3_)%Q
                        end)%Q
                   end *
                   (match n with
                    | Posz elpi_ctx_entry_3_ =>
                        iterop elpi_ctx_entry_3_ addq 1 0
                    | Negz elpi_ctx_entry_3_ =>
                        (-
                         match elpi_ctx_entry_3_ with
                         | 0 => 1%Q
                         | _.+1 =>
                             (1%Q +
                              (fix loop (m : nat) : rat :=
                                 match m with
                                 | 0 => 0
                                 | 1 => 1
                                 | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                     1%Q + loop elpi_ctx_entry_7_
                                 end) elpi_ctx_entry_3_)%Q
                         end)%Q
                    end *
                    match n with
                    | Posz elpi_ctx_entry_3_ =>
                        iterop elpi_ctx_entry_3_ addq 1 0
                    | Negz elpi_ctx_entry_3_ =>
                        (-
                         match elpi_ctx_entry_3_ with
                         | 0 => 1%Q
                         | _.+1 =>
                             (1%Q +
                              (fix loop (m : nat) : rat :=
                                 match m with
                                 | 0 => 0
                                 | 1 => 1
                                 | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                     1%Q + loop elpi_ctx_entry_7_
                                 end) elpi_ctx_entry_3_)%Q
                         end)%Q
                    end)%Q)%Q)%Q)%Q +
                (rat_of_Z
                   (BinNums.Zpos
                      (BinNums.xI
                         (BinNums.xO
                            (BinNums.xI
                               (BinNums.xO
                                  (BinNums.xI
                                     (BinNums.xI
                                        (BinNums.xO
                                           (BinNums.xI
                                              (BinNums.xI
                                                 (BinNums.xI
                                                 (BinNums.xO
                                                 (BinNums.xO (...)))))))))))))) *
                 (match n with
                  | Posz elpi_ctx_entry_3_ =>
                      iterop elpi_ctx_entry_3_ addq 1 0
                  | Negz elpi_ctx_entry_3_ =>
                      (-
                       match elpi_ctx_entry_3_ with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                   1%Q + loop elpi_ctx_entry_7_
                               end) elpi_ctx_entry_3_)%Q
                       end)%Q
                  end *
                  match n with
                  | Posz elpi_ctx_entry_3_ =>
                      iterop elpi_ctx_entry_3_ addq 1 0
                  | Negz elpi_ctx_entry_3_ =>
                      (-
                       match elpi_ctx_entry_3_ with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                   1%Q + loop elpi_ctx_entry_7_
                               end) elpi_ctx_entry_3_)%Q
                       end)%Q
                  end)%Q)%Q)%Q +
               (rat_of_Z
                  (BinNums.Zpos
                     (BinNums.xO
                        (BinNums.xI
                           (BinNums.xI
                              (BinNums.xI
                                 (BinNums.xO
                                    (BinNums.xO
                                       (BinNums.xO
                                          (BinNums.xI
                                             (BinNums.xI
                                                (BinNums.xI
                                                 (BinNums.xI
                                                 (BinNums.xI
                                                 (BinNums.xO (...))))))))))))))) *
                match n with
                | Posz elpi_ctx_entry_3_ => iterop elpi_ctx_entry_3_ addq 1 0
                | Negz elpi_ctx_entry_3_ =>
                    (-
                     match elpi_ctx_entry_3_ with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                 1%Q + loop elpi_ctx_entry_7_
                             end) elpi_ctx_entry_3_)%Q
                     end)%Q
                end)%Q)%Q +
              rat_of_Z
                (BinNums.Zpos
                   (BinNums.xO
                      (BinNums.xO
                         (BinNums.xO
                            (BinNums.xO
                               (BinNums.xO
                                  (BinNums.xI
                                     (BinNums.xO
                                        (BinNums.xO
                                           (BinNums.xO
                                              (BinNums.xO
                                                 (BinNums.xO
                                                 (BinNums.xI
                                                 (BinNums.xI
                                                 (BinNums.xI
                                                 (BinNums.xI (...))))))))))))))))))%Q)%Q *
            b (intZmod.addz n 1))%Q)%Q +
          (((((rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)) *
               match n with
               | Posz elpi_ctx_entry_3_ => iterop elpi_ctx_entry_3_ addq 1 0
               | Negz elpi_ctx_entry_3_ =>
                   (-
                    match elpi_ctx_entry_3_ with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                1%Q + loop elpi_ctx_entry_7_
                            end) elpi_ctx_entry_3_)%Q
                    end)%Q
               end)%Q +
              rat_of_Z (BinNums.Zpos (BinNums.xI (BinNums.xI 1%AC))))%Q *
             ((((rat_of_Z
                   (BinNums.Zpos
                      (BinNums.xO
                         (BinNums.xO
                            (BinNums.xO
                               (BinNums.xO
                                  (BinNums.xO
                                     (BinNums.xI
                                        (BinNums.xO
                                           (BinNums.xI (BinNums.xI 1%AC)))))))))) +
                 (rat_of_Z
                    (BinNums.Zpos
                       (BinNums.xO
                          (BinNums.xI
                             (BinNums.xO
                                (BinNums.xO
                                   (BinNums.xI
                                      (BinNums.xI
                                         (BinNums.xI
                                            (BinNums.xI
                                               (BinNums.xO (BinNums.xO 1%AC))))))))))) *
                  match n with
                  | Posz elpi_ctx_entry_3_ =>
                      iterop elpi_ctx_entry_3_ addq 1 0
                  | Negz elpi_ctx_entry_3_ =>
                      (-
                       match elpi_ctx_entry_3_ with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                   1%Q + loop elpi_ctx_entry_7_
                               end) elpi_ctx_entry_3_)%Q
                       end)%Q
                  end)%Q)%Q +
                (rat_of_Z
                   (BinNums.Zpos
                      (BinNums.xI
                         (BinNums.xI
                            (BinNums.xO
                               (BinNums.xO
                                  (BinNums.xO
                                     (BinNums.xO
                                        (BinNums.xO
                                           (BinNums.xI (BinNums.xO 1%AC)))))))))) *
                 (match n with
                  | Posz elpi_ctx_entry_3_ =>
                      iterop elpi_ctx_entry_3_ addq 1 0
                  | Negz elpi_ctx_entry_3_ =>
                      (-
                       match elpi_ctx_entry_3_ with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                   1%Q + loop elpi_ctx_entry_7_
                               end) elpi_ctx_entry_3_)%Q
                       end)%Q
                  end *
                  match n with
                  | Posz elpi_ctx_entry_3_ =>
                      iterop elpi_ctx_entry_3_ addq 1 0
                  | Negz elpi_ctx_entry_3_ =>
                      (-
                       match elpi_ctx_entry_3_ with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                   1%Q + loop elpi_ctx_entry_7_
                               end) elpi_ctx_entry_3_)%Q
                       end)%Q
                  end)%Q)%Q)%Q +
               (rat_of_Z
                  (BinNums.Zpos
                     (BinNums.xO
                        (BinNums.xO
                           (BinNums.xO
                              (BinNums.xO
                                 (BinNums.xI (BinNums.xO (BinNums.xO 1%AC)))))))) *
                (match n with
                 | Posz elpi_ctx_entry_3_ =>
                     iterop elpi_ctx_entry_3_ addq 1 0
                 | Negz elpi_ctx_entry_3_ =>
                     (-
                      match elpi_ctx_entry_3_ with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                  1%Q + loop elpi_ctx_entry_7_
                              end) elpi_ctx_entry_3_)%Q
                      end)%Q
                 end *
                 (match n with
                  | Posz elpi_ctx_entry_3_ =>
                      iterop elpi_ctx_entry_3_ addq 1 0
                  | Negz elpi_ctx_entry_3_ =>
                      (-
                       match elpi_ctx_entry_3_ with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                   1%Q + loop elpi_ctx_entry_7_
                               end) elpi_ctx_entry_3_)%Q
                       end)%Q
                  end *
                  match n with
                  | Posz elpi_ctx_entry_3_ =>
                      iterop elpi_ctx_entry_3_ addq 1 0
                  | Negz elpi_ctx_entry_3_ =>
                      (-
                       match elpi_ctx_entry_3_ with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                   1%Q + loop elpi_ctx_entry_7_
                               end) elpi_ctx_entry_3_)%Q
                       end)%Q
                  end)%Q)%Q)%Q)%Q +
              (rat_of_Z
                 (BinNums.Zpos (BinNums.xO (BinNums.xO (BinNums.xI 1%AC)))) *
               (match n with
                | Posz elpi_ctx_entry_3_ => iterop elpi_ctx_entry_3_ addq 1 0
                | Negz elpi_ctx_entry_3_ =>
                    (-
                     match elpi_ctx_entry_3_ with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                 1%Q + loop elpi_ctx_entry_7_
                             end) elpi_ctx_entry_3_)%Q
                     end)%Q
                end *
                (match n with
                 | Posz elpi_ctx_entry_3_ =>
                     iterop elpi_ctx_entry_3_ addq 1 0
                 | Negz elpi_ctx_entry_3_ =>
                     (-
                      match elpi_ctx_entry_3_ with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                  1%Q + loop elpi_ctx_entry_7_
                              end) elpi_ctx_entry_3_)%Q
                      end)%Q
                 end *
                 (match n with
                  | Posz elpi_ctx_entry_3_ =>
                      iterop elpi_ctx_entry_3_ addq 1 0
                  | Negz elpi_ctx_entry_3_ =>
                      (-
                       match elpi_ctx_entry_3_ with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                   1%Q + loop elpi_ctx_entry_7_
                               end) elpi_ctx_entry_3_)%Q
                       end)%Q
                  end *
                  match n with
                  | Posz elpi_ctx_entry_3_ =>
                      iterop elpi_ctx_entry_3_ addq 1 0
                  | Negz elpi_ctx_entry_3_ =>
                      (-
                       match elpi_ctx_entry_3_ with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                   1%Q + loop elpi_ctx_entry_7_
                               end) elpi_ctx_entry_3_)%Q
                       end)%Q
                  end)%Q)%Q)%Q)%Q)%Q)%Q *
            ((match n with
              | Posz elpi_ctx_entry_3_ => iterop elpi_ctx_entry_3_ addq 1 0
              | Negz elpi_ctx_entry_3_ =>
                  (-
                   match elpi_ctx_entry_3_ with
                   | 0 => 1%Q
                   | _.+1 =>
                       (1%Q +
                        (fix loop (m : nat) : rat :=
                           match m with
                           | 0 => 0
                           | 1 => 1
                           | (_.+1 as elpi_ctx_entry_7_).+1 =>
                               1%Q + loop elpi_ctx_entry_7_
                           end) elpi_ctx_entry_3_)%Q
                   end)%Q
              end + rat_of_Z (BinNums.Zpos 1%AC))%Q *
             ((match n with
               | Posz elpi_ctx_entry_3_ => iterop elpi_ctx_entry_3_ addq 1 0
               | Negz elpi_ctx_entry_3_ =>
                   (-
                    match elpi_ctx_entry_3_ with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                1%Q + loop elpi_ctx_entry_7_
                            end) elpi_ctx_entry_3_)%Q
                    end)%Q
               end + rat_of_Z (BinNums.Zpos 1%AC))%Q *
              ((match n with
                | Posz elpi_ctx_entry_3_ => iterop elpi_ctx_entry_3_ addq 1 0
                | Negz elpi_ctx_entry_3_ =>
                    (-
                     match elpi_ctx_entry_3_ with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                 1%Q + loop elpi_ctx_entry_7_
                             end) elpi_ctx_entry_3_)%Q
                     end)%Q
                end + rat_of_Z (BinNums.Zpos 1%AC))%Q *
               ((match n with
                 | Posz elpi_ctx_entry_3_ =>
                     iterop elpi_ctx_entry_3_ addq 1 0
                 | Negz elpi_ctx_entry_3_ =>
                     (-
                      match elpi_ctx_entry_3_ with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                  1%Q + loop elpi_ctx_entry_7_
                              end) elpi_ctx_entry_3_)%Q
                      end)%Q
                 end + rat_of_Z (BinNums.Zpos 1%AC))%Q *
                ((match n with
                  | Posz elpi_ctx_entry_3_ =>
                      iterop elpi_ctx_entry_3_ addq 1 0
                  | Negz elpi_ctx_entry_3_ =>
                      (-
                       match elpi_ctx_entry_3_ with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                   1%Q + loop elpi_ctx_entry_7_
                               end) elpi_ctx_entry_3_)%Q
                       end)%Q
                  end + rat_of_Z (BinNums.Zpos 1%AC))%Q *
                 (match n with
                  | Posz elpi_ctx_entry_3_ =>
                      iterop elpi_ctx_entry_3_ addq 1 0
                  | Negz elpi_ctx_entry_3_ =>
                      (-
                       match elpi_ctx_entry_3_ with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                   1%Q + loop elpi_ctx_entry_7_
                               end) elpi_ctx_entry_3_)%Q
                       end)%Q
                  end + rat_of_Z (BinNums.Zpos 1%AC))%Q)%Q)%Q)%Q)%Q)%Q)%Q *
           b n)%Q)%Q; 0%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
i : (2 : int) <= (n : int)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: (((((((((rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)) *
                  match n with
                  | Posz elpi_ctx_entry_2_ =>
                      iterop elpi_ctx_entry_2_ addq 1 0
                  | Negz elpi_ctx_entry_2_ =>
                      (-
                       match elpi_ctx_entry_2_ with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                   1%Q + loop elpi_ctx_entry_6_
                               end) elpi_ctx_entry_2_)%Q
                       end)%Q
                  end)%Q + rat_of_Z (BinNums.Zpos (BinNums.xI 1%AC)))%Q *
                (((((rat_of_Z
                       (BinNums.Zpos
                          (BinNums.xO (BinNums.xO (BinNums.xI 1%AC)))) *
                     (match n with
                      | Posz elpi_ctx_entry_2_ =>
                          iterop elpi_ctx_entry_2_ addq 1 0
                      | Negz elpi_ctx_entry_2_ =>
                          (-
                           match elpi_ctx_entry_2_ with
                           | 0 => 1%Q
                           | _.+1 =>
                               (1%Q +
                                (fix loop (m : nat) : rat :=
                                   match m with
                                   | 0 => 0
                                   | 1 => 1
                                   | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                       1%Q + loop elpi_ctx_entry_6_
                                   end) elpi_ctx_entry_2_)%Q
                           end)%Q
                      end *
                      (match n with
                       | Posz elpi_ctx_entry_2_ =>
                           iterop elpi_ctx_entry_2_ addq 1 0
                       | Negz elpi_ctx_entry_2_ =>
                           (-
                            match elpi_ctx_entry_2_ with
                            | 0 => 1%Q
                            | _.+1 =>
                                (1%Q +
                                 (fix loop (m : nat) : rat :=
                                    match m with
                                    | 0 => 0
                                    | 1 => 1
                                    | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                        1%Q + loop elpi_ctx_entry_6_
                                    end) elpi_ctx_entry_2_)%Q
                            end)%Q
                       end *
                       (match n with
                        | Posz elpi_ctx_entry_2_ =>
                            iterop elpi_ctx_entry_2_ addq 1 0
                        | Negz elpi_ctx_entry_2_ =>
                            (-
                             match elpi_ctx_entry_2_ with
                             | 0 => 1%Q
                             | _.+1 =>
                                 (1%Q +
                                  (fix loop (m : nat) : rat :=
                                     match ... with
                                     | ... => 0
                                     | ... => 1
                                     | ... => 1%Q + ...
                                     end) elpi_ctx_entry_2_)%Q
                             end)%Q
                        end *
                        match n with
                        | Posz elpi_ctx_entry_2_ =>
                            iterop elpi_ctx_entry_2_ addq 1 0
                        | Negz elpi_ctx_entry_2_ =>
                            (-
                             match elpi_ctx_entry_2_ with
                             | 0 => 1%Q
                             | _.+1 =>
                                 (1%Q +
                                  (fix loop (m : nat) : rat :=
                                     match ... with
                                     | ... => 0
                                     | ... => 1
                                     | ... => 1%Q + ...
                                     end) elpi_ctx_entry_2_)%Q
                             end)%Q
                        end)%Q)%Q)%Q)%Q +
                    (rat_of_Z
                       (BinNums.Zpos
                          (BinNums.xO
                             (BinNums.xO
                                (BinNums.xO
                                   (BinNums.xO (BinNums.xO (BinNums.xI 1%AC))))))) *
                     (match n with
                      | Posz elpi_ctx_entry_2_ =>
                          iterop elpi_ctx_entry_2_ addq 1 0
                      | Negz elpi_ctx_entry_2_ =>
                          (-
                           match elpi_ctx_entry_2_ with
                           | 0 => 1%Q
                           | _.+1 =>
                               (1%Q +
                                (fix loop (m : nat) : rat :=
                                   match m with
                                   | 0 => 0
                                   | 1 => 1
                                   | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                       1%Q + loop elpi_ctx_entry_6_
                                   end) elpi_ctx_entry_2_)%Q
                           end)%Q
                      end *
                      (match n with
                       | Posz elpi_ctx_entry_2_ =>
                           iterop elpi_ctx_entry_2_ addq 1 0
                       | Negz elpi_ctx_entry_2_ =>
                           (-
                            match elpi_ctx_entry_2_ with
                            | 0 => 1%Q
                            | _.+1 =>
                                (1%Q +
                                 (fix loop (m : nat) : rat :=
                                    match m with
                                    | 0 => 0
                                    | 1 => 1
                                    | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                        1%Q + loop elpi_ctx_entry_6_
                                    end) elpi_ctx_entry_2_)%Q
                            end)%Q
                       end *
                       match n with
                       | Posz elpi_ctx_entry_2_ =>
                           iterop elpi_ctx_entry_2_ addq 1 0
                       | Negz elpi_ctx_entry_2_ =>
                           (-
                            match elpi_ctx_entry_2_ with
                            | 0 => 1%Q
                            | _.+1 =>
                                (1%Q +
                                 (fix loop (m : nat) : rat :=
                                    match m with
                                    | 0 => 0
                                    | 1 => 1
                                    | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                        1%Q + loop elpi_ctx_entry_6_
                                    end) elpi_ctx_entry_2_)%Q
                            end)%Q
                       end)%Q)%Q)%Q)%Q +
                   (rat_of_Z
                      (BinNums.Zpos
                         (BinNums.xI
                            (BinNums.xI
                               (BinNums.xO
                                  (BinNums.xI
                                     (BinNums.xI
                                        (BinNums.xO
                                           (BinNums.xO (BinNums.xO 1%AC))))))))) *
                    (match n with
                     | Posz elpi_ctx_entry_2_ =>
                         iterop elpi_ctx_entry_2_ addq 1 0
                     | Negz elpi_ctx_entry_2_ =>
                         (-
                          match elpi_ctx_entry_2_ with
                          | 0 => 1%Q
                          | _.+1 =>
                              (1%Q +
                               (fix loop (m : nat) : rat :=
                                  match m with
                                  | 0 => 0
                                  | 1 => 1
                                  | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                      1%Q + loop elpi_ctx_entry_6_
                                  end) elpi_ctx_entry_2_)%Q
                          end)%Q
                     end *
                     match n with
                     | Posz elpi_ctx_entry_2_ =>
                         iterop elpi_ctx_entry_2_ addq 1 0
                     | Negz elpi_ctx_entry_2_ =>
                         (-
                          match elpi_ctx_entry_2_ with
                          | 0 => 1%Q
                          | _.+1 =>
                              (1%Q +
                               (fix loop (m : nat) : rat :=
                                  match m with
                                  | 0 => 0
                                  | 1 => 1
                                  | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                      1%Q + loop elpi_ctx_entry_6_
                                  end) elpi_ctx_entry_2_)%Q
                          end)%Q
                     end)%Q)%Q)%Q +
                  (rat_of_Z
                     (BinNums.Zpos
                        (BinNums.xO
                           (BinNums.xO
                              (BinNums.xI
                                 (BinNums.xI
                                    (BinNums.xO
                                       (BinNums.xI
                                          (BinNums.xI (BinNums.xO 1%AC))))))))) *
                   match n with
                   | Posz elpi_ctx_entry_2_ =>
                       iterop elpi_ctx_entry_2_ addq 1 0
                   | Negz elpi_ctx_entry_2_ =>
                       (-
                        match elpi_ctx_entry_2_ with
                        | 0 => 1%Q
                        | _.+1 =>
                            (1%Q +
                             (fix loop (m : nat) : rat :=
                                match m with
                                | 0 => 0
                                | 1 => 1
                                | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                    1%Q + loop elpi_ctx_entry_6_
                                end) elpi_ctx_entry_2_)%Q
                        end)%Q
                   end)%Q)%Q +
                 rat_of_Z
                   (BinNums.Zpos
                      (BinNums.xI
                         (BinNums.xO
                            (BinNums.xI
                               (BinNums.xI
                                  (BinNums.xO (BinNums.xI (BinNums.xO 1%AC)))))))))%Q)%Q *
               ((match n with
                 | Posz elpi_ctx_entry_2_ =>
                     iterop elpi_ctx_entry_2_ addq 1 0
                 | Negz elpi_ctx_entry_2_ =>
                     (-
                      match elpi_ctx_entry_2_ with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                  1%Q + loop elpi_ctx_entry_6_
                              end) elpi_ctx_entry_2_)%Q
                      end)%Q
                 end + rat_of_Z (BinNums.Zpos (BinNums.xO (BinNums.xO 1%AC))))%Q *
                ((match n with
                  | Posz elpi_ctx_entry_2_ =>
                      iterop elpi_ctx_entry_2_ addq 1 0
                  | Negz elpi_ctx_entry_2_ =>
                      (-
                       match elpi_ctx_entry_2_ with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                   1%Q + loop elpi_ctx_entry_6_
                               end) elpi_ctx_entry_2_)%Q
                       end)%Q
                  end +
                  rat_of_Z (BinNums.Zpos (BinNums.xO (BinNums.xO 1%AC))))%Q *
                 ((match n with
                   | Posz elpi_ctx_entry_2_ =>
                       iterop elpi_ctx_entry_2_ addq 1 0
                   | Negz elpi_ctx_entry_2_ =>
                       (-
                        match elpi_ctx_entry_2_ with
                        | 0 => 1%Q
                        | _.+1 =>
                            (1%Q +
                             (fix loop (m : nat) : rat :=
                                match m with
                                | 0 => 0
                                | 1 => 1
                                | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                    1%Q + loop elpi_ctx_entry_6_
                                end) elpi_ctx_entry_2_)%Q
                        end)%Q
                   end +
                   rat_of_Z (BinNums.Zpos (BinNums.xO (BinNums.xO 1%AC))))%Q *
                  ((match n with
                    | Posz elpi_ctx_entry_2_ =>
                        iterop elpi_ctx_entry_2_ addq 1 0
                    | Negz elpi_ctx_entry_2_ =>
                        (-
                         match elpi_ctx_entry_2_ with
                         | 0 => 1%Q
                         | _.+1 =>
                             (1%Q +
                              (fix loop (m : nat) : rat :=
                                 match m with
                                 | 0 => 0
                                 | 1 => 1
                                 | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                     1%Q + loop elpi_ctx_entry_6_
                                 end) elpi_ctx_entry_2_)%Q
                         end)%Q
                    end +
                    rat_of_Z (BinNums.Zpos (BinNums.xO (BinNums.xO 1%AC))))%Q *
                   ((match n with
                     | Posz elpi_ctx_entry_2_ =>
                         iterop elpi_ctx_entry_2_ addq 1 0
                     | Negz elpi_ctx_entry_2_ =>
                         (-
                          match elpi_ctx_entry_2_ with
                          | 0 => 1%Q
                          | _.+1 =>
                              (1%Q +
                               (fix loop (m : nat) : rat :=
                                  match m with
                                  | 0 => 0
                                  | 1 => 1
                                  | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                      1%Q + loop elpi_ctx_entry_6_
                                  end) elpi_ctx_entry_2_)%Q
                          end)%Q
                     end +
                     rat_of_Z (BinNums.Zpos (BinNums.xO (BinNums.xO 1%AC))))%Q *
                    (match n with
                     | Posz elpi_ctx_entry_2_ =>
                         iterop elpi_ctx_entry_2_ addq 1 0
                     | Negz elpi_ctx_entry_2_ =>
                         (-
                          match elpi_ctx_entry_2_ with
                          | 0 => 1%Q
                          | _.+1 =>
                              (1%Q +
                               (fix loop (m : nat) : rat :=
                                  match m with
                                  | 0 => 0
                                  | 1 => 1
                                  | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                      1%Q + loop elpi_ctx_entry_6_
                                  end) elpi_ctx_entry_2_)%Q
                          end)%Q
                     end +
                     rat_of_Z (BinNums.Zpos (BinNums.xO (BinNums.xO 1%AC))))%Q)%Q)%Q)%Q)%Q)%Q)%Q *
              b
                (intZmod.addz
                   (intZmod.addz (intZmod.addz (intZmod.addz n 1) 1) 1) 1))%Q +
             (((((- rat_of_Z (BinNums.Zpos 1%AC))%Q *
                 ((rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)) *
                   match n with
                   | Posz elpi_ctx_entry_2_ =>
                       iterop elpi_ctx_entry_2_ addq 1 0
                   | Negz elpi_ctx_entry_2_ =>
                       (-
                        match elpi_ctx_entry_2_ with
                        | 0 => 1%Q
                        | _.+1 =>
                            (1%Q +
                             (fix loop (m : nat) : rat :=
                                match m with
                                | 0 => 0
                                | 1 => 1
                                | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                    1%Q + loop elpi_ctx_entry_6_
                                end) elpi_ctx_entry_2_)%Q
                        end)%Q
                   end)%Q + rat_of_Z (BinNums.Zpos (BinNums.xI 1%AC)))%Q)%Q *
                ((rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)) *
                  match n with
                  | Posz elpi_ctx_entry_2_ =>
                      iterop elpi_ctx_entry_2_ addq 1 0
                  | Negz elpi_ctx_entry_2_ =>
                      (-
                       match elpi_ctx_entry_2_ with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                   1%Q + loop elpi_ctx_entry_6_
                               end) elpi_ctx_entry_2_)%Q
                       end)%Q
                  end)%Q +
                 rat_of_Z (BinNums.Zpos (BinNums.xI (BinNums.xI 1%AC))))%Q)%Q *
               ((((((((((rat_of_Z
                           (BinNums.Zpos
                              (BinNums.xO
                                 (BinNums.xO (BinNums.xO (BinNums.xI (...)))))) *
                         (match n with
                          | Posz elpi_ctx_entry_2_ =>
                              iterop elpi_ctx_entry_2_ addq 1 0
                          | Negz elpi_ctx_entry_2_ =>
                              (-
                               match elpi_ctx_entry_2_ with
                               | 0 => 1%Q
                               | _.+1 => (1%Q + (...) elpi_ctx_entry_2_)%Q
                               end)%Q
                          end *
                          (match n with
                           | Posz elpi_ctx_entry_2_ =>
                               iterop elpi_ctx_entry_2_ addq 1 0
                           | Negz elpi_ctx_entry_2_ =>
                               (-
                                match elpi_ctx_entry_2_ with
                                | 0 => 1%Q
                                | _.+1 => (1%Q + ...)%Q
                                end)%Q
                           end *
                           (match n with
                            | Posz elpi_ctx_entry_2_ =>
                                iterop elpi_ctx_entry_2_ addq 1 0
                            | Negz elpi_ctx_entry_2_ =>
                                (- match ... with
                                   | ... 1%Q
                                   | ... ...%Q
                                   end)%Q
                            end *
                            (match n with
                             | Posz elpi_ctx_entry_2_ =>
                                 iterop elpi_ctx_entry_2_ addq 1 0
                             | Negz elpi_ctx_entry_2_ => (- ...)%Q
                             end *
                             (match ... with
                              | ... ...
                              | ... ...%Q
                              end * (... * ...%Q)%Q)%Q)%Q)%Q)%Q)%Q)%Q +
                        (rat_of_Z
                           (BinNums.Zpos
                              (BinNums.xO
                                 (BinNums.xO (BinNums.xI (BinNums.xO (...)))))) *
                         (match n with
                          | Posz elpi_ctx_entry_2_ =>
                              iterop elpi_ctx_entry_2_ addq 1 0
                          | Negz elpi_ctx_entry_2_ =>
                              (-
                               match elpi_ctx_entry_2_ with
                               | 0 => 1%Q
                               | _.+1 => (1%Q + (...) elpi_ctx_entry_2_)%Q
                               end)%Q
                          end *
                          (match n with
                           | Posz elpi_ctx_entry_2_ =>
                               iterop elpi_ctx_entry_2_ addq 1 0
                           | Negz elpi_ctx_entry_2_ =>
                               (-
                                match elpi_ctx_entry_2_ with
                                | 0 => 1%Q
                                | _.+1 => (1%Q + ...)%Q
                                end)%Q
                           end *
                           (match n with
                            | Posz elpi_ctx_entry_2_ =>
                                iterop elpi_ctx_entry_2_ addq 1 0
                            | Negz elpi_ctx_entry_2_ =>
                                (- match ... with
                                   | ... 1%Q
                                   | ... ...%Q
                                   end)%Q
                            end *
                            (match n with
                             | Posz elpi_ctx_entry_2_ =>
                                 iterop elpi_ctx_entry_2_ addq 1 0
                             | Negz elpi_ctx_entry_2_ => (- ...)%Q
                             end *
                             (match ... with
                              | ... ...
                              | ... ...%Q
                              end * (... * ...%Q)%Q)%Q)%Q)%Q)%Q)%Q)%Q)%Q +
                       (rat_of_Z
                          (BinNums.Zpos
                             (BinNums.xO
                                (BinNums.xI
                                   (BinNums.xI
                                      (BinNums.xO (BinNums.xI (...))))))) *
                        (match n with
                         | Posz elpi_ctx_entry_2_ =>
                             iterop elpi_ctx_entry_2_ addq 1 0
                         | Negz elpi_ctx_entry_2_ =>
                             (-
                              match elpi_ctx_entry_2_ with
                              | 0 => 1%Q
                              | _.+1 =>
                                  (1%Q +
                                   (fix loop ... : rat := ...
                                                 ...
                                                 ...
                                                 ...
                                                 end) elpi_ctx_entry_2_)%Q
                              end)%Q
                         end *
                         (match n with
                          | Posz elpi_ctx_entry_2_ =>
                              iterop elpi_ctx_entry_2_ addq 1 0
                          | Negz elpi_ctx_entry_2_ =>
                              (-
                               match elpi_ctx_entry_2_ with
                               | 0 => 1%Q
                               | _.+1 => (1%Q + (...) elpi_ctx_entry_2_)%Q
                               end)%Q
                          end *
                          (match n with
                           | Posz elpi_ctx_entry_2_ =>
                               iterop elpi_ctx_entry_2_ addq 1 0
                           | Negz elpi_ctx_entry_2_ =>
                               (-
                                match elpi_ctx_entry_2_ with
                                | 0 => 1%Q
                                | _.+1 => (1%Q + ...)%Q
                                end)%Q
                           end *
                           (match n with
                            | Posz elpi_ctx_entry_2_ =>
                                iterop elpi_ctx_entry_2_ addq 1 0
                            | Negz elpi_ctx_entry_2_ =>
                                (- match ... with
                                   | ... 1%Q
                                   | ... ...%Q
                                   end)%Q
                            end *
                            (match n with
                             | Posz elpi_ctx_entry_2_ =>
                                 iterop elpi_ctx_entry_2_ addq 1 0
                             | Negz elpi_ctx_entry_2_ => (- ...)%Q
                             end *
                             (match ... with
                              | ... ...
                              | ... ...%Q
                              end * match ... with
                                    | ... ...
                                    | ... ...%Q
                                    end)%Q)%Q)%Q)%Q)%Q)%Q)%Q)%Q +
                      (rat_of_Z
                         (BinNums.Zpos
                            (BinNums.xO
                               (BinNums.xI
                                  (BinNums.xI
                                     (BinNums.xO
                                        (BinNums.xI (BinNums.xI (...)))))))) *
                       (match n with
                        | Posz elpi_ctx_entry_2_ =>
                            iterop elpi_ctx_entry_2_ addq 1 0
                        | Negz elpi_ctx_entry_2_ =>
                            (-
                             match elpi_ctx_entry_2_ with
                             | 0 => 1%Q
                             | _.+1 =>
                                 (1%Q +
                                  (fix loop (m : nat) : rat :=
                                     match ... with
                                     | ... => 0
                                     | ... => 1
                                     | ... => 1%Q + ...
                                     end) elpi_ctx_entry_2_)%Q
                             end)%Q
                        end *
                        (match n with
                         | Posz elpi_ctx_entry_2_ =>
                             iterop elpi_ctx_entry_2_ addq 1 0
                         | Negz elpi_ctx_entry_2_ =>
                             (-
                              match elpi_ctx_entry_2_ with
                              | 0 => 1%Q
                              | _.+1 =>
                                  (1%Q +
                                   (fix loop ... : rat := ...
                                                 ...
                                                 ...
                                                 ...
                                                 end) elpi_ctx_entry_2_)%Q
                              end)%Q
                         end *
                         (match n with
                          | Posz elpi_ctx_entry_2_ =>
                              iterop elpi_ctx_entry_2_ addq 1 0
                          | Negz elpi_ctx_entry_2_ =>
                              (-
                               match elpi_ctx_entry_2_ with
                               | 0 => 1%Q
                               | _.+1 => (1%Q + (...) elpi_ctx_entry_2_)%Q
                               end)%Q
                          end *
                          (match n with
                           | Posz elpi_ctx_entry_2_ =>
                               iterop elpi_ctx_entry_2_ addq 1 0
                           | Negz elpi_ctx_entry_2_ =>
                               (-
                                match elpi_ctx_entry_2_ with
                                | 0 => 1%Q
                                | _.+1 => (1%Q + ...)%Q
                                end)%Q
                           end *
                           (match n with
                            | Posz elpi_ctx_entry_2_ =>
                                iterop elpi_ctx_entry_2_ addq 1 0
                            | Negz elpi_ctx_entry_2_ =>
                                (- match ... with
                                   | ... 1%Q
                                   | ... ...%Q
                                   end)%Q
                            end *
                            match n with
                            | Posz elpi_ctx_entry_2_ =>
                                iterop elpi_ctx_entry_2_ addq 1 0
                            | Negz elpi_ctx_entry_2_ =>
                                (- match ... with
                                   | ... 1%Q
                                   | ... ...%Q
                                   end)%Q
                            end)%Q)%Q)%Q)%Q)%Q)%Q)%Q +
                     (rat_of_Z
                        (BinNums.Zpos
                           (BinNums.xO
                              (BinNums.xO
                                 (BinNums.xO
                                    (BinNums.xO
                                       (BinNums.xI
                                          (BinNums.xI (BinNums.xI (...))))))))) *
                      (match n with
                       | Posz elpi_ctx_entry_2_ =>
                           iterop elpi_ctx_entry_2_ addq 1 0
                       | Negz elpi_ctx_entry_2_ =>
                           (-
                            match elpi_ctx_entry_2_ with
                            | 0 => 1%Q
                            | _.+1 =>
                                (1%Q +
                                 (fix loop (m : nat) : rat :=
                                    match m with
                                    | 0 => 0
                                    | 1 => 1
                                    | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                        1%Q + loop elpi_ctx_entry_6_
                                    end) elpi_ctx_entry_2_)%Q
                            end)%Q
                       end *
                       (match n with
                        | Posz elpi_ctx_entry_2_ =>
                            iterop elpi_ctx_entry_2_ addq 1 0
                        | Negz elpi_ctx_entry_2_ =>
                            (-
                             match elpi_ctx_entry_2_ with
                             | 0 => 1%Q
                             | _.+1 =>
                                 (1%Q +
                                  (fix loop (m : nat) : rat :=
                                     match ... with
                                     | ... => 0
                                     | ... => 1
                                     | ... => 1%Q + ...
                                     end) elpi_ctx_entry_2_)%Q
                             end)%Q
                        end *
                        (match n with
                         | Posz elpi_ctx_entry_2_ =>
                             iterop elpi_ctx_entry_2_ addq 1 0
                         | Negz elpi_ctx_entry_2_ =>
                             (-
                              match elpi_ctx_entry_2_ with
                              | 0 => 1%Q
                              | _.+1 =>
                                  (1%Q +
                                   (fix loop ... : rat := ...
                                                 ...
                                                 ...
                                                 ...
                                                 end) elpi_ctx_entry_2_)%Q
                              end)%Q
                         end *
                         (match n with
                          | Posz elpi_ctx_entry_2_ =>
                              iterop elpi_ctx_entry_2_ addq 1 0
                          | Negz elpi_ctx_entry_2_ =>
                              (-
                               match elpi_ctx_entry_2_ with
                               | 0 => 1%Q
                               | _.+1 => (1%Q + (...) elpi_ctx_entry_2_)%Q
                               end)%Q
                          end *
                          match n with
                          | Posz elpi_ctx_entry_2_ =>
                              iterop elpi_ctx_entry_2_ addq 1 0
                          | Negz elpi_ctx_entry_2_ =>
                              (-
                               match elpi_ctx_entry_2_ with
                               | 0 => 1%Q
                               | _.+1 => (1%Q + (...) elpi_ctx_entry_2_)%Q
                               end)%Q
                          end)%Q)%Q)%Q)%Q)%Q)%Q +
                    (rat_of_Z
                       (BinNums.Zpos
                          (BinNums.xI
                             (BinNums.xO
                                (BinNums.xO
                                   (BinNums.xO
                                      (BinNums.xO
                                         (BinNums.xO
                                            (BinNums.xO (BinNums.xO (...)))))))))) *
                     (match n with
                      | Posz elpi_ctx_entry_2_ =>
                          iterop elpi_ctx_entry_2_ addq 1 0
                      | Negz elpi_ctx_entry_2_ =>
                          (-
                           match elpi_ctx_entry_2_ with
                           | 0 => 1%Q
                           | _.+1 =>
                               (1%Q +
                                (fix loop (m : nat) : rat :=
                                   match m with
                                   | 0 => 0
                                   | 1 => 1
                                   | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                       1%Q + loop elpi_ctx_entry_6_
                                   end) elpi_ctx_entry_2_)%Q
                           end)%Q
                      end *
                      (match n with
                       | Posz elpi_ctx_entry_2_ =>
                           iterop elpi_ctx_entry_2_ addq 1 0
                       | Negz elpi_ctx_entry_2_ =>
                           (-
                            match elpi_ctx_entry_2_ with
                            | 0 => 1%Q
                            | _.+1 =>
                                (1%Q +
                                 (fix loop (m : nat) : rat :=
                                    match m with
                                    | 0 => 0
                                    | 1 => 1
                                    | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                        1%Q + loop elpi_ctx_entry_6_
                                    end) elpi_ctx_entry_2_)%Q
                            end)%Q
                       end *
                       (match n with
                        | Posz elpi_ctx_entry_2_ =>
                            iterop elpi_ctx_entry_2_ addq 1 0
                        | Negz elpi_ctx_entry_2_ =>
                            (-
                             match elpi_ctx_entry_2_ with
                             | 0 => 1%Q
                             | _.+1 =>
                                 (1%Q +
                                  (fix loop (m : nat) : rat :=
                                     match ... with
                                     | ... => 0
                                     | ... => 1
                                     | ... => 1%Q + ...
                                     end) elpi_ctx_entry_2_)%Q
                             end)%Q
                        end *
                        match n with
                        | Posz elpi_ctx_entry_2_ =>
                            iterop elpi_ctx_entry_2_ addq 1 0
                        | Negz elpi_ctx_entry_2_ =>
                            (-
                             match elpi_ctx_entry_2_ with
                             | 0 => 1%Q
                             | _.+1 =>
                                 (1%Q +
                                  (fix loop (m : nat) : rat :=
                                     match ... with
                                     | ... => 0
                                     | ... => 1
                                     | ... => 1%Q + ...
                                     end) elpi_ctx_entry_2_)%Q
                             end)%Q
                        end)%Q)%Q)%Q)%Q)%Q +
                   (rat_of_Z
                      (BinNums.Zpos
                         (BinNums.xO
                            (BinNums.xO
                               (BinNums.xO
                                  (BinNums.xO
                                     (BinNums.xI
                                        (BinNums.xI
                                           (BinNums.xI
                                              (BinNums.xI (BinNums.xO (...))))))))))) *
                    (match n with
                     | Posz elpi_ctx_entry_2_ =>
                         iterop elpi_ctx_entry_2_ addq 1 0
                     | Negz elpi_ctx_entry_2_ =>
                         (-
                          match elpi_ctx_entry_2_ with
                          | 0 => 1%Q
                          | _.+1 =>
                              (1%Q +
                               (fix loop (m : nat) : rat :=
                                  match m with
                                  | 0 => 0
                                  | 1 => 1
                                  | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                      1%Q + loop elpi_ctx_entry_6_
                                  end) elpi_ctx_entry_2_)%Q
                          end)%Q
                     end *
                     (match n with
                      | Posz elpi_ctx_entry_2_ =>
                          iterop elpi_ctx_entry_2_ addq 1 0
                      | Negz elpi_ctx_entry_2_ =>
                          (-
                           match elpi_ctx_entry_2_ with
                           | 0 => 1%Q
                           | _.+1 =>
                               (1%Q +
                                (fix loop (m : nat) : rat :=
                                   match m with
                                   | 0 => 0
                                   | 1 => 1
                                   | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                       1%Q + loop elpi_ctx_entry_6_
                                   end) elpi_ctx_entry_2_)%Q
                           end)%Q
                      end *
                      match n with
                      | Posz elpi_ctx_entry_2_ =>
                          iterop elpi_ctx_entry_2_ addq 1 0
                      | Negz elpi_ctx_entry_2_ =>
                          (-
                           match elpi_ctx_entry_2_ with
                           | 0 => 1%Q
                           | _.+1 =>
                               (1%Q +
                                (fix loop (m : nat) : rat :=
                                   match m with
                                   | 0 => 0
                                   | 1 => 1
                                   | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                       1%Q + loop elpi_ctx_entry_6_
                                   end) elpi_ctx_entry_2_)%Q
                           end)%Q
                      end)%Q)%Q)%Q)%Q +
                  (rat_of_Z
                     (BinNums.Zpos
                        (BinNums.xI
                           (BinNums.xO
                              (BinNums.xO
                                 (BinNums.xO
                                    (BinNums.xI
                                       (BinNums.xO
                                          (BinNums.xI
                                             (BinNums.xI
                                                (BinNums.xI
                                                 (BinNums.xO (...)))))))))))) *
                   (match n with
                    | Posz elpi_ctx_entry_2_ =>
                        iterop elpi_ctx_entry_2_ addq 1 0
                    | Negz elpi_ctx_entry_2_ =>
                        (-
                         match elpi_ctx_entry_2_ with
                         | 0 => 1%Q
                         | _.+1 =>
                             (1%Q +
                              (fix loop (m : nat) : rat :=
                                 match m with
                                 | 0 => 0
                                 | 1 => 1
                                 | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                     1%Q + loop elpi_ctx_entry_6_
                                 end) elpi_ctx_entry_2_)%Q
                         end)%Q
                    end *
                    match n with
                    | Posz elpi_ctx_entry_2_ =>
                        iterop elpi_ctx_entry_2_ addq 1 0
                    | Negz elpi_ctx_entry_2_ =>
                        (-
                         match elpi_ctx_entry_2_ with
                         | 0 => 1%Q
                         | _.+1 =>
                             (1%Q +
                              (fix loop (m : nat) : rat :=
                                 match m with
                                 | 0 => 0
                                 | 1 => 1
                                 | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                     1%Q + loop elpi_ctx_entry_6_
                                 end) elpi_ctx_entry_2_)%Q
                         end)%Q
                    end)%Q)%Q)%Q +
                 (rat_of_Z
                    (BinNums.Zpos
                       (BinNums.xO
                          (BinNums.xI
                             (BinNums.xI
                                (BinNums.xI
                                   (BinNums.xI
                                      (BinNums.xI
                                         (BinNums.xO
                                            (BinNums.xO
                                               (BinNums.xI
                                                 (BinNums.xI
                                                 (BinNums.xI (...))))))))))))) *
                  match n with
                  | Posz elpi_ctx_entry_2_ =>
                      iterop elpi_ctx_entry_2_ addq 1 0
                  | Negz elpi_ctx_entry_2_ =>
                      (-
                       match elpi_ctx_entry_2_ with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                   1%Q + loop elpi_ctx_entry_6_
                               end) elpi_ctx_entry_2_)%Q
                       end)%Q
                  end)%Q)%Q +
                rat_of_Z
                  (BinNums.Zpos
                     (BinNums.xO
                        (BinNums.xO
                           (BinNums.xO
                              (BinNums.xI
                                 (BinNums.xO
                                    (BinNums.xO
                                       (BinNums.xO
                                          (BinNums.xI
                                             (BinNums.xI
                                                (BinNums.xI
                                                 (BinNums.xI
                                                 (BinNums.xO
                                                 (BinNums.xI (...))))))))))))))))%Q)%Q *
              b (intZmod.addz (intZmod.addz (intZmod.addz n 1) 1) 1))%Q)%Q +
            ((((rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)) *
                match n with
                | Posz elpi_ctx_entry_2_ => iterop elpi_ctx_entry_2_ addq 1 0
                | Negz elpi_ctx_entry_2_ =>
                    (-
                     match elpi_ctx_entry_2_ with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                 1%Q + loop elpi_ctx_entry_6_
                             end) elpi_ctx_entry_2_)%Q
                     end)%Q
                end)%Q +
               rat_of_Z (BinNums.Zpos (BinNums.xI (BinNums.xO 1%AC))))%Q *
              (((((((((((rat_of_Z
                           (BinNums.Zpos
                              (BinNums.xO
                                 (BinNums.xO (BinNums.xO (BinNums.xI (...)))))) *
                         (match n with
                          | Posz elpi_ctx_entry_2_ =>
                              iterop elpi_ctx_entry_2_ addq 1 0
                          | Negz elpi_ctx_entry_2_ =>
                              (-
                               match elpi_ctx_entry_2_ with
                               | 0 => 1%Q
                               | _.+1 => (1%Q + (...) elpi_ctx_entry_2_)%Q
                               end)%Q
                          end *
                          (match n with
                           | Posz elpi_ctx_entry_2_ =>
                               iterop elpi_ctx_entry_2_ addq 1 0
                           | Negz elpi_ctx_entry_2_ =>
                               (-
                                match elpi_ctx_entry_2_ with
                                | 0 => 1%Q
                                | _.+1 => (1%Q + ...)%Q
                                end)%Q
                           end *
                           (match n with
                            | Posz elpi_ctx_entry_2_ =>
                                iterop elpi_ctx_entry_2_ addq 1 0
                            | Negz elpi_ctx_entry_2_ =>
                                (- match ... with
                                   | ... 1%Q
                                   | ... ...%Q
                                   end)%Q
                            end *
                            (match n with
                             | Posz elpi_ctx_entry_2_ =>
                                 iterop elpi_ctx_entry_2_ addq 1 0
                             | Negz elpi_ctx_entry_2_ => (- ...)%Q
                             end *
                             (match ... with
                              | ... ...
                              | ... ...%Q
                              end * (... * ...%Q)%Q)%Q)%Q)%Q)%Q)%Q)%Q +
                        (rat_of_Z
                           (BinNums.Zpos
                              (BinNums.xO
                                 (BinNums.xO (BinNums.xO (BinNums.xI (...)))))) *
                         (match n with
                          | Posz elpi_ctx_entry_2_ =>
                              iterop elpi_ctx_entry_2_ addq 1 0
                          | Negz elpi_ctx_entry_2_ =>
                              (-
                               match elpi_ctx_entry_2_ with
                               | 0 => 1%Q
                               | _.+1 => (1%Q + (...) elpi_ctx_entry_2_)%Q
                               end)%Q
                          end *
                          (match n with
                           | Posz elpi_ctx_entry_2_ =>
                               iterop elpi_ctx_entry_2_ addq 1 0
                           | Negz elpi_ctx_entry_2_ =>
                               (-
                                match elpi_ctx_entry_2_ with
                                | 0 => 1%Q
                                | _.+1 => (1%Q + ...)%Q
                                end)%Q
                           end *
                           (match n with
                            | Posz elpi_ctx_entry_2_ =>
                                iterop elpi_ctx_entry_2_ addq 1 0
                            | Negz elpi_ctx_entry_2_ =>
                                (- match ... with
                                   | ... 1%Q
                                   | ... ...%Q
                                   end)%Q
                            end *
                            (match n with
                             | Posz elpi_ctx_entry_2_ =>
                                 iterop elpi_ctx_entry_2_ addq 1 0
                             | Negz elpi_ctx_entry_2_ => (- ...)%Q
                             end *
                             (match ... with
                              | ... ...
                              | ... ...%Q
                              end * (... * ...%Q)%Q)%Q)%Q)%Q)%Q)%Q)%Q)%Q +
                       (rat_of_Z
                          (BinNums.Zpos
                             (BinNums.xO
                                (BinNums.xI
                                   (BinNums.xI
                                      (BinNums.xO (BinNums.xO (...))))))) *
                        (match n with
                         | Posz elpi_ctx_entry_2_ =>
                             iterop elpi_ctx_entry_2_ addq 1 0
                         | Negz elpi_ctx_entry_2_ =>
                             (-
                              match elpi_ctx_entry_2_ with
                              | 0 => 1%Q
                              | _.+1 =>
                                  (1%Q +
                                   (fix loop ... : rat := ...
                                                 ...
                                                 ...
                                                 ...
                                                 end) elpi_ctx_entry_2_)%Q
                              end)%Q
                         end *
                         (match n with
                          | Posz elpi_ctx_entry_2_ =>
                              iterop elpi_ctx_entry_2_ addq 1 0
                          | Negz elpi_ctx_entry_2_ =>
                              (-
                               match elpi_ctx_entry_2_ with
                               | 0 => 1%Q
                               | _.+1 => (1%Q + (...) elpi_ctx_entry_2_)%Q
                               end)%Q
                          end *
                          (match n with
                           | Posz elpi_ctx_entry_2_ =>
                               iterop elpi_ctx_entry_2_ addq 1 0
                           | Negz elpi_ctx_entry_2_ =>
                               (-
                                match elpi_ctx_entry_2_ with
                                | 0 => 1%Q
                                | _.+1 => (1%Q + ...)%Q
                                end)%Q
                           end *
                           (match n with
                            | Posz elpi_ctx_entry_2_ =>
                                iterop elpi_ctx_entry_2_ addq 1 0
                            | Negz elpi_ctx_entry_2_ =>
                                (- match ... with
                                   | ... 1%Q
                                   | ... ...%Q
                                   end)%Q
                            end *
                            (match n with
                             | Posz elpi_ctx_entry_2_ =>
                                 iterop elpi_ctx_entry_2_ addq 1 0
                             | Negz elpi_ctx_entry_2_ => (- ...)%Q
                             end *
                             (match ... with
                              | ... ...
                              | ... ...%Q
                              end * (... * ...)%Q)%Q)%Q)%Q)%Q)%Q)%Q)%Q)%Q +
                      (rat_of_Z
                         (BinNums.Zpos
                            (BinNums.xO
                               (BinNums.xO
                                  (BinNums.xO
                                     (BinNums.xI
                                        (BinNums.xO (BinNums.xO (...)))))))) *
                       (match n with
                        | Posz elpi_ctx_entry_2_ =>
                            iterop elpi_ctx_entry_2_ addq 1 0
                        | Negz elpi_ctx_entry_2_ =>
                            (-
                             match elpi_ctx_entry_2_ with
                             | 0 => 1%Q
                             | _.+1 =>
                                 (1%Q +
                                  (fix loop (m : nat) : rat :=
                                     match ... with
                                     | ... => 0
                                     | ... => 1
                                     | ... => 1%Q + ...
                                     end) elpi_ctx_entry_2_)%Q
                             end)%Q
                        end *
                        (match n with
                         | Posz elpi_ctx_entry_2_ =>
                             iterop elpi_ctx_entry_2_ addq 1 0
                         | Negz elpi_ctx_entry_2_ =>
                             (-
                              match elpi_ctx_entry_2_ with
                              | 0 => 1%Q
                              | _.+1 =>
                                  (1%Q +
                                   (fix loop ... : rat := ...
                                                 ...
                                                 ...
                                                 ...
                                                 end) elpi_ctx_entry_2_)%Q
                              end)%Q
                         end *
                         (match n with
                          | Posz elpi_ctx_entry_2_ =>
                              iterop elpi_ctx_entry_2_ addq 1 0
                          | Negz elpi_ctx_entry_2_ =>
                              (-
                               match elpi_ctx_entry_2_ with
                               | 0 => 1%Q
                               | _.+1 => (1%Q + (...) elpi_ctx_entry_2_)%Q
                               end)%Q
                          end *
                          (match n with
                           | Posz elpi_ctx_entry_2_ =>
                               iterop elpi_ctx_entry_2_ addq 1 0
                           | Negz elpi_ctx_entry_2_ =>
                               (-
                                match elpi_ctx_entry_2_ with
                                | 0 => 1%Q
                                | _.+1 => (1%Q + ...)%Q
                                end)%Q
                           end *
                           (match n with
                            | Posz elpi_ctx_entry_2_ =>
                                iterop elpi_ctx_entry_2_ addq 1 0
                            | Negz elpi_ctx_entry_2_ =>
                                (- match ... with
                                   | ... 1%Q
                                   | ... ...%Q
                                   end)%Q
                            end *
                            (match n with
                             | Posz elpi_ctx_entry_2_ =>
                                 iterop elpi_ctx_entry_2_ addq 1 0
                             | Negz elpi_ctx_entry_2_ => (- ...)%Q
                             end *
                             match n with
                             | Posz elpi_ctx_entry_2_ =>
                                 iterop elpi_ctx_entry_2_ addq 1 0
                             | Negz elpi_ctx_entry_2_ => (- ...)%Q
                             end)%Q)%Q)%Q)%Q)%Q)%Q)%Q)%Q +
                     (rat_of_Z
                        (BinNums.Zpos
                           (BinNums.xO
                              (BinNums.xO
                                 (BinNums.xI
                                    (BinNums.xI
                                       (BinNums.xO
                                          (BinNums.xI (BinNums.xO (...))))))))) *
                      (match n with
                       | Posz elpi_ctx_entry_2_ =>
                           iterop elpi_ctx_entry_2_ addq 1 0
                       | Negz elpi_ctx_entry_2_ =>
                           (-
                            match elpi_ctx_entry_2_ with
                            | 0 => 1%Q
                            | _.+1 =>
                                (1%Q +
                                 (fix loop (m : nat) : rat :=
                                    match m with
                                    | 0 => 0
                                    | 1 => 1
                                    | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                        1%Q + loop elpi_ctx_entry_6_
                                    end) elpi_ctx_entry_2_)%Q
                            end)%Q
                       end *
                       (match n with
                        | Posz elpi_ctx_entry_2_ =>
                            iterop elpi_ctx_entry_2_ addq 1 0
                        | Negz elpi_ctx_entry_2_ =>
                            (-
                             match elpi_ctx_entry_2_ with
                             | 0 => 1%Q
                             | _.+1 =>
                                 (1%Q +
                                  (fix loop (m : nat) : rat :=
                                     match ... with
                                     | ... => 0
                                     | ... => 1
                                     | ... => 1%Q + ...
                                     end) elpi_ctx_entry_2_)%Q
                             end)%Q
                        end *
                        (match n with
                         | Posz elpi_ctx_entry_2_ =>
                             iterop elpi_ctx_entry_2_ addq 1 0
                         | Negz elpi_ctx_entry_2_ =>
                             (-
                              match elpi_ctx_entry_2_ with
                              | 0 => 1%Q
                              | _.+1 =>
                                  (1%Q +
                                   (fix loop ... : rat := ...
                                                 ...
                                                 ...
                                                 ...
                                                 end) elpi_ctx_entry_2_)%Q
                              end)%Q
                         end *
                         (match n with
                          | Posz elpi_ctx_entry_2_ =>
                              iterop elpi_ctx_entry_2_ addq 1 0
                          | Negz elpi_ctx_entry_2_ =>
                              (-
                               match elpi_ctx_entry_2_ with
                               | 0 => 1%Q
                               | _.+1 => (1%Q + (...) elpi_ctx_entry_2_)%Q
                               end)%Q
                          end *
                          (match n with
                           | Posz elpi_ctx_entry_2_ =>
                               iterop elpi_ctx_entry_2_ addq 1 0
                           | Negz elpi_ctx_entry_2_ =>
                               (-
                                match elpi_ctx_entry_2_ with
                                | 0 => 1%Q
                                | _.+1 => (1%Q + ...)%Q
                                end)%Q
                           end *
                           match n with
                           | Posz elpi_ctx_entry_2_ =>
                               iterop elpi_ctx_entry_2_ addq 1 0
                           | Negz elpi_ctx_entry_2_ =>
                               (-
                                match elpi_ctx_entry_2_ with
                                | 0 => 1%Q
                                | _.+1 => (1%Q + ...)%Q
                                end)%Q
                           end)%Q)%Q)%Q)%Q)%Q)%Q)%Q +
                    (rat_of_Z
                       (BinNums.Zpos
                          (BinNums.xO
                             (BinNums.xO
                                (BinNums.xO
                                   (BinNums.xO
                                      (BinNums.xO
                                         (BinNums.xO
                                            (BinNums.xI (BinNums.xI (...)))))))))) *
                     (match n with
                      | Posz elpi_ctx_entry_2_ =>
                          iterop elpi_ctx_entry_2_ addq 1 0
                      | Negz elpi_ctx_entry_2_ =>
                          (-
                           match elpi_ctx_entry_2_ with
                           | 0 => 1%Q
                           | _.+1 =>
                               (1%Q +
                                (fix loop (m : nat) : rat :=
                                   match m with
                                   | 0 => 0
                                   | 1 => 1
                                   | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                       1%Q + loop elpi_ctx_entry_6_
                                   end) elpi_ctx_entry_2_)%Q
                           end)%Q
                      end *
                      (match n with
                       | Posz elpi_ctx_entry_2_ =>
                           iterop elpi_ctx_entry_2_ addq 1 0
                       | Negz elpi_ctx_entry_2_ =>
                           (-
                            match elpi_ctx_entry_2_ with
                            | 0 => 1%Q
                            | _.+1 =>
                                (1%Q +
                                 (fix loop (m : nat) : rat :=
                                    match m with
                                    | 0 => 0
                                    | 1 => 1
                                    | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                        1%Q + loop elpi_ctx_entry_6_
                                    end) elpi_ctx_entry_2_)%Q
                            end)%Q
                       end *
                       (match n with
                        | Posz elpi_ctx_entry_2_ =>
                            iterop elpi_ctx_entry_2_ addq 1 0
                        | Negz elpi_ctx_entry_2_ =>
                            (-
                             match elpi_ctx_entry_2_ with
                             | 0 => 1%Q
                             | _.+1 =>
                                 (1%Q +
                                  (fix loop (m : nat) : rat :=
                                     match ... with
                                     | ... => 0
                                     | ... => 1
                                     | ... => 1%Q + ...
                                     end) elpi_ctx_entry_2_)%Q
                             end)%Q
                        end *
                        (match n with
                         | Posz elpi_ctx_entry_2_ =>
                             iterop elpi_ctx_entry_2_ addq 1 0
                         | Negz elpi_ctx_entry_2_ =>
                             (-
                              match elpi_ctx_entry_2_ with
                              | 0 => 1%Q
                              | _.+1 =>
                                  (1%Q +
                                   (fix loop ... : rat := ...
                                                 ...
                                                 ...
                                                 ...
                                                 end) elpi_ctx_entry_2_)%Q
                              end)%Q
                         end *
                         match n with
                         | Posz elpi_ctx_entry_2_ =>
                             iterop elpi_ctx_entry_2_ addq 1 0
                         | Negz elpi_ctx_entry_2_ =>
                             (-
                              match elpi_ctx_entry_2_ with
                              | 0 => 1%Q
                              | _.+1 =>
                                  (1%Q +
                                   (fix loop ... : rat := ...
                                                 ...
                                                 ...
                                                 ...
                                                 end) elpi_ctx_entry_2_)%Q
                              end)%Q
                         end)%Q)%Q)%Q)%Q)%Q)%Q +
                   (rat_of_Z
                      (BinNums.Zpos
                         (BinNums.xI
                            (BinNums.xO
                               (BinNums.xO
                                  (BinNums.xO
                                     (BinNums.xO
                                        (BinNums.xI
                                           (BinNums.xI
                                              (BinNums.xO (BinNums.xI (...))))))))))) *
                    (match n with
                     | Posz elpi_ctx_entry_2_ =>
                         iterop elpi_ctx_entry_2_ addq 1 0
                     | Negz elpi_ctx_entry_2_ =>
                         (-
                          match elpi_ctx_entry_2_ with
                          | 0 => 1%Q
                          | _.+1 =>
                              (1%Q +
                               (fix loop (m : nat) : rat :=
                                  match m with
                                  | 0 => 0
                                  | 1 => 1
                                  | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                      1%Q + loop elpi_ctx_entry_6_
                                  end) elpi_ctx_entry_2_)%Q
                          end)%Q
                     end *
                     (match n with
                      | Posz elpi_ctx_entry_2_ =>
                          iterop elpi_ctx_entry_2_ addq 1 0
                      | Negz elpi_ctx_entry_2_ =>
                          (-
                           match elpi_ctx_entry_2_ with
                           | 0 => 1%Q
                           | _.+1 =>
                               (1%Q +
                                (fix loop (m : nat) : rat :=
                                   match m with
                                   | 0 => 0
                                   | 1 => 1
                                   | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                       1%Q + loop elpi_ctx_entry_6_
                                   end) elpi_ctx_entry_2_)%Q
                           end)%Q
                      end *
                      (match n with
                       | Posz elpi_ctx_entry_2_ =>
                           iterop elpi_ctx_entry_2_ addq 1 0
                       | Negz elpi_ctx_entry_2_ =>
                           (-
                            match elpi_ctx_entry_2_ with
                            | 0 => 1%Q
                            | _.+1 =>
                                (1%Q +
                                 (fix loop (m : nat) : rat :=
                                    match m with
                                    | 0 => 0
                                    | 1 => 1
                                    | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                        1%Q + loop elpi_ctx_entry_6_
                                    end) elpi_ctx_entry_2_)%Q
                            end)%Q
                       end *
                       match n with
                       | Posz elpi_ctx_entry_2_ =>
                           iterop elpi_ctx_entry_2_ addq 1 0
                       | Negz elpi_ctx_entry_2_ =>
                           (-
                            match elpi_ctx_entry_2_ with
                            | 0 => 1%Q
                            | _.+1 =>
                                (1%Q +
                                 (fix loop (m : nat) : rat :=
                                    match m with
                                    | 0 => 0
                                    | 1 => 1
                                    | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                        1%Q + loop elpi_ctx_entry_6_
                                    end) elpi_ctx_entry_2_)%Q
                            end)%Q
                       end)%Q)%Q)%Q)%Q)%Q +
                  (rat_of_Z
                     (BinNums.Zpos
                        (BinNums.xO
                           (BinNums.xI
                              (BinNums.xI
                                 (BinNums.xI
                                    (BinNums.xO
                                       (BinNums.xO
                                          (BinNums.xI
                                             (BinNums.xO
                                                (BinNums.xO
                                                 (BinNums.xI (...)))))))))))) *
                   (match n with
                    | Posz elpi_ctx_entry_2_ =>
                        iterop elpi_ctx_entry_2_ addq 1 0
                    | Negz elpi_ctx_entry_2_ =>
                        (-
                         match elpi_ctx_entry_2_ with
                         | 0 => 1%Q
                         | _.+1 =>
                             (1%Q +
                              (fix loop (m : nat) : rat :=
                                 match m with
                                 | 0 => 0
                                 | 1 => 1
                                 | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                     1%Q + loop elpi_ctx_entry_6_
                                 end) elpi_ctx_entry_2_)%Q
                         end)%Q
                    end *
                    (match n with
                     | Posz elpi_ctx_entry_2_ =>
                         iterop elpi_ctx_entry_2_ addq 1 0
                     | Negz elpi_ctx_entry_2_ =>
                         (-
                          match elpi_ctx_entry_2_ with
                          | 0 => 1%Q
                          | _.+1 =>
                              (1%Q +
                               (fix loop (m : nat) : rat :=
                                  match m with
                                  | 0 => 0
                                  | 1 => 1
                                  | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                      1%Q + loop elpi_ctx_entry_6_
                                  end) elpi_ctx_entry_2_)%Q
                          end)%Q
                     end *
                     match n with
                     | Posz elpi_ctx_entry_2_ =>
                         iterop elpi_ctx_entry_2_ addq 1 0
                     | Negz elpi_ctx_entry_2_ =>
                         (-
                          match elpi_ctx_entry_2_ with
                          | 0 => 1%Q
                          | _.+1 =>
                              (1%Q +
                               (fix loop (m : nat) : rat :=
                                  match m with
                                  | 0 => 0
                                  | 1 => 1
                                  | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                      1%Q + loop elpi_ctx_entry_6_
                                  end) elpi_ctx_entry_2_)%Q
                          end)%Q
                     end)%Q)%Q)%Q)%Q +
                 (rat_of_Z
                    (BinNums.Zpos
                       (BinNums.xI
                          (BinNums.xO
                             (BinNums.xO
                                (BinNums.xO
                                   (BinNums.xI
                                      (BinNums.xI
                                         (BinNums.xO
                                            (BinNums.xO
                                               (BinNums.xO
                                                 (BinNums.xO
                                                 (BinNums.xI (...))))))))))))) *
                  (match n with
                   | Posz elpi_ctx_entry_2_ =>
                       iterop elpi_ctx_entry_2_ addq 1 0
                   | Negz elpi_ctx_entry_2_ =>
                       (-
                        match elpi_ctx_entry_2_ with
                        | 0 => 1%Q
                        | _.+1 =>
                            (1%Q +
                             (fix loop (m : nat) : rat :=
                                match m with
                                | 0 => 0
                                | 1 => 1
                                | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                    1%Q + loop elpi_ctx_entry_6_
                                end) elpi_ctx_entry_2_)%Q
                        end)%Q
                   end *
                   match n with
                   | Posz elpi_ctx_entry_2_ =>
                       iterop elpi_ctx_entry_2_ addq 1 0
                   | Negz elpi_ctx_entry_2_ =>
                       (-
                        match elpi_ctx_entry_2_ with
                        | 0 => 1%Q
                        | _.+1 =>
                            (1%Q +
                             (fix loop (m : nat) : rat :=
                                match m with
                                | 0 => 0
                                | 1 => 1
                                | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                    1%Q + loop elpi_ctx_entry_6_
                                end) elpi_ctx_entry_2_)%Q
                        end)%Q
                   end)%Q)%Q)%Q +
                (rat_of_Z
                   (BinNums.Zpos
                      (BinNums.xO
                         (BinNums.xI
                            (BinNums.xI
                               (BinNums.xO
                                  (BinNums.xI
                                     (BinNums.xI
                                        (BinNums.xO
                                           (BinNums.xO
                                              (BinNums.xO
                                                 (BinNums.xO
                                                 (BinNums.xO
                                                 (BinNums.xO (...)))))))))))))) *
                 match n with
                 | Posz elpi_ctx_entry_2_ =>
                     iterop elpi_ctx_entry_2_ addq 1 0
                 | Negz elpi_ctx_entry_2_ =>
                     (-
                      match elpi_ctx_entry_2_ with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                  1%Q + loop elpi_ctx_entry_6_
                              end) elpi_ctx_entry_2_)%Q
                      end)%Q
                 end)%Q)%Q +
               rat_of_Z
                 (BinNums.Zpos
                    (BinNums.xO
                       (BinNums.xO
                          (BinNums.xO
                             (BinNums.xI
                                (BinNums.xO
                                   (BinNums.xI
                                      (BinNums.xO
                                         (BinNums.xI
                                            (BinNums.xO
                                               (BinNums.xO
                                                 (BinNums.xI
                                                 (BinNums.xO
                                                 (BinNums.xO
                                                 (BinNums.xO (...)))))))))))))))))%Q)%Q *
             b (intZmod.addz (intZmod.addz n 1) 1))%Q)%Q +
           (((((- rat_of_Z (BinNums.Zpos 1%AC))%Q *
               ((rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)) *
                 match n with
                 | Posz elpi_ctx_entry_2_ =>
                     iterop elpi_ctx_entry_2_ addq 1 0
                 | Negz elpi_ctx_entry_2_ =>
                     (-
                      match elpi_ctx_entry_2_ with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                  1%Q + loop elpi_ctx_entry_6_
                              end) elpi_ctx_entry_2_)%Q
                      end)%Q
                 end)%Q + rat_of_Z (BinNums.Zpos (BinNums.xI 1%AC)))%Q)%Q *
              ((rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)) *
                match n with
                | Posz elpi_ctx_entry_2_ => iterop elpi_ctx_entry_2_ addq 1 0
                | Negz elpi_ctx_entry_2_ =>
                    (-
                     match elpi_ctx_entry_2_ with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                 1%Q + loop elpi_ctx_entry_6_
                             end) elpi_ctx_entry_2_)%Q
                     end)%Q
                end)%Q +
               rat_of_Z (BinNums.Zpos (BinNums.xI (BinNums.xI 1%AC))))%Q)%Q *
             ((((((((((rat_of_Z
                         (BinNums.Zpos
                            (BinNums.xO
                               (BinNums.xO
                                  (BinNums.xO
                                     (BinNums.xI
                                        (BinNums.xI (BinNums.xO (...)))))))) *
                       (match n with
                        | Posz elpi_ctx_entry_2_ =>
                            iterop elpi_ctx_entry_2_ addq 1 0
                        | Negz elpi_ctx_entry_2_ =>
                            (-
                             match elpi_ctx_entry_2_ with
                             | 0 => 1%Q
                             | _.+1 =>
                                 (1%Q +
                                  (fix loop (m : nat) : rat :=
                                     match ... with
                                     | ... => 0
                                     | ... => 1
                                     | ... => 1%Q + ...
                                     end) elpi_ctx_entry_2_)%Q
                             end)%Q
                        end *
                        (match n with
                         | Posz elpi_ctx_entry_2_ =>
                             iterop elpi_ctx_entry_2_ addq 1 0
                         | Negz elpi_ctx_entry_2_ =>
                             (-
                              match elpi_ctx_entry_2_ with
                              | 0 => 1%Q
                              | _.+1 =>
                                  (1%Q +
                                   (fix loop ... : rat := ...
                                                 ...
                                                 ...
                                                 ...
                                                 end) elpi_ctx_entry_2_)%Q
                              end)%Q
                         end *
                         (match n with
                          | Posz elpi_ctx_entry_2_ =>
                              iterop elpi_ctx_entry_2_ addq 1 0
                          | Negz elpi_ctx_entry_2_ =>
                              (-
                               match elpi_ctx_entry_2_ with
                               | 0 => 1%Q
                               | _.+1 => (1%Q + (...) elpi_ctx_entry_2_)%Q
                               end)%Q
                          end *
                          (match n with
                           | Posz elpi_ctx_entry_2_ =>
                               iterop elpi_ctx_entry_2_ addq 1 0
                           | Negz elpi_ctx_entry_2_ =>
                               (-
                                match elpi_ctx_entry_2_ with
                                | 0 => 1%Q
                                | _.+1 => (1%Q + ...)%Q
                                end)%Q
                           end *
                           (match n with
                            | Posz elpi_ctx_entry_2_ =>
                                iterop elpi_ctx_entry_2_ addq 1 0
                            | Negz elpi_ctx_entry_2_ =>
                                (- match ... with
                                   | ... 1%Q
                                   | ... ...%Q
                                   end)%Q
                            end *
                            (match n with
                             | Posz elpi_ctx_entry_2_ =>
                                 iterop elpi_ctx_entry_2_ addq 1 0
                             | Negz elpi_ctx_entry_2_ => (- ...)%Q
                             end *
                             (match ... with
                              | ... ...
                              | ... ...%Q
                              end * (... * ...)%Q)%Q)%Q)%Q)%Q)%Q)%Q)%Q)%Q +
                      (rat_of_Z
                         (BinNums.Zpos
                            (BinNums.xO
                               (BinNums.xO
                                  (BinNums.xI
                                     (BinNums.xO
                                        (BinNums.xI (BinNums.xO (...)))))))) *
                       (match n with
                        | Posz elpi_ctx_entry_2_ =>
                            iterop elpi_ctx_entry_2_ addq 1 0
                        | Negz elpi_ctx_entry_2_ =>
                            (-
                             match elpi_ctx_entry_2_ with
                             | 0 => 1%Q
                             | _.+1 =>
                                 (1%Q +
                                  (fix loop (m : nat) : rat :=
                                     match ... with
                                     | ... => 0
                                     | ... => 1
                                     | ... => 1%Q + ...
                                     end) elpi_ctx_entry_2_)%Q
                             end)%Q
                        end *
                        (match n with
                         | Posz elpi_ctx_entry_2_ =>
                             iterop elpi_ctx_entry_2_ addq 1 0
                         | Negz elpi_ctx_entry_2_ =>
                             (-
                              match elpi_ctx_entry_2_ with
                              | 0 => 1%Q
                              | _.+1 =>
                                  (1%Q +
                                   (fix loop ... : rat := ...
                                                 ...
                                                 ...
                                                 ...
                                                 end) elpi_ctx_entry_2_)%Q
                              end)%Q
                         end *
                         (match n with
                          | Posz elpi_ctx_entry_2_ =>
                              iterop elpi_ctx_entry_2_ addq 1 0
                          | Negz elpi_ctx_entry_2_ =>
                              (-
                               match elpi_ctx_entry_2_ with
                               | 0 => 1%Q
                               | _.+1 => (1%Q + (...) elpi_ctx_entry_2_)%Q
                               end)%Q
                          end *
                          (match n with
                           | Posz elpi_ctx_entry_2_ =>
                               iterop elpi_ctx_entry_2_ addq 1 0
                           | Negz elpi_ctx_entry_2_ =>
                               (-
                                match elpi_ctx_entry_2_ with
                                | 0 => 1%Q
                                | _.+1 => (1%Q + ...)%Q
                                end)%Q
                           end *
                           (match n with
                            | Posz elpi_ctx_entry_2_ =>
                                iterop elpi_ctx_entry_2_ addq 1 0
                            | Negz elpi_ctx_entry_2_ =>
                                (- match ... with
                                   | ... 1%Q
                                   | ... ...%Q
                                   end)%Q
                            end *
                            (match n with
                             | Posz elpi_ctx_entry_2_ =>
                                 iterop elpi_ctx_entry_2_ addq 1 0
                             | Negz elpi_ctx_entry_2_ => (- ...)%Q
                             end *
                             (match ... with
                              | ... ...
                              | ... ...%Q
                              end * match ... with
                                    | ... ...
                                    | ... ...%Q
                                    end)%Q)%Q)%Q)%Q)%Q)%Q)%Q)%Q)%Q +
                     (rat_of_Z
                        (BinNums.Zpos
                           (BinNums.xO
                              (BinNums.xI
                                 (BinNums.xI
                                    (BinNums.xO
                                       (BinNums.xI
                                          (BinNums.xI (BinNums.xI (...))))))))) *
                      (match n with
                       | Posz elpi_ctx_entry_2_ =>
                           iterop elpi_ctx_entry_2_ addq 1 0
                       | Negz elpi_ctx_entry_2_ =>
                           (-
                            match elpi_ctx_entry_2_ with
                            | 0 => 1%Q
                            | _.+1 =>
                                (1%Q +
                                 (fix loop (m : nat) : rat :=
                                    match m with
                                    | 0 => 0
                                    | 1 => 1
                                    | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                        1%Q + loop elpi_ctx_entry_6_
                                    end) elpi_ctx_entry_2_)%Q
                            end)%Q
                       end *
                       (match n with
                        | Posz elpi_ctx_entry_2_ =>
                            iterop elpi_ctx_entry_2_ addq 1 0
                        | Negz elpi_ctx_entry_2_ =>
                            (-
                             match elpi_ctx_entry_2_ with
                             | 0 => 1%Q
                             | _.+1 =>
                                 (1%Q +
                                  (fix loop (m : nat) : rat :=
                                     match ... with
                                     | ... => 0
                                     | ... => 1
                                     | ... => 1%Q + ...
                                     end) elpi_ctx_entry_2_)%Q
                             end)%Q
                        end *
                        (match n with
                         | Posz elpi_ctx_entry_2_ =>
                             iterop elpi_ctx_entry_2_ addq 1 0
                         | Negz elpi_ctx_entry_2_ =>
                             (-
                              match elpi_ctx_entry_2_ with
                              | 0 => 1%Q
                              | _.+1 =>
                                  (1%Q +
                                   (fix loop ... : rat := ...
                                                 ...
                                                 ...
                                                 ...
                                                 end) elpi_ctx_entry_2_)%Q
                              end)%Q
                         end *
                         (match n with
                          | Posz elpi_ctx_entry_2_ =>
                              iterop elpi_ctx_entry_2_ addq 1 0
                          | Negz elpi_ctx_entry_2_ =>
                              (-
                               match elpi_ctx_entry_2_ with
                               | 0 => 1%Q
                               | _.+1 => (1%Q + (...) elpi_ctx_entry_2_)%Q
                               end)%Q
                          end *
                          (match n with
                           | Posz elpi_ctx_entry_2_ =>
                               iterop elpi_ctx_entry_2_ addq 1 0
                           | Negz elpi_ctx_entry_2_ =>
                               (-
                                match elpi_ctx_entry_2_ with
                                | 0 => 1%Q
                                | _.+1 => (1%Q + ...)%Q
                                end)%Q
                           end *
                           (match n with
                            | Posz elpi_ctx_entry_2_ =>
                                iterop elpi_ctx_entry_2_ addq 1 0
                            | Negz elpi_ctx_entry_2_ =>
                                (- match ... with
                                   | ... 1%Q
                                   | ... ...%Q
                                   end)%Q
                            end *
                            match n with
                            | Posz elpi_ctx_entry_2_ =>
                                iterop elpi_ctx_entry_2_ addq 1 0
                            | Negz elpi_ctx_entry_2_ =>
                                (- match ... with
                                   | ... 1%Q
                                   | ... ...%Q
                                   end)%Q
                            end)%Q)%Q)%Q)%Q)%Q)%Q)%Q)%Q +
                    (rat_of_Z
                       (BinNums.Zpos
                          (BinNums.xO
                             (BinNums.xO
                                (BinNums.xI
                                   (BinNums.xI
                                      (BinNums.xI
                                         (BinNums.xO
                                            (BinNums.xO (BinNums.xI (...)))))))))) *
                     (match n with
                      | Posz elpi_ctx_entry_2_ =>
                          iterop elpi_ctx_entry_2_ addq 1 0
                      | Negz elpi_ctx_entry_2_ =>
                          (-
                           match elpi_ctx_entry_2_ with
                           | 0 => 1%Q
                           | _.+1 =>
                               (1%Q +
                                (fix loop (m : nat) : rat :=
                                   match m with
                                   | 0 => 0
                                   | 1 => 1
                                   | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                       1%Q + loop elpi_ctx_entry_6_
                                   end) elpi_ctx_entry_2_)%Q
                           end)%Q
                      end *
                      (match n with
                       | Posz elpi_ctx_entry_2_ =>
                           iterop elpi_ctx_entry_2_ addq 1 0
                       | Negz elpi_ctx_entry_2_ =>
                           (-
                            match elpi_ctx_entry_2_ with
                            | 0 => 1%Q
                            | _.+1 =>
                                (1%Q +
                                 (fix loop (m : nat) : rat :=
                                    match m with
                                    | 0 => 0
                                    | 1 => 1
                                    | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                        1%Q + loop elpi_ctx_entry_6_
                                    end) elpi_ctx_entry_2_)%Q
                            end)%Q
                       end *
                       (match n with
                        | Posz elpi_ctx_entry_2_ =>
                            iterop elpi_ctx_entry_2_ addq 1 0
                        | Negz elpi_ctx_entry_2_ =>
                            (-
                             match elpi_ctx_entry_2_ with
                             | 0 => 1%Q
                             | _.+1 =>
                                 (1%Q +
                                  (fix loop (m : nat) : rat :=
                                     match ... with
                                     | ... => 0
                                     | ... => 1
                                     | ... => 1%Q + ...
                                     end) elpi_ctx_entry_2_)%Q
                             end)%Q
                        end *
                        (match n with
                         | Posz elpi_ctx_entry_2_ =>
                             iterop elpi_ctx_entry_2_ addq 1 0
                         | Negz elpi_ctx_entry_2_ =>
                             (-
                              match elpi_ctx_entry_2_ with
                              | 0 => 1%Q
                              | _.+1 =>
                                  (1%Q +
                                   (fix loop ... : rat := ...
                                                 ...
                                                 ...
                                                 ...
                                                 end) elpi_ctx_entry_2_)%Q
                              end)%Q
                         end *
                         (match n with
                          | Posz elpi_ctx_entry_2_ =>
                              iterop elpi_ctx_entry_2_ addq 1 0
                          | Negz elpi_ctx_entry_2_ =>
                              (-
                               match elpi_ctx_entry_2_ with
                               | 0 => 1%Q
                               | _.+1 => (1%Q + (...) elpi_ctx_entry_2_)%Q
                               end)%Q
                          end *
                          match n with
                          | Posz elpi_ctx_entry_2_ =>
                              iterop elpi_ctx_entry_2_ addq 1 0
                          | Negz elpi_ctx_entry_2_ =>
                              (-
                               match elpi_ctx_entry_2_ with
                               | 0 => 1%Q
                               | _.+1 => (1%Q + (...) elpi_ctx_entry_2_)%Q
                               end)%Q
                          end)%Q)%Q)%Q)%Q)%Q)%Q)%Q +
                   (rat_of_Z
                      (BinNums.Zpos
                         (BinNums.xO
                            (BinNums.xI
                               (BinNums.xO
                                  (BinNums.xI
                                     (BinNums.xO
                                        (BinNums.xO
                                           (BinNums.xI
                                              (BinNums.xO (BinNums.xO (...))))))))))) *
                    (match n with
                     | Posz elpi_ctx_entry_2_ =>
                         iterop elpi_ctx_entry_2_ addq 1 0
                     | Negz elpi_ctx_entry_2_ =>
                         (-
                          match elpi_ctx_entry_2_ with
                          | 0 => 1%Q
                          | _.+1 =>
                              (1%Q +
                               (fix loop (m : nat) : rat :=
                                  match m with
                                  | 0 => 0
                                  | 1 => 1
                                  | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                      1%Q + loop elpi_ctx_entry_6_
                                  end) elpi_ctx_entry_2_)%Q
                          end)%Q
                     end *
                     (match n with
                      | Posz elpi_ctx_entry_2_ =>
                          iterop elpi_ctx_entry_2_ addq 1 0
                      | Negz elpi_ctx_entry_2_ =>
                          (-
                           match elpi_ctx_entry_2_ with
                           | 0 => 1%Q
                           | _.+1 =>
                               (1%Q +
                                (fix loop (m : nat) : rat :=
                                   match m with
                                   | 0 => 0
                                   | 1 => 1
                                   | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                       1%Q + loop elpi_ctx_entry_6_
                                   end) elpi_ctx_entry_2_)%Q
                           end)%Q
                      end *
                      (match n with
                       | Posz elpi_ctx_entry_2_ =>
                           iterop elpi_ctx_entry_2_ addq 1 0
                       | Negz elpi_ctx_entry_2_ =>
                           (-
                            match elpi_ctx_entry_2_ with
                            | 0 => 1%Q
                            | _.+1 =>
                                (1%Q +
                                 (fix loop (m : nat) : rat :=
                                    match m with
                                    | 0 => 0
                                    | 1 => 1
                                    | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                        1%Q + loop elpi_ctx_entry_6_
                                    end) elpi_ctx_entry_2_)%Q
                            end)%Q
                       end *
                       (match n with
                        | Posz elpi_ctx_entry_2_ =>
                            iterop elpi_ctx_entry_2_ addq 1 0
                        | Negz elpi_ctx_entry_2_ =>
                            (-
                             match elpi_ctx_entry_2_ with
                             | 0 => 1%Q
                             | _.+1 =>
                                 (1%Q +
                                  (fix loop (m : nat) : rat :=
                                     match ... with
                                     | ... => 0
                                     | ... => 1
                                     | ... => 1%Q + ...
                                     end) elpi_ctx_entry_2_)%Q
                             end)%Q
                        end *
                        match n with
                        | Posz elpi_ctx_entry_2_ =>
                            iterop elpi_ctx_entry_2_ addq 1 0
                        | Negz elpi_ctx_entry_2_ =>
                            (-
                             match elpi_ctx_entry_2_ with
                             | 0 => 1%Q
                             | _.+1 =>
                                 (1%Q +
                                  (fix loop (m : nat) : rat :=
                                     match ... with
                                     | ... => 0
                                     | ... => 1
                                     | ... => 1%Q + ...
                                     end) elpi_ctx_entry_2_)%Q
                             end)%Q
                        end)%Q)%Q)%Q)%Q)%Q)%Q +
                  (rat_of_Z
                     (BinNums.Zpos
                        (BinNums.xI
                           (BinNums.xI
                              (BinNums.xI
                                 (BinNums.xO
                                    (BinNums.xO
                                       (BinNums.xI
                                          (BinNums.xI
                                             (BinNums.xI
                                                (BinNums.xI
                                                 (BinNums.xI (...)))))))))))) *
                   (match n with
                    | Posz elpi_ctx_entry_2_ =>
                        iterop elpi_ctx_entry_2_ addq 1 0
                    | Negz elpi_ctx_entry_2_ =>
                        (-
                         match elpi_ctx_entry_2_ with
                         | 0 => 1%Q
                         | _.+1 =>
                             (1%Q +
                              (fix loop (m : nat) : rat :=
                                 match m with
                                 | 0 => 0
                                 | 1 => 1
                                 | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                     1%Q + loop elpi_ctx_entry_6_
                                 end) elpi_ctx_entry_2_)%Q
                         end)%Q
                    end *
                    (match n with
                     | Posz elpi_ctx_entry_2_ =>
                         iterop elpi_ctx_entry_2_ addq 1 0
                     | Negz elpi_ctx_entry_2_ =>
                         (-
                          match elpi_ctx_entry_2_ with
                          | 0 => 1%Q
                          | _.+1 =>
                              (1%Q +
                               (fix loop (m : nat) : rat :=
                                  match m with
                                  | 0 => 0
                                  | 1 => 1
                                  | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                      1%Q + loop elpi_ctx_entry_6_
                                  end) elpi_ctx_entry_2_)%Q
                          end)%Q
                     end *
                     (match n with
                      | Posz elpi_ctx_entry_2_ =>
                          iterop elpi_ctx_entry_2_ addq 1 0
                      | Negz elpi_ctx_entry_2_ =>
                          (-
                           match elpi_ctx_entry_2_ with
                           | 0 => 1%Q
                           | _.+1 =>
                               (1%Q +
                                (fix loop (m : nat) : rat :=
                                   match m with
                                   | 0 => 0
                                   | 1 => 1
                                   | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                       1%Q + loop elpi_ctx_entry_6_
                                   end) elpi_ctx_entry_2_)%Q
                           end)%Q
                      end *
                      match n with
                      | Posz elpi_ctx_entry_2_ =>
                          iterop elpi_ctx_entry_2_ addq 1 0
                      | Negz elpi_ctx_entry_2_ =>
                          (-
                           match elpi_ctx_entry_2_ with
                           | 0 => 1%Q
                           | _.+1 =>
                               (1%Q +
                                (fix loop (m : nat) : rat :=
                                   match m with
                                   | 0 => 0
                                   | 1 => 1
                                   | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                       1%Q + loop elpi_ctx_entry_6_
                                   end) elpi_ctx_entry_2_)%Q
                           end)%Q
                      end)%Q)%Q)%Q)%Q)%Q +
                 (rat_of_Z
                    (BinNums.Zpos
                       (BinNums.xO
                          (BinNums.xI
                             (BinNums.xI
                                (BinNums.xO
                                   (BinNums.xO
                                      (BinNums.xI
                                         (BinNums.xO
                                            (BinNums.xI
                                               (BinNums.xI
                                                 (BinNums.xO
                                                 (BinNums.xI (...))))))))))))) *
                  (match n with
                   | Posz elpi_ctx_entry_2_ =>
                       iterop elpi_ctx_entry_2_ addq 1 0
                   | Negz elpi_ctx_entry_2_ =>
                       (-
                        match elpi_ctx_entry_2_ with
                        | 0 => 1%Q
                        | _.+1 =>
                            (1%Q +
                             (fix loop (m : nat) : rat :=
                                match m with
                                | 0 => 0
                                | 1 => 1
                                | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                    1%Q + loop elpi_ctx_entry_6_
                                end) elpi_ctx_entry_2_)%Q
                        end)%Q
                   end *
                   (match n with
                    | Posz elpi_ctx_entry_2_ =>
                        iterop elpi_ctx_entry_2_ addq 1 0
                    | Negz elpi_ctx_entry_2_ =>
                        (-
                         match elpi_ctx_entry_2_ with
                         | 0 => 1%Q
                         | _.+1 =>
                             (1%Q +
                              (fix loop (m : nat) : rat :=
                                 match m with
                                 | 0 => 0
                                 | 1 => 1
                                 | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                     1%Q + loop elpi_ctx_entry_6_
                                 end) elpi_ctx_entry_2_)%Q
                         end)%Q
                    end *
                    match n with
                    | Posz elpi_ctx_entry_2_ =>
                        iterop elpi_ctx_entry_2_ addq 1 0
                    | Negz elpi_ctx_entry_2_ =>
                        (-
                         match elpi_ctx_entry_2_ with
                         | 0 => 1%Q
                         | _.+1 =>
                             (1%Q +
                              (fix loop (m : nat) : rat :=
                                 match m with
                                 | 0 => 0
                                 | 1 => 1
                                 | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                     1%Q + loop elpi_ctx_entry_6_
                                 end) elpi_ctx_entry_2_)%Q
                         end)%Q
                    end)%Q)%Q)%Q)%Q +
                (rat_of_Z
                   (BinNums.Zpos
                      (BinNums.xI
                         (BinNums.xO
                            (BinNums.xI
                               (BinNums.xO
                                  (BinNums.xI
                                     (BinNums.xI
                                        (BinNums.xO
                                           (BinNums.xI
                                              (BinNums.xI
                                                 (BinNums.xI
                                                 (BinNums.xO
                                                 (BinNums.xO (...)))))))))))))) *
                 (match n with
                  | Posz elpi_ctx_entry_2_ =>
                      iterop elpi_ctx_entry_2_ addq 1 0
                  | Negz elpi_ctx_entry_2_ =>
                      (-
                       match elpi_ctx_entry_2_ with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                   1%Q + loop elpi_ctx_entry_6_
                               end) elpi_ctx_entry_2_)%Q
                       end)%Q
                  end *
                  match n with
                  | Posz elpi_ctx_entry_2_ =>
                      iterop elpi_ctx_entry_2_ addq 1 0
                  | Negz elpi_ctx_entry_2_ =>
                      (-
                       match elpi_ctx_entry_2_ with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                   1%Q + loop elpi_ctx_entry_6_
                               end) elpi_ctx_entry_2_)%Q
                       end)%Q
                  end)%Q)%Q)%Q +
               (rat_of_Z
                  (BinNums.Zpos
                     (BinNums.xO
                        (BinNums.xI
                           (BinNums.xI
                              (BinNums.xI
                                 (BinNums.xO
                                    (BinNums.xO
                                       (BinNums.xO
                                          (BinNums.xI
                                             (BinNums.xI
                                                (BinNums.xI
                                                 (BinNums.xI
                                                 (BinNums.xI
                                                 (BinNums.xO (...))))))))))))))) *
                match n with
                | Posz elpi_ctx_entry_2_ => iterop elpi_ctx_entry_2_ addq 1 0
                | Negz elpi_ctx_entry_2_ =>
                    (-
                     match elpi_ctx_entry_2_ with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                 1%Q + loop elpi_ctx_entry_6_
                             end) elpi_ctx_entry_2_)%Q
                     end)%Q
                end)%Q)%Q +
              rat_of_Z
                (BinNums.Zpos
                   (BinNums.xO
                      (BinNums.xO
                         (BinNums.xO
                            (BinNums.xO
                               (BinNums.xO
                                  (BinNums.xI
                                     (BinNums.xO
                                        (BinNums.xO
                                           (BinNums.xO
                                              (BinNums.xO
                                                 (BinNums.xO
                                                 (BinNums.xI
                                                 (BinNums.xI
                                                 (BinNums.xI
                                                 (BinNums.xI (...))))))))))))))))))%Q)%Q *
            b (intZmod.addz n 1))%Q)%Q +
          (((((rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)) *
               match n with
               | Posz elpi_ctx_entry_2_ => iterop elpi_ctx_entry_2_ addq 1 0
               | Negz elpi_ctx_entry_2_ =>
                   (-
                    match elpi_ctx_entry_2_ with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                1%Q + loop elpi_ctx_entry_6_
                            end) elpi_ctx_entry_2_)%Q
                    end)%Q
               end)%Q +
              rat_of_Z (BinNums.Zpos (BinNums.xI (BinNums.xI 1%AC))))%Q *
             ((((rat_of_Z
                   (BinNums.Zpos
                      (BinNums.xO
                         (BinNums.xO
                            (BinNums.xO
                               (BinNums.xO
                                  (BinNums.xO
                                     (BinNums.xI
                                        (BinNums.xO
                                           (BinNums.xI (BinNums.xI 1%AC)))))))))) +
                 (rat_of_Z
                    (BinNums.Zpos
                       (BinNums.xO
                          (BinNums.xI
                             (BinNums.xO
                                (BinNums.xO
                                   (BinNums.xI
                                      (BinNums.xI
                                         (BinNums.xI
                                            (BinNums.xI
                                               (BinNums.xO (BinNums.xO 1%AC))))))))))) *
                  match n with
                  | Posz elpi_ctx_entry_2_ =>
                      iterop elpi_ctx_entry_2_ addq 1 0
                  | Negz elpi_ctx_entry_2_ =>
                      (-
                       match elpi_ctx_entry_2_ with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                   1%Q + loop elpi_ctx_entry_6_
                               end) elpi_ctx_entry_2_)%Q
                       end)%Q
                  end)%Q)%Q +
                (rat_of_Z
                   (BinNums.Zpos
                      (BinNums.xI
                         (BinNums.xI
                            (BinNums.xO
                               (BinNums.xO
                                  (BinNums.xO
                                     (BinNums.xO
                                        (BinNums.xO
                                           (BinNums.xI (BinNums.xO 1%AC)))))))))) *
                 (match n with
                  | Posz elpi_ctx_entry_2_ =>
                      iterop elpi_ctx_entry_2_ addq 1 0
                  | Negz elpi_ctx_entry_2_ =>
                      (-
                       match elpi_ctx_entry_2_ with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                   1%Q + loop elpi_ctx_entry_6_
                               end) elpi_ctx_entry_2_)%Q
                       end)%Q
                  end *
                  match n with
                  | Posz elpi_ctx_entry_2_ =>
                      iterop elpi_ctx_entry_2_ addq 1 0
                  | Negz elpi_ctx_entry_2_ =>
                      (-
                       match elpi_ctx_entry_2_ with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                   1%Q + loop elpi_ctx_entry_6_
                               end) elpi_ctx_entry_2_)%Q
                       end)%Q
                  end)%Q)%Q)%Q +
               (rat_of_Z
                  (BinNums.Zpos
                     (BinNums.xO
                        (BinNums.xO
                           (BinNums.xO
                              (BinNums.xO
                                 (BinNums.xI (BinNums.xO (BinNums.xO 1%AC)))))))) *
                (match n with
                 | Posz elpi_ctx_entry_2_ =>
                     iterop elpi_ctx_entry_2_ addq 1 0
                 | Negz elpi_ctx_entry_2_ =>
                     (-
                      match elpi_ctx_entry_2_ with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                  1%Q + loop elpi_ctx_entry_6_
                              end) elpi_ctx_entry_2_)%Q
                      end)%Q
                 end *
                 (match n with
                  | Posz elpi_ctx_entry_2_ =>
                      iterop elpi_ctx_entry_2_ addq 1 0
                  | Negz elpi_ctx_entry_2_ =>
                      (-
                       match elpi_ctx_entry_2_ with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                   1%Q + loop elpi_ctx_entry_6_
                               end) elpi_ctx_entry_2_)%Q
                       end)%Q
                  end *
                  match n with
                  | Posz elpi_ctx_entry_2_ =>
                      iterop elpi_ctx_entry_2_ addq 1 0
                  | Negz elpi_ctx_entry_2_ =>
                      (-
                       match elpi_ctx_entry_2_ with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                   1%Q + loop elpi_ctx_entry_6_
                               end) elpi_ctx_entry_2_)%Q
                       end)%Q
                  end)%Q)%Q)%Q)%Q +
              (rat_of_Z
                 (BinNums.Zpos (BinNums.xO (BinNums.xO (BinNums.xI 1%AC)))) *
               (match n with
                | Posz elpi_ctx_entry_2_ => iterop elpi_ctx_entry_2_ addq 1 0
                | Negz elpi_ctx_entry_2_ =>
                    (-
                     match elpi_ctx_entry_2_ with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                 1%Q + loop elpi_ctx_entry_6_
                             end) elpi_ctx_entry_2_)%Q
                     end)%Q
                end *
                (match n with
                 | Posz elpi_ctx_entry_2_ =>
                     iterop elpi_ctx_entry_2_ addq 1 0
                 | Negz elpi_ctx_entry_2_ =>
                     (-
                      match elpi_ctx_entry_2_ with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                  1%Q + loop elpi_ctx_entry_6_
                              end) elpi_ctx_entry_2_)%Q
                      end)%Q
                 end *
                 (match n with
                  | Posz elpi_ctx_entry_2_ =>
                      iterop elpi_ctx_entry_2_ addq 1 0
                  | Negz elpi_ctx_entry_2_ =>
                      (-
                       match elpi_ctx_entry_2_ with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                   1%Q + loop elpi_ctx_entry_6_
                               end) elpi_ctx_entry_2_)%Q
                       end)%Q
                  end *
                  match n with
                  | Posz elpi_ctx_entry_2_ =>
                      iterop elpi_ctx_entry_2_ addq 1 0
                  | Negz elpi_ctx_entry_2_ =>
                      (-
                       match elpi_ctx_entry_2_ with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                   1%Q + loop elpi_ctx_entry_6_
                               end) elpi_ctx_entry_2_)%Q
                       end)%Q
                  end)%Q)%Q)%Q)%Q)%Q)%Q *
            ((match n with
              | Posz elpi_ctx_entry_2_ => iterop elpi_ctx_entry_2_ addq 1 0
              | Negz elpi_ctx_entry_2_ =>
                  (-
                   match elpi_ctx_entry_2_ with
                   | 0 => 1%Q
                   | _.+1 =>
                       (1%Q +
                        (fix loop (m : nat) : rat :=
                           match m with
                           | 0 => 0
                           | 1 => 1
                           | (_.+1 as elpi_ctx_entry_6_).+1 =>
                               1%Q + loop elpi_ctx_entry_6_
                           end) elpi_ctx_entry_2_)%Q
                   end)%Q
              end + rat_of_Z (BinNums.Zpos 1%AC))%Q *
             ((match n with
               | Posz elpi_ctx_entry_2_ => iterop elpi_ctx_entry_2_ addq 1 0
               | Negz elpi_ctx_entry_2_ =>
                   (-
                    match elpi_ctx_entry_2_ with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                1%Q + loop elpi_ctx_entry_6_
                            end) elpi_ctx_entry_2_)%Q
                    end)%Q
               end + rat_of_Z (BinNums.Zpos 1%AC))%Q *
              ((match n with
                | Posz elpi_ctx_entry_2_ => iterop elpi_ctx_entry_2_ addq 1 0
                | Negz elpi_ctx_entry_2_ =>
                    (-
                     match elpi_ctx_entry_2_ with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                 1%Q + loop elpi_ctx_entry_6_
                             end) elpi_ctx_entry_2_)%Q
                     end)%Q
                end + rat_of_Z (BinNums.Zpos 1%AC))%Q *
               ((match n with
                 | Posz elpi_ctx_entry_2_ =>
                     iterop elpi_ctx_entry_2_ addq 1 0
                 | Negz elpi_ctx_entry_2_ =>
                     (-
                      match elpi_ctx_entry_2_ with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                  1%Q + loop elpi_ctx_entry_6_
                              end) elpi_ctx_entry_2_)%Q
                      end)%Q
                 end + rat_of_Z (BinNums.Zpos 1%AC))%Q *
                ((match n with
                  | Posz elpi_ctx_entry_2_ =>
                      iterop elpi_ctx_entry_2_ addq 1 0
                  | Negz elpi_ctx_entry_2_ =>
                      (-
                       match elpi_ctx_entry_2_ with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                   1%Q + loop elpi_ctx_entry_6_
                               end) elpi_ctx_entry_2_)%Q
                       end)%Q
                  end + rat_of_Z (BinNums.Zpos 1%AC))%Q *
                 (match n with
                  | Posz elpi_ctx_entry_2_ =>
                      iterop elpi_ctx_entry_2_ addq 1 0
                  | Negz elpi_ctx_entry_2_ =>
                      (-
                       match elpi_ctx_entry_2_ with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as elpi_ctx_entry_6_).+1 =>
                                   1%Q + loop elpi_ctx_entry_6_
                               end) elpi_ctx_entry_2_)%Q
                       end)%Q
                  end + rat_of_Z (BinNums.Zpos 1%AC))%Q)%Q)%Q)%Q)%Q)%Q)%Q *
           b n)%Q)%Q; 0%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching: (update a a_encad Eq0 = a)
Crunching:
(a <= x_encad -> product n (update x x_encad IHP') a = product n x a)
Crunching: (product (fun _ : nat => false) a n = false)
Crunching: (product (fun _ : nat => false) a n = false)
Crunching: (product (fun _ : nat => false) a n = false)
Crunching: (product (fun _ : nat => false) a n = false)
Crunching: (product (fun _ : nat => false) a n = false)
Crunching: (product (fun _ : nat => false) a n = false)
Crunching: (product (fun _ : nat => false) a n = false)
Crunching: (product (fun _ : nat => false) a n = false)
Crunching: (product (fun _ : nat => false) a n = false)
Crunching: (product (fun _ : nat => false) a n = false)
Crunching: (x = 0%R)
Crunching: (product (fun _ : nat => false) a n = false)
Crunching: (product (fun _ : nat => false) a n = false)
Crunching: (product (fun _ : nat => false) a n = false)
Crunching: (product (fun _ : nat => false) a n = false)
Crunching: (product (fun _ : nat => false) a n = false)
Crunching: (x = 0%R)
Crunching: (product (fun _ : nat => false) a n = false)
Crunching: (product (fun _ : nat => false) a n = false)
Crunching: (product (fun _ : nat => false) a n = false)
Crunching: (product (fun _ : nat => false) a n = false)
Crunching: (product (fun _ : nat => false) a n = false)
Crunching: (x = 0%R)
Crunching: (product (fun _ : nat => false) a n = false)
Crunching: (product (fun _ : nat => false) a n = false)
Crunching: (product (fun _ : nat => false) a n = false)
Crunching: (product (fun _ : nat => false) a n = false)
Crunching: (x = 0%R)
Crunching: (product (fun _ : nat => false) a n = false)
Crunching: (product (fun _ : nat => false) a n = false)
Crunching: (product (fun _ : nat => false) a n = false)
Crunching: (product (fun _ : nat => false) a n = false)
Crunching: (x = 0%R)
Crunching: (product (fun _ : nat => false) a n = false)
Crunching: (product (fun _ : nat => false) a n = false)
Crunching: (product (fun _ : nat => false) a n = false)
Crunching: (product (fun _ : nat => false) a n = false)
Crunching: (product (fun _ : nat => false) a n = false)
Crunching: (product (fun _ : nat => false) a n = false)
Crunching: (nat_to_funbool n 0 = (fun _ : nat => false))
Crunching:
(list_to_funbool H0 (repeat false (H0 - 0)) = (fun _ : nat => false))
Crunching: (nat_to_funbool n 0 = (fun _ : nat => false))
Tactic call ran for 0.024 secs (0.024u,0.s) (success)
Crunching:
(list_to_funbool H0 (repeat false (H0 - 0)) = (fun _ : nat => false))
Crunching: (nat_to_funbool n 0 = (fun _ : nat => false))
Crunching:
(list_to_funbool H0 (repeat false (H0 - 0)) = (fun _ : nat => false))
Crunching: (nat_to_funbool n 0 = (fun _ : nat => false))
Crunching: (false = nat_to_funbool H0 0 x)
Crunching: (nat_to_funbool n 0 = (fun _ : nat => false))
Crunching:
(list_to_funbool H0 (repeat false (H0 - 0)) = (fun _ : nat => false))
Crunching: (nat_to_funbool n 0 = (fun _ : nat => false))
Crunching: (nat_to_funbool n 0 = (fun _ : nat => false))
Crunching: (false = nat_to_funbool H0 0 x)
Crunching: (false = nat_to_funbool H0 0 x)
Crunching: (nat_to_funbool H0 0 n = false)
Crunching: (nat_to_funbool n 0 = (fun _ : nat => false))
Crunching: (nat_to_funbool n 0 = (fun _ : nat => false))
Crunching:
(list_to_funbool H0 (repeat false (H0 - 0)) = (fun _ : nat => false))
Crunching:
((if
   (fix eqb (n m : nat) {struct n} : bool :=
      match n with
      | 0 => match m with
             | 0 => true
             | S _ => false
             end
      | S n' => match m with
                | 0 => false
                | S m' => eqb n' m'
                end
      end) H n
  then false
  else
   (fix list_to_funbool (len : nat) (l : list bool) {struct l} :
        nat -> bool :=
      match l with
      | [] => fun _ : nat => false
      | h :: t =>
          fun j : nat =>
          if
           (fix eqb (n m : nat) {struct n} : bool :=
              match n with
              | 0 => match m with
                     | 0 => true
                     | S _ => false
                     end
              | S n' => match m with
                        | 0 => false
                        | S m' => eqb n' m'
                        end
              end) j
             ((fix sub (n m : nat) {struct n} : nat :=
                 match n with
                 | 0 => n
                 | S k => match m with
                          | 0 => n
                          | S l0 => sub k l0
                          end
                 end) len 1)
          then h
          else
           list_to_funbool
             ((fix sub (n m : nat) {struct n} : nat :=
                 match n with
                 | 0 => n
                 | S k => match m with
                          | 0 => n
                          | S l0 => sub k l0
                          end
                 end) len 1) t j
      end) n
     ((fix repeat (x : bool) (n : nat) {struct n} : list bool :=
         match n with
         | 0 => []
         | S k => x :: repeat x k
         end) false n) H) = true <-> false = true)
Finished transaction in 586.915 secs (575.604u,4.435s) (successful)
Tactic call ran for 0.012 secs (0.008u,0.004s) (success)
Crunching: (nat_to_funbool 0 1 = (fun x : nat => x =? 0 - 1))
Crunching:
(update (list_to_funbool (m - 1) (repeat false (m - 1))) (m - 1) true =
 (fun x : nat => x =? m - 1))
Crunching:
(exists alp : R,
   (alp > 0)%R /\
   (forall x0 : Base R_met,
    D_x no_cond 1 x0 /\ (dist R_met x0 1 < alp)%R ->
    (dist R_met (atan x0) (atan 1) < x)%R))
Crunching: (x - y - z = 0)
Crunching: (nat_to_funbool 0 1 = (fun x : nat => x =? 0 - 1))
Crunching:
(list2D_to_matrix [[e]] =
 Zero .+ (fun x y : nat => C1 * basis_vector 1 0 x y))
Crunching: (I 1 = list2D_to_matrix [[basis_vector 1 0 0%nat 0%nat]])
Tactic call ran for 0.017 secs (0.013u,0.004s) (success)
Crunching:
(list2D_to_matrix [[e]] =
 Zero .+ (fun x y : nat => C1 * basis_vector 1 0 x y))
Crunching: (I 1 = list2D_to_matrix [[basis_vector 1 0 0%nat 0%nat]])
Finished transaction in 40.322 secs (39.875u,0.4s) (successful)
Crunching:
(list2D_to_matrix [[e]] =
 Zero .+ (fun x y : nat => C1 * basis_vector 1 0 x y))
Crunching: (I 1 = list2D_to_matrix [[basis_vector 1 0 0%nat 0%nat]])
Crunching:
(list2D_to_matrix [[e]] =
 Zero .+ (fun x y : nat => C1 * basis_vector 1 0 x y))
Crunching: (I 1 = list2D_to_matrix [[basis_vector 1 0 0%nat 0%nat]])
Crunching:
(list2D_to_matrix [[e]] =
 Zero .+ (fun x y : nat => C1 * basis_vector 1 0 x y))
Crunching: (I 1 = list2D_to_matrix [[basis_vector 1 0 0%nat 0%nat]])
Crunching:
(list2D_to_matrix [[e]] =
 Zero .+ (fun x y : nat => C1 * basis_vector 1 0 x y))
Crunching: (I 1 = list2D_to_matrix [[basis_vector 1 0 0%nat 0%nat]])
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (list2D_to_matrix [[e]; [e0]] = hadamard × ∣ true ⟩)
Crunching:
(list2D_to_matrix [[C1 / √ 2]; [- (C1 / √ 2)]] =
 / √ 2 .* (∣ 0 ⟩ .+ (-1) ^ true .* ∣ 1 ⟩))
Crunching: (list2D_to_matrix [[e]; [e0]] = hadamard × ∣ false ⟩)
Crunching:
(list2D_to_matrix [[C1 / √ 2]; [C1 / √ 2]] =
 / √ 2 .* (∣ 0 ⟩ .+ (-1) ^ false .* ∣ 1 ⟩))
Finished transaction in 46.263 secs (45.188u,0.534s) (successful)
Crunching:
(Hcase ⨂ hadamard × f_to_vec Hcase b =
 / √ (IZR (Z.of_N 2) ^ Hcase)
 .* big_sum
      (fun k : nat =>
       (-1) ^ product b (nat_to_funbool Hcase k) Hcase
       .* basis_vector (2 ^ Hcase) k) (2 ^ Hcase))
Crunching:
(Hcase ⨂ hadamard × f_to_vec Hcase b =
 / √ (IZR (Z.of_N 2) ^ Hcase)
 .* big_sum
      (fun k : nat =>
       (-1) ^ product b (nat_to_funbool Hcase k) Hcase
       .* basis_vector (2 ^ Hcase) k) (2 ^ Hcase))
Crunching:
(Hcase ⨂ hadamard × f_to_vec Hcase b =
 / √ (IZR (Z.of_N 2) ^ Hcase)
 .* big_sum
      (fun k : nat =>
       (-1) ^ product b (nat_to_funbool Hcase k) Hcase
       .* basis_vector (2 ^ Hcase) k) (2 ^ Hcase))
Crunching:
(Hcase ⨂ hadamard × f_to_vec Hcase b =
 / √ (IZR (Z.of_N 2) ^ Hcase)
 .* big_sum
      (fun k : nat =>
       (-1) ^ product b (nat_to_funbool Hcase k) Hcase
       .* basis_vector (2 ^ Hcase) k) (2 ^ Hcase))
Crunching:
((c > 0)%nat ->
 (fun x z : nat =>
  Σ (fun y : nat => (c ⨂ hadamard) x y * f_to_vec c q y z) (2 ^ c)) =
 (fun x y : nat =>
  / √ (2 ^ c) *
  big_sum
    (fun k x0 y0 : nat =>
     (-1) ^ product q (nat_to_funbool c k) c * basis_vector (2 ^ c) k x0 y0)
    (2 ^ c) x y))
Crunching:
(forall P : nat -> Type,
 (forall k : nat, (0 < k)%nat -> P k) ->
 ((forall k : nat, (0 < k)%nat -> P k) -> P 0%nat) -> P (S n))
Crunching: (0 <= a <= H -> H * a + a * H <= a * a + H * H)
Crunching: (Rmin a b > f <-> a > f /\ b > f)
Crunching:
(n ⨂ hadamard × n ⨂ ∣0⟩ =
 /
 √ (fix pow (r : R) (n : nat) {struct n} : R :=
      match n with
      | 0%nat => 1
      | S n0 => (r * pow r n0)%R
      end) 2 n .* big_sum (fun k : nat => basis_vector (2 ^ n) k) (2 ^ n))
Crunching:
((/
  √ (fix pow (r : R) (n : nat) {struct n} : R :=
       match n with
       | 0%nat => 1
       | S n0 => (r * pow r n0)%R
       end) 2 Eq2
  .* big_sum (fun k : nat => basis_vector (2 ^ Eq2) k) (2 ^ Eq2)) n alp = 0)
Crunching:
(n ⨂ hadamard × n ⨂ ∣0⟩ =
 /
 √ (fix pow (r : R) (n : nat) {struct n} : R :=
      match n with
      | 0%nat => 1
      | S n0 => (r * pow r n0)%R
      end) 2 n .* big_sum (fun k : nat => basis_vector (2 ^ n) k) (2 ^ n))
