Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 41 - 217 [Require~Import~Category.Core~F...] 1.108 secs (1.01u,0.097s)
Chars 218 - 248 [Require~Import~Basics.Tactics.] 0. secs (0.u,0.s)
Chars 250 - 276 [Set~Universe~Polymorphism.] 0. secs (0.u,0.s)
Chars 277 - 300 [Set~Implicit~Arguments.] 0. secs (0.u,0.s)
Chars 301 - 329 [Generalizable~Variables~all.] 0. secs (0.u,0.s)
Chars 330 - 354 [Set~Asymmetric~Patterns.] 0. secs (0.u,0.s)
Chars 356 - 384 [#[local]Open~Scope~path_scope.] 0. secs (0.u,0.s)
Chars 385 - 417 [#[local]Open~Scope~category_sc...] 0. secs (0.u,0.s)
Chars 418 - 450 [#[local]Open~Scope~morphism_sc...] 0. secs (0.u,0.s)
Chars 520 - 614 [Definition~NaturalIsomorphism~...] 0.001 secs (0.001u,0.s)
Chars 616 - 662 [Arguments~NaturalIsomorphism~{...] 0. secs (0.u,0.s)
Chars 664 - 775 [#[global]~Instance~reflexive_n...] 0.001 secs (0.001u,0.s)
Chars 777 - 947 [Coercion~natural_transformatio...] 0.001 secs (0.001u,0.s)
Chars 949 - 1022 [#[local]Infix~"<~=~>"~:=~Natur...] 0. secs (0.u,0.s)
Chars 1089 - 1206 [Definition~isisomorphism_compo...] 0.001 secs (0.001u,0.s)
Chars 1207 - 1213 [Proof.] 0. secs (0.u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 44 - 109 [Require~Import~Category.Core~D...] 1.164 secs (0.998u,0.165s)
Chars 110 - 164 [Require~Import~Types.Unit~Trun...] 0.001 secs (0.001u,0.s)
Chars 165 - 191 [Require~Import~Basics.Nat.] 0. secs (0.u,0.s)
Chars 193 - 219 [Set~Universe~Polymorphism.] 0. secs (0.u,0.s)
Chars 220 - 243 [Set~Implicit~Arguments.] 0. secs (0.u,0.s)
Chars 244 - 272 [Generalizable~Variables~all.] 0. secs (0.u,0.s)
Chars 273 - 297 [Set~Asymmetric~Patterns.] 0. secs (0.u,0.s)
Chars 298 - 325 [#[local]Open~Scope~nat_scope.] 0. secs (0.u,0.s)
Chars 327 - 346 [Module~Export~Core.] 0. secs (0.u,0.s)
Chars 563 - 740 [Fixpoint~CardinalityRepresenta...] 0. secs (0.u,0.s)
Chars 744 - 799 [Coercion~CardinalityRepresenta...] 0. secs (0.u,0.s)
Chars 834 - 934 [#[global]~Instance~trunc_cardi...] 0. secs (0.u,0.s)
Chars 937 - 943 [Proof.] 0. secs (0.u,0.s)
Chars 948 - 984 [(induction~n;~[~typeclasses~ea...] 0.661 secs (-0.554u,-0.053s)
Chars 1216 - 1232 [exists~(T^-1~x).] 5.194 secs (3.811u,0.174s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 46 - 115 [Require~Import~Category.Core~F...] 0.015 secs (0.011u,0.003s)
Chars 116 - 195 [Require~Import~Functor.Composi...] 0. secs (0.u,0.s)
Chars 196 - 360 [Require~Import~Category.Prod~F...] 1.04 secs (0.966u,0.073s)
Chars 361 - 404 [Require~Import~NaturalTransfor...] 0. secs (0.u,0.s)
Chars 405 - 425 [Require~ProductLaws.] 0.064 secs (0.061u,0.002s)
Chars 427 - 453 [Set~Universe~Polymorphism.] 0. secs (0.u,0.s)
Chars 454 - 477 [Set~Implicit~Arguments.] 0. secs (0.u,0.s)
Chars 478 - 506 [Generalizable~Variables~all.] 0. secs (0.u,0.s)
Chars 507 - 531 [Set~Asymmetric~Patterns.] 0. secs (0.u,0.s)
Chars 642 - 673 [Section~functorial_composition.] 0. secs (0.u,0.s)
Chars 676 - 694 [Context~`{Funext}.] 0. secs (0.u,0.s)
Chars 697 - 727 [Variables~(C~D~E~:~PreCategory).] 0. secs (0.u,0.s)
Chars 731 - 777 [#[local]Open~Scope~natural_tra...] 0. secs (0.u,0.s)
Chars 781 - 1144 [Definition~compose_functor_mor...] 0.005 secs (0.005u,0.s)
Chars 1148 - 1221 [Definition~compose_functor~:~o...] 0. secs (0.u,0.s)
Chars 1224 - 1230 [Proof.] 0. secs (0.u,0.s)
Chars 1235 - 1548 [(refine~~~(Build_Functor~(C~->...] 4.062 secs (0.033u,0.004s)
Chars 1235 - 1548 [(refine~~~(Build_Functor~(C~->...] 0. secs (0.u,0.s)
Chars 1551 - 1559 [Defined.] 0.002 secs (0.001u,0.s)
Chars 1563 - 1712 [Definition~compose_functor_unc...] 0.002 secs (0.002u,0.s)
Chars 1716 - 1917 [Definition~compose_functor'~:~...] 0.003 secs (0.003u,0.s)
Chars 1918 - 1945 [End~functorial_composition.] 0.002 secs (0.002u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 96 - 134 [Require~Import~HoTT.Basics~HoT...] 1.093 secs (0.955u,0.137s)
Chars 135 - 175 [Require~Import~HProp~Extension...] 2.113 secs (2.022u,0.09s)
Chars 176 - 204 [#[local]Open~Scope~path_scope.] 0. secs (0.u,0.s)
Chars 233 - 255 [Section~Factorization.] 0. secs (0.u,0.s)
Chars 258 - 273 [Universe~ctxi.] 0. secs (0.u,0.s)
Chars 440 - 707 [Context~{class1~class2~:~foral...] 0. secs (0.u,0.s)
Chars 820 - 1077 [Record~Factorization~:={~~~~~~...] 0.001 secs (0.001u,0.s)
Chars 1081 - 1248 [Lemma~issig_Factorization~:~~~...] 0.001 secs (0.001u,0.s)
Chars 1251 - 1257 [Proof.] 0. secs (0.u,0.s)
Chars 1262 - 1268 [issig.] 0.866 secs (0.169u,0.041s)
Chars 1262 - 1268 [issig.] 0. secs (0.u,0.s)
Chars 1271 - 1279 [Defined.] 0.014 secs (0.013u,0.s)
Chars 1374 - 1879 [Record~PathFactorization~{fact...] 0.005 secs (0.005u,0.s)
Chars 1882 - 1939 [Arguments~PathFactorization~fa...] 0. secs (0.u,0.s)
Chars 1943 - 2469 [Lemma~issig_PathFactorization~...] 0.003 secs (0.002u,0.001s)
Chars 2472 - 2478 [Proof.] 0. secs (0.u,0.s)
Chars 2483 - 2489 [issig.] 0.37 secs (0.083u,0.04s)
Chars 2483 - 2489 [issig.] 0. secs (0.u,0.s)
Chars 2492 - 2500 [Defined.] 0.022 secs (0.02u,0.001s)
Chars 2504 - 2648 [Definition~equiv_path_factoriz...] 0. secs (0.u,0.s)
Chars 2651 - 2657 [Proof.] 0. secs (0.u,0.s)
Chars 1216 - 1232 [exists~(T^-1~x).] 40.014 secs (0.002u,0.006s)
Chars 1235 - 1236 [-] 0. secs (0.u,0.s)
Chars 1237 - 1285 [exact~(apD10~(ap~components_of...] 0.001 secs (0.001u,0.s)
Chars 1288 - 1289 [-] 0. secs (0.u,0.s)
Chars 1290 - 1339 [exact~(apD10~(ap~components_of...] 0.001 secs (0.001u,0.s)
Chars 1216 - 1232 [exists~(T^-1~x).] 0. secs (0.u,0.s)
Chars 1237 - 1285 [exact~(apD10~(ap~components_of...] 0. secs (0.u,0.s)
Chars 1290 - 1339 [exact~(apD10~(ap~components_of...] 0. secs (0.u,0.s)
Chars 1340 - 1348 [Defined.] 0.001 secs (0.001u,0.s)
Chars 1350 - 1425 [#[export]Hint~Immediate~isisom...] 0. secs (0.u,0.s)
Chars 1565 - 1740 [#[export]~Hint~Extern~10~(@IsI...] 0. secs (0.u,0.s)
Chars 1742 - 1910 [Definition~inverse~`{Funext}~C...] 0. secs (0.u,0.s)
Chars 1911 - 1917 [Proof.] 0. secs (0.u,0.s)
Chars 948 - 984 [(induction~n;~[~typeclasses~ea...] 40.025 secs (0.001u,0.016s)
Chars 989 - 1025 [(induction~n;~[~typeclasses~ea...] 0.003 secs (0.001u,0.001s)
Chars 1030 - 1074 [(intros~[x|~x]~[y|~y];~typecla...] 0.037 secs (0.027u,0.009s)
Chars 948 - 984 [(induction~n;~[~typeclasses~ea...] 0. secs (0.u,0.s)
Chars 989 - 1025 [(induction~n;~[~typeclasses~ea...] 0. secs (0.u,0.s)
Chars 1030 - 1074 [(intros~[x|~x]~[y|~y];~typecla...] 0.001 secs (0.001u,0.s)
Chars 1077 - 1081 [Qed.] 0.003 secs (0.001u,0.001s)
Chars 1123 - 1304 [Definition~nat_category~(n~:~n...] 0.001 secs (0.001u,0.s)
Chars 1308 - 1347 [Module~Export~NatCategoryCoreN...] 0. secs (0.u,0.s)
Chars 1352 - 1402 [Notation~"0"~:=~(nat_category~...] 0. secs (0.u,0.s)
Chars 1407 - 1457 [Notation~"1"~:=~(nat_category~...] 0. secs (0.u,0.s)
Chars 1462 - 1512 [Notation~"2"~:=~(nat_category~...] 0. secs (0.u,0.s)
Chars 1517 - 1567 [Notation~"3"~:=~(nat_category~...] 0. secs (0.u,0.s)
Chars 1572 - 1622 [Notation~"4"~:=~(nat_category~...] 0. secs (0.u,0.s)
Chars 1627 - 1677 [Notation~"5"~:=~(nat_category~...] 0. secs (0.u,0.s)
Chars 1682 - 1732 [Notation~"6"~:=~(nat_category~...] 0. secs (0.u,0.s)
Chars 1737 - 1787 [Notation~"7"~:=~(nat_category~...] 0. secs (0.u,0.s)
Chars 1792 - 1842 [Notation~"8"~:=~(nat_category~...] 0. secs (0.u,0.s)
Chars 1847 - 1897 [Notation~"9"~:=~(nat_category~...] 0. secs (0.u,0.s)
Chars 1900 - 1929 [End~NatCategoryCoreNotations.] 0. secs (0.u,0.s)
Chars 1933 - 1980 [#[export]Typeclasses~Transpare...] 0. secs (0.u,0.s)
Chars 1983 - 2027 [#[export]Hint~Unfold~nat_categ...] 0. secs (0.u,0.s)
Chars 2030 - 2056 [Arguments~nat_category~/.] 0. secs (0.u,0.s)
Chars 2057 - 2066 [End~Core.] 0.002 secs (0.002u,0.s)
Chars 2068 - 2085 [Module~Notations.] 0. secs (0.u,0.s)
Chars 2088 - 2126 [Include~Core.NatCategoryCoreNo...] 0. secs (0.u,0.s)
Chars 2127 - 2141 [End~Notations.] 0. secs (0.u,0.s)
Chars 2662 - 2716 [refine~(_~oE~(issig_PathFactor...] 40.106 secs (0.001u,0.017s)
Chars 2721 - 2791 [(revert~fact~fact';~apply~(equ...] 0.002 secs (0.u,0.001s)
Chars 2796 - 2797 [{] 0. secs (0.u,0.s)
Chars 2798 - 2834 [(intros~[I~[f1~[f2~[ff~[oc1~oc...] 0.145 secs (0.112u,0.032s)
Chars 2841 - 2869 [(exists~(equiv_idmap~I);~cbn).] 0.049 secs (0.041u,0.007s)
Chars 2876 - 2908 [(exists~(fun~x~:~A~=>~1%path);...] 0.002 secs (0.002u,0.s)
Chars 2915 - 2947 [(exists~(fun~x~:~I~=>~1%path);...] 0.002 secs (0.002u,0.s)
Chars 2954 - 2978 [(intros;~apply~concat_1p).] 0.001 secs (0.001u,0.s)
Chars 2979 - 2980 [}] 0. secs (0.u,0.s)
Chars 2985 - 3021 [(intros~[I~[f1~[f2~[ff~[oc1~oc...] 0.07 secs (0.068u,0.001s)
Chars 3026 - 3062 [(contr_sigsig~I~(equiv_idmap~I...] 0.078 secs (0.077u,0.s)
Chars 3067 - 3115 [(contr_sigsig~f1~(fun~x~:~A~=>...] 0.028 secs (0.028u,0.s)
Chars 3120 - 3168 [(contr_sigsig~f2~(fun~x~:~I~=>...] 0.029 secs (0.029u,0.s)
Chars 3173 - 3230 [refine~(contr_equiv'~{ff'~:~f2...] 0.004 secs (0.004u,0.s)
Chars 3235 - 3300 [(symmetry;~srefine~(equiv_func...] 0.008 secs (0.008u,0.s)
Chars 3305 - 3306 [{] 0. secs (0.u,0.s)
Chars 3307 - 3321 [(intros~h;~cbn).] 0. secs (0.u,0.s)
Chars 3328 - 3440 [(srefine~(@istrunc_sigma~_~_~_...] 0.008 secs (0.008u,0.s)
Chars 3441 - 3442 [}] 0. secs (0.u,0.s)
Chars 3447 - 3477 [(intros~[ff'~[oc1'~oc2']];~cbn).] 0.004 secs (0.004u,0.s)
Chars 3482 - 3541 [(refine~(equiv_functor_forall'...] 0.002 secs (0.002u,0.s)
Chars 3546 - 3583 [refine~(equiv_path_inverse~_~_...] 0.001 secs (0.001u,0.s)
Chars 3588 - 3636 [(apply~equiv_concat_l;~symmetr...] 0.003 secs (0.003u,0.s)
Chars 2662 - 2716 [refine~(_~oE~(issig_PathFactor...] 0. secs (0.u,0.s)
Chars 2721 - 2791 [(revert~fact~fact';~apply~(equ...] 0.001 secs (0.001u,0.s)
Chars 2798 - 2834 [(intros~[I~[f1~[f2~[ff~[oc1~oc...] 0. secs (0.u,0.s)
Chars 2841 - 2869 [(exists~(equiv_idmap~I);~cbn).] 0.02 secs (0.02u,0.s)
Chars 2876 - 2908 [(exists~(fun~x~:~A~=>~1%path);...] 0.001 secs (0.001u,0.s)
Chars 2915 - 2947 [(exists~(fun~x~:~I~=>~1%path);...] 0. secs (0.u,0.s)
Chars 2954 - 2978 [(intros;~apply~concat_1p).] 0. secs (0.u,0.s)
Chars 2985 - 3021 [(intros~[I~[f1~[f2~[ff~[oc1~oc...] 0.001 secs (0.001u,0.s)
Chars 3026 - 3062 [(contr_sigsig~I~(equiv_idmap~I...] 0.014 secs (0.014u,0.s)
Chars 3067 - 3115 [(contr_sigsig~f1~(fun~x~:~A~=>...] 0.002 secs (0.002u,0.s)
Chars 3120 - 3168 [(contr_sigsig~f2~(fun~x~:~I~=>...] 0.001 secs (0.001u,0.s)
Chars 3173 - 3230 [refine~(contr_equiv'~{ff'~:~f2...] 0. secs (0.u,0.s)
Chars 3235 - 3300 [(symmetry;~srefine~(equiv_func...] 0.001 secs (0.001u,0.s)
Chars 3307 - 3321 [(intros~h;~cbn).] 0. secs (0.u,0.s)
Chars 3328 - 3440 [(srefine~(@istrunc_sigma~_~_~_...] 0.001 secs (0.001u,0.s)
Chars 3447 - 3477 [(intros~[ff'~[oc1'~oc2']];~cbn).] 0.002 secs (0.002u,0.s)
Chars 3482 - 3541 [(refine~(equiv_functor_forall'...] 0. secs (0.u,0.s)
Chars 3546 - 3583 [refine~(equiv_path_inverse~_~_...] 0. secs (0.u,0.s)
Chars 3588 - 3636 [(apply~equiv_concat_l;~symmetr...] 0.001 secs (0.001u,0.s)
Chars 3639 - 3647 [Defined.] 0.068 secs (0.068u,0.s)
Chars 3651 - 3818 [Definition~path_factorization~...] 0. secs (0.u,0.s)
Chars 3820 - 3838 [End~Factorization.] 0.102 secs (0.102u,0.s)
Chars 3840 - 3886 [Arguments~Factorization~class1...] 0. secs (0.u,0.s)
Chars 3887 - 3948 [Arguments~PathFactorization~{c...] 0. secs (0.u,0.s)
Chars 4117 - 4169 [Coercion~intermediate~:~Factor...] 0. secs (0.u,0.s)
Chars 4379 - 5920 [Record~FactorizationSystem@{i~...] 0.006 secs (0.006u,0.s)
Chars 5922 - 5978 [#[global]Existing~Instances~is...] 0. secs (0.u,0.s)
Chars 6045 - 6210 [Theorem~contr_factor~`{Univale...] 0. secs (0.u,0.s)
Chars 6211 - 6217 [Proof.] 0. secs (0.u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 0 - 93 [Require~Import~HoTT.Types.Univ...] 0.628 secs (0.501u,0.126s)
Chars 94 - 152 [Require~Export~HoTT.Classes.in...] 5.07 secs (4.882u,0.186s)
Chars 153 - 194 [Require~Import~HoTT.Classes.th...] 0.163 secs (0.145u,0.018s)
Chars 197 - 214 [Module~SemiRings.] 0. secs (0.u,0.s)
Chars 216 - 304 [Class~Operations~:=~~~~~operat...] 0.001 secs (0.001u,0.s)
Chars 306 - 434 [Definition~BuildOperations~(T~...] 0.002 secs (0.002u,0.s)
Chars 436 - 487 [Coercion~SR_carrier~(s~:~Opera...] 0. secs (0.u,0.s)
Chars 488 - 561 [#[global]~Instance~SR_plus~~(s...] 0. secs (0.u,0.s)
Chars 562 - 635 [#[global]~Instance~SR_mult~~(s...] 0. secs (0.u,0.s)
Chars 636 - 703 [#[global]Instance~SR_zero~~(s~...] 0. secs (0.u,0.s)
Chars 704 - 763 [#[global]Instance~SR_one~~(s~:...] 0. secs (0.u,0.s)
Chars 765 - 792 [Arguments~SR_plus~!_~/~_~_.] 0. secs (0.u,0.s)
Chars 793 - 820 [Arguments~SR_mult~!_~/~_~_.] 0. secs (0.u,0.s)
Chars 821 - 844 [Arguments~SR_zero~!_~/.] 0. secs (0.u,0.s)
Chars 845 - 867 [Arguments~SR_one~!_~/.] 0. secs (0.u,0.s)
Chars 870 - 887 [Section~contents.] 0. secs (0.u,0.s)
Chars 888 - 901 [Universe~U,V.] 0. secs (0.u,0.s)
Chars 902 - 934 [Context~`{Funext}~`{Univalence}.] 0. secs (0.u,0.s)
Chars 935 - 968 [Context~(A~B~:~Operations@{U~V}).] 0. secs (0.u,0.s)
Chars 970 - 1032 [Context~(f~:~A~->~B)~`{!IsEqui...] 0.002 secs (0.001u,0.s)
Chars 1034 - 1067 [Lemma~iso_same_semirings~:~A~=~B.] 0. secs (0.u,0.s)
Chars 1068 - 1074 [Proof.] 0. secs (0.u,0.s)
Chars 1920 - 2075 [(exists~(fun~x~=>~(T~x)^-1);~~...] 40.066 secs (0.009u,0.007s)
Chars 1920 - 2075 [(exists~(fun~x~=>~(T~x)^-1);~~...] 0. secs (0.u,0.s)
Chars 2076 - 2084 [Defined.] 0.001 secs (0.001u,0.s)
Chars 2151 - 2336 [Definition~isisomorphism_natur...] 0.001 secs (0.001u,0.s)
Chars 2337 - 2343 [Proof.] 0. secs (0.u,0.s)
Chars 2346 - 2489 [(exists~(inverse~_);~~~abstrac...] 1.434 secs (0.008u,0.006s)
Chars 2346 - 2489 [(exists~(inverse~_);~~~abstrac...] 0. secs (0.u,0.s)
Chars 2490 - 2498 [Defined.] 0.001 secs (0.001u,0.s)
Chars 2500 - 2584 [#[export]~Hint~Immediate~isiso...] 0. secs (0.u,0.s)
Chars 2645 - 2661 [Section~idtoiso.] 0. secs (0.u,0.s)
Chars 2664 - 2682 [Context~`{Funext}.] 0. secs (0.u,0.s)
Chars 2685 - 2713 [Variables~(C~D~:~PreCategory).] 0. secs (0.u,0.s)
Chars 2717 - 2851 [Definition~idtoiso_natural_tra...] 0. secs (0.u,0.s)
Chars 2854 - 2860 [Proof.] 0. secs (0.u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 72 - 316 [Require~Import~HoTT.Types.Sigm...] 6.273 secs (5.932u,0.34s)
Chars 318 - 420 [Import~algebra_notations~quoti...] 0. secs (0.u,0.s)
Chars 422 - 467 [#[local]Notation~i~:=~(hom_inc...] 0. secs (0.u,0.s)
Chars 600 - 619 [Section~cong_trace.] 0. secs (0.u,0.s)
Chars 622 - 783 [Context~{σ~:~Signature}~{A~:~A...] 0.001 secs (0.001u,0.s)
Chars 787 - 881 [Definition~cong_trace~(s~:~Sor...] 0.001 secs (0.001u,0.s)
Chars 885 - 972 [#[global]~Instance~equiv_rel_t...] 0. secs (0.u,0.s)
Chars 975 - 981 [Proof.] 0. secs (0.u,0.s)
Chars 1075 - 1102 [(apply~path_sigma_uncurried).] 23.034 secs (0.001u,0.02s)
Chars 1103 - 1184 [(destruct~A~as~[TA~[[[plA~mlA]...] 0.061 secs (0.052u,0.008s)
Chars 1185 - 1426 [(change~plA~with~(@plus~TA~plA...] 0.008 secs (0.006u,0.002s)
Chars 1427 - 1452 [exists~(path_universe~f).] 0.003 secs (0.003u,0.s)
Chars 1453 - 1483 [(rewrite~!transport_prod;~simpl).] 0.014 secs (0.011u,0.002s)
Chars 1484 - 1510 [(unfold~Plus,~Mult,~Zero,~One).] 0.001 secs (0.001u,0.s)
Chars 1511 - 1713 [(repeat~apply~path_prod;~simpl...] 0.039 secs (0.032u,0.006s)
Chars 1714 - 1715 [-] 0. secs (0.u,0.s)
Chars 1716 - 1748 [(rewrite~(preserves_plus~(f:=f...] 0.003 secs (0.002u,0.s)
Chars 1751 - 1777 [(apply~ap011;~apply~eisretr).] 0.002 secs (0.002u,0.s)
Chars 1778 - 1779 [-] 0. secs (0.u,0.s)
Chars 1780 - 1812 [(rewrite~(preserves_mult~(f:=f...] 0.002 secs (0.002u,0.s)
Chars 1815 - 1841 [(apply~ap011;~apply~eisretr).] 0.002 secs (0.001u,0.s)
Chars 1842 - 1843 [-] 0. secs (0.u,0.s)
Chars 1844 - 1862 [(apply~preserves_0).] 0.001 secs (0.001u,0.s)
Chars 1863 - 1864 [-] 0. secs (0.u,0.s)
Chars 1865 - 1883 [(apply~preserves_1).] 0.001 secs (0.u,0.s)
Chars 1075 - 1102 [(apply~path_sigma_uncurried).] 0. secs (0.u,0.s)
Chars 1103 - 1184 [(destruct~A~as~[TA~[[[plA~mlA]...] 0.003 secs (0.003u,0.s)
Chars 1185 - 1426 [(change~plA~with~(@plus~TA~plA...] 0.005 secs (0.004u,0.s)
Chars 1427 - 1452 [exists~(path_universe~f).] 0. secs (0.u,0.s)
Chars 1453 - 1483 [(rewrite~!transport_prod;~simpl).] 0.001 secs (0.001u,0.s)
Chars 1484 - 1510 [(unfold~Plus,~Mult,~Zero,~One).] 0. secs (0.u,0.s)
Chars 1511 - 1713 [(repeat~apply~path_prod;~simpl...] 0.01 secs (0.008u,0.001s)
Chars 1716 - 1748 [(rewrite~(preserves_plus~(f:=f...] 0. secs (0.u,0.s)
Chars 1751 - 1777 [(apply~ap011;~apply~eisretr).] 0. secs (0.u,0.s)
Chars 1780 - 1812 [(rewrite~(preserves_mult~(f:=f...] 0. secs (0.u,0.s)
Chars 1815 - 1841 [(apply~ap011;~apply~eisretr).] 0. secs (0.u,0.s)
Chars 1844 - 1862 [(apply~preserves_0).] 0. secs (0.u,0.s)
Chars 1865 - 1883 [(apply~preserves_1).] 0. secs (0.u,0.s)
Chars 1884 - 1888 [Qed.] 0.026 secs (0.022u,0.003s)
Chars 1890 - 1953 [Lemma~iso_leibnitz~:~forall~P~...] 0. secs (0.u,0.s)
Chars 1954 - 1960 [Proof.] 0. secs (0.u,0.s)
Chars 6220 - 6248 [(apply~contr_inhabited_hprop).] 40.074 secs (0.u,0.017s)
Chars 6251 - 6252 [-] 0. secs (0.u,0.s)
Chars 6253 - 6273 [(apply~hprop_allpath).] 0. secs (0.u,0.s)
Chars 6278 - 6296 [(intros~fact~fact').] 0. secs (0.u,0.s)
Chars 6301 - 6339 [(apply~path_factorization;~try...] 0.012 secs (0.008u,0.003s)
Chars 6344 - 6362 [(apply~path_factor).] 0. secs (0.u,0.s)
Chars 6365 - 6366 [-] 0. secs (0.u,0.s)
Chars 6367 - 6380 [(apply~factor).] 0. secs (0.u,0.s)
Chars 6220 - 6248 [(apply~contr_inhabited_hprop).] 0. secs (0.u,0.s)
Chars 6253 - 6273 [(apply~hprop_allpath).] 0. secs (0.u,0.s)
Chars 6278 - 6296 [(intros~fact~fact').] 0. secs (0.u,0.s)
Chars 6301 - 6339 [(apply~path_factorization;~try...] 0. secs (0.u,0.s)
Chars 6344 - 6362 [(apply~path_factor).] 0. secs (0.u,0.s)
Chars 6367 - 6380 [(apply~factor).] 0. secs (0.u,0.s)
Chars 6381 - 6389 [Defined.] 0. secs (0.u,0.s)
Chars 6391 - 6407 [Section~FactSys.] 0. secs (0.u,0.s)
Chars 6411 - 6451 [Context~(factsys~:~Factorizati...] 0. secs (0.u,0.s)
Chars 6455 - 6561 [Definition~Build_Factorization...] 0. secs (0.u,0.s)
Chars 6565 - 6679 [Definition~Build_PathFactoriza...] 0. secs (0.u,0.s)
Chars 6769 - 6906 [Definition~cancelR_class1~`{Fu...] 0.001 secs (0.001u,0.s)
Chars 6909 - 6915 [Proof.] 0. secs (0.u,0.s)
Chars 2865 - 3172 [(refine~~~(Build_NaturalTransf...] 40.068 secs (0.01u,0.006s)
Chars 2865 - 3172 [(refine~~~(Build_NaturalTransf...] 0.003 secs (0.003u,0.s)
Chars 3175 - 3183 [Defined.] 0.022 secs (0.019u,0.002s)
Chars 3187 - 3282 [Definition~idtoiso~(F~G~:~obje...] 0. secs (0.u,0.s)
Chars 3285 - 3291 [Proof.] 0. secs (0.u,0.s)
Chars 3296 - 3338 [exists~(idtoiso_natural_transf...] 0.054 secs (0.001u,0.007s)
Chars 3343 - 3474 [(exists~(idtoiso_natural_trans...] 0.013 secs (0.012u,0.001s)
Chars 3296 - 3338 [exists~(idtoiso_natural_transf...] 0. secs (0.u,0.s)
Chars 3343 - 3474 [(exists~(idtoiso_natural_trans...] 0. secs (0.u,0.s)
Chars 3477 - 3485 [Defined.] 0.002 secs (0.002u,0.s)
Chars 3489 - 3597 [Lemma~eta_idtoiso~(F~G~:~objec...] 0. secs (0.u,0.s)
Chars 3600 - 3606 [Proof.] 0. secs (0.u,0.s)
Chars 3611 - 3618 [(case~T).] 2.7 secs (0.001u,0.007s)
Chars 3623 - 3636 [(expand;~f_ap).] 0.003 secs (0.003u,0.s)
Chars 3641 - 3658 [exact~(center~_).] 0.002 secs (0.002u,0.s)
Chars 3611 - 3618 [(case~T).] 0. secs (0.u,0.s)
Chars 3623 - 3636 [(expand;~f_ap).] 0. secs (0.u,0.s)
Chars 3641 - 3658 [exact~(center~_).] 0. secs (0.u,0.s)
Chars 3661 - 3665 [Qed.] 0.003 secs (0.003u,0.s)
Chars 3666 - 3678 [End~idtoiso.] 0.008 secs (0.008u,0.s)
Chars 3680 - 3728 [Module~Export~FunctorCategoryM...] 0. secs (0.u,0.s)
Chars 3731 - 3798 [Infix~"<~=~>"~:=~NaturalIsomor...] 0. secs (0.u,0.s)
Chars 3799 - 3837 [End~FunctorCategoryMorphismsNo...] 0. secs (0.u,0.s)
Chars 986 - 1004 [(unfold~cong_trace).] 40.078 secs (0.u,0.019s)
Chars 1009 - 1021 [constructor.] 0. secs (0.u,0.s)
Chars 1026 - 1027 [-] 0. secs (0.u,0.s)
Chars 1028 - 1041 [(intros~[y~Y]).] 0.001 secs (0.001u,0.s)
Chars 1042 - 1054 [reflexivity.] 0.002 secs (0.002u,0.s)
Chars 1059 - 1060 [-] 0. secs (0.u,0.s)
Chars 1061 - 1086 [(intros~[y1~Y1]~[y2~Y2]~S).] 0.002 secs (0.001u,0.s)
Chars 1087 - 1099 [by~symmetry.] 0.002 secs (0.002u,0.s)
Chars 1104 - 1105 [-] 0. secs (0.u,0.s)
Chars 1106 - 1141 [(intros~[y1~Y1]~[y2~Y2]~[y3~Y3...] 0.003 secs (0.002u,0.s)
Chars 1142 - 1161 [by~transitivity~y2.] 0.003 secs (0.002u,0.s)
Chars 986 - 1004 [(unfold~cong_trace).] 0. secs (0.u,0.s)
Chars 1009 - 1021 [constructor.] 0. secs (0.u,0.s)
Chars 1028 - 1041 [(intros~[y~Y]).] 0. secs (0.u,0.s)
Chars 1042 - 1054 [reflexivity.] 0. secs (0.u,0.s)
Chars 1061 - 1086 [(intros~[y1~Y1]~[y2~Y2]~S).] 0. secs (0.u,0.s)
Chars 1087 - 1099 [by~symmetry.] 0. secs (0.u,0.s)
Chars 1106 - 1141 [(intros~[y1~Y1]~[y2~Y2]~[y3~Y3...] 0. secs (0.u,0.s)
Chars 1142 - 1161 [by~transitivity~y2.] 0. secs (0.u,0.s)
Chars 1164 - 1168 [Qed.] 0.003 secs (0.002u,0.s)
Chars 1172 - 1434 [Lemma~for_all_2_family_prod_tr...] 0.005 secs (0.003u,0.002s)
Chars 1437 - 1463 [Proof~with~(try~assumption).] 0. secs (0.u,0.s)
Chars 1961 - 1986 [(intros~P;~apply~transport).] 40.088 secs (0.001u,0.019s)
Chars 2058 - 2122 [(first~[~exact~iso_same_semiri...] 0. secs (0.u,0.s)
Chars 1961 - 1986 [(intros~P;~apply~transport).] 0. secs (0.u,0.s)
Chars 2058 - 2122 [(first~[~exact~iso_same_semiri...] 0. secs (0.u,0.s)
Chars 2123 - 2127 [Qed.] 0. secs (0.u,0.s)
Chars 2129 - 2142 [End~contents.] 0.05 secs (0.037u,0.012s)
Chars 2144 - 2158 [End~SemiRings.] 0.025 secs (0.023u,0.001s)
Chars 2160 - 2173 [Module~Rings.] 0. secs (0.u,0.s)
Chars 2175 - 2274 [Class~Operations~:=~~~~~operat...] 0.001 secs (0.001u,0.s)
Chars 2276 - 2425 [Definition~BuildOperations~(T~...] 0.003 secs (0.002u,0.s)
Chars 2427 - 2477 [Coercion~R_carrier~(s~:~Operat...] 0. secs (0.u,0.s)
Chars 2478 - 2556 [#[global]~Instance~R_plus~~(s~...] 0.001 secs (0.001u,0.s)
Chars 2557 - 2635 [#[global]~Instance~R_mult~~(s~...] 0.001 secs (0.u,0.s)
Chars 2636 - 2708 [#[global]~Instance~R_zero~~(s~...] 0.001 secs (0.001u,0.s)
Chars 2709 - 2773 [#[global]Instance~R_one~~(s~:~...] 0. secs (0.u,0.s)
Chars 2774 - 2838 [#[global]Instance~R_negate~~(s...] 0. secs (0.u,0.s)
Chars 2840 - 2866 [Arguments~R_plus~!_~/~_~_.] 0. secs (0.u,0.s)
Chars 2867 - 2893 [Arguments~R_mult~!_~/~_~_.] 0. secs (0.u,0.s)
Chars 2894 - 2916 [Arguments~R_zero~!_~/.] 0. secs (0.u,0.s)
Chars 2917 - 2938 [Arguments~R_one~!_~/.] 0. secs (0.u,0.s)
Chars 2939 - 2965 [Arguments~R_negate~!_~/~_.] 0. secs (0.u,0.s)
Chars 2967 - 2984 [Section~contents.] 0. secs (0.u,0.s)
Chars 2985 - 2998 [Universe~U,V.] 0. secs (0.u,0.s)
Chars 2999 - 3031 [Context~`{Funext}~`{Univalence}.] 0. secs (0.u,0.s)
Chars 3032 - 3065 [Context~(A~B~:~Operations@{U~V}).] 0. secs (0.u,0.s)
Chars 3128 - 3216 [Context~(f~:~A~->~B)~`{!IsEqui...] 0.004 secs (0.004u,0.s)
Chars 3218 - 3247 [Lemma~iso_same_rings~:~A~=~B.] 0. secs (0.u,0.s)
Chars 3248 - 3254 [Proof.] 0. secs (0.u,0.s)
Chars 6920 - 6936 [(intros~c1f~c1gf).] 40.076 secs (0.u,0.018s)
Chars 6941 - 6995 [(destruct~(factor~factsys~g)~a...] 0.002 secs (0.002u,0.s)
Chars 7000 - 7133 [(pose~~~(fact~:=~~~~Build_Fact...] 0.003 secs (0.003u,0.s)
Chars 7138 - 7303 [(pose~~~(fact'~:=~~~~Build_Fac...] 0.003 secs (0.003u,0.s)
Chars 7308 - 7399 [(destruct~(path_factor~factsys...] 0.007 secs (0.005u,0.001s)
Chars 7404 - 7462 [refine~(transport~(class1~fact...] 0.002 secs (0.u,0.002s)
Chars 7467 - 7512 [refine~(class1_compose~factsys...] 0.001 secs (0.001u,0.s)
Chars 7517 - 7538 [(apply~class1_isequiv).] 0.001 secs (0.001u,0.s)
Chars 7543 - 7590 [(apply~(isequiv_homotopic~_~(f...] 0.003 secs (0.002u,0.s)
Chars 6920 - 6936 [(intros~c1f~c1gf).] 0. secs (0.u,0.s)
Chars 6941 - 6995 [(destruct~(factor~factsys~g)~a...] 0. secs (0.u,0.s)
Chars 7000 - 7133 [(pose~~~(fact~:=~~~~Build_Fact...] 0. secs (0.u,0.s)
Chars 7138 - 7303 [(pose~~~(fact'~:=~~~~Build_Fac...] 0. secs (0.u,0.s)
Chars 7308 - 7399 [(destruct~(path_factor~factsys...] 0.001 secs (0.001u,0.s)
Chars 7404 - 7462 [refine~(transport~(class1~fact...] 0. secs (0.u,0.s)
Chars 7467 - 7512 [refine~(class1_compose~factsys...] 0. secs (0.u,0.s)
Chars 7517 - 7538 [(apply~class1_isequiv).] 0. secs (0.u,0.s)
Chars 7543 - 7590 [(apply~(isequiv_homotopic~_~(f...] 0. secs (0.u,0.s)
Chars 7593 - 7601 [Defined.] 0.001 secs (0.001u,0.s)
Chars 7605 - 7742 [Definition~cancelL_class2~`{Fu...] 0.001 secs (0.001u,0.s)
Chars 7745 - 7751 [Proof.] 0. secs (0.u,0.s)
Chars 1468 - 1482 [(induction~w)~...] 40.087 secs (0.001u,0.02s)
Chars 1487 - 1531 [(destruct~a~as~[x~a],~b~as~[y~...] 0.008 secs (0.007u,0.s)
Chars 1536 - 1544 [split~...] 0.003 secs (0.003u,0.s)
Chars 1549 - 1561 [(apply~IHw)~...] 0.002 secs (0.001u,0.s)
Chars 1468 - 1482 [(induction~w)~...] 0. secs (0.u,0.s)
Chars 1487 - 1531 [(destruct~a~as~[x~a],~b~as~[y~...] 0. secs (0.u,0.s)
Chars 1536 - 1544 [split~...] 0.001 secs (0.u,0.001s)
Chars 1549 - 1561 [(apply~IHw)~...] 0.001 secs (0.001u,0.s)
Chars 1564 - 1568 [Qed.] 0.007 secs (0.006u,0.s)
Chars 1572 - 1653 [#[global]~Instance~ops_compati...] 0. secs (0.u,0.s)
Chars 1656 - 1662 [Proof.] 0. secs (0.u,0.s)
Chars 3255 - 3282 [(apply~path_sigma_uncurried).] 40.083 secs (0.u,0.02s)
Chars 3283 - 3376 [(destruct~A~as~[TA~[[[[plA~mlA...] 0.1 secs (0.072u,0.027s)
Chars 3377 - 3681 [(change~plA~with~(@plus~TA~plA...] 0.011 secs (0.011u,0.s)
Chars 3682 - 3707 [exists~(path_universe~f).] 0.003 secs (0.002u,0.s)
Chars 3708 - 3738 [(rewrite~!transport_prod;~simpl).] 0.022 secs (0.021u,0.s)
Chars 3739 - 3772 [(unfold~Plus,~Mult,~Zero,~One,...] 0.001 secs (0.001u,0.s)
Chars 3773 - 3981 [(repeat~apply~path_prod;~simpl...] 0.054 secs (0.041u,0.013s)
Chars 3982 - 3983 [-] 0. secs (0.u,0.s)
Chars 3984 - 4016 [(rewrite~(preserves_plus~(f:=f...] 0.003 secs (0.002u,0.s)
Chars 4019 - 4045 [(apply~ap011;~apply~eisretr).] 0.002 secs (0.002u,0.s)
Chars 4046 - 4047 [-] 0. secs (0.u,0.s)
Chars 4048 - 4080 [(rewrite~(preserves_mult~(f:=f...] 0.003 secs (0.002u,0.s)
Chars 4083 - 4109 [(apply~ap011;~apply~eisretr).] 0.002 secs (0.001u,0.s)
Chars 4110 - 4111 [-] 0. secs (0.u,0.s)
Chars 4112 - 4130 [(apply~preserves_0).] 0.002 secs (0.002u,0.s)
Chars 4131 - 4132 [-] 0. secs (0.u,0.s)
Chars 4133 - 4151 [(apply~preserves_1).] 0.016 secs (0.015u,0.s)
Chars 4152 - 4153 [-] 0. secs (0.u,0.s)
Chars 4154 - 4188 [(rewrite~(preserves_negate~(f:...] 0.003 secs (0.002u,0.s)
Chars 4191 - 4208 [(apply~ap,~eisretr).] 0.001 secs (0.001u,0.s)
Chars 3255 - 3282 [(apply~path_sigma_uncurried).] 0. secs (0.u,0.s)
Chars 3283 - 3376 [(destruct~A~as~[TA~[[[[plA~mlA...] 0.004 secs (0.003u,0.s)
Chars 3377 - 3681 [(change~plA~with~(@plus~TA~plA...] 0.008 secs (0.008u,0.s)
Chars 3682 - 3707 [exists~(path_universe~f).] 0. secs (0.u,0.s)
Chars 3708 - 3738 [(rewrite~!transport_prod;~simpl).] 0.002 secs (0.002u,0.s)
Chars 3739 - 3772 [(unfold~Plus,~Mult,~Zero,~One,...] 0.001 secs (0.001u,0.s)
Chars 3773 - 3981 [(repeat~apply~path_prod;~simpl...] 0.014 secs (0.012u,0.002s)
Chars 3984 - 4016 [(rewrite~(preserves_plus~(f:=f...] 0. secs (0.u,0.s)
Chars 4019 - 4045 [(apply~ap011;~apply~eisretr).] 0.001 secs (0.001u,0.s)
Chars 4048 - 4080 [(rewrite~(preserves_mult~(f:=f...] 0. secs (0.u,0.s)
Chars 4083 - 4109 [(apply~ap011;~apply~eisretr).] 0. secs (0.u,0.s)
Chars 4112 - 4130 [(apply~preserves_0).] 0. secs (0.u,0.s)
Chars 4133 - 4151 [(apply~preserves_1).] 0. secs (0.u,0.s)
Chars 4154 - 4188 [(rewrite~(preserves_negate~(f:...] 0. secs (0.u,0.s)
Chars 4191 - 4208 [(apply~ap,~eisretr).] 0. secs (0.u,0.s)
Chars 4209 - 4213 [Qed.] 0.036 secs (0.035u,0.s)
Chars 4215 - 4278 [Lemma~iso_leibnitz~:~forall~P~...] 0. secs (0.u,0.s)
Chars 4279 - 4285 [Proof.] 0. secs (0.u,0.s)
Chars 7756 - 7772 [(intros~c2g~c2gf).] 40.08 secs (0.002u,0.015s)
Chars 7777 - 7831 [(destruct~(factor~factsys~f)~a...] 0.002 secs (0.001u,0.s)
Chars 7836 - 7969 [(pose~~~(fact~:=~~~~Build_Fact...] 0.003 secs (0.002u,0.001s)
Chars 7974 - 8142 [(pose~~~(fact'~:=~~~~Build_Fac...] 0.002 secs (0.002u,0.s)
Chars 8147 - 8238 [(destruct~(path_factor~factsys...] 0.024 secs (0.016u,0.007s)
Chars 8243 - 8301 [refine~(transport~(class2~fact...] 0.002 secs (0.002u,0.s)
Chars 8306 - 8351 [refine~(class2_compose~factsys...] 0.001 secs (0.001u,0.s)
Chars 8356 - 8377 [(apply~class2_isequiv).] 0.001 secs (0.001u,0.s)
Chars 8382 - 8413 [(apply~(isequiv_homotopic~_~q1)).] 0.008 secs (0.008u,0.s)
Chars 7756 - 7772 [(intros~c2g~c2gf).] 0. secs (0.u,0.s)
Chars 7777 - 7831 [(destruct~(factor~factsys~f)~a...] 0. secs (0.u,0.s)
Chars 7836 - 7969 [(pose~~~(fact~:=~~~~Build_Fact...] 0. secs (0.u,0.s)
Chars 7974 - 8142 [(pose~~~(fact'~:=~~~~Build_Fac...] 0. secs (0.u,0.s)
Chars 8147 - 8238 [(destruct~(path_factor~factsys...] 0.001 secs (0.001u,0.s)
Chars 8243 - 8301 [refine~(transport~(class2~fact...] 0. secs (0.u,0.s)
Chars 8306 - 8351 [refine~(class2_compose~factsys...] 0. secs (0.u,0.s)
Chars 8356 - 8377 [(apply~class2_isequiv).] 0. secs (0.u,0.s)
Chars 8382 - 8413 [(apply~(isequiv_homotopic~_~q1)).] 0. secs (0.u,0.s)
Chars 8416 - 8424 [Defined.] 0.001 secs (0.001u,0.s)
Chars 8702 - 8716 [Universe~ctxi.] 0. secs (0.u,0.s)
Chars 8719 - 8904 [Context~{A~B~X~Y~:~Type@{ctxi}...] 0.001 secs (0.001u,0.s)
Chars 8937 - 8994 [Let~C~:~Type~:=~intermediate~(...] 0. secs (0.u,0.s)
Chars 8997 - 9054 [Let~f1~:~A~->~C~:=~factor1~(fa...] 0. secs (0.u,0.s)
Chars 9057 - 9114 [Let~f2~:~C~->~X~:=~factor2~(fa...] 0. secs (0.u,0.s)
Chars 9117 - 9174 [Let~ff~:~f2~o~f1~==~f~:=~fact_...] 0.001 secs (0.u,0.001s)
Chars 9195 - 9252 [Let~D~:~Type~:=~intermediate~(...] 0. secs (0.u,0.s)
Chars 9255 - 9312 [Let~g1~:~B~->~D~:=~factor1~(fa...] 0. secs (0.u,0.s)
Chars 9315 - 9372 [Let~g2~:~D~->~Y~:=~factor2~(fa...] 0. secs (0.u,0.s)
Chars 9375 - 9432 [Let~gf~:~g2~o~g1~==~g~:=~fact_...] 0.001 secs (0.001u,0.s)
Chars 9646 - 10008 [Let~fact~:~Factorization~(@cla...] 0.003 secs (0.003u,0.s)
Chars 10011 - 10346 [Let~fact'~:~Factorization~(@cl...] 0.003 secs (0.003u,0.s)
Chars 10449 - 10570 [Let~q~:~C~<~>~D~:=~path_interm...] 0.001 secs (0.001u,0.s)
Chars 10573 - 10689 [Let~q1~:~q~o~f1~==~g1~o~i~:=~~...] 0.002 secs (0.002u,0.s)
Chars 10692 - 10808 [Let~q2~:~p~o~f2~==~g2~o~q~:=~~...] 0.002 secs (0.001u,0.s)
Chars 10857 - 10912 [Definition~lift_factsys~:~B~->...] 0.007 secs (0.005u,0.001s)
Chars 10972 - 11025 [Definition~lift_factsys_tri1~:...] 0. secs (0.u,0.s)
Chars 11028 - 11034 [Proof.] 0. secs (0.u,0.s)
Chars 11039 - 11048 [(intros~x).] 18.304 secs (0.001u,0.017s)
Chars 11053 - 11089 [refine~(ap~(f2~o~q^-1)~(q1~x)^...] 0.003 secs (0.002u,0.s)
Chars 11094 - 11119 [transitivity~(f2~(f1~x)).] 0.004 secs (0.003u,0.s)
Chars 11124 - 11125 [+] 0. secs (0.u,0.s)
Chars 11126 - 11144 [(apply~ap,~eissect).] 0.002 secs (0.002u,0.s)
Chars 11149 - 11150 [+] 0. secs (0.u,0.s)
Chars 11151 - 11160 [(apply~ff).] 0.001 secs (0.001u,0.s)
Chars 11039 - 11048 [(intros~x).] 0.001 secs (0.001u,0.s)
Chars 11053 - 11089 [refine~(ap~(f2~o~q^-1)~(q1~x)^...] 0.001 secs (0.001u,0.s)
Chars 11094 - 11119 [transitivity~(f2~(f1~x)).] 0.001 secs (0.001u,0.s)
Chars 11126 - 11144 [(apply~ap,~eissect).] 0.001 secs (0.u,0.001s)
Chars 11151 - 11160 [(apply~ff).] 0.001 secs (0.001u,0.s)
Chars 11163 - 11171 [Defined.] 0. secs (0.u,0.s)
Chars 11175 - 11228 [Definition~lift_factsys_tri2~:...] 0. secs (0.u,0.s)
Chars 11231 - 11237 [Proof.] 0. secs (0.u,0.s)
Chars 11242 - 11251 [(intros~x).] 2.241 secs (0.002u,0.017s)
Chars 11256 - 11274 [refine~(q2~_~@~_).] 0.002 secs (0.001u,0.s)
Chars 11279 - 11304 [transitivity~(g2~(g1~x)).] 0.004 secs (0.004u,0.s)
Chars 11309 - 11310 [+] 0. secs (0.u,0.s)
Chars 11311 - 11329 [(apply~ap,~eisretr).] 0.002 secs (0.002u,0.s)
Chars 11334 - 11335 [+] 0. secs (0.u,0.s)
Chars 11336 - 11345 [(apply~gf).] 0.001 secs (0.001u,0.s)
Chars 11242 - 11251 [(intros~x).] 0.001 secs (0.001u,0.s)
Chars 11256 - 11274 [refine~(q2~_~@~_).] 0.001 secs (0.001u,0.s)
Chars 11279 - 11304 [transitivity~(g2~(g1~x)).] 0.001 secs (0.u,0.s)
Chars 11311 - 11329 [(apply~ap,~eisretr).] 0.001 secs (0.001u,0.s)
Chars 11336 - 11345 [(apply~gf).] 0.001 secs (0.001u,0.s)
Chars 11348 - 11356 [Defined.] 0. secs (0.u,0.s)
Chars 11453 - 11556 [Definition~lift_factsys_square...] 0.001 secs (0.001u,0.s)
Chars 11559 - 11565 [Proof.] 0. secs (0.u,0.s)
Chars 1667 - 1682 [(intros~u~a~b~R).] 40.082 secs (0.001u,0.018s)
Chars 1687 - 1779 [refine~(transport~(λ~X,~Φ~_~X~...] 0.004 secs (0.003u,0.s)
Chars 1784 - 1876 [refine~(transport~(λ~X,~Φ~_~_~...] 0.004 secs (0.003u,0.s)
Chars 1881 - 1914 [(apply~(ops_compatible_cong~A~...] 0.001 secs (0.u,0.s)
Chars 1919 - 1972 [exact~(for_all_2_family_prod_t...] 0.001 secs (0.001u,0.s)
Chars 1667 - 1682 [(intros~u~a~b~R).] 0. secs (0.u,0.s)
Chars 1687 - 1779 [refine~(transport~(λ~X,~Φ~_~X~...] 0. secs (0.u,0.s)
Chars 1784 - 1876 [refine~(transport~(λ~X,~Φ~_~_~...] 0. secs (0.u,0.s)
Chars 1881 - 1914 [(apply~(ops_compatible_cong~A~...] 0. secs (0.u,0.s)
Chars 1919 - 1972 [exact~(for_all_2_family_prod_t...] 0. secs (0.u,0.s)
Chars 1975 - 1979 [Qed.] 0.003 secs (0.003u,0.s)
Chars 1983 - 2052 [#[global]Instance~is_congruenc...] 0. secs (0.u,0.s)
Chars 2055 - 2061 [Proof.] 0. secs (0.u,0.s)
Chars 4286 - 4311 [(intros~P;~apply~transport).] 40.101 secs (0.u,0.019s)
Chars 4383 - 4439 [(first~[~exact~iso_same_rings~...] 0. secs (0.u,0.s)
Chars 4286 - 4311 [(intros~P;~apply~transport).] 0. secs (0.u,0.s)
Chars 4383 - 4439 [(first~[~exact~iso_same_rings~...] 0. secs (0.u,0.s)
Chars 4440 - 4444 [Qed.] 0. secs (0.u,0.s)
Chars 4446 - 4459 [End~contents.] 0.04 secs (0.034u,0.005s)
Chars 4461 - 4471 [End~Rings.] 0.045 secs (0.036u,0.009s)
Chars 11570 - 11614 [(unfold~lift_factsys_tri1,~lif...] 18.658 secs (0.002u,0.018s)
Chars 11619 - 11646 [Open~Scope~long_path_scope.] 0. secs (0.u,0.s)
Chars 11756 - 11904 [(pose~~~(r~:=~~~~path_fact_fac...] 0.006 secs (0.003u,0.002s)
Chars 11909 - 11934 [(rewrite~concat_p_pp~in~r).] 0.005 secs (0.004u,0.s)
Chars 11939 - 11969 [(apply~moveL_pM,~moveR_Vp~in~r).] 0.004 secs (0.002u,0.001s)
Chars 11974 - 11998 [(refine~(_~@~r);~clear~r).] 0.006 secs (0.005u,0.s)
Chars 2066 - 2178 [(apply~(@BuildIsCongruence~_~(...] 13.118 secs (0.004u,0.019s)
Chars 2066 - 2178 [(apply~(@BuildIsCongruence~_~(...] 0.001 secs (0.001u,0.s)
Chars 2181 - 2185 [Qed.] 0. secs (0.u,0.s)
Chars 2186 - 2201 [End~cong_trace.] 0.013 secs (0.011u,0.001s)
Chars 2331 - 2359 [Section~is_subalgebra_class.] 0. secs (0.u,0.s)
Chars 2362 - 2537 [Context~`{Univalence}~{σ~:~Sig...] 0.001 secs (0.001u,0.s)
Chars 2541 - 2671 [Definition~is_subalgebra_class...] 0.005 secs (0.002u,0.003s)
Chars 12067 - 12125 [(repeat~rewrite~inv_pp;~repeat...] 0.046 secs (0.037u,0.008s)
Chars 2675 - 2917 [Lemma~op_closed_subalgebra_is_...] 0.003 secs (0.003u,0.s)
Chars 2920 - 2926 [Proof.] 0. secs (0.u,0.s)
Chars 12130 - 12173 [(repeat~rewrite~concat_pp_p;~a...] 0.029 secs (0.023u,0.006s)
Chars 12178 - 12221 [(repeat~rewrite~concat_p_pp;~a...] 0.028 secs (0.021u,0.007s)
Chars 12269 - 12319 [(rewrite~(ap_compose~q^-1~f2),...] 0.013 secs (0.011u,0.001s)
Chars 12766 - 12786 [(unfold~lift_factsys).] 0.002 secs (0.001u,0.s)
Chars 12791 - 12808 [(rewrite~<-~ap_pp).] 0.006 secs (0.005u,0.s)
Chars 12813 - 12844 [(rewrite~<-~ap_V,~<-~ap_compose).] 0.008 secs (0.006u,0.002s)
Chars 12849 - 12872 [(rewrite~(concat_Ap~q2)).] 0.006 secs (0.006u,0.s)
Chars 12918 - 12954 [(rewrite~concat_pp_p;~apply~wh...] 0.008 secs (0.008u,0.s)
Chars 13008 - 13027 [(rewrite~ap_compose).] 0.017 secs (0.013u,0.003s)
Chars 13032 - 13049 [(rewrite~<-~ap_pp).] 0.004 secs (0.004u,0.s)
Chars 13054 - 13063 [(apply~ap).] 0.002 secs (0.002u,0.s)
Chars 13123 - 13151 [(rewrite~inv_pp,~ap_pp,~ap_V).] 0.009 secs (0.009u,0.s)
Chars 13156 - 13174 [(rewrite~<-~eisadj).] 0.004 secs (0.003u,0.s)
Chars 13247 - 13283 [(rewrite~concat_pp_p;~apply~mo...] 0.007 secs (0.005u,0.001s)
Chars 13288 - 13326 [(rewrite~<-~ap_V,~inv_V,~<-~ap...] 0.008 secs (0.008u,0.s)
Chars 13331 - 13369 [exact~(concat_A1p~(eisretr~q)~...] 0.003 secs (0.003u,0.s)
Chars 13374 - 13402 [Close~Scope~long_path_scope.] 0. secs (0.u,0.s)
Chars 11570 - 11614 [(unfold~lift_factsys_tri1,~lif...] 0.001 secs (0.001u,0.s)
Chars 11619 - 11646 [Open~Scope~long_path_scope.] 0. secs (0.u,0.s)
Chars 11756 - 11904 [(pose~~~(r~:=~~~~path_fact_fac...] 0.002 secs (0.002u,0.s)
Chars 11909 - 11934 [(rewrite~concat_p_pp~in~r).] 0.002 secs (0.001u,0.s)
Chars 11939 - 11969 [(apply~moveL_pM,~moveR_Vp~in~r).] 0.002 secs (0.001u,0.s)
Chars 11974 - 11998 [(refine~(_~@~r);~clear~r).] 0.004 secs (0.004u,0.s)
Chars 12067 - 12125 [(repeat~rewrite~inv_pp;~repeat...] 0.006 secs (0.005u,0.s)
Chars 12130 - 12173 [(repeat~rewrite~concat_pp_p;~a...] 0.004 secs (0.004u,0.s)
Chars 12178 - 12221 [(repeat~rewrite~concat_p_pp;~a...] 0.004 secs (0.003u,0.s)
Chars 12269 - 12319 [(rewrite~(ap_compose~q^-1~f2),...] 0.002 secs (0.002u,0.s)
Chars 12766 - 12786 [(unfold~lift_factsys).] 0.001 secs (0.001u,0.s)
Chars 12791 - 12808 [(rewrite~<-~ap_pp).] 0.001 secs (0.001u,0.s)
Chars 12813 - 12844 [(rewrite~<-~ap_V,~<-~ap_compose).] 0.001 secs (0.u,0.s)
Chars 12849 - 12872 [(rewrite~(concat_Ap~q2)).] 0.001 secs (0.001u,0.s)
Chars 12918 - 12954 [(rewrite~concat_pp_p;~apply~wh...] 0.003 secs (0.003u,0.s)
Chars 13008 - 13027 [(rewrite~ap_compose).] 0.001 secs (0.001u,0.s)
Chars 13032 - 13049 [(rewrite~<-~ap_pp).] 0.001 secs (0.001u,0.s)
Chars 13054 - 13063 [(apply~ap).] 0.001 secs (0.u,0.s)
Chars 13123 - 13151 [(rewrite~inv_pp,~ap_pp,~ap_V).] 0.001 secs (0.u,0.s)
Chars 13156 - 13174 [(rewrite~<-~eisadj).] 0.001 secs (0.001u,0.s)
Chars 13247 - 13283 [(rewrite~concat_pp_p;~apply~mo...] 0.003 secs (0.003u,0.s)
Chars 13288 - 13326 [(rewrite~<-~ap_V,~inv_V,~<-~ap...] 0.001 secs (0.001u,0.s)
Chars 13331 - 13369 [exact~(concat_A1p~(eisretr~q)~...] 0.001 secs (0.001u,0.s)
Chars 13374 - 13402 [Close~Scope~long_path_scope.] 0. secs (0.u,0.s)
Chars 13405 - 13409 [Qed.] 0.053 secs (0.053u,0.s)
Chars 13411 - 13423 [End~FactSys.] 0.073 secs (0.073u,0.s)
Chars 13425 - 13451 [Section~FactsysExtensions.] 0. secs (0.u,0.s)
Chars 13454 - 13494 [Context~{factsys~:~Factorizati...] 0. secs (0.u,0.s)
Chars 13629 - 13849 [Definition~extension_factsys~{...] 0. secs (0.u,0.s)
Chars 13852 - 13858 [Proof.] 0. secs (0.u,0.s)
Chars 2931 - 2943 [(induction~w).] 40.119 secs (0.u,0.02s)
Chars 2948 - 2949 [-] 0. secs (0.u,0.s)
Chars 2950 - 2968 [specialize~(Q~tt).] 0.001 secs (0.u,0.s)
Chars 2969 - 2978 [(apply~tr).] 0.001 secs (0.001u,0.s)
Chars 2985 - 3000 [exists~(α;~C).] 0.002 secs (0.002u,0.s)
Chars 3007 - 3016 [(cbn~in~Q).] 0.033 secs (0.021u,0.011s)
Chars 3017 - 3029 [(destruct~Q^).] 0.003 secs (0.003u,0.s)
Chars 3036 - 3066 [exact~(EquivRel_Reflexive~α).] 0.002 secs (0.002u,0.s)
Chars 3071 - 3072 [-] 0. secs (0.u,0.s)
Chars 3073 - 3111 [refine~(quotient_ind_prop~(Φ~t...] 0.033 secs (0.03u,0.002s)
Chars 3112 - 3120 [intro~x.] 0.001 secs (0.u,0.s)
Chars 3127 - 3148 [refine~(Trunc_rec~_).] 0.019 secs (0.017u,0.001s)
Chars 3155 - 3168 [(intros~[y~R]).] 0.003 secs (0.002u,0.s)
Chars 3175 - 3225 [(apply~(IHw~(γ~(class_of~(Φ~t)...] 0.003 secs (0.003u,0.s)
Chars 3232 - 3233 [+] 0. secs (0.u,0.s)
Chars 3234 - 3242 [intro~a.] 0.001 secs (0.001u,0.s)
Chars 3251 - 3291 [(destruct~(related_classes_eq~...] 0.022 secs (0.016u,0.005s)
Chars 3300 - 3320 [(apply~(Q~(i~t~y,~a))).] 0.003 secs (0.003u,0.s)
Chars 3327 - 3328 [+] 0. secs (0.u,0.s)
Chars 3329 - 3337 [(apply~C).] 0.001 secs (0.001u,0.s)
Chars 3338 - 3348 [exact~y.2.] 0.001 secs (0.001u,0.s)
Chars 2931 - 2943 [(induction~w).] 0. secs (0.u,0.s)
Chars 2950 - 2968 [specialize~(Q~tt).] 0. secs (0.u,0.s)
Chars 2969 - 2978 [(apply~tr).] 0. secs (0.u,0.s)
Chars 2985 - 3000 [exists~(α;~C).] 0.001 secs (0.u,0.s)
Chars 3007 - 3016 [(cbn~in~Q).] 0.001 secs (0.001u,0.s)
Chars 3017 - 3029 [(destruct~Q^).] 0. secs (0.u,0.s)
Chars 3036 - 3066 [exact~(EquivRel_Reflexive~α).] 0. secs (0.u,0.s)
Chars 3073 - 3111 [refine~(quotient_ind_prop~(Φ~t...] 0. secs (0.u,0.s)
Chars 3112 - 3120 [intro~x.] 0.001 secs (0.001u,0.s)
Chars 3127 - 3148 [refine~(Trunc_rec~_).] 0.001 secs (0.001u,0.s)
Chars 3155 - 3168 [(intros~[y~R]).] 0.001 secs (0.001u,0.s)
Chars 3175 - 3225 [(apply~(IHw~(γ~(class_of~(Φ~t)...] 0.001 secs (0.001u,0.s)
Chars 3234 - 3242 [intro~a.] 0.001 secs (0.u,0.001s)
Chars 3251 - 3291 [(destruct~(related_classes_eq~...] 0.001 secs (0.001u,0.s)
Chars 3300 - 3320 [(apply~(Q~(i~t~y,~a))).] 0.001 secs (0.001u,0.s)
Chars 3329 - 3337 [(apply~C).] 0.001 secs (0.001u,0.s)
Chars 3338 - 3348 [exact~y.2.] 0. secs (0.u,0.s)
Chars 3351 - 3355 [Qed.] 0.012 secs (0.011u,0.s)
Chars 3359 - 3460 [Definition~is_closed_under_ops...] 0. secs (0.u,0.s)
Chars 3463 - 3469 [Proof.] 0. secs (0.u,0.s)
Chars 13863 - 14008 [(pose~~~(e~:=~~~~lift_factsys~...] 40.096 secs (0.u,0.019s)
Chars 14013 - 14164 [(pose~~~(e2~:=~~~~lift_factsys...] 0.002 secs (0.002u,0.s)
Chars 14169 - 14204 [exists~(fun~a~=>~e2~a~#~(e~a).2).] 0.002 secs (0.002u,0.s)
Chars 14209 - 14218 [(intros~a).] 0.001 secs (0.001u,0.s)
Chars 14223 - 14416 [(pose~~~(e1~:=~~~~lift_factsys...] 0.003 secs (0.003u,0.s)
Chars 14421 - 14669 [(pose~~~(e3~:=~~~~moveL_M1~_~_...] 0.012 secs (0.012u,0.s)
Chars 14674 - 14730 [refine~(ap~(fun~p~=>~transport...] 0.007 secs (0.006u,0.s)
Chars 14735 - 14755 [exact~(pr2_path~e1).] 0.005 secs (0.005u,0.s)
Chars 13863 - 14008 [(pose~~~(e~:=~~~~lift_factsys~...] 0. secs (0.u,0.s)
Chars 14013 - 14164 [(pose~~~(e2~:=~~~~lift_factsys...] 0. secs (0.u,0.s)
Chars 14169 - 14204 [exists~(fun~a~=>~e2~a~#~(e~a).2).] 0. secs (0.u,0.s)
Chars 14209 - 14218 [(intros~a).] 0. secs (0.u,0.s)
Chars 14223 - 14416 [(pose~~~(e1~:=~~~~lift_factsys...] 0.001 secs (0.001u,0.s)
Chars 14421 - 14669 [(pose~~~(e3~:=~~~~moveL_M1~_~_...] 0.001 secs (0.001u,0.s)
Chars 14674 - 14730 [refine~(ap~(fun~p~=>~transport...] 0.004 secs (0.003u,0.001s)
Chars 14735 - 14755 [exact~(pr2_path~e1).] 0.021 secs (0.016u,0.005s)
Chars 14758 - 14766 [Defined.] 0.012 secs (0.008u,0.004s)
Chars 14768 - 14790 [End~FactsysExtensions.] 0.016 secs (0.014u,0.002s)
Chars 3474 - 3482 [intro~u.] 40.125 secs (0.u,0.018s)
Chars 3487 - 3535 [(eapply~op_closed_subalgebra_i...] 0.001 secs (0.001u,0.s)
Chars 3540 - 3541 [-] 0. secs (0.u,0.s)
Chars 3542 - 3568 [(apply~compute_op_quotient).] 0.001 secs (0.001u,0.s)
Chars 3573 - 3574 [-] 0. secs (0.u,0.s)
Chars 3575 - 3622 [(apply~is_closed_under_ops_sub...] 0. secs (0.u,0.s)
Chars 3623 - 3631 [exact~_.] 0. secs (0.u,0.s)
Chars 3474 - 3482 [intro~u.] 0. secs (0.u,0.s)
Chars 3487 - 3535 [(eapply~op_closed_subalgebra_i...] 0. secs (0.u,0.s)
Chars 3542 - 3568 [(apply~compute_op_quotient).] 0. secs (0.u,0.s)
Chars 3575 - 3622 [(apply~is_closed_under_ops_sub...] 0. secs (0.u,0.s)
Chars 3623 - 3631 [exact~_.] 0. secs (0.u,0.s)
Chars 3634 - 3638 [Qed.] 0.024 secs (0.018u,0.005s)
Chars 3642 - 3757 [#[global]~Instance~is_subalgeb...] 0.001 secs (0.001u,0.s)
Chars 3760 - 3766 [Proof.] 0. secs (0.u,0.s)
Chars 3771 - 3804 [(apply~BuildIsSubalgebraPredic...] 0.033 secs (-6.259u,-0.555s)
Crunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = I 2 × I 2)
Crunching: (list2D_to_matrix [[C1; 0]; [0; C1]] = I 2)
Crunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = σx × σx)
Crunching: (list2D_to_matrix [[C1; 0]; [0; C1]] = I 2)
Crunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = σy × σy)
Crunching: (list2D_to_matrix [[- Ci * Ci; 0]; [0; Ci * - Ci]] = I 2)
Crunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = σz × σz)
Crunching: (list2D_to_matrix [[C1; 0]; [0; - C1 * - C1]] = I 2)
Crunching: (list2D_to_matrix [[e; e0]; [e1; e2]] = hadamard × hadamard)
Crunching:
(list2D_to_matrix
   [[C1 / √ 2 * (C1 / √ 2) + C1 / √ 2 * (C1 / √ 2);
    C1 / √ 2 * (C1 / √ 2) + C1 / √ 2 * - (C1 / √ 2)];
   [C1 / √ 2 * (C1 / √ 2) + - (C1 / √ 2) * (C1 / √ 2);
   C1 / √ 2 * (C1 / √ 2) + - (C1 / √ 2) * - (C1 / √ 2)]] = 
 I 2)
Crunching:
((fun x z : nat => Σ (fun y : nat => σz x y * hadamard y z) 2) =
 (fun x z : nat => Σ (fun y : nat => hadamard x y * σx y z) 2))
Crunching: (1 - 1 / 6 <= sin_approx 1 (2 * 0 + 1))
Crunching: ((Sgate × σx) x y = (σy × Sgate) x y)
Crunching:
((0 + (0 - snd (Sgate x 0%nat) * 0) +
  (fst (Sgate x 1%nat) * 1 - snd (Sgate x 1%nat) * 0))%R = 
 fst (?y x 0%nat))
Crunching:
((0 + (0 - snd (Sgate x 0%nat) * 0) +
  (fst (Sgate x 1%nat) * 1 - snd (Sgate x 1%nat) * 0))%R = 
 fst (?y x 0%nat))
Crunching:
((0 + (0 - snd (Sgate x 0%nat) * 0) +
  (fst (Sgate x 1%nat) * 1 - snd (Sgate x 1%nat) * 0))%R = 
 fst (?y x 0%nat))
Chars 3771 - 3804 [(apply~BuildIsSubalgebraPredic...] 40.035 secs (0.006u,0.019s)
Chars 3809 - 3855 [(apply~is_closed_under_ops_is_...] 0. secs (0.u,0.s)
Chars 3771 - 3804 [(apply~BuildIsSubalgebraPredic...] 0. secs (0.u,0.s)
Chars 3809 - 3855 [(apply~is_closed_under_ops_is_...] 0. secs (0.u,0.s)
Chars 3858 - 3862 [Qed.] 0.001 secs (0.u,0.s)
Chars 3863 - 3887 [End~is_subalgebra_class.] 0.022 secs (0.02u,0.001s)
Chars 4170 - 4197 [Section~second_isomorphism.] 0. secs (0.u,0.s)
Chars 4200 - 4375 [Context~`{Univalence}~{σ~:~Sig...] 0.001 secs (0.001u,0.s)
Chars 4379 - 4418 [#[local]Notation~Ψ~:=~(cong_tr...] 0. secs (0.u,0.s)
Chars 4422 - 4469 [#[local]Notation~Q~:=~(is_suba...] 0. secs (0.u,0.s)
Chars 4473 - 4855 [Definition~def_second_isomorph...] 0.046 secs (0.04u,0.005s)
Chars 4859 - 5250 [Lemma~oppreserving_second_isom...] 0.011 secs (0.011u,0.s)
Chars 5253 - 5259 [Proof.] 0. secs (0.u,0.s)
Crunching:
((0 + (0 - snd (Sgate x 0%nat) * 0) +
  (fst (Sgate x 1%nat) * 1 - snd (Sgate x 1%nat) * 0))%R = 
 fst (?y x 0%nat))
Crunching:
((0 + (0 - snd (Sgate x 0%nat) * 0) +
  (fst (Sgate x 1%nat) * 1 - snd (Sgate x 1%nat) * 0))%R = 
 fst (?y x 0%nat))
Crunching: (Rabs A < Rabs p -> p > 0 -> A < p)
Crunching: False
Crunching: (1 - 1 / 6 <= sin_approx 1 (1 + 2 * 0))
Crunching: (1 - 1 / 6 <= sin_approx 1 (2 * 0 + 1))
Crunching:
((forall r1 r2 : R, r1 < r2 -> ~ r2 < r1) ->
 (forall r1 r2 : R, r1 < r2 \/ r1 > r2 -> r1 <> r2) ->
 IPR 1 - IPR 1 / IPR 6 <= sin_approx (IPR 1) (2 * 0 + 1))
Crunching: (cnot × (σx ⊗ I 2) = σx ⊗ σx × cnot)
Crunching: (cnot × (σx ⊗ I 2) = σx ⊗ σx × cnot)
Chars 5264 - 5294 [(unfold~ComputeOpQuotient~in~*).] 40.119 secs (0.001u,0.017s)
Chars 5299 - 5321 [(induction~w;~cbn~in~*).] 0.028 secs (0.025u,0.002s)
Chars 5326 - 5327 [-] 0. secs (0.u,0.s)
Chars 5328 - 5351 [(apply~path_sigma_hprop).] 0.008 secs (0.006u,0.001s)
Chars 5358 - 5362 [(cbn).] 0.002 secs (0.002u,0.s)
Chars 5363 - 5391 [(destruct~(QB~tt)^,~(QA~tt)^).] 0.025 secs (0.018u,0.007s)
Chars 5398 - 5426 [by~apply~related_classes_eq.] 0.008 secs (0.006u,0.001s)
Chars 5431 - 5432 [-] 0. secs (0.u,0.s)
Crunching:
(forall c : C, Determinant (eval_matP H2 c) = (DeterminantP H2) [[c]])
Chars 5433 - 5471 [refine~(quotient_ind_prop~(Ψ~t...] 0.045 secs (0.035u,0.009s)
Chars 5472 - 5480 [intro~x.] 0.005 secs (0.003u,0.001s)
Chars 5487 - 5670 [(apply~~~(IHw~(α~(i~t~x))~(γ~(...] 0.012 secs (0.01u,0.001s)
Chars 5677 - 5678 [+] 0. secs (0.u,0.s)
Chars 5679 - 5687 [intro~a.] 0.004 secs (0.004u,0.s)
Chars 5688 - 5710 [exact~(QA~(i~t~x,~a)).] 0.006 secs (0.006u,0.s)
Chars 5717 - 5718 [+] 0. secs (0.u,0.s)
Chars 5719 - 5727 [intro~a.] 0.005 secs (0.004u,0.s)
Chars 5728 - 5746 [exact~(QB~(x,~a)).] 0.006 secs (0.006u,0.s)
Chars 5264 - 5294 [(unfold~ComputeOpQuotient~in~*).] 0.001 secs (0.001u,0.s)
Chars 5299 - 5321 [(induction~w;~cbn~in~*).] 0.008 secs (0.008u,0.s)
Chars 5328 - 5351 [(apply~path_sigma_hprop).] 0.001 secs (0.001u,0.s)
Chars 5358 - 5362 [(cbn).] 0.001 secs (0.u,0.s)
Chars 5363 - 5391 [(destruct~(QB~tt)^,~(QA~tt)^).] 0.001 secs (0.001u,0.s)
Chars 5398 - 5426 [by~apply~related_classes_eq.] 0.001 secs (0.001u,0.s)
Chars 5433 - 5471 [refine~(quotient_ind_prop~(Ψ~t...] 0.004 secs (0.003u,0.s)
Chars 5472 - 5480 [intro~x.] 0.004 secs (0.004u,0.s)
Chars 5487 - 5670 [(apply~~~(IHw~(α~(i~t~x))~(γ~(...] 0.004 secs (0.004u,0.s)
Chars 5679 - 5687 [intro~a.] 0.004 secs (0.004u,0.s)
Chars 5688 - 5710 [exact~(QA~(i~t~x,~a)).] 0.004 secs (0.004u,0.s)
Chars 5719 - 5727 [intro~a.] 0.005 secs (0.005u,0.s)
Chars 5728 - 5746 [exact~(QB~(x,~a)).] 0.005 secs (0.005u,0.s)
Chars 5749 - 5757 [Defined.] 0.043 secs (0.034u,0.008s)
Chars 5761 - 5856 [#[global]~Instance~is_homomorp...] 0. secs (0.u,0.s)
Chars 5859 - 5865 [Proof.] 0. secs (0.u,0.s)
Crunching:
(forall c : C, Determinant (eval_matP H2 c) = (DeterminantP H2) [[c]])
Crunching: False
Crunching:
(forall c : C, Determinant (eval_matP H2 c) = (DeterminantP H2) [[c]])
Chars 5870 - 5878 [intro~u.] 40.157 secs (0.u,0.018s)
Chars 5883 - 5922 [(eapply~oppreserving_second_is...] 0.003 secs (0.001u,0.001s)
Chars 5927 - 5928 [-] 0. secs (0.u,0.s)
Chars 5929 - 5959 [(apply~(compute_op_quotient~A)).] 0.001 secs (0.001u,0.s)
Chars 5964 - 5965 [-] 0. secs (0.u,0.s)
Chars 5966 - 6001 [(apply~(compute_op_quotient~(A...] 0.003 secs (0.003u,0.s)
Chars 5870 - 5878 [intro~u.] 0. secs (0.u,0.s)
Chars 5883 - 5922 [(eapply~oppreserving_second_is...] 0. secs (0.u,0.s)
Chars 5929 - 5959 [(apply~(compute_op_quotient~A)).] 0. secs (0.u,0.s)
Chars 5966 - 6001 [(apply~(compute_op_quotient~(A...] 0. secs (0.u,0.s)
Chars 6004 - 6012 [Defined.] 0.001 secs (0.001u,0.s)
Chars 6016 - 6145 [Definition~hom_second_isomorph...] 0.006 secs (0.005u,0.s)
Chars 6149 - 6253 [#[global]~Instance~embedding_s...] 0.001 secs (0.001u,0.s)
Chars 6256 - 6262 [Proof.] 0. secs (0.u,0.s)
Crunching: (deg_elem_leq_1 (reduceP p 0 AGREE))
Crunching: (deg_elem_leq_1 (reduceP p 0 AGREE))
Crunching: (forall j : nat, degree (reduceP m a b Hb j) <= 1)
Chars 6267 - 6296 [(apply~isembedding_isinj_hset).] 40.124 secs (0.021u,0.02s)
Chars 6301 - 6339 [refine~(quotient_ind_prop~(Ψ~s...] 0.035 secs (0.028u,0.006s)
Chars 6340 - 6348 [intro~x.] 0.001 secs (0.001u,0.s)
Chars 6353 - 6391 [refine~(quotient_ind_prop~(Ψ~s...] 0.039 secs (0.034u,0.004s)
Chars 6392 - 6403 [(intros~y~p).] 0.001 secs (0.001u,0.s)
Chars 6408 - 6433 [(apply~related_classes_eq).] 0.002 secs (0.002u,0.s)
Chars 6438 - 6495 [exact~(classes_eq_related~(Φ~s...] 0.009 secs (0.007u,0.001s)
Chars 6267 - 6296 [(apply~isembedding_isinj_hset).] 0. secs (0.u,0.s)
Chars 6301 - 6339 [refine~(quotient_ind_prop~(Ψ~s...] 0. secs (0.u,0.s)
Chars 6340 - 6348 [intro~x.] 0.001 secs (0.001u,0.s)
Chars 6353 - 6391 [refine~(quotient_ind_prop~(Ψ~s...] 0.001 secs (0.001u,0.s)
Chars 6392 - 6403 [(intros~y~p).] 0.001 secs (0.001u,0.s)
Chars 6408 - 6433 [(apply~related_classes_eq).] 0.001 secs (0.u,0.s)
Chars 6438 - 6495 [exact~(classes_eq_related~(Φ~s...] 0. secs (0.u,0.s)
Chars 6498 - 6502 [Qed.] 0.011 secs (0.01u,0.001s)
Chars 6506 - 6612 [#[global]~Instance~surjection_...] 0.001 secs (0.001u,0.s)
Chars 6615 - 6621 [Proof.] 0. secs (0.u,0.s)
Crunching: (degree (DeterminantP A) <= H2)
Crunching: (degree (DeterminantP A) <= H2)
Crunching:
(forall A : SquareP pol, deg_elem_leq_1 A -> degree (DeterminantP A) <= pol)
Crunching: (degree (DeterminantP A) <= 0)
Crunching: (degree (DeterminantP A) <= 0)
Crunching: (degree (DeterminantP A) <= H2)
Crunching: False
Crunching: False
Crunching: False
Crunching: False
Chars 6626 - 6650 [(apply~BuildIsSurjection).] 40.131 secs (0.001u,0.018s)
Chars 6655 - 6668 [(intros~[y~S]).] 0.002 secs (0.002u,0.s)
Chars 6673 - 6696 [generalize~dependent~S.] 0.001 secs (0.001u,0.s)
Chars 6701 - 6724 [generalize~dependent~y.] 0.001 secs (0.001u,0.s)
Chars 6729 - 6767 [refine~(quotient_ind_prop~(Φ~s...] 0.021 secs (0.016u,0.004s)
Chars 6768 - 6779 [(intros~y~S).] 0.001 secs (0.001u,0.s)
Chars 6784 - 6807 [refine~(Trunc_rec~_~S).] 0.003 secs (0.002u,0.s)
Chars 6808 - 6823 [(intros~[y'~S']).] 0.003 secs (0.003u,0.s)
Chars 6824 - 6833 [(apply~tr).] 0.002 secs (0.002u,0.s)
Chars 6838 - 6861 [exists~(class_of~_~y').] 0.002 secs (0.002u,0.s)
Chars 6866 - 6889 [(apply~path_sigma_hprop).] 0.008 secs (0.008u,0.s)
Chars 6894 - 6922 [by~apply~related_classes_eq.] 0.006 secs (0.003u,0.002s)
Chars 6626 - 6650 [(apply~BuildIsSurjection).] 0. secs (0.u,0.s)
Chars 6655 - 6668 [(intros~[y~S]).] 0. secs (0.u,0.s)
Chars 6673 - 6696 [generalize~dependent~S.] 0. secs (0.u,0.s)
Chars 6701 - 6724 [generalize~dependent~y.] 0. secs (0.u,0.s)
Chars 6729 - 6767 [refine~(quotient_ind_prop~(Φ~s...] 0. secs (0.u,0.s)
Chars 6768 - 6779 [(intros~y~S).] 0. secs (0.u,0.s)
Chars 6784 - 6807 [refine~(Trunc_rec~_~S).] 0.001 secs (0.001u,0.s)
Chars 6808 - 6823 [(intros~[y'~S']).] 0.001 secs (0.001u,0.s)
Chars 6824 - 6833 [(apply~tr).] 0.001 secs (0.001u,0.s)
Chars 6838 - 6861 [exists~(class_of~_~y').] 0.001 secs (0.001u,0.s)
Chars 6866 - 6889 [(apply~path_sigma_hprop).] 0.001 secs (0.001u,0.s)
Chars 6894 - 6922 [by~apply~related_classes_eq.] 0.001 secs (0.001u,0.s)
Chars 6925 - 6929 [Qed.] 0.011 secs (0.009u,0.001s)
Chars 6933 - 7018 [Theorem~is_isomorphism_second_...] 0.001 secs (0.001u,0.s)
Chars 7021 - 7027 [Proof.] 0. secs (0.u,0.s)
Crunching:
(forall (n : nat) (A : Square n), degree (DeterminantP (prep_mat A)) = n)
hit app [global indt «or», global indt «False», global indt «True»]
hit app [global indt «or», global indt «False», global indt «True»]
hit app [global indt «or», global indt «False», global indt «True»]
hit app [global indt «or», global indt «False», global indt «True»]
hit app [global indt «or», global indt «False», global indt «True»]
hit app [global indt «or», global indt «False», global indt «True»]
Finished transaction in 0.075 secs (0.008u,0.013s) (successful)
Finished transaction in 0. secs (0.u,0.s) (successful)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 262 - 324 [Require~Export~Basics.Notation...] 0.008 secs (0.005u,0.003s)
Chars 326 - 376 [Declare~ML~Module~"number_stri...] 0.002 secs (0.002u,0.s)
Chars 432 - 488 [Add~Search~Blacklist~"_admitte...] 0. secs (0.u,0.s)
Chars 490 - 526 [Create~HintDb~rewrite~discrimi...] 0. secs (0.u,0.s)
Chars 527 - 569 [#[export]Hint~Opaque~Variables...] 0. secs (0.u,0.s)
Chars 570 - 618 [Create~HintDb~typeclass_instan...] 0. secs (0.u,0.s)
Chars 815 - 855 [#[local]Set~Typeclasses~Strict...] 0. secs (0.u,0.s)
Chars 1707 - 1739 [#[local]Unset~Elimination~Sche...] 0. secs (0.u,0.s)
Chars 2049 - 2078 [#[global]Set~Keyed~Unification.] 0. secs (0.u,0.s)
Chars 2328 - 2369 [#[global]Unset~Strict~Universe...] 0. secs (0.u,0.s)
Chars 2503 - 2544 [#[global]Unset~Universe~Minimi...] 0. secs (0.u,0.s)
Chars 2585 - 2622 [#[global]Set~Default~Goal~Sele...] 0. secs (0.u,0.s)
Chars 2751 - 2803 [#[global]Set~Printing~Primitiv...] 0. secs (0.u,0.s)
Chars 3056 - 3096 [#[global]Set~Loose~Hint~Behavi...] 0. secs (0.u,0.s)
Chars 3173 - 3232 [Ltac~class_apply~c~:=~autoappl...] 0. secs (0.u,0.s)
Chars 3234 - 3283 [Definition~Relation~(A~:~Type)...] 0. secs (0.u,0.s)
Chars 3285 - 3361 [Class~Reflexive~{A}~(R~:~Relat...] 0. secs (0.u,0.s)
Chars 3362 - 3392 [Arguments~reflexivity~{A~R}~_.] 0. secs (0.u,0.s)
Chars 3394 - 3474 [Class~Symmetric~{A}~(R~:~Relat...] 0.001 secs (0.u,0.s)
Chars 3475 - 3504 [Arguments~symmetry~{A~R~_~_}.] 0. secs (0.u,0.s)
Chars 3506 - 3602 [Class~Transitive~{A}~(R~:~Rela...] 0. secs (0.u,0.s)
Chars 3603 - 3638 [Arguments~transitivity~{A~R~_~...] 0. secs (0.u,0.s)
Chars 3694 - 3821 [Class~PreOrder~{A}~(R~:~Relati...] 0. secs (0.u,0.s)
Chars 3823 - 3867 [#[global]Existing~Instance~Pre...] 0. secs (0.u,0.s)
Chars 3868 - 3913 [#[global]Existing~Instance~Pre...] 0. secs (0.u,0.s)
Chars 3915 - 3949 [Arguments~reflexivity~{A~R~_}~...] 0. secs (0.u,0.s)
Chars 3950 - 3985 [Arguments~symmetry~{A~R~_}~/~_...] 0. secs (0.u,0.s)
Chars 3986 - 4031 [Arguments~transitivity~{A~R~_}...] 0. secs (0.u,0.s)
Chars 4852 - 4888 [Ltac~old_reflexivity~:=~reflex...] 0. secs (0.u,0.s)
Chars 4889 - 5179 [Tactic~Notation~"reflexivity"~...] 0. secs (0.u,0.s)
Chars 5375 - 5753 [Tactic~Notation~"symmetry"~:=~...] 0. secs (0.u,0.s)
Chars 5755 - 6182 [Tactic~Notation~"etransitivity...] 0. secs (0.u,0.s)
Chars 6184 - 6235 [Tactic~Notation~"etransitivity...] 0. secs (0.u,0.s)
Chars 6389 - 6449 [Tactic~Notation~"transitivity"...] 0. secs (0.u,0.s)
Chars 6541 - 6563 [Notation~Type0~:=~Set.] 0. secs (0.u,0.s)
Chars 6790 - 6865 [Definition~Type1@{i}~:=~Eval~h...] 0. secs (0.u,0.s)
Chars 6866 - 6885 [Arguments~Type1~/.] 0. secs (0.u,0.s)
Chars 6886 - 6939 [Identity~Coercion~unfold_Type1...] 0. secs (0.u,0.s)
Chars 7196 - 7279 [Definition~Type2@{i~j}~:=~Eval...] 0. secs (0.u,0.s)
Chars 7280 - 7299 [Arguments~Type2~/.] 0. secs (0.u,0.s)
Chars 7300 - 7353 [Identity~Coercion~unfold_Type2...] 0. secs (0.u,0.s)
Chars 7355 - 7442 [Definition~Type3@{i~j~k}~:=~Ev...] 0. secs (0.u,0.s)
Chars 7443 - 7462 [Arguments~Type3~/.] 0. secs (0.u,0.s)
Chars 7463 - 7516 [Identity~Coercion~unfold_Type3...] 0. secs (0.u,0.s)
Chars 7916 - 8055 [Definition~Type2le@{i~j}~:=~Ev...] 0. secs (0.u,0.s)
Chars 8056 - 8077 [Arguments~Type2le~/.] 0. secs (0.u,0.s)
Chars 8078 - 8135 [Identity~Coercion~unfold_Type2...] 0. secs (0.u,0.s)
Chars 8137 - 8282 [Definition~Type3le@{i~j~k}~:=~...] 0. secs (0.u,0.s)
Chars 8283 - 8304 [Arguments~Type3le~/.] 0. secs (0.u,0.s)
Chars 8305 - 8362 [Identity~Coercion~unfold_Type3...] 0. secs (0.u,0.s)
Chars 8481 - 8512 [Notation~idmap~:=~(fun~x~=>~x).] 0. secs (0.u,0.s)
Chars 8544 - 8593 [Definition~const~{A}~{B}~(b~:~...] 0. secs (0.u,0.s)
Chars 8692 - 8770 [Record~sig~{A}~(P~:~A~->~Type)...] 0. secs (0.u,0.s)
Chars 8772 - 8819 [Scheme~sig_rect~:=~Induction~f...] 0. secs (0.u,0.s)
Chars 8820 - 8866 [Scheme~sig_ind~:=~Induction~fo...] 0. secs (0.u,0.s)
Chars 8867 - 8914 [Scheme~sig_rec~:=~Minimality~f...] 0. secs (0.u,0.s)
Chars 8916 - 8940 [Arguments~sig_ind~{_~_}.] 0. secs (0.u,0.s)
Chars 9100 - 9136 [Arguments~exist~{A}%type~P%typ...] 0. secs (0.u,0.s)
Chars 9137 - 9164 [Arguments~proj1~{A~P}~_~/.] 0. secs (0.u,0.s)
Chars 9165 - 9192 [Arguments~proj2~{A~P}~_~/.] 0. secs (0.u,0.s)
Chars 9194 - 9219 [Arguments~sig~(A~P)%type.] 0. secs (0.u,0.s)
Chars 9221 - 9277 [Notation~"{~x~|~P~}"~:=~(sig~(...] 0. secs (0.u,0.s)
Chars 9278 - 9347 [Notation~"{~x~:~A~|~P~}"~:=~(s...] 0. secs (0.u,0.s)
Chars 9348 - 9437 [Notation~"'exists'~x~..~y~,~p"...] 0. secs (0.u,0.s)
Chars 9438 - 9501 [Notation~"{~x~:~A~~&~P~}"~:=~(...] 0. secs (0.u,0.s)
Chars 9569 - 9590 [Add~Printing~Let~sig.] 0. secs (0.u,0.s)
Chars 9592 - 9628 [#[export]Hint~Resolve~exist:~c...] 0. secs (0.u,0.s)
Chars 9922 - 9978 [Notation~"(~x~;~y~)"~:=~(exist...] 0. secs (0.u,0.s)
Chars 9979 - 10062 [Notation~"(~x~;~..~;~y~;~z~)"~...] 0. secs (0.u,0.s)
Chars 10204 - 10240 [Bind~Scope~fibration_scope~wit...] 0. secs (0.u,0.s)
Chars 10242 - 10264 [Notation~pr1~:=~proj1.] 0. secs (0.u,0.s)
Chars 10265 - 10287 [Notation~pr2~:=~proj2.] 0. secs (0.u,0.s)
Chars 10543 - 10588 [Notation~"x~.1"~:=~(pr1~x)~:~f...] 0. secs (0.u,0.s)
Chars 10589 - 10634 [Notation~"x~.2"~:=~(pr2~x)~:~f...] 0. secs (0.u,0.s)
Chars 10636 - 10718 [Definition~uncurry~{A}~{B}~{C}...] 0.001 secs (0.u,0.s)
Chars 10754 - 10797 [Notation~compose~:=~(fun~g~f~x...] 0. secs (0.u,0.s)
Chars 11622 - 11693 [Notation~"g~'o'~f"~:=~(compose...] 0. secs (0.u,0.s)
Chars 11751 - 11835 [Definition~Compose~{A~B~C~:~Ty...] 0. secs (0.u,0.s)
Chars 11880 - 11983 [#[global]~Instance~iff_compose...] 0.001 secs (0.001u,0.s)
Chars 11984 - 12027 [Arguments~iff_compose~{A~B~C}~...] 0. secs (0.u,0.s)
Chars 12088 - 12170 [#[global]~Instance~iff_inverse...] 0. secs (0.u,0.s)
Chars 12171 - 12210 [Arguments~iff_inverse~{A~B}~f~...] 0. secs (0.u,0.s)
Chars 12243 - 12323 [#[global]~Instance~iff_reflexi...] 0. secs (0.u,0.s)
Chars 12368 - 12453 [Definition~composeD~{A}~{B}~{C...] 0. secs (0.u,0.s)
Chars 12455 - 12523 [#[global]Arguments~composeD~{A...] 0. secs (0.u,0.s)
Chars 12525 - 12563 [#[export]Hint~Unfold~composeD:...] 0. secs (0.u,0.s)
Chars 12565 - 12620 [Notation~"g~'oD'~f"~:=~(compos...] 0. secs (0.u,0.s)
Chars 13294 - 13376 [#[universes(cumulative)]~Induc...] 0. secs (0.u,0.s)
Chars 13378 - 13409 [Arguments~idpath~{A~a},~[A]~a.] 0. secs (0.u,0.s)
Chars 13411 - 13461 [Scheme~paths_ind~:=~Induction~...] 0. secs (0.u,0.s)
Chars 13462 - 13496 [Arguments~paths_ind~[A]~a~P~f~...] 0. secs (0.u,0.s)
Chars 13497 - 13548 [Scheme~paths_rec~:=~Minimality...] 0. secs (0.u,0.s)
Chars 13549 - 13583 [Arguments~paths_rec~[A]~a~P~f~...] 0. secs (0.u,0.s)
Chars 13585 - 13623 [Register~idpath~as~core.identi...] 0. secs (0.u,0.s)
Chars 13679 - 13714 [Definition~paths_rect~:=~paths...] 0. secs (0.u,0.s)
Chars 13716 - 13757 [Register~paths_rect~as~core.id...] 0. secs (0.u,0.s)
Chars 13759 - 13812 [Notation~"x~=~y~:>~A"~:=~(@pat...] 0. secs (0.u,0.s)
Chars 13813 - 13858 [Notation~"x~=~y"~:=~(x~=~y~:>~...] 0. secs (0.u,0.s)
Chars 13995 - 14052 [Lemma~paths_rew~A~a~y~P~(X~:~P...] 0. secs (0.u,0.s)
Chars 14053 - 14059 [Proof.] 0. secs (0.u,0.s)
Chars 14060 - 14073 [(rewrite~<-~H).] 0.007 secs (0.u,0.001s)
Chars 14074 - 14082 [exact~X.] 0. secs (0.u,0.s)
Chars 14060 - 14073 [(rewrite~<-~H).] 0. secs (0.u,0.s)
Chars 14074 - 14082 [exact~X.] 0. secs (0.u,0.s)
Chars 14083 - 14091 [Defined.] 0. secs (0.u,0.s)
Chars 14093 - 14152 [Lemma~paths_rew_r~A~a~y~P~(X~:...] 0. secs (0.u,0.s)
Chars 14153 - 14159 [Proof.] 0. secs (0.u,0.s)
Chars 14160 - 14173 [(rewrite~H).] 0.009 secs (0.001u,0.s)
Chars 14174 - 14182 [exact~X.] 0. secs (0.u,0.s)
Chars 14160 - 14173 [(rewrite~H).] 0. secs (0.u,0.s)
Chars 14174 - 14182 [exact~X.] 0. secs (0.u,0.s)
Chars 14183 - 14191 [Defined.] 0. secs (0.u,0.s)
Chars 14193 - 14230 [Register~paths~as~core.identit...] 0. secs (0.u,0.s)
Chars 14232 - 14308 [#[global]~Instance~reflexive_p...] 0. secs (0.u,0.s)
Chars 14309 - 14338 [Arguments~reflexive_paths~/.] 0. secs (0.u,0.s)
Chars 14433 - 14582 [Definition~paths_ind'~{A~:~Typ...] 0. secs (0.u,0.s)
Chars 14583 - 14589 [Proof.] 0. secs (0.u,0.s)
Chars 14592 - 14608 [(intros~H~?~?~[]).] 0.007 secs (0.001u,0.001s)
Chars 14611 - 14619 [(apply~H).] 0. secs (0.u,0.s)
Chars 14592 - 14608 [(intros~H~?~?~[]).] 0. secs (0.u,0.s)
Chars 14611 - 14619 [(apply~H).] 0. secs (0.u,0.s)
Chars 14620 - 14628 [Defined.] 0. secs (0.u,0.s)
Chars 14694 - 14836 [Definition~paths_ind_r~{A~:~Ty...] 0. secs (0.u,0.s)
Chars 14837 - 14843 [Proof.] 0. secs (0.u,0.s)
Chars 14846 - 14857 [(intros~y~p).] 0.007 secs (0.u,0.001s)
Chars 14860 - 14871 [(destruct~p).] 0.001 secs (0.001u,0.s)
Chars 14874 - 14882 [exact~u.] 0. secs (0.u,0.s)
Chars 14846 - 14857 [(intros~y~p).] 0. secs (0.u,0.s)
Chars 14860 - 14871 [(destruct~p).] 0. secs (0.u,0.s)
Chars 14874 - 14882 [exact~u.] 0. secs (0.u,0.s)
Chars 14883 - 14891 [Defined.] 0. secs (0.u,0.s)
Chars 15157 - 15190 [Bind~Scope~path_scope~with~paths.] 0. secs (0.u,0.s)
Chars 15192 - 15220 [#[local]Open~Scope~path_scope.] 0. secs (0.u,0.s)
Chars 15252 - 15351 [Definition~inverse~{A~:~Type}~...] 0.001 secs (0.u,0.s)
Chars 15353 - 15391 [Register~inverse~as~core.ident...] 0. secs (0.u,0.s)
Chars 15579 - 15623 [Arguments~inverse~{A~x~y}~p~:~...] 0. secs (0.u,0.s)
Chars 15625 - 15702 [#[global]~Instance~symmetric_p...] 0. secs (0.u,0.s)
Chars 15703 - 15732 [Arguments~symmetric_paths~/.] 0. secs (0.u,0.s)
Chars 15818 - 15970 [Definition~paths_rect_r~(A~:~T...] 0. secs (0.u,0.s)
Chars 16863 - 16986 [Definition~concat~{A~:~Type}~{...] 0.001 secs (0.u,0.001s)
Chars 17041 - 17088 [Arguments~concat~{A~x~y~z}~p~q...] 0. secs (0.u,0.s)
Chars 17090 - 17168 [#[global]~Instance~transitive_...] 0. secs (0.u,0.s)
Chars 17169 - 17199 [Arguments~transitive_paths~/.] 0. secs (0.u,0.s)
Chars 17201 - 17240 [Register~concat~as~core.identi...] 0. secs (0.u,0.s)
Chars 17528 - 17564 [Notation~"1"~:=~idpath~:~path_...] 0. secs (0.u,0.s)
Chars 17794 - 17850 [Notation~"p~@~q"~:=~(concat~p%...] 0. secs (0.u,0.s)
Chars 17945 - 17993 [Notation~"p~^"~:=~(inverse~p%p...] 0. secs (0.u,0.s)
Chars 18265 - 18317 [Notation~"p~@'~q"~:=~(concat~p...] 0. secs (0.u,0.s)
Chars 18553 - 18673 [Definition~transport~{A~:~Type...] 0.001 secs (0.u,0.s)
Chars 18728 - 18817 [Arguments~transport~{A}%type_s...] 0. secs (0.u,0.s)
Chars 19050 - 19116 [Notation~"p~#~x"~:=~(transport...] 0. secs (0.u,0.s)
Chars 19656 - 19761 [Definition~ap~{A~B~:~Type}~(f~...] 0. secs (0.u,0.s)
Chars 19763 - 19836 [#[global]Arguments~ap~{A~B}%ty...] 0. secs (0.u,0.s)
Chars 19838 - 19873 [Register~ap~as~core.identity.c...] 0. secs (0.u,0.s)
Chars 20097 - 20132 [Notation~ap01~:=~ap~(only~pars...] 0. secs (0.u,0.s)
Chars 20134 - 20226 [Definition~pointwise_paths~A~(...] 0. secs (0.u,0.s)
Chars 20228 - 20418 [Definition~pointwise_paths_con...] 0. secs (0.u,0.s)
Chars 20420 - 20502 [#[global]~Instance~reflexive_p...] 0. secs (0.u,0.s)
Chars 20503 - 20509 [Proof.] 0. secs (0.u,0.s)
Chars 20512 - 20536 [(intros~?~?;~reflexivity).] 0.012 secs (0.u,0.001s)
Chars 20512 - 20536 [(intros~?~?;~reflexivity).] 0. secs (0.u,0.s)
Chars 20537 - 20545 [Defined.] 0. secs (0.u,0.s)
Chars 20547 - 20631 [#[global]~Instance~transitive_...] 0. secs (0.u,0.s)
Chars 20632 - 20638 [Proof.] 0. secs (0.u,0.s)
Chars 20641 - 20654 [(intros~f~g~h).] 0.081 secs (0.u,0.001s)
Chars 20657 - 20686 [(apply~pointwise_paths_concat).] 0. secs (0.u,0.s)
Chars 20641 - 20654 [(intros~f~g~h).] 0. secs (0.u,0.s)
Chars 20657 - 20686 [(apply~pointwise_paths_concat).] 0. secs (0.u,0.s)
Chars 20687 - 20695 [Defined.] 0. secs (0.u,0.s)
Chars 20697 - 20779 [#[global]~Instance~symmetric_p...] 0. secs (0.u,0.s)
Chars 20780 - 20786 [Proof.] 0. secs (0.u,0.s)
Chars 20789 - 20823 [(intros~?~?~p~?;~symmetry;~app...] 0.115 secs (0.001u,0.s)
Chars 20789 - 20823 [(intros~?~?~p~?;~symmetry;~app...] 0. secs (0.u,0.s)
Chars 20824 - 20832 [Defined.] 0. secs (0.u,0.s)
Chars 20834 - 20907 [#[global]Arguments~pointwise_p...] 0. secs (0.u,0.s)
Chars 20908 - 20953 [#[global]Arguments~reflexive_p...] 0. secs (0.u,0.s)
Chars 20954 - 21000 [#[global]Arguments~transitive_...] 0. secs (0.u,0.s)
Chars 21001 - 21046 [#[global]Arguments~symmetric_p...] 0. secs (0.u,0.s)
Chars 21048 - 21108 [#[export]Hint~Unfold~pointwise...] 0. secs (0.u,0.s)
Chars 21110 - 21166 [Notation~"f~==~g"~:=~(pointwis...] 0. secs (0.u,0.s)
Chars 21168 - 21285 [Definition~apD10~{A}~{B~:~A~->...] 0.001 secs (0.001u,0.s)
Chars 21287 - 21363 [#[global]~Arguments~apD10~{A}%...] 0. secs (0.u,0.s)
Chars 21365 - 21428 [Definition~ap10~{A}~{B}~{f~g~:...] 0. secs (0.u,0.s)
Chars 21430 - 21505 [#[global]Arguments~ap10~{A~B}%...] 0. secs (0.u,0.s)
Chars 21559 - 21598 [Notation~happly~:=~ap10~(only~...] 0. secs (0.u,0.s)
Chars 21600 - 21669 [Definition~ap11~{A}~{B}~{f~g~:...] 0. secs (0.u,0.s)
Chars 21670 - 21676 [Proof.] 0. secs (0.u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 82 - 134 [Require~Import~Basics.Overture...] 0.118 secs (0.075u,0.042s)
Chars 1644 - 3885 [Ltac~~eval_in_using~tac_in~usi...] 0. secs (0.u,0.s)
Chars 3887 - 3941 [Ltac~eval_in~tac_in~H~:=~eval_...] 0. secs (0.u,0.s)
Chars 3943 - 4003 [Example~eval_in_example~:~fora...] 0. secs (0.u,0.s)
Chars 4004 - 4010 [Proof.] 0. secs (0.u,0.s)
Chars 4013 - 4028 [(intros~A~B~H~a).] 0.181 secs (0.u,0.003s)
Chars 4031 - 4102 [(let~x~:=~eval_in~ltac:(fun~H'...] 0.001 secs (0.u,0.s)
Chars 4013 - 4028 [(intros~A~B~H~a).] 0. secs (0.u,0.s)
Chars 4031 - 4102 [(let~x~:=~eval_in~ltac:(fun~H'...] 0. secs (0.u,0.s)
Chars 4732 - 4777 [Inductive~dummy~(A~:~Type)~:=~...] 0.001 secs (0.001u,0.s)
Chars 4779 - 4989 [Ltac~~rewrite_refl~H~:=~~~matc...] 0. secs (0.u,0.s)
Chars 5054 - 5157 [Example~rewrite_refl_example~{...] 0. secs (0.u,0.s)
Chars 5158 - 5164 [Proof.] 0. secs (0.u,0.s)
Chars 5167 - 5180 [(rewrite~ap_1).] 0.014 secs (0.001u,0.003s)
Chars 5183 - 5195 [reflexivity.] 0. secs (0.u,0.s)
Chars 5167 - 5180 [(rewrite~ap_1).] 0. secs (0.u,0.s)
Chars 5183 - 5195 [reflexivity.] 0. secs (0.u,0.s)
Chars 5431 - 5534 [Example~rewrite_refl_example~{...] 0. secs (0.u,0.s)
Chars 5535 - 5541 [Proof.] 0. secs (0.u,0.s)
Chars 5544 - 5563 [(rewrite_refl~@ap_1).] 0.002 secs (0.001u,0.s)
Chars 5566 - 5578 [reflexivity.] 0. secs (0.u,0.s)
Chars 5544 - 5563 [(rewrite_refl~@ap_1).] 0. secs (0.u,0.s)
Chars 5566 - 5578 [reflexivity.] 0. secs (0.u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 45 - 79 [Require~Import~Basics~Types.Si...] 0.529 secs (0.396u,0.132s)
Chars 80 - 108 [Require~Import~WildCat.Core.] 0.024 secs (0.024u,0.s)
Chars 109 - 138 [Require~Import~WildCat.Equiv.] 0.057 secs (0.056u,0.001s)
Chars 139 - 170 [Require~Import~WildCat.Induced.] 0.026 secs (0.025u,0.s)
Chars 171 - 203 [Require~Import~WildCat.NatTrans.] 0.039 secs (0.038u,0.s)
Chars 286 - 406 [Record~Fun01~(A~B~:~Type)~`{Is...] 0.002 secs (0.001u,0.s)
Chars 408 - 446 [Coercion~fun01_F~:~Fun01~>->~F...] 0. secs (0.u,0.s)
Chars 447 - 489 [#[global]Existing~Instance~fun...] 0. secs (0.u,0.s)
Chars 491 - 569 [Arguments~Build_Fun01~A~B~{isg...] 0. secs (0.u,0.s)
Chars 571 - 670 [Definition~issig_Fun01~(A~B~:~...] 0.012 secs (0.012u,0.s)
Chars 985 - 1075 [#[global]~Instance~isgraph_fun...] 0. secs (0.u,0.s)
Chars 1076 - 1082 [Proof.] 0. secs (0.u,0.s)
Chars 1085 - 1107 [srapply~Build_IsGraph.] 0.684 secs (0.u,0.012s)
Chars 1110 - 1129 [(intros~[F~?]~[G~?]).] 0. secs (0.u,0.s)
Chars 1132 - 1153 [exact~(NatTrans~F~G).] 0.001 secs (0.001u,0.s)
Chars 1085 - 1107 [srapply~Build_IsGraph.] 0. secs (0.u,0.s)
Chars 1110 - 1129 [(intros~[F~?]~[G~?]).] 0. secs (0.u,0.s)
Chars 1132 - 1153 [exact~(NatTrans~F~G).] 0. secs (0.u,0.s)
Chars 1154 - 1162 [Defined.] 0. secs (0.u,0.s)
Chars 1164 - 1254 [#[global]~Instance~is01cat_fun...] 0.001 secs (0.001u,0.s)
Chars 1255 - 1261 [Proof.] 0. secs (0.u,0.s)
     = "-(5,-(6,-(7,-())))"
     : string
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 0 - 22 [Require~Import~Basics.] 0.186 secs (0.145u,0.04s)
Chars 91 - 129 [Require~Import~HoTT.Basics~HoT...] 0.977 secs (0.89u,0.087s)
Chars 130 - 161 [Require~Import~Metatheory.Core.] 0. secs (0.u,0.s)
Chars 162 - 190 [#[local]Open~Scope~path_scope.] 0. secs (0.u,0.s)
Chars 847 - 977 [Definition~NaiveFunext~:=~~~fo...] 0. secs (0.u,0.s)
NaiveFunext
     : Type
Chars 978 - 1006 [Check~NaiveFunext@{i~j~max}.] 0. secs (0.u,0.s)
Chars 1095 - 1202 [Definition~NaiveNondepFunext~:...] 0. secs (0.u,0.s)
NaiveNondepFunext
     : Type
Chars 1203 - 1237 [Check~NaiveNondepFunext@{i~j~m...] 0. secs (0.u,0.s)
Chars 1318 - 1433 [Definition~WeakFunext~:=~~~for...] 0. secs (0.u,0.s)
WeakFunext
     : Type
Chars 1434 - 1461 [Check~WeakFunext@{i~j~max}.] 0. secs (0.u,0.s)
Chars 1643 - 1742 [Definition~Funext_implies_Naiv...] 0. secs (0.u,0.s)
Chars 1743 - 1749 [Proof.] 0. secs (0.u,0.s)
Chars 23 - 44 [Require~Import~Types.] 0.785 secs (0.74u,0.044s)
Chars 45 - 75 [Require~Import~Diagrams.Graph.] 0. secs (0.u,0.s)
Chars 76 - 108 [Require~Import~Diagrams.Diagram.] 0.072 secs (0.071u,0.001s)
Chars 110 - 137 [#[local]Open~Scope~nat_scope.] 0. secs (0.u,0.s)
Chars 138 - 166 [#[local]Open~Scope~path_scope.] 0. secs (0.u,0.s)
Chars 253 - 287 [Definition~sequence_graph~:~Gr...] 0. secs (0.u,0.s)
Chars 288 - 294 [Proof.] 0. secs (0.u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 55 - 97 [Require~Import~Category.Core~F...] 0.019 secs (0.013u,0.006s)
Chars 98 - 130 [Require~Import~SetCategory.Core.] 1.096 secs (0.959u,0.136s)
Chars 131 - 186 [Require~Import~Basics.Trunc~HS...] 0.003 secs (0.001u,0.002s)
Chars 187 - 217 [Require~Import~Basics.Tactics.] 0. secs (0.u,0.s)
Chars 219 - 245 [Set~Universe~Polymorphism.] 0. secs (0.u,0.s)
Chars 246 - 269 [Set~Implicit~Arguments.] 0. secs (0.u,0.s)
Chars 270 - 298 [Generalizable~Variables~all.] 0. secs (0.u,0.s)
Chars 299 - 323 [Set~Asymmetric~Patterns.] 0. secs (0.u,0.s)
Chars 325 - 357 [#[local]Open~Scope~morphism_sc...] 0. secs (0.u,0.s)
Chars 359 - 380 [Section~Grothendieck.] 0. secs (0.u,0.s)
Chars 383 - 401 [Context~`{Funext}.] 0. secs (0.u,0.s)
Chars 966 - 991 [Variable~(C~:~PreCategory).] 0. secs (0.u,0.s)
Chars 994 - 1025 [Variable~(F~:~Functor~C~set_cat).] 0. secs (0.u,0.s)
Chars 1029 - 1083 [Record~Pair~:={~c~~:~C;~x~~:~F...] 0.001 secs (0.001u,0.s)
Chars 1087 - 1136 [Definition~issig_pair~:~{c~:~C...] 0. secs (0.u,0.s)
Chars 1139 - 1145 [Proof.] 0. secs (0.u,0.s)
Chars 1150 - 1156 [issig.] 0.063 secs (0.01u,0.018s)
Chars 1150 - 1156 [issig.] 0. secs (0.u,0.s)
Chars 1159 - 1167 [Defined.] 0.001 secs (0.001u,0.s)
Chars 1171 - 1264 [#[local]~Notation~morphism~s~d...] 0. secs (0.u,0.s)
Chars 1268 - 1405 [Definition~compose_H~s~d~d'~(m...] 0.002 secs (0.001u,0.s)
Chars 1408 - 1414 [Proof.] 0. secs (0.u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 102 - 184 [Require~Import~HSet~Types.Unit...] 1.101 secs (0.953u,0.148s)
Chars 185 - 247 [Require~Import~Category.Core~F...] 0.015 secs (0.015u,0.s)
Chars 248 - 298 [Require~Functor.Composition.Co...] 0. secs (0.u,0.s)
Chars 299 - 328 [Require~Import~Functor.Paths.] 0.031 secs (0.03u,0.s)
Chars 329 - 378 [Import~Functor.Identity.Functo...] 0. secs (0.u,0.s)
Chars 379 - 443 [Import~Functor.Composition.Cor...] 0. secs (0.u,0.s)
Chars 445 - 471 [Set~Universe~Polymorphism.] 0. secs (0.u,0.s)
Chars 472 - 495 [Set~Implicit~Arguments.] 0. secs (0.u,0.s)
Chars 496 - 524 [Generalizable~Variables~all.] 0. secs (0.u,0.s)
Chars 525 - 549 [Set~Asymmetric~Patterns.] 0. secs (0.u,0.s)
Chars 551 - 591 [#[local]Notation~sig_type~:=~O...] 0. secs (0.u,0.s)
Chars 592 - 632 [#[local]Notation~pr1_type~:=~O...] 0. secs (0.u,0.s)
Chars 634 - 666 [#[local]Open~Scope~morphism_sc...] 0. secs (0.u,0.s)
Chars 667 - 698 [#[local]Open~Scope~functor_scope.] 0. secs (0.u,0.s)
Chars 700 - 716 [Section~sig_mor.] 0. secs (0.u,0.s)
Chars 719 - 744 [Variable~(A~:~PreCategory).] 0. secs (0.u,0.s)
Chars 747 - 798 [Variable~(Pmor~:~forall~s~d,~m...] 0. secs (0.u,0.s)
Chars 802 - 850 [#[local]Notation~mor~s~d:=~(si...] 0. secs (0.u,0.s)
Chars 853 - 901 [Context~`(HPmor~:~forall~s~d,~...] 0. secs (0.u,0.s)
Chars 905 - 962 [Variable~(Pidentity~:~forall~x...] 0. secs (0.u,0.s)
Chars 965 - 1132 [Variable~~~(Pcompose~:~~~~~~fo...] 0. secs (0.u,0.s)
Chars 1136 - 1195 [#[local]Notation~identity~x:=~...] 0. secs (0.u,0.s)
Chars 1198 - 1290 [#[local]~Notation~compose~m1~m...] 0. secs (0.u,0.s)
Chars 1294 - 1458 [Hypothesis~~~(P_associativity~...] 0.008 secs (0.008u,0.s)
Chars 1462 - 1552 [Hypothesis~~~(P_left_identity~...] 0.001 secs (0.001u,0.s)
Chars 1556 - 1647 [Hypothesis~~~(P_right_identity...] 0.001 secs (0.001u,0.s)
Chars 1699 - 1733 [Definition~sig_mor'~:~PreCateg...] 0. secs (0.u,0.s)
Chars 1736 - 1742 [Proof.] 0. secs (0.u,0.s)
Chars 1747 - 2001 [(refine~~~(@Build_PreCategory~...] 0.04 secs (0.007u,0.014s)
Chars 1747 - 2001 [(refine~~~(@Build_PreCategory~...] 0.004 secs (0.004u,0.s)
Chars 2004 - 2012 [Defined.] 0. secs (0.u,0.s)
Chars 2053 - 2247 [Definition~pr1_mor~:~Functor~s...] 0.002 secs (0.002u,0.s)
Chars 2251 - 2291 [Definition~sig_mor_as_sig~:~Pr...] 0. secs (0.u,0.s)
Chars 2294 - 2300 [Proof.] 0. secs (0.u,0.s)
Chars 2305 - 2475 [(refine~~~(@sig'~A~(fun~_~=>~U...] 0.098 secs (0.02u,0.016s)
Chars 2305 - 2475 [(refine~~~(@sig'~A~(fun~_~=>~U...] 0.008 secs (0.006u,0.001s)
Chars 2478 - 2486 [Defined.] 0.001 secs (0.001u,0.s)
Chars 2490 - 2720 [Definition~sig_functor_mor~:~F...] 0.002 secs (0.002u,0.s)
Chars 2724 - 2966 [Definition~sig_functor_mor_inv...] 0.003 secs (0.003u,0.s)
Chars 2970 - 3001 [#[local]Open~Scope~functor_scope.] 0. secs (0.u,0.s)
Chars 3005 - 3127 [Lemma~sig_mor_eq~`{Funext}~:~~...] 0.001 secs (0.u,0.s)
Chars 3130 - 3136 [Proof.] 0. secs (0.u,0.s)
Chars 3141 - 3177 [(split;~path_functor;~simpl;~t...] 0.669 secs (0.029u,0.021s)
Chars 3182 - 3448 [refine~~(exist~_~~~~~(path_for...] 0.005 secs (0.003u,0.002s)
Chars 3453 - 3487 [(repeat~(apply~path_forall;~in...] 0.004 secs (0.004u,0.s)
Chars 3492 - 3516 [(destruct_head~@sig_type).] 0.011 secs (0.01u,0.s)
Chars 3521 - 3540 [(destruct_head~Unit).] 0.007 secs (0.006u,0.s)
Chars 3545 - 3580 [(rewrite~!transport_forall_con...] 0.015 secs (0.014u,0.s)
Chars 3585 - 3614 [transport_path_forall_hammer.] 0.021 secs (0.018u,0.002s)
Chars 3619 - 3631 [reflexivity.] 0.001 secs (0.001u,0.s)
Chars 3141 - 3177 [(split;~path_functor;~simpl;~t...] 0.005 secs (0.004u,0.s)
Chars 3182 - 3448 [refine~~(exist~_~~~~~(path_for...] 0.001 secs (0.001u,0.s)
Chars 3453 - 3487 [(repeat~(apply~path_forall;~in...] 0.001 secs (0.001u,0.s)
Chars 3492 - 3516 [(destruct_head~@sig_type).] 0.001 secs (0.001u,0.s)
Chars 3521 - 3540 [(destruct_head~Unit).] 0.001 secs (0.001u,0.s)
Chars 3545 - 3580 [(rewrite~!transport_forall_con...] 0.001 secs (0.001u,0.s)
Chars 3585 - 3614 [transport_path_forall_hammer.] 0.001 secs (0.001u,0.s)
Chars 3619 - 3631 [reflexivity.] 0.001 secs (0.001u,0.s)
Chars 3634 - 3638 [Qed.] 0.091 secs (0.083u,0.007s)
Chars 3642 - 3717 [Definition~sig_mor_compat~:~pr...] 0.004 secs (0.002u,0.002s)
Chars 3718 - 3730 [End~sig_mor.] 0.038 secs (0.035u,0.002s)
Chars 3732 - 3829 [Arguments~pr1_mor~~~{A~Pmor~_~...] 0. secs (0.u,0.s)
Chars 3831 - 3853 [Section~sig_mor_hProp.] 0. secs (0.u,0.s)
Chars 3856 - 3881 [Variable~(A~:~PreCategory).] 0. secs (0.u,0.s)
Chars 3884 - 3935 [Variable~(Pmor~:~forall~s~d,~m...] 0. secs (0.u,0.s)
Chars 3939 - 3987 [#[local]Notation~mor~s~d:=~(si...] 0. secs (0.u,0.s)
Chars 3990 - 4044 [Context~`(HPmor~:~forall~s~d~m...] 0. secs (0.u,0.s)
Chars 4048 - 4105 [Variable~(Pidentity~:~forall~x...] 0. secs (0.u,0.s)
Chars 4108 - 4275 [Variable~~~(Pcompose~:~~~~~~fo...] 0. secs (0.u,0.s)
Chars 4279 - 4338 [#[local]Notation~identity~x:=~...] 0. secs (0.u,0.s)
Chars 4341 - 4433 [#[local]~Notation~compose~m1~m...] 0. secs (0.u,0.s)
Chars 4437 - 4561 [#[local]~Ltac~~t~ex_tac~:=~~~i...] 0. secs (0.u,0.s)
Chars 4565 - 4722 [Let~P_associativity~:~~~forall...] 0.01 secs (0.007u,0.002s)
Chars 4725 - 4731 [Proof.] 0. secs (0.u,0.s)
Chars 4736 - 4843 [(abstract~(t~ltac:(exists~(ass...] 0.05 secs (0.005u,0.015s)
Chars 4736 - 4843 [(abstract~(t~ltac:(exists~(ass...] 0. secs (0.u,0.s)
Chars 4846 - 4854 [Defined.] 0.001 secs (0.001u,0.s)
Chars 4858 - 4941 [Let~P_left_identity~:~forall~a...] 0.002 secs (0.002u,0.s)
Chars 4944 - 4950 [Proof.] 0. secs (0.u,0.s)
Chars 4955 - 4977 [clear~P_associativity.] 0.051 secs (0.001u,0.013s)
Chars 4982 - 5081 [(abstract~(t~ltac:(exists~(lef...] 0.004 secs (0.003u,0.s)
Chars 4955 - 4977 [clear~P_associativity.] 0. secs (0.u,0.s)
Chars 4982 - 5081 [(abstract~(t~ltac:(exists~(lef...] 0. secs (0.u,0.s)
Chars 5084 - 5092 [Defined.] 0. secs (0.u,0.s)
Chars 5096 - 5180 [Let~P_right_identity~:~forall~...] 0.002 secs (0.002u,0.s)
Chars 5183 - 5189 [Proof.] 0. secs (0.u,0.s)
Chars 5194 - 5232 [clear~P_associativity~P_left_i...] 0.07 secs (0.001u,0.013s)
Chars 5237 - 5338 [(abstract~(t~ltac:(exists~(rig...] 0.003 secs (0.002u,0.s)
Chars 5194 - 5232 [clear~P_associativity~P_left_i...] 0.001 secs (0.u,0.s)
Chars 5237 - 5338 [(abstract~(t~ltac:(exists~(rig...] 0. secs (0.u,0.s)
Chars 5341 - 5349 [Defined.] 0. secs (0.u,0.s)
Chars 5401 - 5603 [Definition~sig_mor~:~PreCatego...] 0.015 secs (0.012u,0.002s)
Chars 5644 - 5704 [Definition~proj1_sig_mor~:~Fun...] 0.001 secs (0.001u,0.s)
Chars 5705 - 5723 [End~sig_mor_hProp.] 0.006 secs (0.005u,0.s)
Chars 5725 - 5783 [Arguments~proj1_sig_mor~{A~Pmo...] 0. secs (0.u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 51 - 120 [Require~Import~Category.Core~F...] 0.02 secs (0.012u,0.007s)
Chars 121 - 150 [Require~Import~Category.Dual.] 1.119 secs (0.991u,0.128s)
Chars 151 - 180 [Require~Import~Category.Prod.] 0.001 secs (0.001u,0.s)
Chars 181 - 227 [Require~Import~NaturalTransfor...] 0.014 secs (0.014u,0.s)
Chars 228 - 273 [Require~Import~FunctorCategory...] 0.051 secs (0.048u,0.003s)
Chars 274 - 351 [Require~Import~InitialTerminal...] 0. secs (0.u,0.s)
Chars 352 - 371 [Require~Comma.Core.] 0.019 secs (0.019u,0.s)
Chars 372 - 421 [#[local]Set~Warnings~Append~"-...] 0. secs (0.u,0.s)
Chars 574 - 592 [Import~Comma.Core.] 0. secs (0.u,0.s)
Chars 593 - 641 [#[local]Set~Warnings~Append~"n...] 0. secs (0.u,0.s)
Chars 642 - 674 [Require~Import~Comma.Projection.] 0.002 secs (0.002u,0.s)
Chars 675 - 725 [Require~Import~Types.Prod~HoTT...] 0.001 secs (0.001u,0.s)
Chars 726 - 756 [Require~Import~Basics.Tactics.] 0. secs (0.u,0.s)
Chars 758 - 784 [Set~Universe~Polymorphism.] 0. secs (0.u,0.s)
Chars 785 - 808 [Set~Implicit~Arguments.] 0. secs (0.u,0.s)
Chars 809 - 837 [Generalizable~Variables~all.] 0. secs (0.u,0.s)
Chars 838 - 862 [Set~Asymmetric~Patterns.] 0. secs (0.u,0.s)
Chars 864 - 895 [#[local]Open~Scope~functor_scope.] 0. secs (0.u,0.s)
Chars 896 - 928 [#[local]Open~Scope~category_sc...] 0. secs (0.u,0.s)
Chars 1072 - 1111 [Section~comma_category_induced...] 0. secs (0.u,0.s)
Chars 1114 - 1132 [Context~`{Funext}.] 0. secs (0.u,0.s)
Chars 1135 - 1165 [Variables~(A~B~C~:~PreCategory).] 0. secs (0.u,0.s)
Chars 1169 - 1541 [Definition~comma_category_indu...] 0.008 secs (0.008u,0.s)
Chars 1545 - 1687 [Lemma~comma_category_induced_f...] 0. secs (0.u,0.s)
Chars 1690 - 1696 [Proof.] 0. secs (0.u,0.s)
Chars 1752 - 1772 [(intros~fe~A~P~f~g~h).] 16.869 secs (0.u,0.003s)
Chars 1775 - 1799 [(unfold~Funext_type~in~*).] 0. secs (0.u,0.s)
Chars 1802 - 1832 [exact~((@apD10~A~P~f~g)^-1~h).] 0.001 secs (0.001u,0.s)
Chars 1752 - 1772 [(intros~fe~A~P~f~g~h).] 0. secs (0.u,0.s)
Chars 1775 - 1799 [(unfold~Funext_type~in~*).] 0. secs (0.u,0.s)
Chars 1802 - 1832 [exact~((@apD10~A~P~f~g)^-1~h).] 0. secs (0.u,0.s)
Chars 1833 - 1841 [Defined.] 0. secs (0.u,0.s)
Chars 1843 - 1945 [Definition~NaiveFunext_implies...] 0. secs (0.u,0.s)
Chars 1946 - 1952 [Proof.] 0. secs (0.u,0.s)
solution'_b = 
STEP
  (b:=|> # # # # # # # <|
      |> # _ _ _ _ _ # <|
      +> # _ + X _ _ # <|
      |> # _ _ _ _ _ # <|
      |> # _ _ _ _ O # <|
      |> # # # # # # # <|
      |><|
      ) (d:=Ea)
  ((((STEP
        (b:=|> # # # # # # # <|
            |> # _ _ _ _ _ # <|
            +> # _ _ + X _ # <|
            |> # _ _ _ _ _ # <|
            |> # _ _ _ _ O # <|
            |> # # # # # # # <|
            |><|
            ) (d:=Ea)
        (STEP
           (b:=|> # # # # # # # <|
               |> # _ _ _ _ _ # <|
               +> # _ _ _ + X # <|
               |> # _ _ _ _ _ # <|
               |> # _ _ _ _ O # <|
               |> # # # # # # # <|
               |><|
               ) (d:=No)
           (STEP
              (b:=|> # # # # # # # <|
                  +> # _ _ _ + _ # <|
                  |> # _ _ _ _ X # <|
                  |> # _ _ _ _ _ # <|
                  |> # _ _ _ _ O # <|
                  |> # # # # # # # <|
                  |><|
                  ) (d:=No)
              (STEP
                 (b:=|> # # # # # # # <|
                     +> # _ _ _ + _ # <|
                     |> # _ _ _ _ X # <|
                     |> # _ _ _ _ _ # <|
                     |> # _ _ _ _ O # <|
                     |> # # # # # # # <|
                     |><|
                     ) (d:=Ea)
                 (STEP
                    (b:=|> # # # # # # # <|
                        +> # _ _ _ _ + # <|
                        |> # _ _ _ _ X # <|
                        |> # _ _ _ _ _ # <|
                        |> # _ _ _ _ O # <|
                        |> # # # # # # # <|
                        |><|
                        ) (d:=So)
                    (STEP
                       (b:=|> # # # # # # # <|
                           |> # _ _ _ _ _ # <|
                           +> # _ _ _ _ + # <|
                           |> # _ _ _ _ X # <|
                           |> # _ _ _ _ O # <|
                           |> # # # # # # # <|
                           |><|
                           ) (d:=So)
                       (OK
                          (b:=|> # # # # # # # <|
                              |> # _ _ _ _ _ # <|
                              |> # _ _ _ _ _ # <|
                              +> # _ _ _ _ + # <|
                              |> # _ _ _ _ * # <|
                              |> # # # # # # # <|
                              |><|
                              )
                          (conj
                             (conj I
                                (conj I
                                   (conj I
                                      (conj I (conj I (conj I (conj I I)))))))
                             (conj
                                (conj I
                                   (conj I
                                      (conj I (conj I (conj I (conj I ...))))))
                                (conj
                                   (conj I
                                      (conj I (conj I (conj I (conj I ...)))))
                                   (conj
                                      (conj I (conj I (conj I (conj I ...))))
                                      (conj (conj I (conj I (conj I ...)))
                                         (conj (conj I (conj I ...)) I)))))
                           :
                           ready
                             |> # # # # # # # <|
                             |> # _ _ _ _ _ # <|
                             |> # _ _ _ _ _ # <|
                             +> # _ _ _ _ + # <|
                             |> # _ _ _ _ * # <|
                             |> # # # # # # # <|
                             |><|
                             )
                        :
                        solvable
                          (dostep So
                             |> # # # # # # # <|
                             |> # _ _ _ _ _ # <|
                             +> # _ _ _ _ + # <|
                             |> # _ _ _ _ X # <|
                             |> # _ _ _ _ O # <|
                             |> # # # # # # # <|
                             |><|
                             ))
                     :
                     solvable
                       (dostep So
                          |> # # # # # # # <|
                          +> # _ _ _ _ + # <|
                          |> # _ _ _ _ X # <|
                          |> # _ _ _ _ _ # <|
                          |> # _ _ _ _ O # <|
                          |> # # # # # # # <|
                          |><|
                          ))
                  :
                  solvable
                    (dostep Ea
                       |> # # # # # # # <|
                       +> # _ _ _ + _ # <|
                       |> # _ _ _ _ X # <|
                       |> # _ _ _ _ _ # <|
                       |> # _ _ _ _ O # <|
                       |> # # # # # # # <|
                       |><|
                       ))
               :
               solvable
                 (dostep No
                    |> # # # # # # # <|
                    +> # _ _ _ + _ # <|
                    |> # _ _ _ _ X # <|
                    |> # _ _ _ _ _ # <|
                    |> # _ _ _ _ O # <|
                    |> # # # # # # # <|
                    |><|
                    ))
            :
            solvable
              (dostep No
                 |> # # # # # # # <|
                 |> # _ _ _ _ _ # <|
                 +> # _ _ _ + X # <|
                 |> # _ _ _ _ _ # <|
                 |> # _ _ _ _ O # <|
                 |> # # # # # # # <|
                 |><|
                 ))
         :
         solvable
           (dostep Ea
              |> # # # # # # # <|
              |> # _ _ _ _ _ # <|
              +> # _ _ + X _ # <|
              |> # _ _ _ _ _ # <|
              |> # _ _ _ _ O # <|
              |> # # # # # # # <|
              |><|
              ))
      :
      solvable
        |> # # # # # # # <|
        |> # _ _ _ _ _ # <|
        +> match move {| t1 := Wall; t2 := Empty; t3 := Keeper |} with
           | CAN {| t1 := x'; t2 := y'; t3 := z' |} =>
               C x' (C y' (C z' X _ _ # <|))
           | CANT =>
               #
               match move {| t1 := Empty; t2 := Keeper; t3 := Box |} with
               | CAN {| t1 := x'; t2 := y'; t3 := z' |} =>
                   C x' (C y' (C z' _ _ # <|))
               | CANT =>
                   _ match
                       move {| t1 := Keeper; t2 := Box; t3 := Empty |}
                     with
                     | CAN {| t1 := x'; t2 := y'; t3 := z' |} =>
                         C x' (C y' (C z' _ # <|))
                     | CANT =>
                         +
                         match
                           move {| t1 := Box; t2 := Empty; t3 := Empty |}
                         with
                         | CAN {| t1 := x'; t2 := y'; t3 := z' |} =>
                             C x' (C y' (C z' # <|))
                         | CANT =>
                             X match
                                 move
                                   {| t1 := Empty; t2 := Empty; t3 := Wall |}
                               with
                               | CAN {| t1 := x'; t2 := y'; t3 := z' |} =>
                                   C x' (C y' (C z' <|))
                               | CANT => _ _ # <|
                               end
                         end
                     end
               end
           end
        |> # _ _ _ _ _ # <|
        |> # _ _ _ _ O # <|
        |> # # # # # # # <|
        |><|
        )
     :
     solvable
       |> # # # # # # # <|
       |> # _ _ _ _ _ # <|
       +> (rowstepeast # _ + X _ _ # <|)
       |> # _ _ _ _ _ # <|
       |> # _ _ _ _ O # <|
       |> # # # # # # # <|
       |><|
       )
    :
    solvable
      (stepeast
         |> # # # # # # # <|
         |> # _ _ _ _ _ # <|
         +> # _ + X _ _ # <|
         |> # _ _ _ _ _ # <|
         |> # _ _ _ _ O # <|
         |> # # # # # # # <|
         |><|
         ))
   :
   solvable
     (dostep Ea
        |> # # # # # # # <|
        |> # _ _ _ _ _ # <|
        +> # _ + X _ _ # <|
        |> # _ _ _ _ _ # <|
        |> # _ _ _ _ O # <|
        |> # # # # # # # <|
        |><|
        ))
:
solvable b
     : solvable b
microban_1_solution = 
STEP
  (b:=|> # # # # <|
      |> # _ O # <|
      |> # _ _ # # # <|
      +> # * + _ _ # <|
      |> # _ _ X _ # <|
      |> # _ _ # # # <|
      |> # # # # <|
      |><|
      ) (d:=So)
  (STEP
     (b:=|> # # # # <|
         |> # _ O # <|
         |> # _ _ # # # <|
         |> # * _ _ _ # <|
         +> # _ + X _ # <|
         |> # _ _ # # # <|
         |> # # # # <|
         |><|
         ) (d:=We)
     (STEP
        (b:=|> # # # # <|
            |> # _ O # <|
            |> # _ _ # # # <|
            |> # * _ _ _ # <|
            +> # + _ X _ # <|
            |> # _ _ # # # <|
            |> # # # # <|
            |><|
            ) (d:=No)
        (STEP
           (b:=|> # # # # <|
               |> # _ O # <|
               |> # X _ # # # <|
               +> # o _ _ _ # <|
               |> # _ _ X _ # <|
               |> # _ _ # # # <|
               |> # # # # <|
               |><|
               ) (d:=Ea)
           (STEP
              (b:=|> # # # # <|
                  |> # _ O # <|
                  |> # X _ # # # <|
                  +> # O + _ _ # <|
                  |> # _ _ X _ # <|
                  |> # _ _ # # # <|
                  |> # # # # <|
                  |><|
                  ) (d:=Ea)
              (STEP
                 (b:=|> # # # # <|
                     |> # _ O # <|
                     |> # X _ # # # <|
                     +> # O _ + _ # <|
                     |> # _ _ X _ # <|
                     |> # _ _ # # # <|
                     |> # # # # <|
                     |><|
                     ) (d:=Ea)
                 (STEP
                    (b:=|> # # # # <|
                        |> # _ O # <|
                        |> # X _ # # # <|
                        +> # O _ _ + # <|
                        |> # _ _ X _ # <|
                        |> # _ _ # # # <|
                        |> # # # # <|
                        |><|
                        ) (d:=So)
                    (STEP
                       (b:=|> # # # # <|
                           |> # _ O # <|
                           |> # X _ # # # <|
                           |> # O _ _ _ # <|
                           +> # _ _ X + # <|
                           |> # _ _ # # # <|
                           |> # # # # <|
                           |><|
                           ) (d:=We)
                       (STEP
                          (b:=|> # # # # <|
                              |> # _ O # <|
                              |> # X _ # # # <|
                              |> # O _ _ _ # <|
                              +> # _ X + _ # <|
                              |> # _ _ # # # <|
                              |> # # # # <|
                              |><|
                              ) (d:=No)
                          (STEP
                             (b:=|> # # # # <|
                                 |> # _ O # <|
                                 |> # X _ # # # <|
                                 +> # O _ + _ # <|
                                 |> # _ X _ _ # <|
                                 |> # _ _ # # # <|
                                 |> # # # # <|
                                 |><|
                                 ) (d:=We)
                             (STEP
                                (b:=|> # # # # <|
                                    |> # _ O # <|
                                    |> # X _ # # # <|
                                    +> # O + _ _ # <|
                                    |> # _ X _ _ # <|
                                    |> # _ _ # # # <|
                                    |> # # # # <|
                                    |><|
                                    ) (d:=We)
                                (STEP
                                   (b:=|> # # # # <|
                                       |> # _ O # <|
                                       |> # X _ # # # <|
                                       +> # o _ _ _ # <|
                                       |> # _ X _ _ # <|
                                       |> # _ _ # # # <|
                                       |> # # # # <|
                                       |><|
                                       ) (d:=So)
                                   (STEP
                                      (b:=|> # # # # <|
                                          |> # _ O # <|
                                          |> # X _ # # # <|
                                          |> # O _ _ _ # <|
                                          +> # + X _ _ # <|
                                          |> # _ _ # ...
                                          |> # ...
                                          |><|
                                          ) (d:=So)
                                      (STEP
                                         (b:=|> # # # # <|
                                             |> # _ O # <|
                                             |> # X _ # ...
                                             |> # O _ _ _ ...
                                             |> ...
                                             ...) (d:=Ea)
                                         (STEP (b:=
                                            |> # ...
                                            |> ...
                                            ...) (d:=No) 
                                            (... : ...)
                                          :
                                          solvable (dostep Ea ...))
                                       :
                                       solvable
                                         (dostep So
                                            |> # # ...
                                            |> # _ O ...
                                            |> ...
                                            ...))
                                    :
                                    solvable
                                      (dostep So
                                         |> # # # # <|
                                         |> # _ O # <|
                                         |> # X _ # # ...
                                         +> # o _ _ _ ...
                                         |> # _ X _ _ ...
                                         |> ...
                                         ...))
                                 :
                                 solvable
                                   (dostep We
                                      |> # # # # <|
                                      |> # _ O # <|
                                      |> # X _ # # # <|
                                      +> # O + _ _ # <|
                                      |> # _ X _ _ # <|
                                      |> # _ _ # # ...
                                      |> # # ...
                                      |><|
                                      ))
                              :
                              solvable
                                (dostep We
                                   |> # # # # <|
                                   |> # _ O # <|
                                   |> # X _ # # # <|
                                   +> # O _ + _ # <|
                                   |> # _ X _ _ # <|
                                   |> # _ _ # # # <|
                                   |> # # # # <|
                                   |><|
                                   ))
                           :
                           solvable
                             (dostep No
                                |> # # # # <|
                                |> # _ O # <|
                                |> # X _ # # # <|
                                |> # O _ _ _ # <|
                                +> # _ X + _ # <|
                                |> # _ _ # # # <|
                                |> # # # # <|
                                |><|
                                ))
                        :
                        solvable
                          (dostep We
                             |> # # # # <|
                             |> # _ O # <|
                             |> # X _ # # # <|
                             |> # O _ _ _ # <|
                             +> # _ _ X + # <|
                             |> # _ _ # # # <|
                             |> # # # # <|
                             |><|
                             ))
                     :
                     solvable
                       (dostep So
                          |> # # # # <|
                          |> # _ O # <|
                          |> # X _ # # # <|
                          +> # O _ _ + # <|
                          |> # _ _ X _ # <|
                          |> # _ _ # # # <|
                          |> # # # # <|
                          |><|
                          ))
                  :
                  solvable
                    (dostep Ea
                       |> # # # # <|
                       |> # _ O # <|
                       |> # X _ # # # <|
                       +> # O _ + _ # <|
                       |> # _ _ X _ # <|
                       |> # _ _ # # # <|
                       |> # # # # <|
                       |><|
                       ))
               :
               solvable
                 (dostep Ea
                    |> # # # # <|
                    |> # _ O # <|
                    |> # X _ # # # <|
                    +> # O + _ _ # <|
                    |> # _ _ X _ # <|
                    |> # _ _ # # # <|
                    |> # # # # <|
                    |><|
                    ))
            :
            solvable
              (dostep Ea
                 |> # # # # <|
                 |> # _ O # <|
                 |> # X _ # # # <|
                 +> # o _ _ _ # <|
                 |> # _ _ X _ # <|
                 |> # _ _ # # # <|
                 |> # # # # <|
                 |><|
                 ))
         :
         solvable
           (dostep No
              |> # # # # <|
              |> # _ O # <|
              |> # _ _ # # # <|
              |> # * _ _ _ # <|
              +> # + _ X _ # <|
              |> # _ _ # # # <|
              |> # # # # <|
              |><|
              ))
      :
      solvable
        (dostep We
           |> # # # # <|
           |> # _ O # <|
           |> # _ _ # # # <|
           |> # * _ _ _ # <|
           +> # _ + X _ # <|
           |> # _ _ # # # <|
           |> # # # # <|
           |><|
           ))
   :
   solvable
     (dostep So
        |> # # # # <|
        |> # _ O # <|
        |> # _ _ # # # <|
        +> # * + _ _ # <|
        |> # _ _ X _ # <|
        |> # _ _ # # # <|
        |> # # # # <|
        |><|
        ))
:
solvable microban_1
     : solvable microban_1
microban_2 = 
|> # # # # # # <|
|> # _ _ _ _ # <|
+> # _ # + _ # <|
|> # _ X * _ # <|
|> # _ O * _ # <|
|> # _ _ _ _ # <|
|> # # # # # # <|
|><|

     : Board
Chars 1264 - 1286 [srapply~Build_Is01Cat.] 26.907 secs (0.001u,0.011s)
Chars 1289 - 1290 [-] 0. secs (0.u,0.s)
Chars 1291 - 1309 [(intros~[F~?];~cbn).] 0.001 secs (0.001u,0.s)
Chars 1314 - 1352 [(exists~(id_transformation~F);...] 0.002 secs (0.002u,0.s)
Chars 1355 - 1356 [-] 0. secs (0.u,0.s)
Chars 1357 - 1412 [(intros~[F~?]~[G~?]~[K~?]~[gam...] 0.004 secs (0.004u,0.s)
Chars 1417 - 1458 [(exists~(trans_comp~gamma~alph...] 0.004 secs (0.004u,0.s)
Chars 1264 - 1286 [srapply~Build_Is01Cat.] 0. secs (0.u,0.s)
Chars 1291 - 1309 [(intros~[F~?];~cbn).] 0. secs (0.u,0.s)
Chars 1314 - 1352 [(exists~(id_transformation~F);...] 0. secs (0.u,0.s)
Chars 1357 - 1412 [(intros~[F~?]~[G~?]~[K~?]~[gam...] 0. secs (0.u,0.s)
Chars 1417 - 1458 [(exists~(trans_comp~gamma~alph...] 0. secs (0.u,0.s)
Chars 1459 - 1467 [Defined.] 0.001 secs (0.u,0.s)
Chars 1469 - 1561 [#[global]~Instance~is2graph_fu...] 0.001 secs (0.001u,0.s)
Chars 1562 - 1568 [Proof.] 0. secs (0.u,0.s)
Chars 21679 - 21702 [(destruct~h,~p;~reflexivity).] 40.008 secs (0.001u,0.001s)
Chars 21679 - 21702 [(destruct~h,~p;~reflexivity).] 0. secs (0.u,0.s)
Chars 21703 - 21711 [Defined.] 0. secs (0.u,0.s)
Chars 21713 - 21805 [#[global]~Arguments~ap11~{A~B}...] 0. secs (0.u,0.s)
Chars 21860 - 21905 [Arguments~ap~{A~B}~f~{x~y}~p~:...] 0. secs (0.u,0.s)
Chars 22392 - 22524 [Definition~apD~{A~:~Type}~{B~:...] 0.001 secs (0.001u,0.s)
Chars 22579 - 22662 [Arguments~apD~{A}%type_scope~{...] 0. secs (0.u,0.s)
Chars 24621 - 24836 [#[universes(cumulative)]~Class...] 0.003 secs (0.001u,0.002s)
Chars 24838 - 24896 [Arguments~eisretr~{A~B}%type_s...] 0. secs (0.u,0.s)
Chars 24897 - 24955 [Arguments~eissect~{A~B}%type_s...] 0. secs (0.u,0.s)
Chars 24956 - 25013 [Arguments~eisadj~{A~B}%type_sc...] 0. secs (0.u,0.s)
Chars 25014 - 25066 [Arguments~IsEquiv~{A~B}%type_s...] 0. secs (0.u,0.s)
Chars 25279 - 25300 [#[global]Opaque~eisadj.] 0. secs (0.u,0.s)
Chars 25372 - 25466 [#[universes(cumulative)]~Recor...] 0. secs (0.u,0.s)
Chars 25468 - 25508 [Coercion~equiv_fun~:~Equiv~>->...] 0. secs (0.u,0.s)
Chars 25510 - 25549 [#[global]Existing~Instance~equ...] 0. secs (0.u,0.s)
Chars 25551 - 25581 [Arguments~equiv_fun~{A~B}~_~_.] 0. secs (0.u,0.s)
Chars 25582 - 25614 [Arguments~equiv_isequiv~{A~B}~_.] 0. secs (0.u,0.s)
Chars 25616 - 25650 [Bind~Scope~equiv_scope~with~Eq...] 0. secs (0.u,0.s)
Chars 25652 - 25699 [Notation~"A~<~>~B"~:=~(Equiv~A...] 0. secs (0.u,0.s)
Chars 26006 - 26064 [Notation~"f~^-1"~:=~(@equiv_in...] 0. secs (0.u,0.s)
Chars 26128 - 26227 [Definition~ap10_equiv~{A~B~:~T...] 0.001 secs (0.001u,0.s)
Chars 30109 - 30212 [Class~Contr_internal~(A~:~Type...] 0.001 secs (0.u,0.001s)
Chars 30214 - 30237 [Arguments~center~A~{_}.] 0. secs (0.u,0.s)
Chars 31107 - 31204 [Inductive~trunc_index~:~Type~:...] 0. secs (0.u,0.s)
Chars 31206 - 31268 [Scheme~trunc_index_ind~:=~Indu...] 0. secs (0.u,0.s)
Chars 31269 - 31332 [Scheme~trunc_index_rec~:=~Mini...] 0. secs (0.u,0.s)
Chars 31388 - 31435 [Definition~trunc_index_rect~:=...] 0. secs (0.u,0.s)
Chars 31521 - 31561 [Bind~Scope~trunc_scope~with~tr...] 0. secs (0.u,0.s)
Chars 31562 - 31594 [Arguments~trunc_S~_%trunc_scope.] 0. secs (0.u,0.s)
Chars 31864 - 31910 [Notation~"n~.+1"~:=~(trunc_S~n...] 0. secs (0.u,0.s)
Chars 31911 - 31961 [Notation~"n~.+2"~:=~(n.+1.+1)%...] 0. secs (0.u,0.s)
Chars 31962 - 32012 [Notation~"n~.+3"~:=~(n.+1.+2)%...] 0. secs (0.u,0.s)
Chars 32013 - 32063 [Notation~"n~.+4"~:=~(n.+1.+3)%...] 0. secs (0.u,0.s)
Chars 32064 - 32114 [Notation~"n~.+5"~:=~(n.+1.+4)%...] 0. secs (0.u,0.s)
Chars 32115 - 32144 [#[local]Open~Scope~trunc_scope.] 0. secs (0.u,0.s)
Chars 33191 - 33374 [Fixpoint~IsTrunc_internal~(n~:...] 0.001 secs (0.001u,0.s)
Chars 33376 - 33423 [Arguments~IsTrunc_internal~n~A...] 0. secs (0.u,0.s)
Chars 33425 - 33518 [Class~IsTrunc~(n~:~trunc_index...] 0. secs (0.u,0.s)
Chars 34047 - 34084 [#[global]Typeclasses~Opaque~Is...] 0. secs (0.u,0.s)
Chars 34140 - 34172 [Arguments~IsTrunc~:~simpl~never.] 0. secs (0.u,0.s)
Chars 34221 - 34327 [#[global]~Instance~istrunc_pat...] 0. secs (0.u,0.s)
Chars 34357 - 34389 [Existing~Class~IsTrunc_internal.] 0. secs (0.u,0.s)
Chars 34391 - 34514 [#[export]~Hint~Extern~0~(IsTru...] 0. secs (0.u,0.s)
Chars 34551 - 34665 [#[export]~Hint~Extern~0~(IsTru...] 0. secs (0.u,0.s)
Chars 35195 - 36169 [#[export]~Hint~Extern~10~~=>~~...] 0. secs (0.u,0.s)
Chars 36171 - 36209 [Notation~Contr~:=~(IsTrunc~min...] 0. secs (0.u,0.s)
Chars 36210 - 36253 [Notation~IsHProp~:=~(IsTrunc~m...] 0. secs (0.u,0.s)
Chars 36254 - 36296 [Notation~IsHSet~:=~(IsTrunc~mi...] 0. secs (0.u,0.s)
Chars 36298 - 36394 [#[export]~Hint~Extern~0~~=>~(p...] 0. secs (0.u,0.s)
Chars 36771 - 36895 [Ltac~~simple_induction~n~n'~IH...] 0. secs (0.u,0.s)
Chars 37247 - 37316 [Notation~is_mere_relation~A~R:...] 0. secs (0.u,0.s)
Chars 39266 - 39299 [#[universes(polymorphic=no)]Ax...] 0. secs (0.u,0.s)
Chars 39300 - 39322 [Existing~Class~Funext.] 0. secs (0.u,0.s)
Chars 39323 - 39419 [Axiom~~~(isequiv_apD10~:~~~~~~...] 0. secs (0.u,0.s)
Chars 39420 - 39459 [#[global]Existing~Instance~ise...] 0. secs (0.u,0.s)
Chars 39461 - 39594 [Definition~path_forall~`{Funex...] 0.001 secs (0.u,0.s)
Chars 39596 - 39667 [#[global]Arguments~path_forall...] 0. secs (0.u,0.s)
Chars 40372 - 40423 [#[export]Hint~Resolve~idpath~i...] 0. secs (0.u,0.s)
Chars 40424 - 40461 [#[export]Hint~Resolve~idpath:~...] 0. secs (0.u,0.s)
Chars 40463 - 40538 [Ltac~path_via~mid~:=~apply~@co...] 0. secs (0.u,0.s)
Chars 40771 - 40801 [#[local]Set~Elimination~Schemes.] 0. secs (0.u,0.s)
Chars 40828 - 40879 [Inductive~nat~:~Type~:=~~~|~O~...] 0. secs (0.u,0.s)
Chars 40881 - 40913 [#[local]Unset~Elimination~Sche...] 0. secs (0.u,0.s)
Chars 41123 - 41147 [Declare~Scope~nat_scope.] 0. secs (0.u,0.s)
Chars 41148 - 41181 [Delimit~Scope~nat_scope~with~nat.] 0. secs (0.u,0.s)
Chars 41182 - 41212 [Bind~Scope~nat_scope~with~nat.] 0. secs (0.u,0.s)
Chars 41213 - 41231 [Arguments~S~_%nat.] 0. secs (0.u,0.s)
Chars 41315 - 41343 [Inductive~Empty~:~Type0~:=.] 0. secs (0.u,0.s)
Chars 41344 - 41378 [Register~Empty~as~core.False.t...] 0. secs (0.u,0.s)
Chars 41380 - 41430 [Scheme~Empty_ind~:=~Induction~...] 0. secs (0.u,0.s)
Chars 41431 - 41482 [Scheme~Empty_rec~:=~Minimality...] 0. secs (0.u,0.s)
Chars 41483 - 41518 [Definition~Empty_rect~:=~Empty...] 0. secs (0.u,0.s)
Chars 41520 - 41565 [Definition~not~(A~:~Type)~:~Ty...] 0. secs (0.u,0.s)
Chars 41566 - 41605 [Notation~"~~x"~:=~(not~x)~:~ty...] 0. secs (0.u,0.s)
Chars 41606 - 41645 [Notation~"~~~x"~:=~(~~~~x)~:~t...] 0. secs (0.u,0.s)
Chars 41646 - 41678 [#[export]Hint~Unfold~not:~core.] 0. secs (0.u,0.s)
Chars 41679 - 41739 [Notation~"x~<>~y~~:>~~T"~:=~(n...] 0. secs (0.u,0.s)
Chars 41740 - 41788 [Notation~"x~<>~y"~:=~(x~<>~y~:...] 0. secs (0.u,0.s)
Chars 41790 - 41873 [Definition~symmetric_neq~{A}~{...] 0.001 secs (0.u,0.s)
Chars 41875 - 41957 [Definition~complement~{A}~(R~:...] 0. secs (0.u,0.s)
Chars 41959 - 41999 [#[global]Typeclasses~Opaque~co...] 0. secs (0.u,0.s)
Chars 42001 - 42086 [Class~Irreflexive~{A}~(R~:~Rel...] 0. secs (0.u,0.s)
Chars 42088 - 42192 [Class~Asymmetric~{A}~(R~:~Rela...] 0.001 secs (0.001u,0.s)
Chars 42280 - 42316 [Inductive~Unit~:~Type0~:=~~~~~...] 0. secs (0.u,0.s)
Chars 42318 - 42366 [Scheme~Unit_ind~:=~Induction~f...] 0. secs (0.u,0.s)
Chars 42367 - 42416 [Scheme~Unit_rec~:=~Minimality~...] 0. secs (0.u,0.s)
Chars 42417 - 42450 [Definition~Unit_rect~:=~Unit_ind.] 0. secs (0.u,0.s)
Chars 42517 - 42550 [#[export]Hint~Resolve~tt:~core.] 0. secs (0.u,0.s)
Chars 42552 - 42586 [Register~Unit~as~core.IDProp.t...] 0. secs (0.u,0.s)
Chars 42587 - 42619 [Register~Unit~as~core.True.type.] 0. secs (0.u,0.s)
Chars 42620 - 42654 [Register~tt~as~core.IDProp.idP...] 0. secs (0.u,0.s)
Chars 42655 - 42682 [Register~tt~as~core.True.I.] 0. secs (0.u,0.s)
Chars 42763 - 42803 [Class~IsPointed~(A~:~Type)~:=~...] 0. secs (0.u,0.s)
Chars 42805 - 42849 [#[global]Typeclasses~Transpare...] 0. secs (0.u,0.s)
Chars 42851 - 42873 [Arguments~point~A~{_}.] 0. secs (0.u,0.s)
Chars 42875 - 42974 [#[universes(cumulative)]~Recor...] 0. secs (0.u,0.s)
Chars 42976 - 43020 [Coercion~pointed_type~:~pType~...] 0. secs (0.u,0.s)
Chars 43022 - 43062 [#[global]Existing~Instance~isp...] 0. secs (0.u,0.s)
Chars 43159 - 43234 [Definition~hfiber~{A~B~:~Type}...] 0. secs (0.u,0.s)
Chars 43236 - 43296 [#[global]Arguments~hfiber~{A~B...] 0. secs (0.u,0.s)
Chars 43323 - 43875 [Ltac~~easy~:=~~~let~rec~use_hy...] 0. secs (0.u,0.s)
Chars 43877 - 43920 [Tactic~Notation~"now"~tactic(t...] 0. secs (0.u,0.s)
Chars 1419 - 1453 [(etransitivity;~[~~|~exact~m1....] 23.659 secs (0.002u,0.017s)
Chars 1458 - 1502 [(etransitivity;~[~~|~apply~ap;...] 0.004 secs (0.003u,0.s)
Chars 1507 - 1593 [(match~goal~with~~|~|-~?f~?x~=...] 0.001 secs (0.001u,0.s)
Chars 1598 - 1677 [(match~goal~with~~|~|-~?f~?x~=...] 0.001 secs (0.001u,0.s)
Chars 1682 - 1707 [(apply~(composition_of~F)).] 0.001 secs (0.001u,0.s)
Chars 1419 - 1453 [(etransitivity;~[~~|~exact~m1....] 0. secs (0.u,0.s)
Chars 1458 - 1502 [(etransitivity;~[~~|~apply~ap;...] 0.001 secs (0.001u,0.s)
Chars 1507 - 1593 [(match~goal~with~~|~|-~?f~?x~=...] 0. secs (0.u,0.s)
Chars 1598 - 1677 [(match~goal~with~~|~|-~?f~?x~=...] 0. secs (0.u,0.s)
Chars 1682 - 1707 [(apply~(composition_of~F)).] 0. secs (0.u,0.s)
Chars 1710 - 1718 [Defined.] 0.001 secs (0.001u,0.s)
Chars 1722 - 1833 [Definition~compose~s~d~d'~(m1~...] 0.001 secs (0.001u,0.s)
Chars 1836 - 1842 [Proof.] 0. secs (0.u,0.s)
Chars 1571 - 1611 [(intros~[F~?]~[G~?];~apply~Bui...] 11.498 secs (0.002u,0.01s)
Chars 1614 - 1641 [(intros~[alpha~?]~[gamma~?]).] 0.001 secs (0.u,0.s)
Chars 1644 - 1682 [exact~(forall~a,~alpha~a~$==~g...] 0.004 secs (0.003u,0.s)
Chars 1571 - 1611 [(intros~[F~?]~[G~?];~apply~Bui...] 0. secs (0.u,0.s)
Chars 1614 - 1641 [(intros~[alpha~?]~[gamma~?]).] 0. secs (0.u,0.s)
Chars 1644 - 1682 [exact~(forall~a,~alpha~a~$==~g...] 0. secs (0.u,0.s)
Chars 1683 - 1691 [Defined.] 0.001 secs (0.u,0.s)
Chars 1888 - 1976 [#[global]~Instance~is1cat_fun0...] 0.002 secs (0.001u,0.s)
Chars 1977 - 1983 [Proof.] 0. secs (0.u,0.s)
Chars 297 - 323 [srapply~(Build_Graph~nat).] 40.01 secs (0.u,0.002s)
Chars 326 - 354 [(intros~n~m;~exact~(S~n~=~m)).] 0. secs (0.u,0.s)
Chars 297 - 323 [srapply~(Build_Graph~nat).] 0. secs (0.u,0.s)
Chars 326 - 354 [(intros~n~m;~exact~(S~n~=~m)).] 0. secs (0.u,0.s)
Chars 355 - 363 [Defined.] 0. secs (0.u,0.s)
Chars 365 - 411 [Definition~Sequence~:=~Diagram...] 0. secs (0.u,0.s)
Chars 413 - 504 [Definition~Build_Sequence~(X~:...] 0. secs (0.u,0.s)
Chars 505 - 511 [Proof.] 0. secs (0.u,0.s)
     = 1
     : nat
     = 1
     : nat
     = 2
     : nat
     = 3
     : nat
     = 5
     : nat
     = 8
     : nat
     = 1
     : nat
     = 1
     : nat
     = 2
     : nat
     = 3
     : nat
     = 5
     : nat
     = 8
     : nat
Chars 1701 - 1886 [(let~x1~:=~match~goal~with~~~~...] 40.055 secs (0.002u,0.014s)
Chars 1891 - 1897 [(simpl).] 0.001 secs (0.001u,0.s)
Chars 1902 - 1966 [(abstract~(rewrite~?left_ident...] 0.008 secs (0.008u,0.s)
Chars 1701 - 1886 [(let~x1~:=~match~goal~with~~~~...] 0. secs (0.u,0.s)
Chars 1891 - 1897 [(simpl).] 0. secs (0.u,0.s)
Chars 1902 - 1966 [(abstract~(rewrite~?left_ident...] 0. secs (0.u,0.s)
Chars 1969 - 1977 [Defined.] 0.003 secs (0.003u,0.s)
Chars 1981 - 2348 [Definition~comma_category_indu...] 0.003 secs (0.002u,0.001s)
Chars 2351 - 2357 [Proof.] 0. secs (0.u,0.s)
Chars 2362 - 2547 [(let~x1~:=~match~goal~with~~~~...] 2.293 secs (0.003u,0.014s)
Chars 2552 - 2672 [(abstract~(destruct~m',~m,~x;~...] 0.08 secs (0.07u,0.01s)
Chars 2362 - 2547 [(let~x1~:=~match~goal~with~~~~...] 0. secs (0.u,0.s)
Chars 2552 - 2672 [(abstract~(destruct~m',~m,~x;~...] 0.001 secs (0.u,0.s)
Chars 2675 - 2683 [Defined.] 0.006 secs (0.006u,0.s)
Chars 2687 - 2965 [Definition~comma_category_indu...] 0.004 secs (0.003u,0.s)
Chars 2968 - 2974 [Proof.] 0. secs (0.u,0.s)
Chars 1955 - 1972 [(intros~nf~A~P~Pc).] 40.011 secs (0.u,0.003s)
Chars 1975 - 2006 [exists~(fun~x~=>~center~(P~x)).] 0.001 secs (0.001u,0.s)
Chars 2009 - 2038 [(intros~f;~apply~nf;~intros~x).] 0. secs (0.u,0.s)
Chars 2041 - 2053 [(apply~contr).] 0. secs (0.u,0.s)
Chars 1955 - 1972 [(intros~nf~A~P~Pc).] 0. secs (0.u,0.s)
Chars 1975 - 2006 [exists~(fun~x~=>~center~(P~x)).] 0. secs (0.u,0.s)
Chars 2009 - 2038 [(intros~f;~apply~nf;~intros~x).] 0. secs (0.u,0.s)
Chars 2041 - 2053 [(apply~contr).] 0. secs (0.u,0.s)
Chars 2054 - 2062 [Defined.] 0. secs (0.u,0.s)
Chars 2064 - 2225 [Definition~NaiveFunext_implies...] 0. secs (0.u,0.s)
Chars 2604 - 2623 [Section~Homotopies.] 0. secs (0.u,0.s)
Chars 2627 - 2653 [Context~(wf~:~WeakFunext).] 0. secs (0.u,0.s)
Chars 2656 - 2689 [Context~{A~:~Type}~{B~:~A~->~T...] 0. secs (0.u,0.s)
Chars 2693 - 2721 [Context~(f~:~forall~x,~B~x).] 0. secs (0.u,0.s)
Chars 2820 - 2865 [Let~idhtpy~:~f~==~f~:=~fun~x~=...] 0. secs (0.u,0.s)
Chars 3054 - 3128 [#[global]Instance~contr_basedh...] 0. secs (0.u,0.s)
Chars 3131 - 3137 [Proof.] 0. secs (0.u,0.s)
Chars 2979 - 2985 [(simpl).] 11.85 secs (10.114u,0.24s)
Chars 1847 - 1868 [exists~(m1.1~o~m2.1).] 40.058 secs (0.001u,0.017s)
Chars 1873 - 1889 [(apply~compose_H).] 0.001 secs (0.001u,0.s)
Chars 1847 - 1868 [exists~(m1.1~o~m2.1).] 0. secs (0.u,0.s)
Chars 1873 - 1889 [(apply~compose_H).] 0. secs (0.u,0.s)
Chars 1892 - 1900 [Defined.] 0. secs (0.u,0.s)
Chars 1904 - 1969 [Definition~identity_H~s~:=~apD...] 0.001 secs (0.001u,0.s)
Chars 1973 - 2010 [Definition~identity~s~:~morphi...] 0. secs (0.u,0.s)
Chars 2013 - 2019 [Proof.] 0. secs (0.u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 0 - 22 [Require~Import~Basics.] 0.204 secs (0.162u,0.041s)
Chars 23 - 44 [Require~Import~Types.] 0.841 secs (0.76u,0.08s)
Chars 45 - 77 [Require~Import~Colimits.Pushout.] 1.547 secs (1.497u,0.049s)
Chars 78 - 114 [Require~Import~Colimits.SpanPu...] 0.005 secs (0.005u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 0 - 55 [Require~Import~HoTT.Basics.Dec...] 0.174 secs (0.139u,0.034s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 115 - 147 [Require~Import~HoTT.Truncations.] 2.789 secs (2.686u,0.101s)
Chars 148 - 177 [Require~Import~Homotopy.Join.] 0.078 secs (0.077u,0.s)
Chars 178 - 213 [Require~Import~Homotopy.Suspen...] 0. secs (0.u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 214 - 252 [Require~Import~Homotopy.Blaker...] 0.359 secs (0.349u,0.009s)
Chars 541 - 680 [#[global]~Instance~freudenthal...] 0. secs (0.u,0.s)
Chars 681 - 687 [Proof.] 0. secs (0.u,0.s)
Chars 0 - 43 [Require~Import~HoTT.Basics~HoT...] 0.575 secs (0.442u,0.132s)
Chars 1986 - 2007 [srapply~Build_Is1Cat.] 40.143 secs (0.071u,0.037s)
Chars 2010 - 2011 [-] 0. secs (0.u,0.s)
Chars 2012 - 2054 [(intros~[F~?]~[G~?];~srapply~B...] 0.003 secs (0.002u,0.s)
Chars 2059 - 2060 [+] 0. secs (0.u,0.s)
Chars 2061 - 2085 [(intros~[alpha~?]~a;~cbn).] 0.002 secs (0.002u,0.s)
Chars 2092 - 2104 [reflexivity.] 0.001 secs (0.001u,0.s)
Chars 2109 - 2110 [+] 0. secs (0.u,0.s)
Chars 2111 - 2154 [(intros~[alpha~?]~[gamma~?]~[p...] 0.005 secs (0.005u,0.s)
Chars 2161 - 2182 [exact~(mu~a~$@~nu~a).] 0.001 secs (0.001u,0.s)
Chars 2185 - 2186 [-] 0. secs (0.u,0.s)
Chars 2187 - 2228 [(intros~[F~?]~[G~?];~srapply~B...] 0.016 secs (0.013u,0.002s)
Chars 2233 - 2265 [(intros~[alpha~?]~[gamma~?]~mu...] 0.003 secs (0.002u,0.001s)
Chars 2270 - 2287 [exact~(mu~a)^$.] 0.003 secs (0.002u,0.s)
Chars 2290 - 2291 [-] 0. secs (0.u,0.s)
Chars 2292 - 2327 [(intros~[F~?]~[G~?]~[K~?]~[alp...] 0.006 secs (0.006u,0.s)
Chars 2332 - 2357 [srapply~Build_Is0Functor.] 0.004 secs (0.004u,0.s)
Chars 2362 - 2388 [(intros~[phi~?]~[mu~?]~f~a).] 0.005 secs (0.003u,0.002s)
Chars 2393 - 2417 [exact~(alpha~a~$@L~f~a).] 0.002 secs (0.002u,0.s)
Chars 2420 - 2421 [-] 0. secs (0.u,0.s)
Chars 2422 - 2457 [(intros~[F~?]~[G~?]~[K~?]~[alp...] 0.005 secs (0.005u,0.s)
Chars 2462 - 2487 [srapply~Build_Is0Functor.] 0.004 secs (0.002u,0.002s)
Chars 2492 - 2518 [(intros~[phi~?]~[mu~?]~f~a).] 0.005 secs (0.002u,0.002s)
Chars 2523 - 2547 [exact~(f~a~$@R~alpha~a).] 0.012 secs (0.008u,0.003s)
Chars 2550 - 2551 [-] 0. secs (0.u,0.s)
Chars 2552 - 2618 [(intros~[F~?]~[G~?]~[K~?]~[L~?...] 0.078 secs (0.069u,0.008s)
Chars 2623 - 2641 [srapply~cat_assoc.] 0.004 secs (0.002u,0.001s)
Chars 2644 - 2645 [-] 0. secs (0.u,0.s)
Chars 2646 - 2682 [(intros~[F~?]~[G~?]~[alpha~?]~...] 0.04 secs (0.034u,0.005s)
Chars 2687 - 2703 [srapply~cat_idl.] 0.001 secs (0.001u,0.s)
Chars 2706 - 2707 [-] 0. secs (0.u,0.s)
Chars 2708 - 2744 [(intros~[F~?]~[G~?]~[alpha~?]~...] 0.027 secs (0.027u,0.s)
Chars 2749 - 2765 [srapply~cat_idr.] 0.001 secs (0.001u,0.s)
Chars 1986 - 2007 [srapply~Build_Is1Cat.] 0. secs (0.u,0.s)
Chars 2012 - 2054 [(intros~[F~?]~[G~?];~srapply~B...] 0. secs (0.u,0.s)
Chars 2061 - 2085 [(intros~[alpha~?]~a;~cbn).] 0. secs (0.u,0.s)
Chars 2092 - 2104 [reflexivity.] 0. secs (0.u,0.s)
Chars 2111 - 2154 [(intros~[alpha~?]~[gamma~?]~[p...] 0. secs (0.u,0.s)
Chars 2161 - 2182 [exact~(mu~a~$@~nu~a).] 0. secs (0.u,0.s)
Chars 2187 - 2228 [(intros~[F~?]~[G~?];~srapply~B...] 0.002 secs (0.002u,0.s)
Chars 2233 - 2265 [(intros~[alpha~?]~[gamma~?]~mu...] 0. secs (0.u,0.s)
Chars 2270 - 2287 [exact~(mu~a)^$.] 0. secs (0.u,0.s)
Chars 2292 - 2327 [(intros~[F~?]~[G~?]~[K~?]~[alp...] 0. secs (0.u,0.s)
Chars 2332 - 2357 [srapply~Build_Is0Functor.] 0. secs (0.u,0.s)
Chars 2362 - 2388 [(intros~[phi~?]~[mu~?]~f~a).] 0. secs (0.u,0.s)
Chars 2393 - 2417 [exact~(alpha~a~$@L~f~a).] 0.001 secs (0.001u,0.s)
Chars 2422 - 2457 [(intros~[F~?]~[G~?]~[K~?]~[alp...] 0. secs (0.u,0.s)
Chars 2462 - 2487 [srapply~Build_Is0Functor.] 0. secs (0.u,0.s)
Chars 2492 - 2518 [(intros~[phi~?]~[mu~?]~f~a).] 0. secs (0.u,0.s)
Chars 2523 - 2547 [exact~(f~a~$@R~alpha~a).] 0. secs (0.u,0.s)
Chars 2552 - 2618 [(intros~[F~?]~[G~?]~[K~?]~[L~?...] 0.003 secs (0.003u,0.s)
Chars 2623 - 2641 [srapply~cat_assoc.] 0. secs (0.u,0.s)
Chars 2646 - 2682 [(intros~[F~?]~[G~?]~[alpha~?]~...] 0.003 secs (0.003u,0.s)
Chars 2687 - 2703 [srapply~cat_idl.] 0. secs (0.u,0.s)
Chars 2708 - 2744 [(intros~[F~?]~[G~?]~[alpha~?]~...] 0.003 secs (0.003u,0.s)
Chars 2749 - 2765 [srapply~cat_idr.] 0. secs (0.u,0.s)
Chars 2766 - 2774 [Defined.] 0.039 secs (0.036u,0.002s)
Chars 3030 - 3129 [#[global]~Instance~hasequivs_f...] 0.002 secs (0.002u,0.s)
Chars 3130 - 3136 [Proof.] 0. secs (0.u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 345 - 367 [Require~Import~Basics.] 0.227 secs (0.147u,0.079s)
Chars 368 - 389 [Require~Import~Types.] 0.852 secs (0.775u,0.076s)
Chars 390 - 422 [Require~Import~Diagrams.Diagram.] 0.075 secs (0.072u,0.002s)
Chars 423 - 456 [Require~Import~Diagrams.Sequence.] 0.012 secs (0.012u,0.s)
Chars 457 - 488 [Require~Import~Diagrams.Cocone.] 0.046 secs (0.045u,0.001s)
Chars 56 - 179 [Require~Import~HoTT.Classes.in...] 5.319 secs (5.071u,0.247s)
Chars 181 - 207 [Generalizable~Variable~A.] 0. secs (0.u,0.s)
Chars 209 - 294 [Lemma~irrefl_neq~`{R~:~Relatio...] 0. secs (0.u,0.s)
Chars 295 - 301 [Proof.] 0. secs (0.u,0.s)
Chars 489 - 521 [Require~Import~Colimits.Colimit.] 0.49 secs (0.483u,0.006s)
Chars 44 - 164 [Require~Import~HoTT.Classes.th...] 5.302 secs (5.108u,0.194s)
Chars 166 - 213 [Class~AlmostNegate~A~:=~~~~~al...] 0. secs (0.u,0.s)
Chars 215 - 453 [Class~AlmostRing~A~{Aplus~:~Pl...] 0.003 secs (0.003u,0.s)
Chars 455 - 478 [Section~almostring_mor.] 0. secs (0.u,0.s)
Chars 479 - 684 [Context~{A~B~:~Type}~{Aplus~:~...] 0. secs (0.u,0.s)
Chars 686 - 859 [Class~AlmostRingPreserving~(f~...] 0.002 secs (0.002u,0.s)
Chars 860 - 879 [End~almostring_mor.] 0.001 secs (0.001u,0.s)
Chars 881 - 896 [Module~Quoting.] 0. secs (0.u,0.s)
Chars 898 - 1029 [Inductive~Expr~(V~:~Type0)~:=~...] 0.001 secs (0.001u,0.s)
Chars 1031 - 1051 [Arguments~Var~{V}~v.] 0. secs (0.u,0.s)
Chars 1052 - 1071 [Arguments~Zero~{V}.] 0. secs (0.u,0.s)
Chars 1072 - 1090 [Arguments~One~{V}.] 0. secs (0.u,0.s)
Chars 1091 - 1114 [Arguments~Plus~{V}~a~b.] 0. secs (0.u,0.s)
Chars 1115 - 1138 [Arguments~Mult~{V}~a~b.] 0. secs (0.u,0.s)
Chars 1139 - 1159 [Arguments~Neg~{V}~a.] 0. secs (0.u,0.s)
Chars 1161 - 1178 [Section~contents.] 0. secs (0.u,0.s)
Chars 1179 - 1190 [Universe~U.] 0. secs (0.u,0.s)
Chars 1191 - 1228 [Context~(R~:~Type@{U})~`{Almos...] 0. secs (0.u,0.s)
Chars 1230 - 1258 [Notation~Vars~V:=~(V~->~R).] 0. secs (0.u,0.s)
Chars 1260 - 1499 [Fixpoint~eval~{V~:~Type0}~(vs~...] 0.001 secs (0.001u,0.s)
Chars 1501 - 1629 [Lemma~eval_ext~{V~:~Type0}~(vs...] 0. secs (0.u,0.s)
Chars 1630 - 1636 [Proof.] 0. secs (0.u,0.s)
Chars 0 - 90 [From~HoTT~Require~Import~Basic...] 5.597 secs (5.255u,0.34s)
Chars 91 - 142 [From~HoTT~Require~Import~PropR...] 0. secs (0.u,0.s)
Chars 143 - 181 [From~HoTT~Require~Import~HIT.q...] 0.402 secs (0.382u,0.019s)
Chars 350 - 459 [Inductive~Accessible~{A}~(R~:~...] 0.002 secs (0.001u,0.001s)
Chars 462 - 559 [#[global]~Instance~ishprop_Acc...] 0. secs (0.u,0.s)
Chars 560 - 566 [Proof.] 0. secs (0.u,0.s)
Chars 514 - 536 [srapply~Build_Diagram.] 40.011 secs (0.u,0.002s)
Chars 539 - 550 [1:~exact~X.] 0. secs (0.u,0.s)
Chars 553 - 566 [(intros~?~?~p).] 0. secs (0.u,0.s)
Chars 569 - 580 [(destruct~p).] 0. secs (0.u,0.s)
Chars 583 - 591 [(apply~f).] 0. secs (0.u,0.s)
Chars 514 - 536 [srapply~Build_Diagram.] 0. secs (0.u,0.s)
Chars 539 - 550 [1:~exact~X.] 0. secs (0.u,0.s)
Chars 553 - 566 [(intros~?~?~p).] 0. secs (0.u,0.s)
Chars 569 - 580 [(destruct~p).] 0. secs (0.u,0.s)
Chars 583 - 591 [(apply~f).] 0. secs (0.u,0.s)
Chars 592 - 600 [Defined.] 0. secs (0.u,0.s)
Chars 668 - 864 [Definition~equiv_sequence~(D1~...] 0.002 secs (0.002u,0.s)
Chars 865 - 871 [Proof.] 0. secs (0.u,0.s)
Chars 116 - 167 [Require~Export~HoTT.Classes.th...] 6.001 secs (5.648u,0.351s)
Chars 169 - 239 [Require~Import~HoTT.Basics~HoT...] 0.013 secs (0.012u,0.001s)
Chars 349 - 588 [Record~Isomorphic~{σ~:~Signatu...] 0.003 secs (0.003u,0.s)
Chars 590 - 709 [Arguments~BuildIsomorphic~{σ~A...] 0. secs (0.u,0.s)
Chars 711 - 745 [Arguments~def_isomorphic~{σ~A~B}.] 0. secs (0.u,0.s)
Chars 746 - 792 [Arguments~is_homomorphism_isom...] 0. secs (0.u,0.s)
Chars 793 - 838 [Arguments~is_isomorphism_isomo...] 0. secs (0.u,0.s)
Chars 840 - 892 [#[global]Existing~Instance~is_...] 0. secs (0.u,0.s)
Chars 893 - 944 [#[global]Existing~Instance~is_...] 0. secs (0.u,0.s)
Chars 946 - 974 [Module~isomorphic_notations.] 0. secs (0.u,0.s)
Chars 977 - 1039 [#[global]Notation~"A~≅~B"~:=~(...] 0. secs (0.u,0.s)
Chars 1040 - 1065 [End~isomorphic_notations.] 0. secs (0.u,0.s)
Chars 1067 - 1095 [Import~isomorphic_notations.] 0. secs (0.u,0.s)
Chars 1097 - 1254 [Definition~SigIsomorphic~{σ~:~...] 0.001 secs (0.001u,0.s)
Chars 1256 - 1349 [Lemma~issig_isomorphic~{σ~:~Si...] 0. secs (0.u,0.s)
Chars 1350 - 1356 [Proof.] 0. secs (0.u,0.s)
Chars 522 - 548 [Require~Import~Spaces.Nat.] 4.042 secs (3.87u,0.17s)
Chars 549 - 570 [Require~Import~HProp.] 0. secs (0.u,0.s)
Chars 571 - 594 [Require~Import~PathAny.] 0. secs (0.u,0.s)
Chars 596 - 623 [#[local]Open~Scope~nat_scope.] 0. secs (0.u,0.s)
Chars 624 - 652 [#[local]Open~Scope~path_scope.] 0. secs (0.u,0.s)
Chars 654 - 688 [Notation~coe~:=~(transport~idm...] 0. secs (0.u,0.s)
Chars 689 - 740 [Notation~"a~^+"~:=~(@arr~seque...] 0. secs (0.u,0.s)
Chars 742 - 809 [Definition~seq_shift_from_zero...] 0. secs (0.u,0.s)
Chars 810 - 816 [Proof.] 0. secs (0.u,0.s)
Chars 1359 - 1365 [issig.] 0.239 secs (0.048u,0.035s)
Chars 1359 - 1365 [issig.] 0. secs (0.u,0.s)
Chars 1366 - 1374 [Defined.] 0.003 secs (0.002u,0.s)
Chars 1443 - 1529 [Corollary~id_isomorphic~`{Univ...] 0. secs (0.u,0.s)
Chars 1530 - 1536 [Proof.] 0. secs (0.u,0.s)
Chars 569 - 589 [(apply~hprop_allpath).] 2.444 secs (0.u,0.018s)
Chars 592 - 604 [(intros~acc1).] 0. secs (0.u,0.s)
Chars 605 - 636 [(induction~acc1~as~[a~acc1'~IH]).] 0. secs (0.u,0.s)
Chars 639 - 654 [(intros~[acc2']).] 0. secs (0.u,0.s)
Chars 655 - 664 [(apply~ap).] 0. secs (0.u,0.s)
Chars 667 - 695 [(apply~path_forall;~intros~b).] 0.001 secs (0.001u,0.s)
Chars 696 - 725 [(apply~path_forall;~intros~Hb).] 0.001 secs (0.001u,0.s)
Chars 728 - 737 [(apply~IH).] 0. secs (0.u,0.s)
Chars 569 - 589 [(apply~hprop_allpath).] 0. secs (0.u,0.s)
Chars 592 - 604 [(intros~acc1).] 0. secs (0.u,0.s)
Chars 605 - 636 [(induction~acc1~as~[a~acc1'~IH]).] 0. secs (0.u,0.s)
Chars 639 - 654 [(intros~[acc2']).] 0. secs (0.u,0.s)
Chars 655 - 664 [(apply~ap).] 0. secs (0.u,0.s)
Chars 667 - 695 [(apply~path_forall;~intros~b).] 0. secs (0.u,0.s)
Chars 696 - 725 [(apply~path_forall;~intros~Hb).] 0. secs (0.u,0.s)
Chars 728 - 737 [(apply~IH).] 0. secs (0.u,0.s)
Chars 738 - 742 [Qed.] 0.001 secs (0.001u,0.s)
Chars 745 - 837 [Class~WellFounded~{A}~(R~:~Rel...] 0. secs (0.u,0.s)
Chars 840 - 935 [#[global]~Instance~ishprop_Wel...] 0. secs (0.u,0.s)
Chars 936 - 942 [Proof.] 0. secs (0.u,0.s)
All solutions:
occurrence 0: transitivity through forall x : X, plus x x
1 possible(s) substitution(s)
0:	[x: f (a + a); ]

occurrence 1: transitivity through forall x : X,
                                    plus (f (x + x)) (f (a + a))
1 possible(s) substitution(s)
0:	[x: a; ]


All solutions:
occurrence 0: transitivity through forall x y : X, dot (a * x * y) b
3 possible(s) substitution(s)
0:	[x: c; y: dot (d * c) d; ]
1:	[x: dot c d; y: dot c d; ]
2:	[x: dot (c * d) c; y: d; ]


All solutions:
occurrence 0: transitivity through forall x y : X, dot (a * x * y) b
3 possible(s) substitution(s)
0:	[x: c; y: dot (d * c) d; ]
1:	[x: dot c d; y: dot c d; ]
2:	[x: dot (c * d) c; y: d; ]


All solutions:
occurrence 0: transitivity through forall x y : X, dot (a * x * y) b
3 possible(s) substitution(s)
0:	[x: c; y: dot (d * c) d; ]
1:	[x: dot c d; y: dot c d; ]
2:	[x: dot (c * d) c; y: d; ]


All solutions:
occurrence 0: transitivity through forall x y : X, dot (a * x * y) b
3 possible(s) substitution(s)
0:	[x: c; y: dot (d * c) d; ]
1:	[x: dot c d; y: dot c d; ]
2:	[x: dot (c * d) c; y: d; ]


All solutions:
occurrence 0: transitivity through forall x y : X, dot (a * x * y) b
3 possible(s) substitution(s)
0:	[x: c; y: dot (d * c) d; ]
1:	[x: dot c d; y: dot c d; ]
2:	[x: dot (c * d) c; y: d; ]


Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 2979 - 2985 [(simpl).] 40.022 secs (0.u,0.014s)
Chars 2990 - 3265 [(let~s~:=~match~goal~with~~~~~...] 0.003 secs (0.001u,0.001s)
Chars 3270 - 3613 [(abstract~(destruct_head~prod;...] 0.129 secs (0.112u,0.016s)
Chars 2979 - 2985 [(simpl).] 0. secs (0.u,0.s)
Chars 2990 - 3265 [(let~s~:=~match~goal~with~~~~~...] 0. secs (0.u,0.s)
Chars 3270 - 3613 [(abstract~(destruct_head~prod;...] 0. secs (0.u,0.s)
Chars 3630 - 3638 [Defined.] 0.01 secs (0.009u,0.s)
Chars 3642 - 3789 [Definition~comma_category_indu...] 0.003 secs (0.002u,0.s)
Chars 3792 - 3798 [Proof.] 0. secs (0.u,0.s)
All solutions:
occurrence 0: transitivity through forall x y : X, dot (a * x * y) b
3 possible(s) substitution(s)
0:	[x: c; y: dot (d * c) d; ]
1:	[x: dot c d; y: dot c d; ]
2:	[x: dot (c * d) c; y: d; ]


Chars 0 - 28 [Require~Import~Basics~Types.] 0.982 secs (0.913u,0.069s)
Chars 3803 - 4167 [(refine~~~(Build_Functor~(fst~...] 1.178 secs (-0.46u,-0.03s)
Chars 29 - 52 [Require~Import~Cubical.] 1.004 secs (0.988u,0.016s)
All solutions:
occurrence 0: transitivity through forall x y : X, dot (a * x * y) b
3 possible(s) substitution(s)
0:	[x: c; y: dot (d * c) d; ]
1:	[x: dot c d; y: dot c d; ]
2:	[x: dot (c * d) c; y: d; ]


Chars 53 - 82 [Require~Import~Colimits.Coeq.] 0.295 secs (0.291u,0.003s)
Chars 83 - 110 [Require~Import~Spaces.List.] 0.002 secs (0.002u,0.s)
Chars 1539 - 1583 [exact~(path_isomorphism~(def_i...] 11.248 secs (0.001u,0.018s)
Chars 1539 - 1583 [exact~(path_isomorphism~(def_i...] 0. secs (0.u,0.s)
Chars 1584 - 1592 [Defined.] 0. secs (0.u,0.s)
Chars 1658 - 1724 [Lemma~isomorphic_id~{σ}~{A~B~:...] 0. secs (0.u,0.s)
Chars 1725 - 1731 [Proof.] 0. secs (0.u,0.s)
Chars 111 - 143 [Require~Import~Colimits.Pushout.] 1.159 secs (1.146u,0.012s)
All solutions:
occurrence 0: transitivity through forall x y : X, dot (a * x * y) b
3 possible(s) substitution(s)
0:	[x: c; y: dot (d * c) d; ]
1:	[x: dot c d; y: dot c d; ]
2:	[x: dot (c * d) c; y: d; ]


All solutions:
occurrence 0: transitivity through forall x y : X, dot (a * x * y) b
3 possible(s) substitution(s)
0:	[x: c; y: dot (d * c) d; ]
1:	[x: dot c d; y: dot c d; ]
2:	[x: dot (c * d) c; y: d; ]


Chars 144 - 180 [Require~Import~Algebra.Groups....] 2.028 secs (1.999u,0.029s)
Chars 182 - 210 [#[local]Open~Scope~list_scope.] 0. secs (0.u,0.s)
Chars 211 - 237 [#[local]Open~Scope~mc_scope.] 0. secs (0.u,0.s)
Chars 238 - 269 [#[local]Open~Scope~mc_mult_scope.] 0. secs (0.u,0.s)
Chars 1340 - 1360 [Section~FreeProduct.] 0. secs (0.u,0.s)
Chars 1364 - 1448 [Context~(G~H~K~:~Group)~(f~:~G...] 0. secs (0.u,0.s)
Chars 1452 - 1498 [#[local]Definition~Words~:~Typ...] 0. secs (0.u,0.s)
Chars 1502 - 1541 [#[local]Notation~"[~x~]"~:=~(c...] 0. secs (0.u,0.s)
Chars 1545 - 1607 [#[local]Definition~word_concat...] 0. secs (0.u,0.s)
Chars 1610 - 1616 [Proof.] 0. secs (0.u,0.s)
Chars 0 - 209 [Require~Import~HoTT.Classes.in...] 5.541 secs (5.405u,0.135s)
Chars 211 - 241 [Generalizable~Variables~K~L~f.] 0. secs (0.u,0.s)
Chars 429 - 460 [Section~join_semilattice_order.] 0. secs (0.u,0.s)
Chars 463 - 497 [Context~`{JoinSemiLatticeOrder...] 0. secs (0.u,0.s)
Chars 501 - 547 [Lemma~join_ub_3_r~x~y~z~:~z~≤~...] 0. secs (0.u,0.s)
Chars 550 - 556 [Proof.] 0. secs (0.u,0.s)
Chars 3142 - 3166 [(unfold~WeakFunext~in~wf).] 40.012 secs (0.u,0.003s)
Chars 3217 - 3235 [exists~(f;~idhtpy).] 0. secs (0.u,0.s)
Chars 3236 - 3249 [(intros~[g~h]).] 0. secs (0.u,0.s)
Chars 3470 - 3559 [(pose~~~(r~:=~~~~fun~k~=>~exis...] 0.001 secs (0.001u,0.s)
Chars 3564 - 3630 [(pose~(s~:=~fun~(g~:~forall~x,...] 0.001 secs (0.001u,0.s)
Chars 3758 - 3813 [(change~(r~(fun~x~=>~(f~x;~idp...] 0.001 secs (0.001u,0.s)
Chars 3818 - 3847 [(apply~ap;~srapply~path_contr).] 0.008 secs (0.008u,0.s)
Chars 3142 - 3166 [(unfold~WeakFunext~in~wf).] 0. secs (0.u,0.s)
Chars 3217 - 3235 [exists~(f;~idhtpy).] 0. secs (0.u,0.s)
Chars 3236 - 3249 [(intros~[g~h]).] 0. secs (0.u,0.s)
Chars 3470 - 3559 [(pose~~~(r~:=~~~~fun~k~=>~exis...] 0. secs (0.u,0.s)
Chars 3564 - 3630 [(pose~(s~:=~fun~(g~:~forall~x,...] 0. secs (0.u,0.s)
Chars 3758 - 3813 [(change~(r~(fun~x~=>~(f~x;~idp...] 0. secs (0.u,0.s)
Chars 3818 - 3847 [(apply~ap;~srapply~path_contr).] 0.001 secs (0.001u,0.s)
Chars 3850 - 3858 [Defined.] 0. secs (0.u,0.s)
Chars 3976 - 4018 [Context~(Q~:~forall~g~(h~:~f~=...] 0. secs (0.u,0.s)
Chars 4021 - 4046 [Context~(d~:~Q~f~idhtpy).] 0. secs (0.u,0.s)
Chars 4050 - 4176 [Definition~htpy_ind~g~h~:~Q~g~...] 0.001 secs (0.001u,0.s)
Chars 4245 - 4520 [Definition~htpy_ind_beta~:~htp...] 0.003 secs (0.003u,0.s)
Chars 4522 - 4537 [End~Homotopies.] 0.004 secs (0.004u,0.s)
Chars 4682 - 4776 [Theorem~WeakFunext_implies_Fun...] 0. secs (0.u,0.s)
Chars 4777 - 4783 [Proof.] 0. secs (0.u,0.s)
All solutions:
occurrence 0: transitivity through forall x y : X, dot (a * x * y) b
3 possible(s) substitution(s)
0:	[x: c; y: dot (d * c) d; ]
1:	[x: dot c d; y: dot c d; ]
2:	[x: dot (c * d) c; y: d; ]


Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
All solutions:
occurrence 0: transitivity through forall x y : X, dot (a * x * y) b
3 possible(s) substitution(s)
0:	[x: c; y: dot (d * c) d; ]
1:	[x: dot c d; y: dot c d; ]
2:	[x: dot (c * d) c; y: d; ]


Chars 945 - 979 [(apply~hprop_allpath;~intros~H...] 16.633 secs (0.001u,0.019s)
Chars 982 - 1010 [(apply~path_forall;~intros~a).] 0.001 secs (0.001u,0.s)
Chars 1013 - 1032 [(apply~path_ishprop).] 0.002 secs (0.002u,0.s)
Chars 945 - 979 [(apply~hprop_allpath;~intros~H...] 0. secs (0.u,0.s)
Chars 982 - 1010 [(apply~path_forall;~intros~a).] 0. secs (0.u,0.s)
Chars 1013 - 1032 [(apply~path_ishprop).] 0. secs (0.u,0.s)
Chars 1033 - 1037 [Qed.] 0. secs (0.u,0.s)
Chars 1067 - 1179 [Class~Extensional~{A}~(R~:~Lt~...] 0.001 secs (0.u,0.s)
Chars 1181 - 1288 [#[global]~Instance~ishprop_Ext...] 0. secs (0.u,0.s)
Chars 1289 - 1295 [Proof.] 0. secs (0.u,0.s)
Chars 0 - 28 [Require~Import~Basics~Types.] 1.049 secs (0.925u,0.124s)
All solutions:
occurrence 0: transitivity through forall x y : X, dot (a * x * y) b
3 possible(s) substitution(s)
0:	[x: c; y: dot (d * c) d; ]
1:	[x: dot c d; y: dot c d; ]
2:	[x: dot (c * d) c; y: d; ]


Chars 1296 - 1315 [(unfold~Extensional).] 3.81 secs (0.u,0.021s)
Chars 1316 - 1324 [exact~_.] 0.017 secs (0.012u,0.004s)
Chars 1296 - 1315 [(unfold~Extensional).] 0. secs (0.u,0.s)
Chars 1316 - 1324 [exact~_.] 0. secs (0.u,0.s)
Chars 1325 - 1329 [Qed.] 0. secs (0.u,0.s)
Chars 1352 - 1675 [Class~IsOrdinal@{carrier~relat...] 0.003 secs (0.003u,0.s)
Chars 1677 - 1753 [#[global]~Instance~ishprop_IsO...] 0. secs (0.u,0.s)
Chars 1754 - 1760 [Proof.] 0. secs (0.u,0.s)
All solutions:
occurrence 0: transitivity through forall x y : X, dot (a * x * y) b
3 possible(s) substitution(s)
0:	[x: c; y: dot (d * c) d; ]
1:	[x: dot c d; y: dot c d; ]
2:	[x: dot (c * d) c; y: d; ]


Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 29 - 65 [Require~Import~Algebra.Groups....] 4.807 secs (4.616u,0.19s)
Chars 66 - 105 [Require~Import~Algebra.Groups....] 0.05 secs (0.05u,0.s)
Chars 44 - 82 [Require~Import~HoTT.Basics~HoT...] 0.965 secs (0.895u,0.069s)
Chars 83 - 111 [Require~Import~HProp~HFiber.] 0.09 secs (0.088u,0.001s)
Chars 106 - 150 [Require~Import~Algebra.Groups....] 0.841 secs (0.829u,0.01s)
Chars 151 - 180 [Require~Import~Spaces.Finite.] 0. secs (0.u,0.s)
Chars 181 - 207 [Require~Import~Spaces.Nat.] 0.001 secs (0.001u,0.s)
Chars 208 - 241 [Require~Import~Colimits.Quotient.] 0. secs (0.u,0.s)
Chars 273 - 300 [#[local]Open~Scope~nat_scope.] 0. secs (0.u,0.s)
Chars 302 - 422 [Definition~subgroup_index~{U~:...] 0. secs (0.u,0.s)
Chars 423 - 429 [Proof.] 0. secs (0.u,0.s)
Chars 2024 - 2033 [exists~1.] 40.057 secs (0.u,0.016s)
Chars 2038 - 2055 [(apply~identity_H).] 0. secs (0.u,0.s)
Chars 2024 - 2033 [exists~1.] 0. secs (0.u,0.s)
Chars 2038 - 2055 [(apply~identity_H).] 0. secs (0.u,0.s)
Chars 2058 - 2066 [Defined.] 0. secs (0.u,0.s)
Chars 2070 - 2111 [#[global]Arguments~compose_H~:...] 0. secs (0.u,0.s)
Chars 2114 - 2156 [#[global]Arguments~identity_H~...] 0. secs (0.u,0.s)
Chars 2159 - 2190 [#[global]Arguments~identity~_~/.] 0. secs (0.u,0.s)
Chars 2193 - 2231 [#[global]Arguments~compose~_~_...] 0. secs (0.u,0.s)
Chars 2268 - 2302 [Definition~category~:~PreCateg...] 0. secs (0.u,0.s)
Chars 2305 - 2311 [Proof.] 0. secs (0.u,0.s)
Chars 2316 - 2773 [(refine~~~(@Build_PreCategory~...] 0.09 secs (0.048u,0.025s)
Chars 2316 - 2773 [(refine~~~(@Build_PreCategory~...] 0.001 secs (0.001u,0.s)
Chars 2776 - 2784 [Defined.] 0.003 secs (0.003u,0.s)
Chars 2825 - 3006 [Definition~pr1~:~Functor~categ...] 0.003 secs (0.002u,0.s)
Chars 3007 - 3024 [End~Grothendieck.] 0.034 secs (0.022u,0.012s)
All solutions:
occurrence 0: transitivity through forall x y : X, dot (a * x * y) b
3 possible(s) substitution(s)
0:	[x: c; y: dot (d * c) d; ]
1:	[x: dot c d; y: dot c d; ]
2:	[x: dot (c * d) c; y: d; ]


Chars 112 - 159 [Require~Import~Modalities.Moda...] 4.002 secs (3.948u,0.053s)
All solutions:
occurrence 0: transitivity through forall x y : X, dot (a * x * y) b
3 possible(s) substitution(s)
0:	[x: c; y: dot (d * c) d; ]
1:	[x: dot c d; y: dot c d; ]
2:	[x: dot (c * d) c; y: d; ]


Chars 160 - 187 [Require~Import~Spaces.BAut.] 2.196 secs (2.168u,0.027s)
Chars 189 - 218 [#[local]Open~Scope~trunc_scope.] 0. secs (0.u,0.s)
Chars 219 - 247 [#[local]Open~Scope~path_scope.] 0. secs (0.u,0.s)
Chars 271 - 348 [Class~IsRigid~(A~:~Type)~:=~~~...] 0.001 secs (0.001u,0.s)
Chars 431 - 517 [#[global]~Instance~contr_aut_r...] 0. secs (0.u,0.s)
Chars 518 - 524 [Proof.] 0. secs (0.u,0.s)
Chars 527 - 546 [exists~equiv_idmap.] 0.443 secs (0.001u,0.003s)
Chars 549 - 604 [(intros~f;~apply~path_equiv,~p...] 0.001 secs (0.u,0.s)
Chars 527 - 546 [exists~equiv_idmap.] 0. secs (0.u,0.s)
Chars 549 - 604 [(intros~f;~apply~path_equiv,~p...] 0. secs (0.u,0.s)
Chars 605 - 613 [Defined.] 0. secs (0.u,0.s)
Chars 699 - 789 [#[global]~Instance~contr_baut_...] 0. secs (0.u,0.s)
Chars 790 - 796 [Proof.] 0. secs (0.u,0.s)
Chars 799 - 845 [refine~(contr_change_center~(p...] 0.672 secs (-6.59u,-0.104s)
All solutions:
occurrence 0: transitivity through forall x y : X, dot (a * x * y) b
3 possible(s) substitution(s)
0:	[x: c; y: dot (d * c) d; ]
1:	[x: dot c d; y: dot c d; ]
2:	[x: dot (c * d) c; y: d; ]


All solutions:
occurrence 0: transitivity through forall x y : X, dot (a * x * y) b
3 possible(s) substitution(s)
0:	[x: c; y: dot (d * c) d; ]
1:	[x: dot c d; y: dot c d; ]
2:	[x: dot (c * d) c; y: d; ]


Chars 4786 - 4817 [(intros~wf;~hnf;~intros~A~B~f~g).] 17.034 secs (0.u,0.003s)
Chars 4820 - 4919 [refine~~(isequiv_adjointify~(@...] 0.001 secs (0.001u,0.s)
Chars 4922 - 4923 [-] 0. secs (0.u,0.s)
Chars 4924 - 4961 [(revert~g;~refine~(htpy_ind~wf...] 0.001 secs (0.001u,0.s)
Chars 4966 - 5005 [refine~(ap~_~(htpy_ind_beta~wf...] 0.001 secs (0.001u,0.s)
Chars 5008 - 5009 [-] 0. secs (0.u,0.s)
Chars 5010 - 5031 [(intros~h;~destruct~h).] 0.001 secs (0.001u,0.s)
Chars 5036 - 5068 [refine~(htpy_ind_beta~wf~_~_~_).] 0. secs (0.u,0.s)
Chars 4786 - 4817 [(intros~wf;~hnf;~intros~A~B~f~g).] 0. secs (0.u,0.s)
Chars 4820 - 4919 [refine~~(isequiv_adjointify~(@...] 0. secs (0.u,0.s)
Chars 4924 - 4961 [(revert~g;~refine~(htpy_ind~wf...] 0. secs (0.u,0.s)
Chars 4966 - 5005 [refine~(ap~_~(htpy_ind_beta~wf...] 0. secs (0.u,0.s)
Chars 5010 - 5031 [(intros~h;~destruct~h).] 0. secs (0.u,0.s)
Chars 5036 - 5068 [refine~(htpy_ind_beta~wf~_~_~_).] 0. secs (0.u,0.s)
Chars 5069 - 5077 [Defined.] 0.001 secs (0.001u,0.s)
Chars 5247 - 5378 [Definition~NaiveFunext_implies...] 0. secs (0.u,0.s)
Chars 5569 - 5974 [Definition~equiv_postcompose_f...] 0.004 secs (0.004u,0.s)
Chars 6502 - 6583 [Theorem~NaiveNondepFunext_impl...] 0. secs (0.u,0.s)
Chars 6584 - 6590 [Proof.] 0. secs (0.u,0.s)
Chars 690 - 744 [(pose~(blakers_massey~n~n~(fun...] 40.125 secs (0.028u,0.023s)
Chars 747 - 1011 [(pose~~~(f~:=~~~~equiv_pushout...] 0.007 secs (0.007u,0.s)
Chars 1014 - 1216 [srefine~~(@cancelR_equiv_conn_...] 0.034 secs (0.034u,0.s)
Chars 1219 - 1228 [(intros~x).] 0.001 secs (0.001u,0.s)
Chars 1231 - 1452 [refine~~(_~@~~~(equiv_pushout_...] 0.019 secs (0.016u,0.003s)
Chars 1455 - 1492 [exact~(concat_p1~_~@~concat_1p...] 0.011 secs (0.01u,0.s)
Chars 690 - 744 [(pose~(blakers_massey~n~n~(fun...] 0. secs (0.u,0.s)
Chars 747 - 1011 [(pose~~~(f~:=~~~~equiv_pushout...] 0. secs (0.u,0.s)
Chars 1014 - 1216 [srefine~~(@cancelR_equiv_conn_...] 0.001 secs (0.001u,0.s)
Chars 1219 - 1228 [(intros~x).] 0.001 secs (0.001u,0.s)
Chars 1231 - 1452 [refine~~(_~@~~~(equiv_pushout_...] 0.001 secs (0.001u,0.s)
Chars 1455 - 1492 [exact~(concat_p1~_~@~concat_1p...] 0.004 secs (0.004u,0.s)
Chars 1493 - 1501 [Defined.] 0.118 secs (0.096u,0.022s)
Chars 1621 - 1642 [(induction~x;~trivial).] 18.921 secs (13.329u,0.016s)
All solutions:
occurrence 0: transitivity through forall x y : X, dot (a * x * y) b
3 possible(s) substitution(s)
0:	[x: c; y: dot (d * c) d; ]
1:	[x: dot c d; y: dot c d; ]
2:	[x: dot (c * d) c; y: d; ]


Chars 3139 - 3163 [srapply~Build_HasEquivs.] 40.062 secs (0.01u,0.012s)
Chars 3166 - 3169 [1:~{] 0. secs (0.u,0.s)
Chars 3170 - 3189 [(intros~[F~?]~[G~?]).] 0.001 secs (0.001u,0.s)
Chars 3190 - 3211 [exact~(NatEquiv~F~G).] 0.001 secs (0.001u,0.s)
Chars 3212 - 3213 [}] 0. secs (0.u,0.s)
Chars 3216 - 3219 [1:~{] 0. secs (0.u,0.s)
Chars 3220 - 3259 [(intros~[F~?]~[G~?]~[alpha~?];...] 0.002 secs (0.002u,0.s)
Chars 3266 - 3305 [exact~(forall~a,~CatIsEquiv~(a...] 0.001 secs (0.001u,0.s)
Chars 3306 - 3307 [}] 0. secs (0.u,0.s)
Chars 3310 - 3357 [all:~(intros~[F~?]~[G~?]~[alph...] 0.054 secs (0.05u,0.003s)
Chars 3360 - 3361 [-] 0. secs (0.u,0.s)
Chars 3362 - 3400 [(exists~(fun~a~=>~alpha~a);~as...] 0.002 secs (0.002u,0.s)
Chars 3403 - 3404 [-] 0. secs (0.u,0.s)
Chars 3405 - 3423 [(intros~a;~exact~_).] 0.002 secs (0.002u,0.s)
Chars 3426 - 3427 [-] 0. secs (0.u,0.s)
Chars 3428 - 3437 [(intros~?).] 0. secs (0.u,0.s)
Chars 3442 - 3466 [snrapply~Build_NatEquiv.] 0.004 secs (0.002u,0.002s)
Chars 3471 - 3472 [+] 0. secs (0.u,0.s)
Chars 3473 - 3516 [(intros~a;~exact~(Build_CatEqu...] 0.002 secs (0.001u,0.s)
Chars 3521 - 3522 [+] 0. secs (0.u,0.s)
Chars 3523 - 3527 [(cbn).] 0. secs (0.u,0.s)
Chars 3528 - 3566 [refine~(is1natural_homotopic~a...] 0.002 secs (0.002u,0.s)
Chars 3573 - 3609 [(intros~a;~apply~cate_buildequ...] 0.002 secs (0.001u,0.s)
Chars 3612 - 3613 [-] 0. secs (0.u,0.s)
Chars 3614 - 3653 [(cbn;~intros;~apply~cate_build...] 0.005 secs (0.005u,0.s)
Chars 3656 - 3657 [-] 0. secs (0.u,0.s)
Chars 3658 - 3690 [exists~(fun~a~=>~(alpha~a)^-1$).] 0.002 secs (0.002u,0.s)
Chars 3695 - 3708 [(intros~a~b~f).] 0. secs (0.u,0.s)
Chars 3713 - 3741 [refine~((cat_idr~_)^$~$@~_).] 0.005 secs (0.004u,0.s)
Chars 3746 - 3794 [refine~((_~$@L~(cate_isretr~(a...] 0.005 secs (0.005u,0.s)
Chars 3799 - 3829 [refine~(cat_assoc~_~_~_~$@~_).] 0.002 secs (0.002u,0.s)
Chars 3834 - 3878 [refine~((_~$@L~cat_assoc_opp~_...] 0.004 secs (0.004u,0.s)
Chars 3883 - 3944 [refine~((_~$@L~((isnat~(fun~a~...] 0.008 secs (0.006u,0.001s)
Chars 3949 - 3989 [refine~((_~$@L~cat_assoc~_~_~_...] 0.038 secs (0.033u,0.005s)
Chars 3994 - 4028 [refine~(cat_assoc_opp~_~_~_~$@...] 0.002 secs (0.001u,0.001s)
Chars 4033 - 4077 [refine~((cate_issect~(alpha~b)...] 0.003 secs (0.001u,0.001s)
Chars 4082 - 4100 [exact~(cat_idl~_).] 0.001 secs (0.001u,0.s)
Chars 4103 - 4104 [-] 0. secs (0.u,0.s)
Chars 4105 - 4131 [(intros;~apply~cate_issect).] 0.02 secs (0.015u,0.004s)
Chars 4134 - 4135 [-] 0. secs (0.u,0.s)
Chars 4136 - 4162 [(intros;~apply~cate_isretr).] 0.019 secs (0.017u,0.001s)
Chars 4165 - 4166 [-] 0. secs (0.u,0.s)
Chars 4167 - 4200 [(intros~[gamma~?]~r~s~a;~cbn~i...] 0.004 secs (0.003u,0.001s)
Chars 4205 - 4263 [refine~(catie_adjointify~(alph...] 0.002 secs (0.002u,0.s)
Chars 3139 - 3163 [srapply~Build_HasEquivs.] 0. secs (0.u,0.s)
Chars 3170 - 3189 [(intros~[F~?]~[G~?]).] 0. secs (0.u,0.s)
Chars 3190 - 3211 [exact~(NatEquiv~F~G).] 0. secs (0.u,0.s)
Chars 3220 - 3259 [(intros~[F~?]~[G~?]~[alpha~?];...] 0. secs (0.u,0.s)
Chars 3266 - 3305 [exact~(forall~a,~CatIsEquiv~(a...] 0. secs (0.u,0.s)
Chars 3310 - 3357 [all:~(intros~[F~?]~[G~?]~[alph...] 0.013 secs (0.013u,0.s)
Chars 3362 - 3400 [(exists~(fun~a~=>~alpha~a);~as...] 0.001 secs (0.001u,0.s)
Chars 3405 - 3423 [(intros~a;~exact~_).] 0.001 secs (0.u,0.s)
Chars 3428 - 3437 [(intros~?).] 0. secs (0.u,0.s)
Chars 3442 - 3466 [snrapply~Build_NatEquiv.] 0. secs (0.u,0.s)
Chars 3473 - 3516 [(intros~a;~exact~(Build_CatEqu...] 0. secs (0.u,0.s)
Chars 3523 - 3527 [(cbn).] 0. secs (0.u,0.s)
Chars 3528 - 3566 [refine~(is1natural_homotopic~a...] 0. secs (0.u,0.s)
Chars 3573 - 3609 [(intros~a;~apply~cate_buildequ...] 0.001 secs (0.001u,0.s)
Chars 3614 - 3653 [(cbn;~intros;~apply~cate_build...] 0.003 secs (0.003u,0.s)
Chars 3658 - 3690 [exists~(fun~a~=>~(alpha~a)^-1$).] 0. secs (0.u,0.s)
Chars 3695 - 3708 [(intros~a~b~f).] 0. secs (0.u,0.s)
Chars 3713 - 3741 [refine~((cat_idr~_)^$~$@~_).] 0. secs (0.u,0.s)
Chars 3746 - 3794 [refine~((_~$@L~(cate_isretr~(a...] 0.001 secs (0.u,0.s)
Chars 3799 - 3829 [refine~(cat_assoc~_~_~_~$@~_).] 0.001 secs (0.001u,0.s)
Chars 3834 - 3878 [refine~((_~$@L~cat_assoc_opp~_...] 0.001 secs (0.001u,0.s)
Chars 3883 - 3944 [refine~((_~$@L~((isnat~(fun~a~...] 0.001 secs (0.001u,0.s)
Chars 3949 - 3989 [refine~((_~$@L~cat_assoc~_~_~_...] 0.001 secs (0.u,0.s)
Chars 3994 - 4028 [refine~(cat_assoc_opp~_~_~_~$@...] 0.001 secs (0.001u,0.s)
Chars 4033 - 4077 [refine~((cate_issect~(alpha~b)...] 0.001 secs (0.001u,0.s)
Chars 4082 - 4100 [exact~(cat_idl~_).] 0.001 secs (0.u,0.001s)
Chars 4105 - 4131 [(intros;~apply~cate_issect).] 0.014 secs (0.011u,0.002s)
Chars 4136 - 4162 [(intros;~apply~cate_isretr).] 0.014 secs (0.01u,0.003s)
Chars 4167 - 4200 [(intros~[gamma~?]~r~s~a;~cbn~i...] 0.001 secs (0.001u,0.s)
Chars 4205 - 4263 [refine~(catie_adjointify~(alph...] 0. secs (0.u,0.s)
Chars 4264 - 4272 [Defined.] 0.058 secs (0.045u,0.013s)
Chars 4321 - 4487 [Record~Fun11~(A~B~:~Type)~`{Is...] 0.006 secs (0.005u,0.s)
Chars 4489 - 4529 [Coercion~fun11_fun~:~Fun11~>->...] 0. secs (0.u,0.s)
Chars 4530 - 4572 [#[global]Existing~Instance~is0...] 0. secs (0.u,0.s)
Chars 4573 - 4615 [#[global]Existing~Instance~is1...] 0. secs (0.u,0.s)
Chars 4617 - 4779 [Arguments~Build_Fun11~A~B~~~{i...] 0. secs (0.u,0.s)
Chars 4781 - 4880 [Coercion~fun01_fun11~{A~B~:~Ty...] 0.002 secs (0.002u,0.s)
Chars 4881 - 4887 [Proof.] 0. secs (0.u,0.s)
Chars 302 - 331 [(intros~?~?~E~e;~rewrite~e~in~E).] 40.065 secs (0.001u,0.018s)
Chars 332 - 360 [(apply~(irreflexivity~_~_~E)).] 0. secs (0.u,0.s)
Chars 302 - 331 [(intros~?~?~E~e;~rewrite~e~in~E).] 0. secs (0.u,0.s)
Chars 332 - 360 [(apply~(irreflexivity~_~_~E)).] 0. secs (0.u,0.s)
Chars 361 - 365 [Qed.] 0. secs (0.u,0.s)
Chars 367 - 441 [Lemma~le_flip~`{Le~A}~`{!Total...] 0. secs (0.u,0.s)
Chars 442 - 448 [Proof.] 0. secs (0.u,0.s)
All solutions:
occurrence 0: transitivity through forall x y : X, dot (a * x * y) b
3 possible(s) substitution(s)
0:	[x: c; y: dot (d * c) d; ]
1:	[x: dot c d; y: dot c d; ]
2:	[x: dot (c * d) c; y: d; ]


All solutions:
occurrence 0: transitivity through forall x y : X, dot (a * x * y) b
3 possible(s) substitution(s)
0:	[x: c; y: dot (d * c) d; ]
1:	[x: dot c d; y: dot c d; ]
2:	[x: dot (c * d) c; y: d; ]


Chars 1637 - 1688 [(intros~E~e;~induction~e;~simp...] 40.074 secs (0.009u,0.021s)
Chars 1637 - 1688 [(intros~E~e;~induction~e;~simp...] 0.005 secs (0.005u,0.s)
Chars 1689 - 1693 [Qed.] 0.001 secs (0.u,0.s)
Chars 1695 - 1726 [Definition~noVars~:~Vars~Empty.] 0. secs (0.u,0.s)
Chars 1727 - 1733 [Proof.] 0. secs (0.u,0.s)
Chars 1734 - 1744 [(intros~[]).] 0.035 secs (0.u,0.017s)
Chars 1734 - 1744 [(intros~[]).] 0. secs (0.u,0.s)
Chars 1745 - 1753 [Defined.] 0. secs (0.u,0.s)
Chars 1755 - 1804 [Definition~singleton~x~:~Vars~...] 0. secs (0.u,0.s)
Chars 1806 - 1948 [Definition~merge~{A~B~:~Type0}...] 0. secs (0.u,0.s)
Chars 1950 - 1965 [Section~Lookup.] 0. secs (0.u,0.s)
Chars 1969 - 2063 [Class~Lookup~{A~:~Type0}~(x~:~...] 0.001 secs (0.001u,0.s)
Chars 2067 - 2103 [#[global]Arguments~lookup~{A}~...] 0. secs (0.u,0.s)
Chars 2107 - 2162 [Context~(x~:~R)~{A~B~:~Type0}~...] 0. secs (0.u,0.s)
Chars 2166 - 2231 [#[local]Instance~lookup_l~~`{!...] 0. secs (0.u,0.s)
Chars 2234 - 2240 [Proof.] 0. secs (0.u,0.s)
Chars 874 - 943 [(srapply~(Build_diagram_equiv~...] 40.027 secs (0.016u,0.002s)
Chars 946 - 947 [-] 0. secs (0.u,0.s)
Chars 948 - 964 [(apply~equiv_fun).] 0. secs (0.u,0.s)
Chars 969 - 981 [(induction~n).] 0. secs (0.u,0.s)
Chars 986 - 987 [+] 0. secs (0.u,0.s)
Chars 988 - 997 [(apply~H0).] 0. secs (0.u,0.s)
Chars 1002 - 1003 [+] 0. secs (0.u,0.s)
Chars 1004 - 1023 [exact~(Hn~n~IHn).1.] 0. secs (0.u,0.s)
Chars 1026 - 1027 [-] 0. secs (0.u,0.s)
Chars 1028 - 1051 [(intros~m~q;~destruct~q).] 0.002 secs (0.001u,0.s)
Chars 1056 - 1075 [(induction~n;~simpl).] 0.003 secs (0.003u,0.s)
Chars 1080 - 1081 [+] 0. secs (0.u,0.s)
Chars 1082 - 1100 [exact~(Hn~0~H0).2.] 0.001 secs (0.001u,0.s)
Chars 1105 - 1106 [+] 0. secs (0.u,0.s)
Chars 1107 - 1135 [simple~refine~(Hn~n.+1~_).2.] 0.001 secs (0.001u,0.s)
Chars 1138 - 1139 [-] 0. secs (0.u,0.s)
Chars 1140 - 1159 [(induction~n;~simpl).] 0.002 secs (0.002u,0.s)
Chars 1164 - 1165 [+] 0. secs (0.u,0.s)
Chars 1166 - 1175 [(apply~H0).] 0. secs (0.u,0.s)
Chars 1180 - 1181 [+] 0. secs (0.u,0.s)
Chars 1182 - 1200 [(apply~(Hn~n~_).1).] 0.001 secs (0.001u,0.s)
Chars 874 - 943 [(srapply~(Build_diagram_equiv~...] 0.002 secs (0.002u,0.s)
Chars 948 - 964 [(apply~equiv_fun).] 0. secs (0.u,0.s)
Chars 969 - 981 [(induction~n).] 0. secs (0.u,0.s)
Chars 988 - 997 [(apply~H0).] 0. secs (0.u,0.s)
Chars 1004 - 1023 [exact~(Hn~n~IHn).1.] 0. secs (0.u,0.s)
Chars 1028 - 1051 [(intros~m~q;~destruct~q).] 0.001 secs (0.001u,0.s)
Chars 1056 - 1075 [(induction~n;~simpl).] 0.002 secs (0.002u,0.s)
Chars 1082 - 1100 [exact~(Hn~0~H0).2.] 0. secs (0.u,0.s)
Chars 1107 - 1135 [simple~refine~(Hn~n.+1~_).2.] 0. secs (0.u,0.s)
Chars 1140 - 1159 [(induction~n;~simpl).] 0.001 secs (0.001u,0.s)
Chars 1166 - 1175 [(apply~H0).] 0. secs (0.u,0.s)
Chars 1182 - 1200 [(apply~(Hn~n~_).1).] 0. secs (0.u,0.s)
Chars 1201 - 1209 [Defined.] 0.006 secs (0.005u,0.s)
All solutions:
occurrence 0: transitivity through forall x y : X, dot (a * x * y) b
3 possible(s) substitution(s)
0:	[x: c; y: dot (d * c) d; ]
1:	[x: dot c d; y: dot c d; ]
2:	[x: dot (c * d) c; y: d; ]


Chars 819 - 843 [(induction~k~as~[|~k~q]).] 40.102 secs (0.001u,0.016s)
Chars 846 - 847 [-] 0. secs (0.u,0.s)
Chars 848 - 856 [exact~a.] 0. secs (0.u,0.s)
Chars 859 - 860 [-] 0. secs (0.u,0.s)
Chars 861 - 871 [exact~(q)~^+.] 0. secs (0.u,0.s)
Chars 819 - 843 [(induction~k~as~[|~k~q]).] 0. secs (0.u,0.s)
Chars 848 - 856 [exact~a.] 0. secs (0.u,0.s)
Chars 861 - 871 [exact~(q)~^+.] 0. secs (0.u,0.s)
Chars 872 - 880 [Defined.] 0. secs (0.u,0.s)
Chars 882 - 932 [Notation~"a~^+~k"~:=~(seq_shif...] 0. secs (0.u,0.s)
Chars 996 - 1057 [Definition~seq_pair_shift~{A~:...] 0. secs (0.u,0.s)
Chars 1058 - 1064 [Proof.] 0. secs (0.u,0.s)
Chars 1067 - 1106 [(destruct~x~as~[n~a];~exact~(n...] 0.748 secs (0.003u,0.017s)
Chars 1067 - 1106 [(destruct~x~as~[n~a];~exact~(n...] 0. secs (0.u,0.s)
Chars 1107 - 1115 [Defined.] 0. secs (0.u,0.s)
Chars 1117 - 1191 [Definition~seq_pair_shift_by~{...] 0. secs (0.u,0.s)
Chars 1192 - 1198 [Proof.] 0. secs (0.u,0.s)
Chars 1201 - 1225 [(induction~k~as~[|~k~y]).] 0.044 secs (0.u,0.018s)
Chars 1228 - 1229 [-] 0. secs (0.u,0.s)
Chars 1230 - 1238 [exact~x.] 0. secs (0.u,0.s)
Chars 1241 - 1242 [-] 0. secs (0.u,0.s)
Chars 1243 - 1268 [exact~(seq_pair_shift~y).] 0. secs (0.u,0.s)
Chars 1201 - 1225 [(induction~k~as~[|~k~y]).] 0. secs (0.u,0.s)
Chars 1230 - 1238 [exact~x.] 0. secs (0.u,0.s)
Chars 1243 - 1268 [exact~(seq_pair_shift~y).] 0. secs (0.u,0.s)
Chars 1269 - 1277 [Defined.] 0. secs (0.u,0.s)
Chars 1279 - 1318 [Notation~"x~^++"~:=~(seq_pair_...] 0. secs (0.u,0.s)
Chars 1319 - 1365 [Notation~"x~^++~k"~:=~(seq_pai...] 0. secs (0.u,0.s)
Chars 1367 - 1464 [Definition~seq_pair_shift_asso...] 0. secs (0.u,0.s)
Chars 1465 - 1471 [Proof.] 0. secs (0.u,0.s)
All solutions:
occurrence 0: transitivity through forall x y : X, dot (a * x * y) b
3 possible(s) substitution(s)
0:	[x: c; y: dot (d * c) d; ]
1:	[x: dot c d; y: dot c d; ]
2:	[x: dot (c * d) c; y: d; ]


All solutions:
occurrence 0: transitivity through forall x y : X, dot (a * x * y) b
3 possible(s) substitution(s)
0:	[x: c; y: dot (d * c) d; ]
1:	[x: dot c d; y: dot c d; ]
2:	[x: dot (c * d) c; y: d; ]


All solutions:
occurrence 0: transitivity through forall x y : X, dot (a * x * y) b
3 possible(s) substitution(s)
0:	[x: c; y: dot (d * c) d; ]
1:	[x: dot c d; y: dot c d; ]
2:	[x: dot (c * d) c; y: d; ]


All solutions:
occurrence 0: transitivity through forall x y : X, dot (a * x * y) b
3 possible(s) substitution(s)
0:	[x: c; y: dot (d * c) d; ]
1:	[x: dot c d; y: dot c d; ]
2:	[x: dot (c * d) c; y: d; ]


All solutions:
occurrence 0: transitivity through forall x y : X, dot (a * x * y) b
4 possible(s) substitution(s)
0:	[x: c; y: dot (d * c * d) b; ]
1:	[x: dot c d; y: dot (c * d) b; ]
2:	[x: dot (c * d) c; y: dot d b; ]
3:	[x: dot (c * d * c) d; y: b; ]

occurrence 1: transitivity through forall x y : X, dot (a * x * y * b) b
3 possible(s) substitution(s)
0:	[x: c; y: dot (d * c) d; ]
1:	[x: dot c d; y: dot c d; ]
2:	[x: dot (c * d) c; y: d; ]


All solutions:
occurrence 0: transitivity through forall x y : X, dot (a * x * y) b
4 possible(s) substitution(s)
0:	[x: c; y: dot (d * c * d) b; ]
1:	[x: dot c d; y: dot (c * d) b; ]
2:	[x: dot (c * d) c; y: dot d b; ]
3:	[x: dot (c * d * c) d; y: b; ]

occurrence 1: transitivity through forall x y : X, dot (a * x * y * b) b
3 possible(s) substitution(s)
0:	[x: c; y: dot (d * c) d; ]
1:	[x: dot c d; y: dot c d; ]
2:	[x: dot (c * d) c; y: d; ]


All solutions:
occurrence 0: transitivity through forall x y : X, dot (a * x * y) b
4 possible(s) substitution(s)
0:	[x: c; y: dot (d * c * d) b; ]
1:	[x: dot c d; y: dot (c * d) b; ]
2:	[x: dot (c * d) c; y: dot d b; ]
3:	[x: dot (c * d * c) d; y: b; ]

occurrence 1: transitivity through forall x y : X, dot (a * x * y * b) b
3 possible(s) substitution(s)
0:	[x: c; y: dot (d * c) d; ]
1:	[x: dot c d; y: dot c d; ]
2:	[x: dot (c * d) c; y: d; ]


All solutions:
occurrence 0: transitivity through forall x y : X, dot (a * x * y) b
4 possible(s) substitution(s)
0:	[x: c; y: dot (d * c * d) b; ]
1:	[x: dot c d; y: dot (c * d) b; ]
2:	[x: dot (c * d) c; y: dot d b; ]
3:	[x: dot (c * d * c) d; y: b; ]

occurrence 1: transitivity through forall x y : X, dot (a * x * y * b) b
3 possible(s) substitution(s)
0:	[x: c; y: dot (d * c) d; ]
1:	[x: dot c d; y: dot c d; ]
2:	[x: dot (c * d) c; y: d; ]


All solutions:
occurrence 0: transitivity through forall x y : X, dot (a * x * y) b
4 possible(s) substitution(s)
0:	[x: c; y: dot (d * c * d) b; ]
1:	[x: dot c d; y: dot (c * d) b; ]
2:	[x: dot (c * d) c; y: dot d b; ]
3:	[x: dot (c * d * c) d; y: b; ]

occurrence 1: transitivity through forall x y : X, dot (a * x * y * b) b
3 possible(s) substitution(s)
0:	[x: c; y: dot (d * c) d; ]
1:	[x: dot c d; y: dot c d; ]
2:	[x: dot (c * d) c; y: d; ]


Chars 3803 - 4167 [(refine~~~(Build_Functor~(fst~...] 40.04 secs (0.018u,0.015s)
Chars 3803 - 4167 [(refine~~~(Build_Functor~(fst~...] 0.001 secs (0.001u,0.s)
Chars 4170 - 4178 [Defined.] 0.003 secs (0.003u,0.s)
Chars 4179 - 4214 [End~comma_category_induced_fun...] 0.019 secs (0.019u,0.s)
Chars 4299 - 4338 [Section~slice_category_induced...] 0. secs (0.u,0.s)
Chars 4341 - 4359 [Context~`{Funext}.] 0. secs (0.u,0.s)
Chars 4362 - 4387 [Variable~(C~:~PreCategory).] 0. secs (0.u,0.s)
Chars 4391 - 4413 [Section~slice_coslice.] 0. secs (0.u,0.s)
Chars 4418 - 4443 [Variable~(D~:~PreCategory).] 0. secs (0.u,0.s)
Chars 4593 - 4697 [Definition~slice_category_indu...] 0.005 secs (0.004u,0.001s)
Chars 4702 - 4708 [Proof.] 0. secs (0.u,0.s)
All solutions:
occurrence 0: transitivity through forall x y : X, dot (a * x * y) b
4 possible(s) substitution(s)
0:	[x: c; y: dot (d * c * d) b; ]
1:	[x: dot c d; y: dot (c * d) b; ]
2:	[x: dot (c * d) c; y: dot d b; ]
3:	[x: dot (c * d * c) d; y: b; ]

occurrence 1: transitivity through forall x y : X, dot (a * x * y * b) b
3 possible(s) substitution(s)
0:	[x: c; y: dot (d * c) d; ]
1:	[x: dot c d; y: dot c d; ]
2:	[x: dot (c * d) c; y: d; ]


All solutions:
occurrence 0: transitivity through forall x y : X, dot (a * x * y) b
1 possible(s) substitution(s)
0:	[x: plus (d * c * d) c; y: b; ]


Chars 432 - 472 [refine~(fcard~(Quotient~(in_co...] 28.195 secs (0.053u,0.02s)
Chars 475 - 499 [nrapply~finite_quotient.] 0.025 secs (0.012u,0.012s)
Chars 502 - 515 [1-5:~exact~_.] 0.009 secs (0.008u,0.s)
Chars 518 - 529 [(intros~x~y).] 0. secs (0.u,0.s)
Chars 532 - 575 [(pose~(dec_H~:=~detachable_fin...] 0.007 secs (0.004u,0.002s)
Chars 578 - 590 [(apply~dec_H).] 0. secs (0.u,0.s)
Chars 432 - 472 [refine~(fcard~(Quotient~(in_co...] 0. secs (0.u,0.s)
Chars 475 - 499 [nrapply~finite_quotient.] 0. secs (0.u,0.s)
Chars 502 - 515 [1-5:~exact~_.] 0. secs (0.u,0.s)
Chars 518 - 529 [(intros~x~y).] 0. secs (0.u,0.s)
Chars 532 - 575 [(pose~(dec_H~:=~detachable_fin...] 0. secs (0.u,0.s)
Chars 578 - 590 [(apply~dec_H).] 0. secs (0.u,0.s)
Chars 591 - 599 [Defined.] 0.001 secs (0.001u,0.s)
Chars 898 - 1039 [Theorem~lagrange~{U~:~Univalen...] 0.001 secs (0.001u,0.s)
Chars 1040 - 1046 [Proof.] 0. secs (0.u,0.s)
Chars 1734 - 1745 [(destruct~p).] 40.07 secs (0.001u,0.017s)
Chars 1746 - 1781 [exact~(BuildIsomorphic~(hom_id...] 0.002 secs (0.001u,0.s)
Chars 1734 - 1745 [(destruct~p).] 0. secs (0.u,0.s)
Chars 1746 - 1781 [exact~(BuildIsomorphic~(hom_id...] 0. secs (0.u,0.s)
Chars 1782 - 1790 [Defined.] 0. secs (0.u,0.s)
Chars 1973 - 2183 [Lemma~path_isomorphic~`{Funext...] 0.002 secs (0.001u,0.s)
Chars 2184 - 2190 [Proof.] 0. secs (0.u,0.s)
All solutions:
occurrence 0: transitivity through forall x y : X, dot (a * x * y) b
4 possible(s) substitution(s)
0:	[x: c; y: dot (d * c * d) b; ]
1:	[x: dot c d; y: dot (c * d) b; ]
2:	[x: dot (c * d) c; y: dot d b; ]
3:	[x: dot (c * d * c) d; y: b; ]

occurrence 1: transitivity through forall x y : X, dot (a * x * y * b) b
3 possible(s) substitution(s)
0:	[x: c; y: dot (d * c) d; ]
1:	[x: dot c d; y: dot c d; ]
2:	[x: dot (c * d) c; y: d; ]


All solutions:
occurrence 0: transitivity through forall x y : X, dot (a * x * y) b
1 possible(s) substitution(s)
0:	[x: plus (d * c * d) c; y: b; ]


Chars 1621 - 1642 [(induction~x;~trivial).] 40.008 secs (0.002u,0.002s)
Chars 1647 - 1657 [(cbn;~f_ap).] 0.001 secs (0.001u,0.s)
Chars 1621 - 1642 [(induction~x;~trivial).] 0. secs (0.u,0.s)
Chars 1647 - 1657 [(cbn;~f_ap).] 0. secs (0.u,0.s)
Chars 1660 - 1668 [Defined.] 0. secs (0.u,0.s)
Chars 1672 - 1754 [#[local]~Definition~word_conca...] 0. secs (0.u,0.s)
Chars 1757 - 1763 [Proof.] 0. secs (0.u,0.s)
Chars 559 - 575 [(apply~join_ub_r).] 40.012 secs (0.u,0.004s)
Chars 559 - 575 [(apply~join_ub_r).] 0. secs (0.u,0.s)
Chars 578 - 582 [Qed.] 0. secs (0.u,0.s)
Chars 586 - 632 [Lemma~join_ub_3_m~x~y~z~:~y~≤~...] 0. secs (0.u,0.s)
Chars 635 - 641 [Proof.] 0. secs (0.u,0.s)
All solutions:
occurrence 0: transitivity through forall x y : X, dot (a * x * y) b
4 possible(s) substitution(s)
0:	[x: c; y: dot (d * c * d) b; ]
1:	[x: dot c d; y: dot (c * d) b; ]
2:	[x: dot (c * d) c; y: dot d b; ]
3:	[x: dot (c * d * c) d; y: b; ]

occurrence 1: transitivity through forall x y : X, dot (a * x * y * b) b
3 possible(s) substitution(s)
0:	[x: c; y: dot (d * c) d; ]
1:	[x: dot c d; y: dot c d; ]
2:	[x: dot (c * d) c; y: d; ]


All solutions:
occurrence 0: transitivity through forall x y : X, dot (a * x * y) b
1 possible(s) substitution(s)
0:	[x: plus (d * c * d) c; y: b; ]


Chars 4715 - 4827 [(exists~(fun~_~:~Unit~=>~m);~s...] 6.238 secs (4.404u,0.099s)
All solutions:
occurrence 0: transitivity through forall x y : X, dot (a * x * y) b
4 possible(s) substitution(s)
0:	[x: c; y: dot (d * c * d) b; ]
1:	[x: dot c d; y: dot (c * d) b; ]
2:	[x: dot (c * d) c; y: dot d b; ]
3:	[x: dot (c * d * c) d; y: b; ]

occurrence 1: transitivity through forall x y : X, dot (a * x * y * b) b
3 possible(s) substitution(s)
0:	[x: c; y: dot (d * c) d; ]
1:	[x: dot c d; y: dot c d; ]
2:	[x: dot (c * d) c; y: d; ]


All solutions:
occurrence 0: transitivity through forall x y : X, dot (a * x * y) b
4 possible(s) substitution(s)
0:	[x: c; y: dot (d * c * d) b; ]
1:	[x: dot c d; y: dot (c * d) b; ]
2:	[x: dot (c * d) c; y: dot d b; ]
3:	[x: dot (c * d * c) d; y: b; ]

occurrence 1: transitivity through forall x y : X, dot (a * x * y * b) b
3 possible(s) substitution(s)
0:	[x: c; y: dot (d * c) d; ]
1:	[x: dot c d; y: dot c d; ]
2:	[x: dot (c * d) c; y: d; ]


All solutions:
occurrence 0: transitivity through forall x y : X, dot (a * x * y) b
4 possible(s) substitution(s)
0:	[x: c; y: dot (d * c * d) b; ]
1:	[x: dot c d; y: dot (c * d) b; ]
2:	[x: dot (c * d) c; y: dot d b; ]
3:	[x: dot (c * d * c) d; y: b; ]

occurrence 1: transitivity through forall x y : X, dot (a * x * y * b) b
3 possible(s) substitution(s)
0:	[x: c; y: dot (d * c) d; ]
1:	[x: dot c d; y: dot c d; ]
2:	[x: dot (c * d) c; y: d; ]


All solutions:
occurrence 0: transitivity through forall x y : X, dot (a * x * y) b
1 possible(s) substitution(s)
0:	[x: plus (d * c * d) c; y: b; ]


All solutions:
occurrence 0: transitivity through forall x y : X, dot (a * x * y) b
4 possible(s) substitution(s)
0:	[x: c; y: dot (d * c * d) b; ]
1:	[x: dot c d; y: dot (c * d) b; ]
2:	[x: dot (c * d) c; y: dot d b; ]
3:	[x: dot (c * d * c) d; y: b; ]

occurrence 1: transitivity through forall x y : X, dot (a * x * y * b) b
3 possible(s) substitution(s)
0:	[x: c; y: dot (d * c) d; ]
1:	[x: dot c d; y: dot c d; ]
2:	[x: dot (c * d) c; y: d; ]


Chars 1763 - 1792 [(eapply~istrunc_equiv_istrunc).] 40.081 secs (0.001u,0.019s)
Chars 1793 - 1794 [{] 0. secs (0.u,0.s)
Chars 1799 - 1805 [issig.] 0.05 secs (0.04u,0.009s)
Chars 1808 - 1809 [}] 0. secs (0.u,0.s)
Chars 1812 - 1830 [(unfold~Transitive).] 0. secs (0.u,0.s)
Chars 1831 - 1839 [exact~_.] 0.075 secs (0.061u,0.014s)
Chars 1763 - 1792 [(eapply~istrunc_equiv_istrunc).] 0. secs (0.u,0.s)
Chars 1799 - 1805 [issig.] 0. secs (0.u,0.s)
Chars 1812 - 1830 [(unfold~Transitive).] 0. secs (0.u,0.s)
Chars 1831 - 1839 [exact~_.] 0. secs (0.u,0.s)
Chars 1840 - 1844 [Qed.] 0.01 secs (0.009u,0.s)
Chars 1847 - 2064 [Record~Ordinal@{carrier~relati...] 0.001 secs (0.001u,0.s)
Chars 2066 - 2126 [#[global]Existing~Instances~or...] 0. secs (0.u,0.s)
Chars 2128 - 2210 [Coercion~ordinal_as_hset~(A~:~...] 0.007 secs (0.007u,0.s)
Chars 2214 - 2298 [#[global]~Instance~irreflexive...] 0. secs (0.u,0.s)
Chars 2299 - 2305 [Proof.] 0. secs (0.u,0.s)
All solutions:
occurrence 0: transitivity through forall x y : X, dot (a * x * y) b
4 possible(s) substitution(s)
0:	[x: c; y: dot (d * c * d) b; ]
1:	[x: dot c d; y: dot (c * d) b; ]
2:	[x: dot (c * d) c; y: dot d b; ]
3:	[x: dot (c * d * c) d; y: b; ]

occurrence 1: transitivity through forall x y : X, dot (a * x * y * b) b
3 possible(s) substitution(s)
0:	[x: c; y: dot (d * c) d; ]
1:	[x: dot c d; y: dot c d; ]
2:	[x: dot (c * d) c; y: d; ]


All solutions:
occurrence 0: transitivity through forall x y : X, dot (a * x * y) b
4 possible(s) substitution(s)
0:	[x: c; y: dot (d * c * d) b; ]
1:	[x: dot c d; y: dot (c * d) b; ]
2:	[x: dot (c * d) c; y: dot d b; ]
3:	[x: dot (c * d * c) d; y: b; ]

occurrence 1: transitivity through forall x y : X, dot (a * x * y * b) b
3 possible(s) substitution(s)
0:	[x: c; y: dot (d * c) d; ]
1:	[x: dot c d; y: dot c d; ]
2:	[x: dot (c * d) c; y: d; ]


All solutions:
occurrence 0: transitivity through forall x y : X, dot (a * x * y) b
1 possible(s) substitution(s)
0:	[x: plus (d * c * d) c; y: b; ]


All solutions:
occurrence 0: transitivity through forall x y : X, dot (a * x * y) b
4 possible(s) substitution(s)
0:	[x: c; y: dot (d * c * d) b; ]
1:	[x: dot c d; y: dot (c * d) b; ]
2:	[x: dot (c * d) c; y: dot d b; ]
3:	[x: dot (c * d * c) d; y: b; ]

occurrence 1: transitivity through forall x y : X, dot (a * x * y * b) b
3 possible(s) substitution(s)
0:	[x: c; y: dot (d * c) d; ]
1:	[x: dot c d; y: dot c d; ]
2:	[x: dot (c * d) c; y: d; ]


All solutions:
occurrence 0: transitivity through forall x y : X, dot (a * x * y) b
4 possible(s) substitution(s)
0:	[x: c; y: dot (d * c * d) b; ]
1:	[x: dot c d; y: dot (c * d) b; ]
2:	[x: dot (c * d) c; y: dot d b; ]
3:	[x: dot (c * d * c) d; y: b; ]

occurrence 1: transitivity through forall x y : X, dot (a * x * y * b) b
3 possible(s) substitution(s)
0:	[x: c; y: dot (d * c) d; ]
1:	[x: dot c d; y: dot c d; ]
2:	[x: dot (c * d) c; y: d; ]


All solutions:
occurrence 0: transitivity through forall x y : X, dot (a * x * y) b
4 possible(s) substitution(s)
0:	[x: c; y: dot (d * c * d) b; ]
1:	[x: dot c d; y: dot (c * d) b; ]
2:	[x: dot (c * d) c; y: dot d b; ]
3:	[x: dot (c * d * c) d; y: b; ]

occurrence 1: transitivity through forall x y : X, dot (a * x * y * b) b
3 possible(s) substitution(s)
0:	[x: c; y: dot (d * c) d; ]
1:	[x: dot c d; y: dot c d; ]
2:	[x: dot (c * d) c; y: d; ]


All solutions:
occurrence 0: transitivity through forall x y : X, dot (a * x * y) b
1 possible(s) substitution(s)
0:	[x: plus (d * c * d) c; y: b; ]


All solutions:
occurrence 0: transitivity through forall x y : X, dot (a * x * y) b
1 possible(s) substitution(s)
0:	[x: plus (d * c * d) c; y: b; ]


Chars 799 - 845 [refine~(contr_change_center~(p...] 40.012 secs (0.004u,0.004s)
Chars 848 - 881 [refine~(contr_trunc_conn~(Tr~0)).] 0.161 secs (0.158u,0.002s)
Chars 884 - 908 [(intros~Z~W;~baut_reduce).] 0.008 secs (0.008u,0.s)
Chars 911 - 1030 [refine~~(istrunc_equiv_istrunc...] 0.009 secs (0.009u,0.s)
Chars 799 - 845 [refine~(contr_change_center~(p...] 0. secs (0.u,0.s)
Chars 848 - 881 [refine~(contr_trunc_conn~(Tr~0)).] 0. secs (0.u,0.s)
Chars 884 - 908 [(intros~Z~W;~baut_reduce).] 0. secs (0.u,0.s)
Chars 911 - 1030 [refine~~(istrunc_equiv_istrunc...] 0. secs (0.u,0.s)
Chars 1031 - 1039 [Defined.] 0.001 secs (0.001u,0.s)
Chars 1041 - 1126 [Definition~rigid_contr_Baut~`{...] 0. secs (0.u,0.s)
Chars 1127 - 1133 [Proof.] 0. secs (0.u,0.s)
Chars 6593 - 6609 [(intros~nf~X~P~H).] 40.012 secs (0.u,0.002s)
Chars 6612 - 6699 [(pose~~~(T~:=~~~~hfiber~(equiv...] 0.001 secs (0.001u,0.s)
Chars 6702 - 6855 [exact~~(@contr_retract~T~_~_~(...] 0.006 secs (0.006u,0.s)
Chars 6593 - 6609 [(intros~nf~X~P~H).] 0. secs (0.u,0.s)
Chars 6612 - 6699 [(pose~~~(T~:=~~~~hfiber~(equiv...] 0. secs (0.u,0.s)
Chars 6702 - 6855 [exact~~(@contr_retract~T~_~_~(...] 0. secs (0.u,0.s)
Chars 6856 - 6864 [Defined.] 0.001 secs (0.001u,0.s)
Chars 7130 - 7313 [Definition~NaiveNondepFunext_i...] 0. secs (0.u,0.s)
Chars 7469 - 7531 [Lemma~Funext_downward_closed~`...] 0. secs (0.u,0.s)
Chars 7532 - 7538 [Proof.] 0. secs (0.u,0.s)
Chars 7541 - 7575 [(apply~@NaiveFunext_implies_Fu...] 0.449 secs (0.u,0.002s)
Chars 7578 - 7616 [(apply~Funext_implies_NaiveFun...] 0. secs (0.u,0.s)
Chars 7619 - 7628 [(hnf~in~*).] 0. secs (0.u,0.s)
Chars 7631 - 7649 [(intros~A~P~f~g~H').] 0. secs (0.u,0.s)
Chars 7812 - 7882 [(case~(H~(Lift~A)~(fun~x~=>~Li...] 0.001 secs (0.001u,0.s)
Chars 7885 - 7898 [exact~idpath.] 0. secs (0.u,0.s)
Chars 7541 - 7575 [(apply~@NaiveFunext_implies_Fu...] 0. secs (0.u,0.s)
Chars 7578 - 7616 [(apply~Funext_implies_NaiveFun...] 0. secs (0.u,0.s)
Chars 7619 - 7628 [(hnf~in~*).] 0. secs (0.u,0.s)
Chars 7631 - 7649 [(intros~A~P~f~g~H').] 0. secs (0.u,0.s)
Chars 7812 - 7882 [(case~(H~(Lift~A)~(fun~x~=>~Li...] 0. secs (0.u,0.s)
Chars 7885 - 7898 [exact~idpath.] 0. secs (0.u,0.s)
Chars 7899 - 7907 [Defined.] 0. secs (0.u,0.s)
Chars 4890 - 4908 [(exists~F;~exact~_).] 40.06 secs (0.002u,0.011s)
Chars 4890 - 4908 [(exists~F;~exact~_).] 0. secs (0.u,0.s)
Chars 4909 - 4917 [Defined.] 0.002 secs (0.002u,0.s)
Chars 4919 - 5043 [#[global]~Instance~isgraph_fun...] 0.006 secs (0.003u,0.002s)
Chars 5045 - 5169 [#[global]~Instance~is01cat_fun...] 0.006 secs (0.005u,0.s)
Chars 5171 - 5296 [#[global]~Instance~is2graph_fu...] 0.007 secs (0.005u,0.001s)
Chars 5298 - 5418 [#[global]~Instance~is1cat_fun1...] 0.009 secs (0.006u,0.002s)
Chars 5420 - 5553 [#[global]~Instance~hasequivs_f...] 0.013 secs (0.007u,0.005s)
Chars 5583 - 5659 [Definition~fun01_id~{A}~`{IsGr...] 0.001 secs (0.001u,0.s)
Chars 5661 - 5736 [Definition~fun11_id~{A}~`{Is1C...] 0.003 secs (0.001u,0.002s)
Chars 5772 - 5880 [Definition~fun01_compose~{A}~{...] 0.001 secs (0.001u,0.s)
Chars 5881 - 5887 [Proof.] 0. secs (0.u,0.s)
Chars 449 - 460 [(intros~nle).] 40.065 secs (0.001u,0.018s)
Chars 461 - 499 [(destruct~(total~_~x~y)~as~[?|...] 0.008 secs (0.008u,0.s)
Chars 500 - 518 [(destruct~(nle~le)).] 0. secs (0.u,0.s)
Chars 449 - 460 [(intros~nle).] 0. secs (0.u,0.s)
Chars 461 - 499 [(destruct~(total~_~x~y)~as~[?|...] 0. secs (0.u,0.s)
Chars 500 - 518 [(destruct~(nle~le)).] 0. secs (0.u,0.s)
Chars 519 - 523 [Qed.] 0. secs (0.u,0.s)
Chars 525 - 547 [Section~partial_order.] 0. secs (0.u,0.s)
Chars 550 - 576 [Context~`{PartialOrder~A}.] 0. secs (0.u,0.s)
Chars 580 - 615 [Lemma~eq_le~x~y~:~x~=~y~->~x~≤~y.] 0. secs (0.u,0.s)
Chars 618 - 624 [Proof.] 0. secs (0.u,0.s)
Chars 1136 - 1151 [(unfold~IsRigid).] 7.438 secs (0.u,0.003s)
Chars 1154 - 1219 [(equiv_intro~(path_baut~(point...] 0.004 secs (0.004u,0.s)
Chars 1222 - 1287 [(equiv_intro~(path_baut~(point...] 0.004 secs (0.004u,0.s)
Chars 1290 - 1321 [(apply~ap10,~ap,~ap,~path_contr).] 0.004 secs (0.004u,0.s)
Chars 1136 - 1151 [(unfold~IsRigid).] 0. secs (0.u,0.s)
Chars 1154 - 1219 [(equiv_intro~(path_baut~(point...] 0. secs (0.u,0.s)
Chars 1222 - 1287 [(equiv_intro~(path_baut~(point...] 0. secs (0.u,0.s)
Chars 1290 - 1321 [(apply~ap10,~ap,~ap,~path_contr).] 0. secs (0.u,0.s)
Chars 1322 - 1330 [Defined.] 0.003 secs (0.003u,0.s)
Chars 1360 - 1433 [#[global]Instance~rigid_ishpro...] 0. secs (0.u,0.s)
Chars 1434 - 1440 [Proof.] 0. secs (0.u,0.s)
Chars 2243 - 2270 [exists~(inl~(lookup~x~va)).] 40.071 secs (0.001u,0.017s)
Chars 2271 - 2292 [(apply~lookup_correct).] 0. secs (0.u,0.s)
Chars 2243 - 2270 [exists~(inl~(lookup~x~va)).] 0. secs (0.u,0.s)
Chars 2271 - 2292 [(apply~lookup_correct).] 0. secs (0.u,0.s)
Chars 2295 - 2303 [Defined.] 0. secs (0.u,0.s)
Chars 2307 - 2372 [#[local]Instance~lookup_r~~`{!...] 0. secs (0.u,0.s)
Chars 2375 - 2381 [Proof.] 0. secs (0.u,0.s)
Chars 1443 - 1476 [(intros~f~g~x;~apply~path_ishp...] 0.812 secs (0.u,0.004s)
Chars 1443 - 1476 [(intros~f~g~x;~apply~path_ishp...] 0. secs (0.u,0.s)
Chars 1477 - 1485 [Defined.] 0. secs (0.u,0.s)
Chars 1763 - 1972 [Definition~aut_homomorphism_en...] 0.001 secs (0.001u,0.s)
Chars 1973 - 1979 [Proof.] 0. secs (0.u,0.s)
Chars 1982 - 2049 [(assert~(MS~:~forall~f~g,~g~o~...] 0.341 secs (0.002u,0.003s)
Chars 2052 - 2053 [{] 0. secs (0.u,0.s)
Chars 2054 - 2069 [(intros~g~f~s~x).] 0. secs (0.u,0.s)
Chars 2074 - 2101 [transitivity~(M~(f~o~g)~x).] 0.001 secs (0.001u,0.s)
Chars 2106 - 2107 [+] 0. secs (0.u,0.s)
Chars 2108 - 2117 [symmetry.] 0.001 secs (0.001u,0.s)
Chars 2118 - 2136 [refine~(MC~g~f~x).] 0. secs (0.u,0.s)
Chars 2141 - 2142 [+] 0. secs (0.u,0.s)
Chars 2143 - 2168 [transitivity~(M~idmap~x).] 0.001 secs (0.001u,0.s)
Chars 2175 - 2176 [*] 0. secs (0.u,0.s)
Chars 2177 - 2204 [(apply~ap10,~ap,~path_arrow).] 0.001 secs (0.001u,0.s)
Chars 2213 - 2231 [(intros~y;~apply~s).] 0. secs (0.u,0.s)
Chars 2238 - 2239 [*] 0. secs (0.u,0.s)
Chars 2240 - 2250 [(apply~Mid).] 0. secs (0.u,0.s)
Chars 2251 - 2252 [}] 0. secs (0.u,0.s)
Chars 2255 - 2308 [(assert~(ME~:~forall~f,~IsEqui...] 0.001 secs (0.001u,0.s)
Chars 2311 - 2312 [{] 0. secs (0.u,0.s)
Chars 2313 - 2324 [(intros~f~?).] 0. secs (0.u,0.s)
Chars 2329 - 2427 [(refine~(isequiv_adjointify~(M...] 0.003 secs (0.003u,0.s)
Chars 2428 - 2429 [}] 0. secs (0.u,0.s)
Chars 2432 - 2482 [exact~(fun~f~=>~Build_Equiv~_~...] 0.001 secs (0.001u,0.s)
Chars 1982 - 2049 [(assert~(MS~:~forall~f~g,~g~o~...] 0. secs (0.u,0.s)
Chars 2054 - 2069 [(intros~g~f~s~x).] 0. secs (0.u,0.s)
Chars 2074 - 2101 [transitivity~(M~(f~o~g)~x).] 0. secs (0.u,0.s)
Chars 2108 - 2117 [symmetry.] 0. secs (0.u,0.s)
Chars 2118 - 2136 [refine~(MC~g~f~x).] 0. secs (0.u,0.s)
Chars 2143 - 2168 [transitivity~(M~idmap~x).] 0. secs (0.u,0.s)
Chars 2177 - 2204 [(apply~ap10,~ap,~path_arrow).] 0. secs (0.u,0.s)
Chars 2213 - 2231 [(intros~y;~apply~s).] 0. secs (0.u,0.s)
Chars 2240 - 2250 [(apply~Mid).] 0. secs (0.u,0.s)
Chars 2255 - 2308 [(assert~(ME~:~forall~f,~IsEqui...] 0. secs (0.u,0.s)
Chars 2313 - 2324 [(intros~f~?).] 0. secs (0.u,0.s)
Chars 2329 - 2427 [(refine~(isequiv_adjointify~(M...] 0.001 secs (0.001u,0.s)
Chars 2432 - 2482 [exact~(fun~f~=>~Build_Equiv~_~...] 0. secs (0.u,0.s)
Chars 2483 - 2491 [Defined.] 0. secs (0.u,0.s)
Chars 2493 - 2674 [Definition~baut_prod_rigid_equ...] 0. secs (0.u,0.s)
Chars 2675 - 2681 [Proof.] 0. secs (0.u,0.s)
Chars 1474 - 1498 [(induction~k~as~[|~k~q]).] 40.093 secs (0.001u,0.017s)
Chars 1501 - 1502 [-] 0. secs (0.u,0.s)
Chars 1503 - 1515 [reflexivity.] 0. secs (0.u,0.s)
Chars 1518 - 1519 [-] 0. secs (0.u,0.s)
Chars 1520 - 1548 [exact~(ap~seq_pair_shift~q).] 0.001 secs (0.001u,0.s)
Chars 1474 - 1498 [(induction~k~as~[|~k~q]).] 0. secs (0.u,0.s)
Chars 1503 - 1515 [reflexivity.] 0. secs (0.u,0.s)
Chars 1520 - 1548 [exact~(ap~seq_pair_shift~q).] 0. secs (0.u,0.s)
Chars 1549 - 1557 [Defined.] 0. secs (0.u,0.s)
Chars 1559 - 1645 [Definition~seq_shift_pair_from...] 0. secs (0.u,0.s)
Chars 1646 - 1652 [Proof.] 0. secs (0.u,0.s)
Chars 1655 - 1679 [(induction~k~as~[|~k~q]).] 0.094 secs (0.001u,0.016s)
Chars 1682 - 1683 [-] 0. secs (0.u,0.s)
Chars 1684 - 1696 [reflexivity.] 0. secs (0.u,0.s)
Chars 1699 - 1700 [-] 0. secs (0.u,0.s)
Chars 1701 - 1729 [exact~(ap~seq_pair_shift~q).] 0.001 secs (0.001u,0.s)
Chars 1655 - 1679 [(induction~k~as~[|~k~q]).] 0. secs (0.u,0.s)
Chars 1684 - 1696 [reflexivity.] 0. secs (0.u,0.s)
Chars 1701 - 1729 [exact~(ap~seq_pair_shift~q).] 0. secs (0.u,0.s)
Chars 1730 - 1738 [Defined.] 0.001 secs (0.001u,0.s)
Chars 1740 - 1784 [Notation~inj~A:=~(@colim~seque...] 0. secs (0.u,0.s)
Chars 1785 - 1849 [Notation~glue~A:=~(fun~n~=>~@c...] 0. secs (0.u,0.s)
Chars 1919 - 2122 [Definition~seq_colimit_uniq~{A...] 0.006 secs (0.006u,0.s)
Chars 2123 - 2129 [Proof.] 0. secs (0.u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
All solutions:
occurrence 0: transitivity through forall x y : X, dot (a * x * y) b
4 possible(s) substitution(s)
0:	[x: c; y: dot (d * c * d) b; ]
1:	[x: dot c d; y: dot (c * d) b; ]
2:	[x: dot (c * d) c; y: dot d b; ]
3:	[x: dot (c * d * c) d; y: b; ]

occurrence 1: transitivity through forall x y : X, dot (a * x * y * b) b
3 possible(s) substitution(s)
0:	[x: c; y: dot (d * c) d; ]
1:	[x: dot c d; y: dot c d; ]
2:	[x: dot (c * d) c; y: d; ]


All solutions:
occurrence 0: transitivity through forall x y : X, dot (a * x * y) b
1 possible(s) substitution(s)
0:	[x: plus (c * d) (c * d); y: b; ]


Chars 4715 - 4827 [(exists~(fun~_~:~Unit~=>~m);~s...] 40.034 secs (0.01u,0.017s)
Chars 4715 - 4827 [(exists~(fun~_~:~Unit~=>~m);~s...] 0.002 secs (0.001u,0.s)
Chars 4832 - 4840 [Defined.] 0.002 secs (0.002u,0.s)
Chars 4846 - 4871 [Variable~(F~:~Functor~C~D).] 0. secs (0.u,0.s)
Chars 4876 - 4891 [Variable~(a~:~D).] 0. secs (0.u,0.s)
Chars 4897 - 4911 [Section~slice.] 0. secs (0.u,0.s)
Chars 4918 - 5249 [Definition~slice_category_indu...] 0.006 secs (0.005u,0.s)
Chars 5257 - 5359 [Definition~slice_category_nt_i...] 0. secs (0.u,0.s)
Chars 5366 - 5474 [Definition~slice_category_morp...] 0. secs (0.u,0.s)
Chars 5479 - 5489 [End~slice.] 0. secs (0.u,0.s)
Chars 5495 - 5511 [Section~coslice.] 0. secs (0.u,0.s)
Chars 5518 - 5851 [Definition~coslice_category_in...] 0.006 secs (0.004u,0.001s)
Chars 5859 - 5965 [Definition~coslice_category_nt...] 0. secs (0.u,0.s)
Chars 5972 - 6084 [Definition~coslice_category_mo...] 0. secs (0.u,0.s)
Chars 6089 - 6101 [End~coslice.] 0. secs (0.u,0.s)
Chars 6104 - 6122 [End~slice_coslice.] 0.012 secs (0.01u,0.001s)
Chars 6126 - 6296 [Definition~slice_category_over...] 0.006 secs (0.005u,0.s)
Chars 6299 - 6473 [Definition~coslice_category_ov...] 0.005 secs (0.003u,0.001s)
Chars 6474 - 6509 [End~slice_category_induced_fun...] 0.008 secs (0.008u,0.s)
Chars 6577 - 6610 [Section~cat_over_induced_functor.] 0. secs (0.u,0.s)
Chars 6613 - 6641 [#[local]Open~Scope~type_scope.] 0. secs (0.u,0.s)
Chars 6645 - 6663 [Context~`{Funext}.] 0. secs (0.u,0.s)
Chars 6666 - 6699 [Variable~(P~:~PreCategory~->~T...] 0. secs (0.u,0.s)
Chars 6702 - 6765 [Context~`{H0~:~forall~C~D,~P~C...] 0. secs (0.u,0.s)
Chars 6769 - 6813 [#[local]Notation~cat~:=~(@sub_...] 0. secs (0.u,0.s)
Chars 6817 - 6969 [Definition~cat_over_induced_fu...] 0.005 secs (0.004u,0.s)
Chars 6973 - 7127 [Definition~over_cat_induced_fu...] 0.002 secs (0.002u,0.s)
Chars 7128 - 7157 [End~cat_over_induced_functor.] 0.001 secs (0.001u,0.s)
Chars 1049 - 1081 [exists~(subgroup_index~G~H~_~_).] 40.062 secs (0.002u,0.011s)
Chars 1084 - 1093 [symmetry.] 0.001 secs (0.001u,0.s)
Chars 1096 - 1138 [refine~(fcard_quotient~(in_cos...] 0.053 secs (0.04u,0.012s)
Chars 1141 - 1171 [refine~(_~@~finadd_const~_~_).] 0.003 secs (0.003u,0.s)
Chars 1174 - 1196 [(apply~ap,~path_forall).] 0.003 secs (0.003u,0.s)
Chars 2193 - 2233 [(apply~(ap~(issig_isomorphic~A...] 40.092 secs (0.017u,0.02s)
Chars 2236 - 2255 [srapply~path_sigma.] 0.001 secs (0.001u,0.s)
Chars 2258 - 2259 [-] 0. secs (0.u,0.s)
Chars 2260 - 2268 [exact~a.] 0. secs (0.u,0.s)
Chars 2271 - 2272 [-] 0. secs (0.u,0.s)
Chars 0 - 311 [Require~Import~HoTT.Classes.in...] 8.065 secs (7.7u,0.364s)
Chars 313 - 341 [Generalizable~Variables~Q~F.] 0. secs (0.u,0.s)
Chars 343 - 370 [Section~strict_field_order.] 0. secs (0.u,0.s)
Chars 373 - 396 [Context~`{Rationals~Q}.] 0.001 secs (0.001u,0.s)
Chars 2273 - 2296 [(apply~path_sigma_hprop).] 0.008 secs (0.007u,0.s)
Chars 399 - 465 [Context~{Qmeet}~{Qjoin}~`{@Lat...] 0. secs (0.u,0.s)
Chars 468 - 494 [Context~`{OrderedField~F}.] 0.001 secs (0.001u,0.s)
Chars 2301 - 2341 [refine~(ap~_~(transport_sigma~...] 0.002 secs (0.002u,0.s)
Chars 2346 - 2354 [(apply~b).] 0.001 secs (0.001u,0.s)
Chars 1199 - 1226 [srapply~Quotient_ind_hprop.] 0.048 secs (0.035u,0.012s)
Chars 2193 - 2233 [(apply~(ap~(issig_isomorphic~A...] 0. secs (0.u,0.s)
Chars 2236 - 2255 [srapply~path_sigma.] 0. secs (0.u,0.s)
Chars 2260 - 2268 [exact~a.] 0. secs (0.u,0.s)
Chars 1229 - 1235 [(simpl).] 0.002 secs (0.002u,0.s)
Chars 2273 - 2296 [(apply~path_sigma_hprop).] 0. secs (0.u,0.s)
Chars 1275 - 1284 [(intros~x).] 0. secs (0.u,0.s)
Chars 2301 - 2341 [refine~(ap~_~(transport_sigma~...] 0. secs (0.u,0.s)
Chars 2346 - 2354 [(apply~b).] 0. secs (0.u,0.s)
Chars 1287 - 1306 [(apply~fcard_equiv').] 0.001 secs (0.u,0.s)
Chars 1376 - 1382 [(simpl).] 0. secs (0.u,0.s)
Chars 497 - 540 [Context~{archim~:~ArchimedeanP...] 0.011 secs (0.01u,0.s)
Chars 1385 - 1414 [snrapply~equiv_functor_sigma.] 0.003 secs (0.003u,0.s)
Chars 2355 - 2363 [Defined.] 0.005 secs (0.003u,0.001s)
Chars 1417 - 1455 [2:~(apply~(isequiv_group_left_...] 0.001 secs (0.001u,0.s)
Chars 1458 - 1474 [1:~(hnf;~trivial).] 0. secs (0.u,0.s)
Chars 2544 - 2708 [Lemma~path_hset_isomorphic~`{F...] 0.001 secs (0.001u,0.s)
Chars 2709 - 2715 [Proof.] 0. secs (0.u,0.s)
Chars 544 - 597 [Definition~qinc~:~Cast~Q~F~:=~...] 0.012 secs (0.012u,0.s)
Chars 600 - 623 [Existing~Instance~qinc.] 0. secs (0.u,0.s)
Chars 627 - 674 [Lemma~char_minus_left~x~y~:~-~...] 0.001 secs (0.001u,0.s)
Chars 677 - 683 [Proof.] 0. secs (0.u,0.s)
Chars 1477 - 1485 [exact~_.] 0.014 secs (0.011u,0.002s)
Chars 1049 - 1081 [exists~(subgroup_index~G~H~_~_).] 0. secs (0.u,0.s)
Chars 1084 - 1093 [symmetry.] 0. secs (0.u,0.s)
Chars 1096 - 1138 [refine~(fcard_quotient~(in_cos...] 0. secs (0.u,0.s)
Chars 1141 - 1171 [refine~(_~@~finadd_const~_~_).] 0. secs (0.u,0.s)
Chars 1174 - 1196 [(apply~ap,~path_forall).] 0. secs (0.u,0.s)
Chars 1199 - 1226 [srapply~Quotient_ind_hprop.] 0. secs (0.u,0.s)
Chars 1229 - 1235 [(simpl).] 0. secs (0.u,0.s)
Chars 1275 - 1284 [(intros~x).] 0. secs (0.u,0.s)
Chars 1287 - 1306 [(apply~fcard_equiv').] 0. secs (0.u,0.s)
Chars 1376 - 1382 [(simpl).] 0. secs (0.u,0.s)
Chars 1385 - 1414 [snrapply~equiv_functor_sigma.] 0. secs (0.u,0.s)
Chars 1417 - 1455 [2:~(apply~(isequiv_group_left_...] 0. secs (0.u,0.s)
Chars 1458 - 1474 [1:~(hnf;~trivial).] 0. secs (0.u,0.s)
Chars 1477 - 1485 [exact~_.] 0. secs (0.u,0.s)
Chars 1486 - 1494 [Defined.] 0.012 secs (0.009u,0.002s)
Chars 1496 - 1664 [Corollary~lagrange_normal~{U~:...] 0.019 secs (0.014u,0.004s)
Chars 1665 - 1671 [Proof.] 0. secs (0.u,0.s)
Chars 1768 - 1779 [revert~x~z.] 40.011 secs (0.001u,0.003s)
Chars 1784 - 1808 [(induction~y;~intros~x~z).] 0.001 secs (0.001u,0.s)
Chars 1813 - 1814 [{] 0. secs (0.u,0.s)
Chars 1815 - 1830 [(f_ap;~symmetry).] 0.004 secs (0.004u,0.s)
Chars 1837 - 1861 [(apply~word_concat_w_nil).] 0. secs (0.u,0.s)
Chars 1862 - 1863 [}] 0. secs (0.u,0.s)
Chars 1868 - 1890 [(simpl;~revert~z~y~IHy).] 0.001 secs (0.001u,0.s)
Chars 1895 - 1916 [(induction~x;~trivial).] 0.003 secs (0.003u,0.s)
Chars 1921 - 1936 [(intros~z~y~IHy).] 0. secs (0.u,0.s)
Chars 1941 - 1953 [(simpl;~f_ap).] 0.002 secs (0.002u,0.s)
Chars 1958 - 1973 [(apply~IHx,~IHy).] 0.001 secs (0.001u,0.s)
Chars 1768 - 1779 [revert~x~z.] 0. secs (0.u,0.s)
Chars 1784 - 1808 [(induction~y;~intros~x~z).] 0. secs (0.u,0.s)
Chars 1815 - 1830 [(f_ap;~symmetry).] 0. secs (0.u,0.s)
Chars 1837 - 1861 [(apply~word_concat_w_nil).] 0. secs (0.u,0.s)
Chars 1868 - 1890 [(simpl;~revert~z~y~IHy).] 0. secs (0.u,0.s)
Chars 1895 - 1916 [(induction~x;~trivial).] 0.001 secs (0.001u,0.s)
Chars 1921 - 1936 [(intros~z~y~IHy).] 0. secs (0.u,0.s)
Chars 1941 - 1953 [(simpl;~f_ap).] 0.001 secs (0.001u,0.s)
Chars 1958 - 1973 [(apply~IHx,~IHy).] 0. secs (0.u,0.s)
Chars 1976 - 1984 [Defined.] 0.001 secs (0.001u,0.s)
Chars 1988 - 2036 [#[local]Fixpoint~word_inverse~...] 0. secs (0.u,0.s)
Chars 2039 - 2045 [Proof.] 0. secs (0.u,0.s)
Chars 644 - 667 [transitivity~(x~⊔~y).] 40.02 secs (0.007u,0.003s)
Chars 670 - 671 [-] 0. secs (0.u,0.s)
Chars 672 - 688 [(apply~join_ub_r).] 0. secs (0.u,0.s)
Chars 691 - 692 [-] 0. secs (0.u,0.s)
Chars 693 - 709 [(apply~join_ub_l).] 0. secs (0.u,0.s)
Chars 644 - 667 [transitivity~(x~⊔~y).] 0. secs (0.u,0.s)
Chars 672 - 688 [(apply~join_ub_r).] 0. secs (0.u,0.s)
Chars 693 - 709 [(apply~join_ub_l).] 0. secs (0.u,0.s)
Chars 712 - 716 [Qed.] 0. secs (0.u,0.s)
Chars 720 - 766 [Lemma~join_ub_3_l~x~y~z~:~x~≤~...] 0. secs (0.u,0.s)
Chars 769 - 775 [Proof.] 0. secs (0.u,0.s)
Chars 2718 - 2748 [(apply~(path_isomorphic~F~G~a)).] 2.67 secs (0.u,0.018s)
Chars 2749 - 2768 [(apply~path_ishprop).] 0.003 secs (0.002u,0.001s)
Chars 2718 - 2748 [(apply~(path_isomorphic~F~G~a)).] 0. secs (0.u,0.s)
Chars 2749 - 2768 [(apply~path_ishprop).] 0. secs (0.u,0.s)
Chars 2769 - 2777 [Defined.] 0. secs (0.u,0.s)
Chars 2779 - 2820 [Section~path_def_isomorphic_id...] 0. secs (0.u,0.s)
Chars 2823 - 2867 [Context~{σ~:~Signature}~{A~B~:...] 0. secs (0.u,0.s)
Chars 2871 - 3038 [Lemma~path_def_isomorphic_id_t...] 0.001 secs (0.001u,0.s)
Chars 3041 - 3047 [Proof.] 0. secs (0.u,0.s)
Chars 778 - 818 [(transitivity~(x~⊔~y);~apply~j...] 0.53 secs (0.009u,0.003s)
Chars 778 - 818 [(transitivity~(x~⊔~y);~apply~j...] 0. secs (0.u,0.s)
Chars 821 - 825 [Qed.] 0. secs (0.u,0.s)
Chars 829 - 883 [Lemma~join_ub_3_assoc_l~x~y~z~...] 0. secs (0.u,0.s)
Chars 886 - 892 [Proof.] 0. secs (0.u,0.s)
Chars 895 - 911 [(apply~join_ub_l).] 1.236 secs (0.001u,0.003s)
Chars 895 - 911 [(apply~join_ub_l).] 0. secs (0.u,0.s)
Chars 914 - 918 [Qed.] 0. secs (0.u,0.s)
Chars 922 - 976 [Lemma~join_ub_3_assoc_m~x~y~z~...] 0. secs (0.u,0.s)
Chars 979 - 985 [Proof.] 0. secs (0.u,0.s)
Chars 2308 - 2330 [(intros~is_ordinal~a~H).] 40.072 secs (0.u,0.018s)
Chars 2333 - 2376 [(induction~(well_foundedness~a...] 0.001 secs (0.u,0.s)
Chars 2379 - 2404 [(apply~(IH~a);~assumption).] 0. secs (0.u,0.s)
Chars 2308 - 2330 [(intros~is_ordinal~a~H).] 0. secs (0.u,0.s)
Chars 2333 - 2376 [(induction~(well_foundedness~a...] 0. secs (0.u,0.s)
Chars 2379 - 2404 [(apply~(IH~a);~assumption).] 0. secs (0.u,0.s)
Chars 2405 - 2409 [Qed.] 0. secs (0.u,0.s)
Chars 2412 - 2471 [Definition~TypeWithRelation~:=...] 0. secs (0.u,0.s)
Chars 2473 - 2566 [Coercion~ordinal_as_type_with_...] 0. secs (0.u,0.s)
Chars 2598 - 2698 [Definition~equiv_Ordinal_to_si...] 0. secs (0.u,0.s)
Chars 2699 - 2705 [Proof.] 0. secs (0.u,0.s)
Chars 3052 - 3070 [by~path_induction.] 7.802 secs (0.002u,0.017s)
Chars 3052 - 3070 [by~path_induction.] 0. secs (0.u,0.s)
Chars 3073 - 3081 [Defined.] 0. secs (0.u,0.s)
Chars 3085 - 3251 [Lemma~path_def_isomorphic_id_t...] 0.001 secs (0.001u,0.s)
Chars 3254 - 3260 [Proof.] 0. secs (0.u,0.s)
Chars 3265 - 3283 [by~path_induction.] 0.038 secs (0.002u,0.017s)
Chars 3265 - 3283 [by~path_induction.] 0. secs (0.u,0.s)
Chars 3286 - 3294 [Defined.] 0. secs (0.u,0.s)
Chars 3295 - 3332 [End~path_def_isomorphic_id_tra...] 0.001 secs (0.001u,0.s)
Chars 3665 - 3815 [Lemma~path_path_isomorphism_ho...] 0.002 secs (0.001u,0.001s)
Chars 3816 - 3822 [Proof.] 0. secs (0.u,0.s)
Chars 5890 - 5901 [(intros~F~G).] 40.054 secs (0.u,0.011s)
Chars 5904 - 5924 [nrapply~Build_Fun01.] 0.002 secs (0.001u,0.s)
Chars 5927 - 5959 [rapply~(is0functor_compose~G~F).] 0.002 secs (0.002u,0.s)
Chars 5890 - 5901 [(intros~F~G).] 0. secs (0.u,0.s)
Chars 5904 - 5924 [nrapply~Build_Fun01.] 0. secs (0.u,0.s)
Chars 5927 - 5959 [rapply~(is0functor_compose~G~F).] 0. secs (0.u,0.s)
Chars 5960 - 5968 [Defined.] 0. secs (0.u,0.s)
Chars 5970 - 6110 [Definition~fun01_postcomp~{A}~...] 0.004 secs (0.002u,0.001s)
Chars 6184 - 6326 [#[global]~Instance~is0functor_...] 0.005 secs (0.005u,0.s)
Chars 6327 - 6333 [Proof.] 0. secs (0.u,0.s)
Chars 627 - 636 [(intros~E).] 40.066 secs (0.u,0.017s)
Chars 639 - 649 [(rewrite~E).] 0. secs (0.u,0.s)
Chars 652 - 670 [(apply~reflexivity).] 0.001 secs (0.001u,0.s)
Chars 627 - 636 [(intros~E).] 0. secs (0.u,0.s)
Chars 639 - 649 [(rewrite~E).] 0. secs (0.u,0.s)
Chars 652 - 670 [(apply~reflexivity).] 0. secs (0.u,0.s)
Chars 673 - 677 [Qed.] 0. secs (0.u,0.s)
Chars 681 - 721 [Lemma~eq_le_flip~x~y~:~x~=~y~-...] 0. secs (0.u,0.s)
Chars 724 - 730 [Proof.] 0. secs (0.u,0.s)
Chars 733 - 742 [(intros~E).] 0.05 secs (0.u,0.017s)
Chars 745 - 755 [(rewrite~E).] 0. secs (0.u,0.s)
Chars 758 - 776 [(apply~reflexivity).] 0.001 secs (0.001u,0.s)
Chars 733 - 742 [(intros~E).] 0. secs (0.u,0.s)
Chars 745 - 755 [(rewrite~E).] 0. secs (0.u,0.s)
Chars 758 - 776 [(apply~reflexivity).] 0. secs (0.u,0.s)
Chars 779 - 783 [Qed.] 0. secs (0.u,0.s)
Chars 787 - 830 [Lemma~not_le_ne~x~y~:~~~(x~≤~y...] 0. secs (0.u,0.s)
Chars 833 - 839 [Proof.] 0. secs (0.u,0.s)
Chars 2384 - 2411 [exists~(inr~(lookup~x~vb)).] 40.077 secs (0.001u,0.017s)
Chars 2412 - 2433 [(apply~lookup_correct).] 0. secs (0.u,0.s)
Chars 2384 - 2411 [exists~(inr~(lookup~x~vb)).] 0. secs (0.u,0.s)
Chars 2412 - 2433 [(apply~lookup_correct).] 0. secs (0.u,0.s)
Chars 2436 - 2444 [Defined.] 0. secs (0.u,0.s)
Chars 2448 - 2502 [#[local]Instance~lookup_single...] 0. secs (0.u,0.s)
Chars 2505 - 2511 [Proof.] 0. secs (0.u,0.s)
Chars 2684 - 2729 [refine~(Build_Equiv~_~_~(baut_...] 40.038 secs (0.024u,0.004s)
Chars 2732 - 2755 [(apply~isequiv_surj_emb).] 0. secs (0.u,0.s)
Chars 2758 - 2759 [{] 0. secs (0.u,0.s)
Chars 2760 - 2794 [(apply~BuildIsSurjection;~intr...] 0. secs (0.u,0.s)
Chars 2799 - 2811 [baut_reduce.] 0.003 secs (0.003u,0.s)
Chars 2816 - 2842 [refine~(tr~(point~_;~_)).] 0.001 secs (0.001u,0.s)
Chars 2847 - 2883 [(apply~path_sigma_hprop;~refle...] 0.003 secs (0.003u,0.s)
Chars 2884 - 2885 [}] 0. secs (0.u,0.s)
Chars 2888 - 2889 [{] 0. secs (0.u,0.s)
Chars 2890 - 2919 [(apply~isembedding_isequiv_ap).] 0. secs (0.u,0.s)
Chars 2924 - 2935 [(intros~Z~W).] 0. secs (0.u,0.s)
Chars 2940 - 3003 [(pose~(L~:=~fun~e~:~Z~<~>~W~=>...] 0. secs (0.u,0.s)
Chars 3008 - 3212 [refine~~(isequiv_commsq~L~(ap~...] 0.035 secs (0.035u,0.s)
Chars 3217 - 3270 [refine~(isconnected_elim~(Tr~(...] 0.059 secs (0.056u,0.002s)
Chars 3275 - 3276 [{] 0. secs (0.u,0.s)
Chars 3277 - 3360 [(apply~contr_inhabited_hprop;~...] 0.002 secs (0.002u,0.s)
Chars 3361 - 3362 [}] 0. secs (0.u,0.s)
Chars 3367 - 3377 [(intros~a0).] 0. secs (0.u,0.s)
Chars 3382 - 3394 [baut_reduce.] 0.016 secs (0.016u,0.s)
Chars 3399 - 3455 [(pose~(M~:=~fun~f~:~X~*~A~->~X...] 0.001 secs (0.001u,0.s)
Chars 3460 - 3555 [(assert~~~(MH~:~~~~forall~(a~:...] 0.002 secs (0.002u,0.s)
Chars 3560 - 3561 [{] 0. secs (0.u,0.s)
Chars 3562 - 3611 [refine~(conn_map_elim~(Tr~n)~(...] 0.015 secs (0.015u,0.s)
Chars 3618 - 3638 [(intros;~reflexivity).] 0.001 secs (0.001u,0.s)
Chars 3639 - 3640 [}] 0. secs (0.u,0.s)
Chars 3645 - 3708 [(assert~(MC~:~forall~f~g~:~X~*...] 0.002 secs (0.002u,0.s)
Chars 3713 - 3714 [{] 0. secs (0.u,0.s)
Chars 3715 - 3738 [(intros~f~g~x;~unfold~M).] 0.001 secs (0.001u,0.s)
Chars 3745 - 3801 [transitivity~(fst~(g~(fst~(f~(...] 0.002 secs (0.002u,0.s)
Chars 3808 - 3809 [-] 0. secs (0.u,0.s)
Chars 3810 - 3822 [reflexivity.] 0. secs (0.u,0.s)
Chars 3829 - 3830 [-] 0. secs (0.u,0.s)
Chars 3831 - 3840 [(apply~MH).] 0.001 secs (0.001u,0.s)
Chars 3841 - 3842 [}] 0. secs (0.u,0.s)
Chars 3847 - 3899 [(pose~(M'~:=~aut_homomorphism_...] 0.002 secs (0.002u,0.s)
Chars 3904 - 3962 [(assert~(Mker~:~forall~f,~M'~f...] 0.002 secs (0.002u,0.s)
Chars 3967 - 3968 [{] 0. secs (0.u,0.s)
Chars 3969 - 3987 [(unfold~M',~M;~cbn).] 0.002 secs (0.002u,0.s)
Chars 3988 - 3999 [(intros~f~p).] 0.001 secs (0.001u,0.s)
Chars 4006 - 4047 [(pose~(fh~:=~fun~x~a~=>~MH~a~f...] 0.001 secs (0.001u,0.s)
Chars 4054 - 4091 [(pose~(g~:=~fun~x~a~=>~snd~(f~...] 0.002 secs (0.002u,0.s)
Chars 4098 - 4136 [(assert~(ge~:~forall~x,~IsEqui...] 0.001 secs (0.001u,0.s)
Chars 4143 - 4144 [{] 0. secs (0.u,0.s)
Chars 4145 - 4178 [(apply~isequiv_from_functor_si...] 0.001 secs (0.001u,0.s)
Chars 4187 - 4284 [refine~~(isequiv_commsq'~_~f~(...] 0.007 secs (0.007u,0.s)
Chars 4293 - 4311 [(intros~[x~a];~cbn).] 0.003 secs (0.003u,0.s)
Chars 4320 - 4364 [(apply~path_prod;~[~apply~fh~|...] 0.004 secs (0.004u,0.s)
Chars 4365 - 4366 [}] 0. secs (0.u,0.s)
Chars 4373 - 4386 [(intros~[x~a]).] 0.001 secs (0.001u,0.s)
Chars 4393 - 4457 [(pose~(gisid~:=~path_aut_rigid...] 0.002 secs (0.002u,0.s)
Chars 4464 - 4480 [(apply~path_prod).] 0.001 secs (0.001u,0.s)
Chars 4487 - 4488 [-] 0. secs (0.u,0.s)
Chars 4489 - 4498 [(apply~fh).] 0.001 secs (0.001u,0.s)
Chars 4505 - 4506 [-] 0. secs (0.u,0.s)
Chars 4507 - 4519 [(apply~gisid).] 0.001 secs (0.001u,0.s)
Chars 4520 - 4521 [}] 0. secs (0.u,0.s)
Chars 4526 - 4577 [(assert~(Minj~:~forall~f~g,~M'...] 0.002 secs (0.002u,0.s)
Chars 4582 - 4583 [{] 0. secs (0.u,0.s)
Chars 4584 - 4599 [(intros~f~g~p~z).] 0.001 secs (0.001u,0.s)
Chars 4606 - 4626 [(apply~moveL_equiv_M).] 0.003 secs (0.003u,0.s)
Chars 4633 - 4642 [revert~z.] 0.001 secs (0.001u,0.s)
Chars 4649 - 4677 [refine~(Mker~(g^-1~oE~f)~_).] 0.001 secs (0.001u,0.s)
Chars 4684 - 4693 [(intros~x).] 0.001 secs (0.001u,0.s)
Chars 4700 - 4725 [refine~(MC~f~g^-1~x~@~_).] 0.002 secs (0.002u,0.s)
Chars 4732 - 4763 [(change~((M'~g)^-1~(M~f~x)~=~x)).] 0.003 secs (0.003u,0.s)
Chars 4770 - 4793 [(apply~moveR_equiv_V,~p).] 0.001 secs (0.001u,0.s)
Chars 4794 - 4795 [}] 0. secs (0.u,0.s)
Chars 4800 - 4940 [(refine~(isequiv_adjointify~L~...] 0.017 secs (0.017u,0.s)
Chars 4941 - 4942 [}] 0. secs (0.u,0.s)
Chars 2684 - 2729 [refine~(Build_Equiv~_~_~(baut_...] 0. secs (0.u,0.s)
Chars 2732 - 2755 [(apply~isequiv_surj_emb).] 0. secs (0.u,0.s)
Chars 2760 - 2794 [(apply~BuildIsSurjection;~intr...] 0. secs (0.u,0.s)
Chars 2799 - 2811 [baut_reduce.] 0. secs (0.u,0.s)
Chars 2816 - 2842 [refine~(tr~(point~_;~_)).] 0. secs (0.u,0.s)
Chars 2847 - 2883 [(apply~path_sigma_hprop;~refle...] 0. secs (0.u,0.s)
Chars 2890 - 2919 [(apply~isembedding_isequiv_ap).] 0. secs (0.u,0.s)
Chars 2924 - 2935 [(intros~Z~W).] 0. secs (0.u,0.s)
Chars 2940 - 3003 [(pose~(L~:=~fun~e~:~Z~<~>~W~=>...] 0. secs (0.u,0.s)
Chars 3008 - 3212 [refine~~(isequiv_commsq~L~(ap~...] 0. secs (0.u,0.s)
Chars 3217 - 3270 [refine~(isconnected_elim~(Tr~(...] 0. secs (0.u,0.s)
Chars 3277 - 3360 [(apply~contr_inhabited_hprop;~...] 0. secs (0.u,0.s)
Chars 3367 - 3377 [(intros~a0).] 0. secs (0.u,0.s)
Chars 3382 - 3394 [baut_reduce.] 0. secs (0.u,0.s)
Chars 3399 - 3455 [(pose~(M~:=~fun~f~:~X~*~A~->~X...] 0. secs (0.u,0.s)
Chars 3460 - 3555 [(assert~~~(MH~:~~~~forall~(a~:...] 0. secs (0.u,0.s)
Chars 3562 - 3611 [refine~(conn_map_elim~(Tr~n)~(...] 0. secs (0.u,0.s)
Chars 3618 - 3638 [(intros;~reflexivity).] 0. secs (0.u,0.s)
Chars 3645 - 3708 [(assert~(MC~:~forall~f~g~:~X~*...] 0. secs (0.u,0.s)
Chars 3715 - 3738 [(intros~f~g~x;~unfold~M).] 0.001 secs (0.001u,0.s)
Chars 3745 - 3801 [transitivity~(fst~(g~(fst~(f~(...] 0. secs (0.u,0.s)
Chars 3810 - 3822 [reflexivity.] 0. secs (0.u,0.s)
Chars 3831 - 3840 [(apply~MH).] 0. secs (0.u,0.s)
Chars 3847 - 3899 [(pose~(M'~:=~aut_homomorphism_...] 0. secs (0.u,0.s)
Chars 3904 - 3962 [(assert~(Mker~:~forall~f,~M'~f...] 0. secs (0.u,0.s)
Chars 3969 - 3987 [(unfold~M',~M;~cbn).] 0.001 secs (0.001u,0.s)
Chars 3988 - 3999 [(intros~f~p).] 0. secs (0.u,0.s)
Chars 4006 - 4047 [(pose~(fh~:=~fun~x~a~=>~MH~a~f...] 0. secs (0.u,0.s)
Chars 4054 - 4091 [(pose~(g~:=~fun~x~a~=>~snd~(f~...] 0. secs (0.u,0.s)
Chars 4098 - 4136 [(assert~(ge~:~forall~x,~IsEqui...] 0. secs (0.u,0.s)
Chars 4145 - 4178 [(apply~isequiv_from_functor_si...] 0. secs (0.u,0.s)
Chars 4187 - 4284 [refine~~(isequiv_commsq'~_~f~(...] 0. secs (0.u,0.s)
Chars 4293 - 4311 [(intros~[x~a];~cbn).] 0.002 secs (0.002u,0.s)
Chars 4320 - 4364 [(apply~path_prod;~[~apply~fh~|...] 0.002 secs (0.002u,0.s)
Chars 4373 - 4386 [(intros~[x~a]).] 0.001 secs (0.001u,0.s)
Chars 4393 - 4457 [(pose~(gisid~:=~path_aut_rigid...] 0.001 secs (0.001u,0.s)
Chars 4464 - 4480 [(apply~path_prod).] 0.001 secs (0.001u,0.s)
Chars 4489 - 4498 [(apply~fh).] 0.001 secs (0.001u,0.s)
Chars 4507 - 4519 [(apply~gisid).] 0.001 secs (0.001u,0.s)
Chars 4526 - 4577 [(assert~(Minj~:~forall~f~g,~M'...] 0. secs (0.u,0.s)
Chars 4584 - 4599 [(intros~f~g~p~z).] 0. secs (0.u,0.s)
Chars 4606 - 4626 [(apply~moveL_equiv_M).] 0. secs (0.u,0.s)
Chars 4633 - 4642 [revert~z.] 0. secs (0.u,0.s)
Chars 4649 - 4677 [refine~(Mker~(g^-1~oE~f)~_).] 0. secs (0.u,0.s)
Chars 4684 - 4693 [(intros~x).] 0. secs (0.u,0.s)
Chars 4700 - 4725 [refine~(MC~f~g^-1~x~@~_).] 0. secs (0.u,0.s)
Chars 4732 - 4763 [(change~((M'~g)^-1~(M~f~x)~=~x)).] 0. secs (0.u,0.s)
Chars 4770 - 4793 [(apply~moveR_equiv_V,~p).] 0. secs (0.u,0.s)
Chars 4800 - 4940 [(refine~(isequiv_adjointify~L~...] 0.01 secs (0.01u,0.s)
Chars 4943 - 4951 [Defined.] 0.01 secs (0.01u,0.s)
Chars 2132 - 2186 [(srapply~(Colimit_ind~_~h);~in...] 40.085 secs (0.006u,0.017s)
Chars 2189 - 2251 [(generalize~(H~n~a);~generaliz...] 0.016 secs (0.015u,0.s)
Chars 2254 - 2334 [(intros~p~q;~srefine~((concat_...] 0.009 secs (0.008u,0.s)
Chars 2132 - 2186 [(srapply~(Colimit_ind~_~h);~in...] 0.002 secs (0.002u,0.s)
Chars 2189 - 2251 [(generalize~(H~n~a);~generaliz...] 0.003 secs (0.003u,0.s)
Chars 2254 - 2334 [(intros~p~q;~srefine~((concat_...] 0.006 secs (0.006u,0.s)
Chars 2335 - 2343 [Defined.] 0.012 secs (0.01u,0.001s)
Chars 2391 - 2492 [Definition~succ_seq~(A~:~Seque...] 0.001 secs (0.u,0.s)
Chars 2538 - 2647 [Definition~shift_seq~(A~:~Sequ...] 0.001 secs (0.001u,0.s)
Chars 2780 - 2857 [Definition~colim_succ_seq_to_c...] 0. secs (0.u,0.s)
Chars 2858 - 2864 [Proof.] 0. secs (0.u,0.s)
All solutions:
occurrence 0: transitivity through forall x : Z, (- (x + x) + (b + b + c))%Z
1 possible(s) substitution(s)
0:	[x: a; ]

occurrence 1: transitivity through forall x : Z, (x + x + (- (a + a) + c))%Z
1 possible(s) substitution(s)
0:	[x: b; ]


All solutions:
occurrence 0: transitivity through forall x : X, dot (a * x) a
1 possible(s) substitution(s)
0:	[x: 1; ]


Chars 6336 - 6359 [(apply~Build_Is0Functor).] 15.32 secs (0.001u,0.011s)
Chars 6362 - 6375 [(intros~a~b~f).] 0. secs (0.u,0.s)
Chars 6378 - 6406 [rapply~nattrans_postwhisker.] 0.06 secs (0.048u,0.011s)
Chars 6409 - 6417 [exact~f.] 0. secs (0.u,0.s)
Chars 6336 - 6359 [(apply~Build_Is0Functor).] 0. secs (0.u,0.s)
Chars 6362 - 6375 [(intros~a~b~f).] 0. secs (0.u,0.s)
Chars 6378 - 6406 [rapply~nattrans_postwhisker.] 0. secs (0.u,0.s)
Chars 6409 - 6417 [exact~f.] 0. secs (0.u,0.s)
Chars 6418 - 6426 [Defined.] 0.002 secs (0.001u,0.s)
Chars 6428 - 6570 [#[global]~Instance~is1functor_...] 0.01 secs (0.01u,0.s)
Chars 6571 - 6577 [Proof.] 0. secs (0.u,0.s)
Chars 688 - 701 [(intros~ltnxy).] 40.079 secs (0.u,0.02s)
Chars 702 - 735 [(rewrite~<-~(negate_involutive...] 0.007 secs (0.007u,0.s)
Chars 736 - 769 [(apply~(snd~(flip_lt_negate~_~...] 0.013 secs (0.011u,0.002s)
Chars 770 - 781 [assumption.] 0.001 secs (0.001u,0.s)
Chars 688 - 701 [(intros~ltnxy).] 0. secs (0.u,0.s)
Chars 702 - 735 [(rewrite~<-~(negate_involutive...] 0. secs (0.u,0.s)
Chars 736 - 769 [(apply~(snd~(flip_lt_negate~_~...] 0. secs (0.u,0.s)
Chars 770 - 781 [assumption.] 0. secs (0.u,0.s)
Chars 784 - 788 [Qed.] 0. secs (0.u,0.s)
Chars 792 - 840 [Lemma~char_minus_right~x~y~:~x...] 0.002 secs (0.001u,0.s)
Chars 843 - 849 [Proof.] 0. secs (0.u,0.s)
Chars 1674 - 1689 [(apply~lagrange).] 40.11 secs (0.017u,0.014s)
Chars 1674 - 1689 [(apply~lagrange).] 0. secs (0.u,0.s)
Chars 1690 - 1698 [Defined.] 0.02 secs (0.016u,0.003s)
Chars 2050 - 2072 [(destruct~x~as~[|~x~xs]).] 39.283 secs (0.001u,0.003s)
Chars 2077 - 2090 [1:~exact~nil.] 0. secs (0.u,0.s)
Chars 2095 - 2115 [(destruct~x~as~[h|~k]).] 0. secs (0.u,0.s)
Chars 2120 - 2121 [+] 0. secs (0.u,0.s)
Chars 2122 - 2163 [exact~(word_inverse~xs~++~[inl...] 0.001 secs (0.001u,0.s)
Chars 2168 - 2169 [+] 0. secs (0.u,0.s)
Chars 2170 - 2211 [exact~(word_inverse~xs~++~[inr...] 0. secs (0.u,0.s)
Chars 2050 - 2072 [(destruct~x~as~[|~x~xs]).] 0. secs (0.u,0.s)
Chars 2077 - 2090 [1:~exact~nil.] 0. secs (0.u,0.s)
Chars 2095 - 2115 [(destruct~x~as~[h|~k]).] 0. secs (0.u,0.s)
Chars 2122 - 2163 [exact~(word_inverse~xs~++~[inl...] 0. secs (0.u,0.s)
Chars 2170 - 2211 [exact~(word_inverse~xs~++~[inr...] 0. secs (0.u,0.s)
Chars 2214 - 2222 [Defined.] 0. secs (0.u,0.s)
Chars 2277 - 2387 [#[local]~Definition~word_inver...] 0. secs (0.u,0.s)
Chars 2390 - 2396 [Proof.] 0. secs (0.u,0.s)
Chars 2514 - 2524 [exists~tt.] 17.108 secs (0.u,0.018s)
Chars 2525 - 2537 [reflexivity.] 0. secs (0.u,0.s)
Chars 2514 - 2524 [exists~tt.] 0. secs (0.u,0.s)
Chars 2525 - 2537 [reflexivity.] 0. secs (0.u,0.s)
Chars 2540 - 2548 [Defined.] 0. secs (0.u,0.s)
Chars 2550 - 2561 [End~Lookup.] 0.002 secs (0.002u,0.s)
Chars 2563 - 2842 [Fixpoint~expr_map~{V~W~:~Type0...] 0.001 secs (0.001u,0.s)
Chars 2844 - 2950 [Lemma~eval_map~{V~W~:~Type0}~(...] 0. secs (0.u,0.s)
Chars 2951 - 2957 [Proof.] 0. secs (0.u,0.s)
Chars 988 - 1011 [transitivity~(y~⊔~z).] 40.019 secs (0.008u,0.002s)
Chars 1014 - 1015 [-] 0. secs (0.u,0.s)
Chars 1016 - 1032 [(apply~join_ub_l).] 0. secs (0.u,0.s)
Chars 1035 - 1036 [-] 0. secs (0.u,0.s)
Chars 1037 - 1053 [(apply~join_ub_r).] 0. secs (0.u,0.s)
Chars 988 - 1011 [transitivity~(y~⊔~z).] 0. secs (0.u,0.s)
Chars 1016 - 1032 [(apply~join_ub_l).] 0. secs (0.u,0.s)
Chars 1037 - 1053 [(apply~join_ub_r).] 0. secs (0.u,0.s)
Chars 1056 - 1060 [Qed.] 0. secs (0.u,0.s)
Chars 1064 - 1118 [Lemma~join_ub_3_assoc_r~x~y~z~...] 0. secs (0.u,0.s)
Chars 1121 - 1127 [Proof.] 0. secs (0.u,0.s)
Chars 1130 - 1170 [(transitivity~(y~⊔~z);~apply~j...] 1.148 secs (0.009u,0.002s)
Chars 1130 - 1170 [(transitivity~(y~⊔~z);~apply~j...] 0. secs (0.u,0.s)
Chars 1173 - 1177 [Qed.] 0. secs (0.u,0.s)
Chars 1181 - 1233 [Instance~join_sl_order_join_sl...] 0. secs (0.u,0.s)
Chars 1236 - 1242 [Proof.] 0. secs (0.u,0.s)
Chars 2708 - 2771 [transitivity~{A~:~Type~&~{R~:~...] 40.094 secs (0.003u,0.018s)
Chars 2772 - 2773 [{] 0. secs (0.u,0.s)
Chars 2778 - 2787 [symmetry.] 0. secs (0.u,0.s)
Chars 2788 - 2794 [issig.] 0.018 secs (0.013u,0.004s)
Chars 2797 - 2798 [}] 0. secs (0.u,0.s)
Chars 2801 - 2826 [(apply~equiv_sigma_assoc').] 0. secs (0.u,0.s)
Chars 2708 - 2771 [transitivity~{A~:~Type~&~{R~:~...] 0. secs (0.u,0.s)
Chars 2778 - 2787 [symmetry.] 0. secs (0.u,0.s)
Chars 2788 - 2794 [issig.] 0. secs (0.u,0.s)
Chars 2801 - 2826 [(apply~equiv_sigma_assoc').] 0. secs (0.u,0.s)
Chars 2827 - 2835 [Defined.] 0.003 secs (0.003u,0.s)
Chars 2838 - 3012 [Definition~Isomorphism~:~TypeW...] 0.002 secs (0.002u,0.s)
Chars 3015 - 3070 [#[global]Instance~isomorphism_...] 0. secs (0.u,0.s)
Chars 3071 - 3077 [Proof.] 0. secs (0.u,0.s)
Chars 3825 - 3854 [(apply~path_path_hset_algebra).] 40.084 secs (0.001u,0.016s)
Chars 3857 - 3895 [(rewrite~path_ap_carriers_path...] 0.002 secs (0.001u,0.s)
Chars 3898 - 3968 [(apply~(paths_ind~(λ~s,~idpath...] 0.002 secs (0.002u,0.s)
Chars 3971 - 3972 [-] 0. secs (0.u,0.s)
Chars 3973 - 3993 [(apply~path_forall_1).] 0. secs (0.u,0.s)
Chars 3996 - 3997 [-] 0. secs (0.u,0.s)
Chars 3998 - 4005 [(intros).] 0. secs (0.u,0.s)
Chars 4010 - 4019 [funext~s.] 0.001 secs (0.001u,0.s)
Chars 4024 - 4033 [symmetry.] 0.001 secs (0.001u,0.s)
Chars 4038 - 4085 [(rewrite~(path_ishprop~_~(iseq...] 0.006 secs (0.004u,0.001s)
Chars 4090 - 4112 [(apply~path_universe_1).] 0.001 secs (0.001u,0.s)
Chars 3825 - 3854 [(apply~path_path_hset_algebra).] 0. secs (0.u,0.s)
Chars 3857 - 3895 [(rewrite~path_ap_carriers_path...] 0. secs (0.u,0.s)
Chars 3898 - 3968 [(apply~(paths_ind~(λ~s,~idpath...] 0. secs (0.u,0.s)
Chars 3973 - 3993 [(apply~path_forall_1).] 0. secs (0.u,0.s)
Chars 3998 - 4005 [(intros).] 0. secs (0.u,0.s)
Chars 4010 - 4019 [funext~s.] 0. secs (0.u,0.s)
Chars 4024 - 4033 [symmetry.] 0. secs (0.u,0.s)
Chars 4038 - 4085 [(rewrite~(path_ishprop~_~(iseq...] 0. secs (0.u,0.s)
Chars 4090 - 4112 [(apply~path_universe_1).] 0. secs (0.u,0.s)
Chars 4113 - 4117 [Qed.] 0.004 secs (0.004u,0.s)
Chars 4228 - 4258 [Section~isequiv_isomorphic_id.] 0. secs (0.u,0.s)
Chars 4261 - 4326 [Context~`{Univalence}~{σ}~(A~B...] 0. secs (0.u,0.s)
Chars 4330 - 4406 [Lemma~sect_id_isomorphic~:~@is...] 0.001 secs (0.001u,0.s)
Chars 4409 - 4415 [Proof.] 0. secs (0.u,0.s)
Chars 842 - 855 [(intros~E1~E2).] 40.064 secs (0.u,0.017s)
Chars 858 - 867 [(apply~E1).] 0. secs (0.u,0.s)
Chars 870 - 881 [(rewrite~E2).] 0. secs (0.u,0.s)
Chars 884 - 902 [(apply~reflexivity).] 0.001 secs (0.001u,0.s)
Chars 842 - 855 [(intros~E1~E2).] 0. secs (0.u,0.s)
Chars 858 - 867 [(apply~E1).] 0. secs (0.u,0.s)
Chars 870 - 881 [(rewrite~E2).] 0. secs (0.u,0.s)
Chars 884 - 902 [(apply~reflexivity).] 0. secs (0.u,0.s)
Chars 905 - 909 [Qed.] 0. secs (0.u,0.s)
Chars 913 - 964 [Lemma~eq_iff_le~x~y~:~x~=~y~<-...] 0. secs (0.u,0.s)
Chars 967 - 973 [Proof.] 0. secs (0.u,0.s)
Chars 2867 - 2909 [(srapply~Colimit_rec;~srapply~...] 40.082 secs (0.001u,0.017s)
Chars 2912 - 2913 [+] 0. secs (0.u,0.s)
Chars 2914 - 2946 [exact~(fun~n~a~=>~inj~_~n.+1~a).] 0.001 secs (0.001u,0.s)
Chars 2949 - 2950 [+] 0. secs (0.u,0.s)
Chars 2951 - 2997 [(intros~n~m~p;~destruct~p;~exa...] 0.003 secs (0.003u,0.s)
Chars 2867 - 2909 [(srapply~Colimit_rec;~srapply~...] 0. secs (0.u,0.s)
Chars 2914 - 2946 [exact~(fun~n~a~=>~inj~_~n.+1~a).] 0. secs (0.u,0.s)
Chars 2951 - 2997 [(intros~n~m~p;~destruct~p;~exa...] 0. secs (0.u,0.s)
Chars 2998 - 3006 [Defined.] 0.001 secs (0.001u,0.s)
Chars 3008 - 3144 [Definition~colim_succ_seq_to_c...] 0.002 secs (0.001u,0.s)
Chars 3145 - 3151 [Proof.] 0. secs (0.u,0.s)
Chars 3154 - 3186 [srapply~Colimit_rec_beta_colimp.] 5.658 secs (-0.361u,-0.079s)
All solutions:
occurrence 0: transitivity through forall x y z : X,
                                   plus (x * y + x * z) (a * b)
2 possible(s) substitution(s)
0:	[x: a; y: c; z: dot b c; ]
1:	[x: a; y: dot b c; z: c; ]

occurrence 1: transitivity through forall x y z : X,
                                    plus (x * y + x * z) (a * c)
2 possible(s) substitution(s)
0:	[x: a; y: dot b c; z: b; ]
1:	[x: a; y: b; z: dot b c; ]

occurrence 2: transitivity through forall x y z : X,
                                    plus (x * y + x * z) (a * b * c)
2 possible(s) substitution(s)
0:	[x: a; y: c; z: b; ]
1:	[x: a; y: b; z: c; ]


All solutions:
occurrence 0: transitivity through forall x y z : X, plus (x * y) (x * z)
6 possible(s) substitution(s)
0:	[x: 1; y: dot a (b * c + c); z: dot a b; ]
1:	[x: a; y: plus (b * c) c; z: b; ]
2:	[x: 1; y: 0; z: plus (a * (b * c + c)) (a * b); ]
3:	[x: 1; y: plus (a * (b * c + c)) (a * b); z: 0; ]
4:	[x: 1; y: dot a b; z: dot a (b * c + c); ]
5:	[x: a; y: b; z: plus (b * c) c; ]

occurrence 1: transitivity through forall x y z : X,
                                    plus (x * y + x * z) (a * b)
2 possible(s) substitution(s)
0:	[x: 1; y: dot a (b * c + c); z: 0; ]
1:	[x: 1; y: 0; z: dot a (b * c + c); ]

occurrence 2: transitivity through forall x y z : X,
                                    plus (a * (x * y + x * z)) (a * b)
4 possible(s) substitution(s)
0:	[x: 1; y: dot b c; z: c; ]
1:	[x: 1; y: 0; z: plus (b * c) c; ]
2:	[x: 1; y: plus (b * c) c; z: 0; ]
3:	[x: 1; y: c; z: dot b c; ]

occurrence 3: transitivity through forall x y z : X,
                                    plus (a * (x * y + x * z + c)) (a * b)
2 possible(s) substitution(s)
0:	[x: 1; y: dot b c; z: 0; ]
1:	[x: 1; y: 0; z: dot b c; ]

occurrence 4: transitivity through forall x y z : X,
                                    plus (x * y + x * z) (a * (b * c + c))
2 possible(s) substitution(s)
0:	[x: 1; y: dot a b; z: 0; ]
1:	[x: 1; y: 0; z: dot a b; ]

occurrence 5: transitivity through forall x y z : X,
                                    plus (a * (b * (x * y + x * z) + c))
                                      (a * b)
2 possible(s) substitution(s)
0:	[x: 1; y: c; z: 0; ]
1:	[x: 1; y: 0; z: c; ]

occurrence 6: transitivity through forall x y z : X,
                                    plus (a * ((x * y + x * z) * c + c))
                                      (a * b)
2 possible(s) substitution(s)
0:	[x: 1; y: b; z: 0; ]
1:	[x: 1; y: 0; z: b; ]

occurrence 7: transitivity through forall x y z : X,
                                    plus (a * (x * y + x * z + b * c))
                                      (a * b)
2 possible(s) substitution(s)
0:	[x: 1; y: c; z: 0; ]
1:	[x: 1; y: 0; z: c; ]

occurrence 8: transitivity through forall x y z : X,
                                    plus ((x * y + x * z) * (b * c + c))
                                      (a * b)
2 possible(s) substitution(s)
0:	[x: 1; y: a; z: 0; ]
1:	[x: 1; y: 0; z: a; ]

occurrence 9: transitivity through forall x y z : X,
                                    plus (a * (x * y + x * z))
                                      (a * (b * c + c))
2 possible(s) substitution(s)
0:	[x: 1; y: b; z: 0; ]
1:	[x: 1; y: 0; z: b; ]

occurrence 10: transitivity through forall x y z : X,
                                     plus ((x * y + x * z) * b)
                                       (a * (b * c + c))
2 possible(s) substitution(s)
0:	[x: 1; y: a; z: 0; ]
1:	[x: 1; y: 0; z: a; ]

occurrence 11: transitivity through plus (a * (b * c + c))
                                       ((1 * 1 + 1 * 0) * (a * b))

occurrence 12: transitivity through 
plus (a * (b * c + c)) (a * b * (1 * 1 + 1 * 0))

occurrence 13: transitivity through 
plus (a * (b * c + c)) (a * ((1 * 1 + 1 * 0) * b))

occurrence 14: transitivity through 
plus (a * b) ((1 * 1 + 1 * 0) * (a * (b * c + c)))

occurrence 15: transitivity through 
plus (a * b) (a * (b * c + c) * (1 * 1 + 1 * 0))

occurrence 16: transitivity through 
plus (a * b) (a * (b * c + (1 * 1 + 1 * 0) * c))

occurrence 17: transitivity through 
plus (a * b) (a * (b * c + c * (1 * 1 + 1 * 0)))

occurrence 18: transitivity through 
plus (a * b) (a * (c + (1 * 1 + 1 * 0) * (b * c)))

occurrence 19: transitivity through 
plus (a * b) (a * (c + b * c * (1 * 1 + 1 * 0)))

occurrence 20: transitivity through 
plus (a * b) (a * (c + b * ((1 * 1 + 1 * 0) * c)))

occurrence 21: transitivity through 
plus (a * b) (a * ((1 * 1 + 1 * 0) * (b * c + c)))

occurrence 22: transitivity through 
dot (a * (b * c + c) + a * b) (1 * 1 + 1 * 0)

occurrence 23: transitivity through 
dot (1 * 1 + 1 * 0) (a * (b * c + c) + a * b)

occurrence 24: transitivity through 
plus (a * (b * c + c)) ((1 * 0 + 1 * 1) * (a * b))

occurrence 25: transitivity through 
plus (a * (b * c + c)) (a * b * (1 * 0 + 1 * 1))

occurrence 26: transitivity through 
plus (a * (b * c + c)) (a * ((1 * 0 + 1 * 1) * b))

occurrence 27: transitivity through 
plus (a * b) ((1 * 0 + 1 * 1) * (a * (b * c + c)))

occurrence 28: transitivity through 
plus (a * b) (a * (b * c + c) * (1 * 0 + 1 * 1))

occurrence 29: transitivity through 
plus (a * b) (a * (b * c + (1 * 0 + 1 * 1) * c))

occurrence 30: transitivity through 
plus (a * b) (a * (b * c + c * (1 * 0 + 1 * 1)))

occurrence 31: transitivity through 
plus (a * b) (a * (c + (1 * 0 + 1 * 1) * (b * c)))

occurrence 32: transitivity through 
plus (a * b) (a * (c + b * c * (1 * 0 + 1 * 1)))

occurrence 33: transitivity through 
plus (a * b) (a * (c + b * ((1 * 0 + 1 * 1) * c)))

occurrence 34: transitivity through 
plus (a * b) (a * ((1 * 0 + 1 * 1) * (b * c + c)))

occurrence 35: transitivity through 
dot (a * (b * c + c) + a * b) (1 * 0 + 1 * 1)

occurrence 36: transitivity through 
dot (1 * 0 + 1 * 1) (a * (b * c + c) + a * b)

occurrence 37: transitivity through 
plus (a * (b * c + c) + a * b) (1 * 0 + 1 * 0)

occurrence 38: transitivity through 
plus (a * (b * c + c)) (a * (b + (1 * 0 + 1 * 0)))

occurrence 39: transitivity through 
plus (a * (b * c + c)) ((a + (1 * 0 + 1 * 0)) * b)

occurrence 40: transitivity through 
plus (a * b) (a * (b * c + c + (1 * 0 + 1 * 0)))

occurrence 41: transitivity through 
plus (a * b) (a * (c + b * (c + (1 * 0 + 1 * 0))))

occurrence 42: transitivity through 
plus (a * b) (a * (c + (b + (1 * 0 + 1 * 0)) * c))

occurrence 43: transitivity through 
plus (a * b) ((a + (1 * 0 + 1 * 0)) * (b * c + c))

occurrence 44: transitivity through 
plus (a * (b * c + c) + a * b) (0 * 1 + 0 * 1)

occurrence 45: transitivity through 
plus (a * (b * c + c)) (a * (b + (0 * 1 + 0 * 1)))

occurrence 46: transitivity through 
plus (a * (b * c + c)) ((a + (0 * 1 + 0 * 1)) * b)

occurrence 47: transitivity through 
plus (a * b) (a * (b * c + c + (0 * 1 + 0 * 1)))

occurrence 48: transitivity through 
plus (a * b) (a * (c + b * (c + (0 * 1 + 0 * 1))))

occurrence 49: transitivity through 
plus (a * b) (a * (c + (b + (0 * 1 + 0 * 1)) * c))

occurrence 50: transitivity through 
plus (a * b) ((a + (0 * 1 + 0 * 1)) * (b * c + c))

occurrence 51: transitivity through 
plus (a * (b * c + c)) (a * b * (1 + (1 * 0 + 1 * 0)))

occurrence 52: transitivity through 
plus (a * (b * c + c)) (a * ((1 + (1 * 0 + 1 * 0)) * b))

occurrence 53: transitivity through 
plus (a * (b * c + c)) ((1 + (1 * 0 + 1 * 0)) * (a * b))

occurrence 54: transitivity through 
plus (a * b) (a * (b * c + c) * (1 + (1 * 0 + 1 * 0)))

occurrence 55: transitivity through 
plus (a * b) (a * (c + b * c * (1 + (1 * 0 + 1 * 0))))

occurrence 56: transitivity through 
plus (a * b) (a * (c + b * ((1 + (1 * 0 + 1 * 0)) * c)))

occurrence 57: transitivity through 
plus (a * b) (a * (c + (1 + (1 * 0 + 1 * 0)) * (b * c)))

occurrence 58: transitivity through 
plus (a * b) (a * ((1 + (1 * 0 + 1 * 0)) * (b * c + c)))

occurrence 59: transitivity through 
plus (a * b) ((1 + (1 * 0 + 1 * 0)) * (a * (b * c + c)))

occurrence 60: transitivity through 
plus (a * (b * c + c)) (a * b * (1 + (0 * 1 + 0 * 1)))

occurrence 61: transitivity through 
plus (a * (b * c + c)) (a * ((1 + (0 * 1 + 0 * 1)) * b))

occurrence 62: transitivity through 
plus (a * (b * c + c)) ((1 + (0 * 1 + 0 * 1)) * (a * b))

occurrence 63: transitivity through 
plus (a * b) (a * (b * c + c) * (1 + (0 * 1 + 0 * 1)))

occurrence 64: transitivity through 
plus (a * b) (a * (c + b * c * (1 + (0 * 1 + 0 * 1))))

occurrence 65: transitivity through 
plus (a * b) (a * (c + b * ((1 + (0 * 1 + 0 * 1)) * c)))

occurrence 66: transitivity through 
plus (a * b) (a * (c + (1 + (0 * 1 + 0 * 1)) * (b * c)))

occurrence 67: transitivity through 
plus (a * b) (a * ((1 + (0 * 1 + 0 * 1)) * (b * c + c)))

occurrence 68: transitivity through 
plus (a * b) ((1 + (0 * 1 + 0 * 1)) * (a * (b * c + c)))


All solutions:
occurrence 0: transitivity through forall x y z : nat,
                                   Nat.max (x + y) (x + z)
2 possible(s) substitution(s)
0:	[x: a; y: b; z: c; ]
1:	[x: a; y: c; z: b; ]


Chars 6580 - 6603 [(apply~Build_Is1Functor).] 40.054 secs (0.002u,0.011s)
Chars 6606 - 6607 [-] 0. secs (0.u,0.s)
Chars 6608 - 6627 [(intros~a~b~f~g~p~x).] 0.001 secs (0.001u,0.s)
Chars 6632 - 6645 [rapply~fmap2.] 0.026 secs (0.022u,0.003s)
Chars 6650 - 6659 [rapply~p.] 0.001 secs (0.001u,0.s)
Chars 6662 - 6663 [-] 0. secs (0.u,0.s)
Chars 6664 - 6675 [(intros~f~x).] 0.001 secs (0.001u,0.s)
All solutions:
occurrence 0: transitivity through forall x y z : nat,
                                   Nat.max (x + y) (x + z)
2 possible(s) substitution(s)
0:	[x: a; y: b; z: c; ]
1:	[x: a; y: c; z: b; ]


Chars 6680 - 6695 [rapply~fmap_id.] 0.011 secs (0.01u,0.s)
Chars 6698 - 6699 [-] 0. secs (0.u,0.s)
Chars 6700 - 6719 [(intros~a~b~c~f~g~x).] 0.001 secs (0.001u,0.s)
Chars 6724 - 6741 [rapply~fmap_comp.] 0.026 secs (0.022u,0.003s)
Chars 6580 - 6603 [(apply~Build_Is1Functor).] 0. secs (0.u,0.s)
Chars 6608 - 6627 [(intros~a~b~f~g~p~x).] 0.001 secs (0.001u,0.s)
Chars 6632 - 6645 [rapply~fmap2.] 0.001 secs (0.001u,0.s)
Chars 6650 - 6659 [rapply~p.] 0. secs (0.u,0.s)
Chars 6664 - 6675 [(intros~f~x).] 0. secs (0.u,0.s)
Chars 6680 - 6695 [rapply~fmap_id.] 0. secs (0.u,0.s)
Chars 6700 - 6719 [(intros~a~b~c~f~g~x).] 0.001 secs (0.001u,0.s)
Chars 6724 - 6741 [rapply~fmap_comp.] 0.001 secs (0.001u,0.s)
Chars 6742 - 6750 [Defined.] 0.006 secs (0.004u,0.001s)
Chars 6752 - 6917 [Definition~fun11_fun01_postcom...] 0.012 secs (0.011u,0.001s)
Chars 6919 - 7024 [Definition~fun11_compose~{A}~{...] 0.004 secs (0.003u,0.001s)
Chars 7025 - 7031 [Proof.] 0. secs (0.u,0.s)
Chars 854 - 867 [(intros~ltnxy).] 40.081 secs (0.001u,0.018s)
Chars 868 - 901 [(rewrite~<-~(negate_involutive...] 0.007 secs (0.005u,0.002s)
Chars 902 - 935 [(apply~(snd~(flip_lt_negate~_~...] 0.013 secs (0.012u,0.s)
Chars 936 - 947 [assumption.] 0.011 secs (0.008u,0.002s)
Chars 854 - 867 [(intros~ltnxy).] 0. secs (0.u,0.s)
Chars 868 - 901 [(rewrite~<-~(negate_involutive...] 0. secs (0.u,0.s)
Chars 902 - 935 [(apply~(snd~(flip_lt_negate~_~...] 0. secs (0.u,0.s)
Chars 936 - 947 [assumption.] 0. secs (0.u,0.s)
Chars 950 - 954 [Qed.] 0. secs (0.u,0.s)
Chars 958 - 1081 [Lemma~char_plus_left~:~~~foral...] 0.003 secs (0.003u,0.s)
Chars 1084 - 1090 [Proof.] 0. secs (0.u,0.s)
Chars 1100 - 1224 [Lemma~char_plus_right~:~~~fora...] 0.003 secs (0.003u,0.s)
Chars 1227 - 1233 [Proof.] 0. secs (0.u,0.s)
Chars 1244 - 1453 [Definition~hexists4~{X}~{Y}~{Z...] 0.003 secs (0.003u,0.s)
Chars 1457 - 1797 [Lemma~char_times_left~:~~~fora...] 0.005 secs (0.005u,0.s)
Chars 1800 - 1806 [Proof.] 0. secs (0.u,0.s)
Chars 1816 - 2157 [Lemma~char_times_right~:~~~for...] 0.005 secs (0.005u,0.s)
Chars 2160 - 2166 [Proof.] 0. secs (0.u,0.s)
Chars 2176 - 2302 [Lemma~char_recip_pos_left~:~~~...] 0.008 secs (0.008u,0.s)
Chars 2305 - 2311 [Proof.] 0. secs (0.u,0.s)
Chars 2321 - 2449 [Lemma~char_recip_pos_right~:~~...] 0.008 secs (0.006u,0.001s)
Chars 2452 - 2458 [Proof.] 0. secs (0.u,0.s)
Chars 2468 - 2594 [Lemma~char_recip_neg_left~:~~~...] 0.008 secs (0.007u,0.001s)
Chars 2597 - 2603 [Proof.] 0. secs (0.u,0.s)
Chars 2613 - 2741 [Lemma~char_recip_neg_right~:~~...] 0.008 secs (0.006u,0.001s)
Chars 2744 - 2750 [Proof.] 0. secs (0.u,0.s)
Chars 2761 - 2854 [Lemma~char_meet_left~:~~~foral...] 0.002 secs (0.u,0.002s)
Chars 2857 - 2863 [Proof.] 0. secs (0.u,0.s)
Chars 2873 - 2969 [Lemma~char_meet_right~:~~~fora...] 0.002 secs (0.001u,0.s)
Chars 2972 - 2978 [Proof.] 0. secs (0.u,0.s)
Chars 2988 - 3084 [Lemma~char_join_left~:~~~foral...] 0.002 secs (0.002u,0.s)
Chars 3087 - 3093 [Proof.] 0. secs (0.u,0.s)
Chars 3103 - 3197 [Lemma~char_join_right~:~~~fora...] 0.002 secs (0.002u,0.s)
Chars 3200 - 3206 [Proof.] 0. secs (0.u,0.s)
Chars 3215 - 3238 [End~strict_field_order.] 0.008 secs (0.008u,0.s)
Chars 2401 - 2424 [(induction~x~as~[|~x~xs]).] 40.012 secs (0.001u,0.002s)
Chars 2429 - 2430 [{] 0. secs (0.u,0.s)
Chars 2431 - 2440 [symmetry.] 0. secs (0.u,0.s)
Chars 2447 - 2471 [(apply~word_concat_w_nil).] 0. secs (0.u,0.s)
Chars 2472 - 2473 [}] 0. secs (0.u,0.s)
Chars 2478 - 2484 [(simpl).] 0. secs (0.u,0.s)
Chars 2489 - 2546 [(destruct~x;~refine~(_~@~(word...] 0.011 secs (0.011u,0.s)
Chars 2401 - 2424 [(induction~x~as~[|~x~xs]).] 0. secs (0.u,0.s)
Chars 2431 - 2440 [symmetry.] 0. secs (0.u,0.s)
Chars 2447 - 2471 [(apply~word_concat_w_nil).] 0. secs (0.u,0.s)
Chars 2478 - 2484 [(simpl).] 0. secs (0.u,0.s)
Chars 2489 - 2546 [(destruct~x;~refine~(_~@~(word...] 0.002 secs (0.002u,0.s)
Chars 2549 - 2557 [Defined.] 0.002 secs (0.002u,0.s)
Chars 2801 - 2854 [#[local]Definition~pc1~:~Type~...] 0. secs (0.u,0.s)
Chars 2857 - 2910 [#[local]Definition~pc2~:~Type~...] 0. secs (0.u,0.s)
Chars 2913 - 2962 [#[local]Definition~pc3~:~Type~...] 0. secs (0.u,0.s)
Chars 2965 - 3010 [#[local]Definition~pc4~:~Type~...] 0. secs (0.u,0.s)
Chars 3013 - 3058 [#[local]Definition~pc5~:~Type~...] 0. secs (0.u,0.s)
Chars 3112 - 3147 [#[local]Definition~m1~:~pc1~->...] 0. secs (0.u,0.s)
Chars 3150 - 3156 [Proof.] 0. secs (0.u,0.s)
Chars 3161 - 3184 [(intros~[[[x~h1]~h2]~y]).] 0.202 secs (0.001u,0.002s)
Chars 3189 - 3228 [exact~(x~++~(inl~h1~::~[inl~h2...] 0.001 secs (0.001u,0.s)
Chars 3161 - 3184 [(intros~[[[x~h1]~h2]~y]).] 0. secs (0.u,0.s)
Chars 3189 - 3228 [exact~(x~++~(inl~h1~::~[inl~h2...] 0. secs (0.u,0.s)
Chars 3231 - 3239 [Defined.] 0. secs (0.u,0.s)
Chars 3243 - 3279 [#[local]Definition~m1'~:~pc1~-...] 0. secs (0.u,0.s)
Chars 3282 - 3288 [Proof.] 0. secs (0.u,0.s)
Chars 3293 - 3316 [(intros~[[[x~h1]~h2]~y]).] 0.02 secs (0.001u,0.003s)
Chars 3321 - 3355 [exact~(x~++~[inl~(h1~*~h2)]~++...] 0.001 secs (0.001u,0.s)
Chars 3293 - 3316 [(intros~[[[x~h1]~h2]~y]).] 0. secs (0.u,0.s)
Chars 3321 - 3355 [exact~(x~++~[inl~(h1~*~h2)]~++...] 0. secs (0.u,0.s)
Chars 3358 - 3366 [Defined.] 0. secs (0.u,0.s)
Chars 3419 - 3454 [#[local]Definition~m2~:~pc2~->...] 0. secs (0.u,0.s)
Chars 3457 - 3463 [Proof.] 0. secs (0.u,0.s)
Chars 3468 - 3491 [(intros~[[[x~k1]~k2]~y]).] 0.338 secs (0.001u,0.002s)
Chars 3496 - 3535 [exact~(x~++~(inr~k1~::~[inr~k2...] 0.001 secs (0.001u,0.s)
Chars 3468 - 3491 [(intros~[[[x~k1]~k2]~y]).] 0. secs (0.u,0.s)
Chars 3496 - 3535 [exact~(x~++~(inr~k1~::~[inr~k2...] 0. secs (0.u,0.s)
Chars 3538 - 3546 [Defined.] 0. secs (0.u,0.s)
Chars 3550 - 3586 [#[local]Definition~m2'~:~pc2~-...] 0. secs (0.u,0.s)
Chars 3589 - 3595 [Proof.] 0. secs (0.u,0.s)
Chars 3600 - 3623 [(intros~[[[x~k1]~k2]~y]).] 0.104 secs (0.001u,0.002s)
Chars 3628 - 3662 [exact~(x~++~[inr~(k1~*~k2)]~++...] 0.001 secs (0.001u,0.s)
Chars 3600 - 3623 [(intros~[[[x~k1]~k2]~y]).] 0. secs (0.u,0.s)
Chars 3628 - 3662 [exact~(x~++~[inr~(k1~*~k2)]~++...] 0. secs (0.u,0.s)
Chars 3665 - 3673 [Defined.] 0. secs (0.u,0.s)
Chars 3727 - 3762 [#[local]Definition~m3~:~pc3~->...] 0. secs (0.u,0.s)
Chars 3765 - 3771 [Proof.] 0. secs (0.u,0.s)
Chars 3776 - 3793 [(intros~[[x~z]~y]).] 0.111 secs (0.u,0.003s)
Chars 3798 - 3828 [exact~(x~++~[inl~(f~z)]~++~y).] 0.017 secs (0.014u,0.003s)
Chars 3776 - 3793 [(intros~[[x~z]~y]).] 0. secs (0.u,0.s)
Chars 3798 - 3828 [exact~(x~++~[inl~(f~z)]~++~y).] 0. secs (0.u,0.s)
Chars 3831 - 3839 [Defined.] 0. secs (0.u,0.s)
Chars 3843 - 3879 [#[local]Definition~m3'~:~pc3~-...] 0. secs (0.u,0.s)
Chars 3882 - 3888 [Proof.] 0. secs (0.u,0.s)
Chars 3893 - 3910 [(intros~[[x~z]~y]).] 0.019 secs (0.001u,0.003s)
Chars 3915 - 3945 [exact~(x~++~[inr~(g~z)]~++~y).] 0. secs (0.u,0.s)
Chars 3893 - 3910 [(intros~[[x~z]~y]).] 0. secs (0.u,0.s)
Chars 3915 - 3945 [exact~(x~++~[inr~(g~z)]~++~y).] 0. secs (0.u,0.s)
Chars 3948 - 3956 [Defined.] 0. secs (0.u,0.s)
Chars 4011 - 4046 [#[local]Definition~m4~:~pc4~->...] 0. secs (0.u,0.s)
Chars 4049 - 4055 [Proof.] 0. secs (0.u,0.s)
Chars 2958 - 3009 [(induction~e;~simpl;~try~refle...] 40.111 secs (0.027u,0.026s)
Chars 2958 - 3009 [(induction~e;~simpl;~try~refle...] 0.006 secs (0.006u,0.s)
Chars 3010 - 3014 [Qed.] 0.002 secs (0.001u,0.001s)
Chars 3016 - 3030 [Section~Quote.] 0. secs (0.u,0.s)
Chars 3034 - 3194 [Class~Quote~{V~:~Type0}~(l~:~V...] 0.001 secs (0.u,0.s)
Chars 3198 - 3238 [#[global]Arguments~quote~{V~l}...] 0. secs (0.u,0.s)
Chars 3241 - 3286 [#[global]Arguments~eval_quote~...] 0. secs (0.u,0.s)
Chars 3290 - 3355 [Definition~sum_assoc~{A}~{B}~{...] 0. secs (0.u,0.s)
Chars 3358 - 3364 [Proof.] 0. secs (0.u,0.s)
Chars 4060 - 4073 [(intros~[x~y]).] 0.696 secs (0.001u,0.002s)
Chars 4078 - 4111 [exact~(x~++~[inl~mon_unit]~++~y).] 0.001 secs (0.001u,0.s)
Chars 4060 - 4073 [(intros~[x~y]).] 0. secs (0.u,0.s)
Chars 4078 - 4111 [exact~(x~++~[inl~mon_unit]~++~y).] 0. secs (0.u,0.s)
Chars 4114 - 4122 [Defined.] 0. secs (0.u,0.s)
Chars 4126 - 4162 [#[local]Definition~m4'~:~pc4~-...] 0. secs (0.u,0.s)
Chars 4165 - 4171 [Proof.] 0. secs (0.u,0.s)
Chars 4176 - 4189 [(intros~[x~y]).] 0.018 secs (0.u,0.003s)
Chars 4194 - 4209 [exact~(x~++~y).] 0. secs (0.u,0.s)
Chars 4176 - 4189 [(intros~[x~y]).] 0. secs (0.u,0.s)
Chars 4194 - 4209 [exact~(x~++~y).] 0. secs (0.u,0.s)
Chars 4212 - 4220 [Defined.] 0. secs (0.u,0.s)
Chars 4274 - 4309 [#[local]Definition~m5~:~pc5~->...] 0. secs (0.u,0.s)
Chars 4312 - 4318 [Proof.] 0. secs (0.u,0.s)
Chars 4323 - 4336 [(intros~[x~y]).] 0.023 secs (0.001u,0.003s)
Chars 4341 - 4374 [exact~(x~++~[inr~mon_unit]~++~y).] 0.001 secs (0.001u,0.s)
Chars 4323 - 4336 [(intros~[x~y]).] 0. secs (0.u,0.s)
Chars 4341 - 4374 [exact~(x~++~[inr~mon_unit]~++~y).] 0. secs (0.u,0.s)
Chars 4377 - 4385 [Defined.] 0. secs (0.u,0.s)
Chars 4389 - 4425 [#[local]Definition~m5'~:~pc5~-...] 0. secs (0.u,0.s)
Chars 4428 - 4434 [Proof.] 0. secs (0.u,0.s)
Chars 4439 - 4452 [(intros~[x~y]).] 0.018 secs (0.u,0.003s)
Chars 4457 - 4472 [exact~(x~++~y).] 0. secs (0.u,0.s)
Chars 4439 - 4452 [(intros~[x~y]).] 0. secs (0.u,0.s)
Chars 4457 - 4472 [exact~(x~++~y).] 0. secs (0.u,0.s)
Chars 4475 - 4483 [Defined.] 0. secs (0.u,0.s)
Chars 4605 - 4666 [#[local]Definition~map1~:~pc1~...] 0. secs (0.u,0.s)
Chars 4669 - 4675 [Proof.] 0. secs (0.u,0.s)
Chars 1245 - 1258 [(repeat~split).] 40.012 secs (0.001u,0.002s)
Chars 1261 - 1262 [-] 0. secs (0.u,0.s)
Chars 1263 - 1271 [(apply~_).] 0.005 secs (0.004u,0.s)
Chars 1274 - 1275 [-] 0. secs (0.u,0.s)
Chars 1276 - 1289 [(intros~x~y~z).] 0. secs (0.u,0.s)
Chars 1290 - 1317 [(apply~(antisymmetry~(≤))).] 0.002 secs (0.002u,0.s)
Chars 1322 - 1323 [+] 0. secs (0.u,0.s)
Chars 1324 - 1339 [(apply~join_lub).] 0. secs (0.u,0.s)
Chars 1346 - 1347 [*] 0. secs (0.u,0.s)
Chars 1348 - 1366 [(apply~join_ub_3_l).] 0. secs (0.u,0.s)
Chars 1373 - 1374 [*] 0. secs (0.u,0.s)
Chars 1375 - 1390 [(apply~join_lub).] 0. secs (0.u,0.s)
Chars 1399 - 1401 [**] 0. secs (0.u,0.s)
Chars 1402 - 1420 [(apply~join_ub_3_m).] 0. secs (0.u,0.s)
Chars 1429 - 1431 [**] 0. secs (0.u,0.s)
Chars 1432 - 1450 [(apply~join_ub_3_r).] 0.017 secs (0.017u,0.s)
Chars 1455 - 1456 [+] 0. secs (0.u,0.s)
Chars 1457 - 1472 [(apply~join_lub).] 0.001 secs (0.001u,0.s)
Chars 1479 - 1480 [*] 0. secs (0.u,0.s)
Chars 1481 - 1496 [(apply~join_lub).] 0. secs (0.u,0.s)
Chars 1505 - 1507 [**] 0. secs (0.u,0.s)
Chars 1508 - 1532 [(apply~join_ub_3_assoc_l).] 0. secs (0.u,0.s)
Chars 1541 - 1543 [**] 0. secs (0.u,0.s)
Chars 1544 - 1568 [(apply~join_ub_3_assoc_m).] 0. secs (0.u,0.s)
Chars 1575 - 1576 [*] 0. secs (0.u,0.s)
Chars 1577 - 1601 [(apply~join_ub_3_assoc_r).] 0. secs (0.u,0.s)
Chars 1604 - 1605 [-] 0. secs (0.u,0.s)
Chars 1606 - 1617 [(intros~x~y).] 0. secs (0.u,0.s)
Chars 1618 - 1708 [(apply~(antisymmetry~(≤));~app...] 0.005 secs (0.005u,0.s)
Chars 1711 - 1712 [-] 0. secs (0.u,0.s)
Chars 1713 - 1722 [(intros~x).] 0. secs (0.u,0.s)
Chars 1723 - 1727 [(red).] 0. secs (0.u,0.s)
Chars 1728 - 1755 [(apply~(antisymmetry~(≤))).] 0.002 secs (0.002u,0.s)
Chars 1760 - 1761 [+] 0. secs (0.u,0.s)
Chars 1762 - 1796 [(apply~join_lub;~apply~reflexi...] 0.005 secs (0.005u,0.s)
Chars 1801 - 1802 [+] 0. secs (0.u,0.s)
Chars 1803 - 1819 [(apply~join_ub_l).] 0. secs (0.u,0.s)
Chars 1245 - 1258 [(repeat~split).] 0. secs (0.u,0.s)
Chars 1263 - 1271 [(apply~_).] 0. secs (0.u,0.s)
Chars 1276 - 1289 [(intros~x~y~z).] 0. secs (0.u,0.s)
Chars 1290 - 1317 [(apply~(antisymmetry~(≤))).] 0. secs (0.u,0.s)
Chars 1324 - 1339 [(apply~join_lub).] 0. secs (0.u,0.s)
Chars 1348 - 1366 [(apply~join_ub_3_l).] 0. secs (0.u,0.s)
Chars 1375 - 1390 [(apply~join_lub).] 0. secs (0.u,0.s)
Chars 1402 - 1420 [(apply~join_ub_3_m).] 0. secs (0.u,0.s)
Chars 1432 - 1450 [(apply~join_ub_3_r).] 0. secs (0.u,0.s)
Chars 1457 - 1472 [(apply~join_lub).] 0. secs (0.u,0.s)
Chars 1481 - 1496 [(apply~join_lub).] 0. secs (0.u,0.s)
Chars 1508 - 1532 [(apply~join_ub_3_assoc_l).] 0. secs (0.u,0.s)
Chars 1544 - 1568 [(apply~join_ub_3_assoc_m).] 0. secs (0.u,0.s)
Chars 1577 - 1601 [(apply~join_ub_3_assoc_r).] 0. secs (0.u,0.s)
Chars 1606 - 1617 [(intros~x~y).] 0. secs (0.u,0.s)
Chars 1618 - 1708 [(apply~(antisymmetry~(≤));~app...] 0. secs (0.u,0.s)
Chars 1713 - 1722 [(intros~x).] 0. secs (0.u,0.s)
Chars 1723 - 1727 [(red).] 0. secs (0.u,0.s)
Chars 1728 - 1755 [(apply~(antisymmetry~(≤))).] 0. secs (0.u,0.s)
Chars 1762 - 1796 [(apply~join_lub;~apply~reflexi...] 0. secs (0.u,0.s)
Chars 1803 - 1819 [(apply~join_ub_l).] 0. secs (0.u,0.s)
Chars 1822 - 1826 [Qed.] 0.001 secs (0.001u,0.s)
Chars 1830 - 1886 [Lemma~join_le_compat_r~x~y~z~:...] 0. secs (0.u,0.s)
Chars 1889 - 1895 [Proof.] 0. secs (0.u,0.s)
Chars 3367 - 3389 [(intros~[[?|~?]|~?];~auto).] 5.982 secs (0.002u,0.018s)
Chars 3367 - 3389 [(intros~[[?|~?]|~?];~auto).] 0. secs (0.u,0.s)
Chars 3392 - 3400 [Defined.] 0. secs (0.u,0.s)
Chars 3404 - 3461 [Definition~sum_aux~{A}~{B}~{C}...] 0. secs (0.u,0.s)
Chars 3464 - 3470 [Proof.] 0. secs (0.u,0.s)
Chars 3078 - 3087 [(intros~A).] 40.098 secs (0.u,0.019s)
Chars 3088 - 3107 [exists~equiv_idmap.] 0. secs (0.u,0.s)
Chars 3108 - 3112 [(cbn).] 0. secs (0.u,0.s)
Chars 3113 - 3125 [(intros~a~a').] 0. secs (0.u,0.s)
Chars 3126 - 3138 [reflexivity.] 0.001 secs (0.001u,0.s)
Chars 3078 - 3087 [(intros~A).] 0. secs (0.u,0.s)
Chars 3088 - 3107 [exists~equiv_idmap.] 0. secs (0.u,0.s)
Chars 3108 - 3112 [(cbn).] 0. secs (0.u,0.s)
Chars 3113 - 3125 [(intros~a~a').] 0. secs (0.u,0.s)
Chars 3126 - 3138 [reflexivity.] 0. secs (0.u,0.s)
Chars 3139 - 3143 [Qed.] 0. secs (0.u,0.s)
Chars 3145 - 3230 [Lemma~isomorphism_inverse~:~fo...] 0. secs (0.u,0.s)
Chars 3231 - 3237 [Proof.] 0. secs (0.u,0.s)
Chars 3473 - 3491 [(intros~[?|~?];~auto).] 1.102 secs (0.001u,0.018s)
Chars 3473 - 3491 [(intros~[?|~?];~auto).] 0. secs (0.u,0.s)
Chars 3494 - 3502 [Defined.] 0. secs (0.u,0.s)
Chars 3506 - 3572 [#[local]Instance~quote_zero~~(...] 0. secs (0.u,0.s)
Chars 3575 - 3581 [Proof.] 0. secs (0.u,0.s)
Chars 4420 - 4428 [intro~F.] 40.076 secs (0.u,0.017s)
Chars 4433 - 4460 [(apply~path_hset_isomorphic).] 0.001 secs (0.001u,0.s)
Chars 4465 - 4510 [(rewrite~path_def_isomorphic_i...] 0.002 secs (0.002u,0.s)
Chars 4515 - 4526 [funext~s~x.] 0.001 secs (0.001u,0.s)
Chars 4531 - 4566 [(rewrite~!transport_forall_con...] 0.038 secs (0.029u,0.008s)
Chars 4571 - 4609 [(rewrite~path_ap_carriers_path...] 0.002 secs (0.002u,0.s)
Chars 4614 - 4643 [transport_path_forall_hammer.] 0.006 secs (0.005u,0.001s)
Chars 4648 - 4678 [(apply~transport_path_universe).] 0.001 secs (0.001u,0.s)
Chars 4420 - 4428 [intro~F.] 0. secs (0.u,0.s)
Chars 4433 - 4460 [(apply~path_hset_isomorphic).] 0. secs (0.u,0.s)
Chars 4465 - 4510 [(rewrite~path_def_isomorphic_i...] 0. secs (0.u,0.s)
Chars 4515 - 4526 [funext~s~x.] 0. secs (0.u,0.s)
Chars 4531 - 4566 [(rewrite~!transport_forall_con...] 0. secs (0.u,0.s)
Chars 4571 - 4609 [(rewrite~path_ap_carriers_path...] 0. secs (0.u,0.s)
Chars 4614 - 4643 [transport_path_forall_hammer.] 0. secs (0.u,0.s)
Chars 4648 - 4678 [(apply~transport_path_universe).] 0. secs (0.u,0.s)
Chars 4681 - 4685 [Qed.] 0.009 secs (0.008u,0.s)
Chars 4689 - 4765 [Lemma~sect_isomorphic_id~:~id_...] 0.001 secs (0.001u,0.s)
Chars 4768 - 4774 [Proof.] 0. secs (0.u,0.s)
Chars 3584 - 3596 [exists~Zero.] 9.627 secs (0.001u,0.017s)
Chars 3599 - 3611 [reflexivity.] 0. secs (0.u,0.s)
Chars 3584 - 3596 [exists~Zero.] 0. secs (0.u,0.s)
Chars 3599 - 3611 [reflexivity.] 0. secs (0.u,0.s)
Chars 3614 - 3622 [Defined.] 0. secs (0.u,0.s)
Chars 3626 - 3691 [#[local]Instance~quote_one~~(V...] 0. secs (0.u,0.s)
Chars 3694 - 3700 [Proof.] 0. secs (0.u,0.s)
Chars 3703 - 3714 [exists~One.] 0.968 secs (0.001u,0.017s)
Chars 3717 - 3729 [reflexivity.] 0. secs (0.u,0.s)
Chars 3703 - 3714 [exists~One.] 0. secs (0.u,0.s)
Chars 3717 - 3729 [reflexivity.] 0. secs (0.u,0.s)
Chars 3732 - 3740 [Defined.] 0. secs (0.u,0.s)
Chars 3744 - 4021 [Lemma~quote_plus_ok~(V~:~Type0...] 0.003 secs (0.003u,0.s)
Chars 4024 - 4030 [Proof.] 0. secs (0.u,0.s)
Chars 4033 - 4039 [(simpl).] 2.725 secs (0.u,0.017s)
Chars 4042 - 4101 [(rewrite~<-~(eval_quote~n),~<-...] 0.006 secs (0.005u,0.s)
Chars 4104 - 4131 [(apply~ap011;~apply~eval_ext).] 0.003 secs (0.003u,0.s)
Chars 4134 - 4135 [-] 0. secs (0.u,0.s)
Chars 4136 - 4161 [(intros~[?|~?];~reflexivity).] 0.002 secs (0.001u,0.s)
Chars 4164 - 4165 [-] 0. secs (0.u,0.s)
Chars 4166 - 4195 [(intros~[[?|~?]|~?];~reflexivi...] 0.004 secs (0.004u,0.s)
Chars 4033 - 4039 [(simpl).] 0. secs (0.u,0.s)
Chars 4042 - 4101 [(rewrite~<-~(eval_quote~n),~<-...] 0. secs (0.u,0.s)
Chars 4104 - 4131 [(apply~ap011;~apply~eval_ext).] 0.001 secs (0.001u,0.s)
Chars 4136 - 4161 [(intros~[?|~?];~reflexivity).] 0.001 secs (0.001u,0.s)
Chars 4166 - 4195 [(intros~[[?|~?]|~?];~reflexivi...] 0.002 secs (0.001u,0.s)
Chars 4198 - 4202 [Qed.] 0.004 secs (0.004u,0.s)
Chars 4206 - 4393 [#[local]~Instance~quote_plus~~...] 0.001 secs (0.001u,0.s)
Chars 4396 - 4402 [Proof.] 0. secs (0.u,0.s)
Chars 976 - 992 [(split;~intros~E).] 40.081 secs (0.001u,0.017s)
Chars 995 - 996 [-] 0. secs (0.u,0.s)
Chars 997 - 1007 [(rewrite~E).] 0. secs (0.u,0.s)
Chars 1008 - 1032 [(split;~apply~reflexivity).] 0.002 secs (0.002u,0.s)
Chars 1035 - 1036 [-] 0. secs (0.u,0.s)
Chars 1037 - 1076 [(apply~(antisymmetry~(≤)~x~y);...] 0.001 secs (0.001u,0.s)
Chars 976 - 992 [(split;~intros~E).] 0. secs (0.u,0.s)
Chars 997 - 1007 [(rewrite~E).] 0. secs (0.u,0.s)
Chars 1008 - 1032 [(split;~apply~reflexivity).] 0. secs (0.u,0.s)
Chars 1037 - 1076 [(apply~(antisymmetry~(≤)~x~y);...] 0. secs (0.u,0.s)
Chars 1079 - 1083 [Qed.] 0. secs (0.u,0.s)
Chars 1084 - 1102 [End~partial_order.] 0.002 secs (0.002u,0.s)
Chars 1104 - 1125 [Section~strict_order.] 0. secs (0.u,0.s)
Chars 1128 - 1153 [Context~`{StrictOrder~A}.] 0. secs (0.u,0.s)
Chars 1157 - 1195 [Lemma~lt_flip~x~y~:~x~<~y~->~~...] 0. secs (0.u,0.s)
Chars 1198 - 1204 [Proof.] 0. secs (0.u,0.s)
Chars 3154 - 3186 [srapply~Colimit_rec_beta_colimp.] 40.032 secs (0.006u,0.018s)
Chars 3154 - 3186 [srapply~Colimit_rec_beta_colimp.] 0. secs (0.u,0.s)
Chars 3187 - 3195 [Defined.] 0.002 secs (0.001u,0.s)
Chars 3197 - 3360 [Definition~colim_succ_seq_to_c...] 0.003 secs (0.002u,0.001s)
Chars 3361 - 3367 [Proof.] 0. secs (0.u,0.s)
Chars 3370 - 3394 [(destruct~p;~reflexivity).] 1.901 secs (0.002u,0.018s)
Chars 3370 - 3394 [(destruct~p;~reflexivity).] 0. secs (0.u,0.s)
Chars 3395 - 3403 [Defined.] 0.002 secs (0.002u,0.s)
Chars 3405 - 3503 [#[global]~Instance~isequiv_col...] 0. secs (0.u,0.s)
Chars 3504 - 3510 [Proof.] 0. secs (0.u,0.s)
Chars 7034 - 7045 [(intros~F~G).] 40.046 secs (0.u,0.011s)
Chars 7048 - 7068 [nrapply~Build_Fun11.] 0.018 secs (0.014u,0.004s)
Chars 7071 - 7103 [rapply~(is1functor_compose~G~F).] 0.003 secs (0.003u,0.s)
Chars 7034 - 7045 [(intros~F~G).] 0. secs (0.u,0.s)
Chars 7048 - 7068 [nrapply~Build_Fun11.] 0. secs (0.u,0.s)
Chars 7071 - 7103 [rapply~(is1functor_compose~G~F).] 0. secs (0.u,0.s)
Chars 7104 - 7112 [Defined.] 0. secs (0.u,0.s)
Chars 4680 - 4705 [(intros~[[[[x|~x]|~x]|~x]|~x]).] 40.012 secs (0.002u,0.003s)
Chars 4710 - 4711 [+] 0. secs (0.u,0.s)
Chars 4712 - 4725 [exact~(m1~x).] 0. secs (0.u,0.s)
Chars 4730 - 4731 [+] 0. secs (0.u,0.s)
Chars 4732 - 4745 [exact~(m2~x).] 0. secs (0.u,0.s)
Chars 4750 - 4751 [+] 0. secs (0.u,0.s)
Chars 4752 - 4765 [exact~(m3~x).] 0. secs (0.u,0.s)
Chars 4770 - 4771 [+] 0. secs (0.u,0.s)
Chars 4772 - 4785 [exact~(m4~x).] 0. secs (0.u,0.s)
Chars 4790 - 4791 [+] 0. secs (0.u,0.s)
Chars 4792 - 4805 [exact~(m5~x).] 0. secs (0.u,0.s)
Chars 4680 - 4705 [(intros~[[[[x|~x]|~x]|~x]|~x]).] 0. secs (0.u,0.s)
Chars 4712 - 4725 [exact~(m1~x).] 0. secs (0.u,0.s)
Chars 4732 - 4745 [exact~(m2~x).] 0. secs (0.u,0.s)
Chars 4752 - 4765 [exact~(m3~x).] 0. secs (0.u,0.s)
Chars 4772 - 4785 [exact~(m4~x).] 0. secs (0.u,0.s)
Chars 4792 - 4805 [exact~(m5~x).] 0. secs (0.u,0.s)
Chars 4808 - 4816 [Defined.] 0. secs (0.u,0.s)
Chars 4820 - 4881 [#[local]Definition~map2~:~pc1~...] 0. secs (0.u,0.s)
Chars 4884 - 4890 [Proof.] 0. secs (0.u,0.s)
Chars 4895 - 4920 [(intros~[[[[x|~x]|~x]|~x]|~x]).] 0.039 secs (0.001u,0.003s)
Chars 4925 - 4926 [+] 0. secs (0.u,0.s)
Chars 4927 - 4941 [exact~(m1'~x).] 0. secs (0.u,0.s)
Chars 4946 - 4947 [+] 0. secs (0.u,0.s)
Chars 4948 - 4962 [exact~(m2'~x).] 0. secs (0.u,0.s)
Chars 4967 - 4968 [+] 0. secs (0.u,0.s)
Chars 4969 - 4983 [exact~(m3'~x).] 0. secs (0.u,0.s)
Chars 4988 - 4989 [+] 0. secs (0.u,0.s)
Chars 4990 - 5004 [exact~(m4'~x).] 0. secs (0.u,0.s)
Chars 5009 - 5010 [+] 0. secs (0.u,0.s)
Chars 5011 - 5025 [exact~(m5'~x).] 0. secs (0.u,0.s)
Chars 4895 - 4920 [(intros~[[[[x|~x]|~x]|~x]|~x]).] 0. secs (0.u,0.s)
Chars 4927 - 4941 [exact~(m1'~x).] 0. secs (0.u,0.s)
Chars 4948 - 4962 [exact~(m2'~x).] 0. secs (0.u,0.s)
Chars 4969 - 4983 [exact~(m3'~x).] 0. secs (0.u,0.s)
Chars 4990 - 5004 [exact~(m4'~x).] 0. secs (0.u,0.s)
Chars 5011 - 5025 [exact~(m5'~x).] 0. secs (0.u,0.s)
Chars 5028 - 5036 [Defined.] 0. secs (0.u,0.s)
Chars 5133 - 5186 [Definition~amal_type~:~Type~:=...] 0. secs (0.u,0.s)
Chars 5231 - 5285 [Definition~amal_eta~:~Words~->...] 0.001 secs (0.001u,0.s)
Chars 5289 - 5427 [Definition~amal_mu_H~(x~y~:~Wo...] 0.001 secs (0.001u,0.s)
Chars 5430 - 5436 [Proof.] 0. secs (0.u,0.s)
Chars 1898 - 1907 [(intros~E).] 40.011 secs (0.u,0.002s)
Chars 1908 - 1923 [transitivity~x.] 0.007 secs (0.007u,0.s)
Chars 1926 - 1927 [-] 0. secs (0.u,0.s)
Chars 1928 - 1936 [trivial.] 0. secs (0.u,0.s)
Chars 1939 - 1940 [-] 0. secs (0.u,0.s)
Chars 1941 - 1957 [(apply~join_ub_l).] 0. secs (0.u,0.s)
Chars 1898 - 1907 [(intros~E).] 0. secs (0.u,0.s)
Chars 1908 - 1923 [transitivity~x.] 0. secs (0.u,0.s)
Chars 1928 - 1936 [trivial.] 0. secs (0.u,0.s)
Chars 1941 - 1957 [(apply~join_ub_l).] 0. secs (0.u,0.s)
Chars 1960 - 1964 [Qed.] 0. secs (0.u,0.s)
Chars 1968 - 2024 [Lemma~join_le_compat_l~x~y~z~:...] 0. secs (0.u,0.s)
Chars 2027 - 2033 [Proof.] 0. secs (0.u,0.s)
Chars 3240 - 3271 [(intros~[A~R__A]~[B~R__B]~[f~H]).] 40.079 secs (0.u,0.02s)
Chars 3274 - 3299 [exists~(equiv_inverse~f).] 0. secs (0.u,0.s)
Chars 3302 - 3314 [(intros~b~b').] 0. secs (0.u,0.s)
Chars 3317 - 3321 [(cbn).] 0. secs (0.u,0.s)
Chars 3324 - 3349 [(rewrite~<-~(eisretr~f~b)).] 0.003 secs (0.002u,0.s)
Chars 3350 - 3368 [(set~(a~:=~f^-1~b)).] 0.001 secs (0.001u,0.s)
Chars 3369 - 3385 [(rewrite~eissect).] 0.001 secs (0.001u,0.s)
Chars 3388 - 3414 [(rewrite~<-~(eisretr~f~b')).] 0.002 secs (0.002u,0.s)
Chars 3415 - 3435 [(set~(a'~:=~f^-1~b')).] 0.001 secs (0.001u,0.s)
Chars 3436 - 3452 [(rewrite~eissect).] 0.001 secs (0.001u,0.s)
Chars 3552 - 3567 [(split;~apply~H).] 0.001 secs (0.001u,0.s)
Chars 3240 - 3271 [(intros~[A~R__A]~[B~R__B]~[f~H]).] 0. secs (0.u,0.s)
Chars 3274 - 3299 [exists~(equiv_inverse~f).] 0. secs (0.u,0.s)
Chars 3302 - 3314 [(intros~b~b').] 0. secs (0.u,0.s)
Chars 3317 - 3321 [(cbn).] 0. secs (0.u,0.s)
Chars 3324 - 3349 [(rewrite~<-~(eisretr~f~b)).] 0. secs (0.u,0.s)
Chars 3350 - 3368 [(set~(a~:=~f^-1~b)).] 0. secs (0.u,0.s)
Chars 3369 - 3385 [(rewrite~eissect).] 0. secs (0.u,0.s)
Chars 3388 - 3414 [(rewrite~<-~(eisretr~f~b')).] 0. secs (0.u,0.s)
Chars 3415 - 3435 [(set~(a'~:=~f^-1~b')).] 0. secs (0.u,0.s)
Chars 3436 - 3452 [(rewrite~eissect).] 0. secs (0.u,0.s)
Chars 3552 - 3567 [(split;~apply~H).] 0. secs (0.u,0.s)
Chars 3568 - 3576 [Defined.] 0.002 secs (0.u,0.002s)
Chars 3579 - 3629 [#[global]Instance~transitive_i...] 0. secs (0.u,0.s)
Chars 3630 - 3636 [Proof.] 0. secs (0.u,0.s)
Chars 4779 - 4787 [intro~p.] 40.081 secs (0.u,0.016s)
Chars 4792 - 4803 [(destruct~p).] 0.001 secs (0.001u,0.s)
Chars 4808 - 4848 [(apply~path_path_isomorphism_h...] 0.012 secs (0.009u,0.003s)
Chars 4853 - 4861 [exact~_.] 0. secs (0.u,0.s)
Chars 4779 - 4787 [intro~p.] 0. secs (0.u,0.s)
Chars 4792 - 4803 [(destruct~p).] 0. secs (0.u,0.s)
Chars 4808 - 4848 [(apply~path_path_isomorphism_h...] 0. secs (0.u,0.s)
Chars 4853 - 4861 [exact~_.] 0. secs (0.u,0.s)
Chars 4864 - 4868 [Qed.] 0. secs (0.u,0.s)
Chars 4872 - 5076 [#[global]~Instance~isequiv_iso...] 0.001 secs (0.001u,0.s)
Chars 5078 - 5104 [End~isequiv_isomorphic_id.] 0.005 secs (0.005u,0.s)
Chars 4405 - 4418 [econstructor.] 40.084 secs (0.u,0.018s)
Chars 4419 - 4439 [(apply~quote_plus_ok).] 0.001 secs (0.001u,0.s)
Chars 4405 - 4418 [econstructor.] 0. secs (0.u,0.s)
Chars 4419 - 4439 [(apply~quote_plus_ok).] 0. secs (0.u,0.s)
Chars 4442 - 4450 [Defined.] 0. secs (0.u,0.s)
Chars 4454 - 4731 [Lemma~quote_mult_ok~(V~:~Type0...] 0.003 secs (0.003u,0.s)
Chars 4734 - 4740 [Proof.] 0. secs (0.u,0.s)
Chars 1207 - 1220 [(intros~E1~E2).] 40.074 secs (0.001u,0.017s)
Chars 1223 - 1251 [(apply~(irreflexivity~(<)~x)).] 0.001 secs (0.001u,0.s)
Chars 1254 - 1280 [(transitivity~y;~assumption).] 0.001 secs (0.001u,0.s)
Chars 1207 - 1220 [(intros~E1~E2).] 0. secs (0.u,0.s)
Chars 1223 - 1251 [(apply~(irreflexivity~(<)~x)).] 0. secs (0.u,0.s)
Chars 1254 - 1280 [(transitivity~y;~assumption).] 0. secs (0.u,0.s)
Chars 1283 - 1287 [Qed.] 0. secs (0.u,0.s)
Chars 1291 - 1327 [Lemma~lt_antisym~x~y~:~~~(x~<~...] 0. secs (0.u,0.s)
Chars 1330 - 1336 [Proof.] 0. secs (0.u,0.s)
Chars 1339 - 1354 [(intros~[E1~E2]).] 0.059 secs (0.u,0.018s)
Chars 1357 - 1391 [(destruct~(lt_flip~x~y);~assum...] 0. secs (0.u,0.s)
Chars 1339 - 1354 [(intros~[E1~E2]).] 0. secs (0.u,0.s)
Chars 1357 - 1391 [(destruct~(lt_flip~x~y);~assum...] 0. secs (0.u,0.s)
Chars 1394 - 1398 [Qed.] 0. secs (0.u,0.s)
Chars 1402 - 1436 [Lemma~lt_ne~x~y~:~x~<~y~->~x~<...] 0. secs (0.u,0.s)
Chars 1439 - 1445 [Proof.] 0. secs (0.u,0.s)
Chars 1448 - 1461 [(intros~E1~E2).] 0.073 secs (0.u,0.017s)
Chars 1464 - 1481 [(rewrite~E2~in~E1).] 0. secs (0.u,0.s)
Chars 1484 - 1512 [(apply~(irreflexivity~(<)~y)).] 0.001 secs (0.001u,0.s)
Chars 1513 - 1524 [assumption.] 0. secs (0.u,0.s)
Chars 1448 - 1461 [(intros~E1~E2).] 0. secs (0.u,0.s)
Chars 1464 - 1481 [(rewrite~E2~in~E1).] 0. secs (0.u,0.s)
Chars 1484 - 1512 [(apply~(irreflexivity~(<)~y)).] 0. secs (0.u,0.s)
Chars 1513 - 1524 [assumption.] 0. secs (0.u,0.s)
Chars 1527 - 1531 [Qed.] 0. secs (0.u,0.s)
Chars 1535 - 1574 [Lemma~lt_ne_flip~x~y~:~x~<~y~-...] 0. secs (0.u,0.s)
Chars 1577 - 1583 [Proof.] 0. secs (0.u,0.s)
Chars 4743 - 4749 [(simpl).] 4.489 secs (0.001u,0.019s)
Chars 4752 - 4811 [(rewrite~<-~(eval_quote~n),~<-...] 0.006 secs (0.005u,0.s)
Chars 4814 - 4841 [(apply~ap011;~apply~eval_ext).] 0.003 secs (0.002u,0.s)
Chars 4844 - 4845 [-] 0. secs (0.u,0.s)
Chars 4846 - 4871 [(intros~[?|~?];~reflexivity).] 0.002 secs (0.002u,0.s)
Chars 4874 - 4875 [-] 0. secs (0.u,0.s)
Chars 4876 - 4905 [(intros~[[?|~?]|~?];~reflexivi...] 0.004 secs (0.004u,0.s)
Chars 4743 - 4749 [(simpl).] 0. secs (0.u,0.s)
Chars 4752 - 4811 [(rewrite~<-~(eval_quote~n),~<-...] 0. secs (0.u,0.s)
Chars 4814 - 4841 [(apply~ap011;~apply~eval_ext).] 0.001 secs (0.001u,0.s)
Chars 4846 - 4871 [(intros~[?|~?];~reflexivity).] 0.001 secs (0.001u,0.s)
Chars 4876 - 4905 [(intros~[[?|~?]|~?];~reflexivi...] 0.002 secs (0.002u,0.s)
Chars 4908 - 4912 [Qed.] 0.004 secs (0.004u,0.s)
Chars 4916 - 5112 [#[local]~Instance~quote_mult~~...] 0.001 secs (0.001u,0.s)
Chars 5115 - 5121 [Proof.] 0. secs (0.u,0.s)
Chars 3513 - 3540 [srapply~isequiv_adjointify.] 40.09 secs (0.u,0.017s)
Chars 3543 - 3544 [+] 0. secs (0.u,0.s)
Chars 3545 - 3587 [(srapply~Colimit_rec;~srapply~...] 0.003 secs (0.002u,0.s)
Chars 3592 - 3593 [*] 0. secs (0.u,0.s)
Chars 3594 - 3636 [exact~(fun~n~a~=>~inj~(succ_se...] 0.037 secs (0.026u,0.011s)
Chars 3641 - 3642 [*] 0. secs (0.u,0.s)
Chars 3643 - 3703 [(intros~n~m~p~a;~destruct~p;~e...] 0.004 secs (0.003u,0.001s)
Chars 3706 - 3707 [+] 0. secs (0.u,0.s)
Chars 3708 - 3733 [srapply~seq_colimit_uniq.] 0.006 secs (0.004u,0.001s)
Chars 3738 - 3739 [*] 0. secs (0.u,0.s)
Chars 3740 - 3770 [exact~(fun~n~a~=>~glue~_~n~a).] 0.003 secs (0.002u,0.001s)
Chars 3775 - 3776 [*] 0. secs (0.u,0.s)
Chars 3777 - 3843 [(intros~n~a;~rewrite~ap_idmap,...] 0.061 secs (0.052u,0.008s)
Chars 3850 - 3909 [(rewrite~colim_succ_seq_to_col...] 0.023 secs (0.021u,0.001s)
Chars 3912 - 3913 [+] 0. secs (0.u,0.s)
Chars 3914 - 3939 [srapply~seq_colimit_uniq.] 0.005 secs (0.005u,0.s)
Chars 3944 - 3945 [*] 0. secs (0.u,0.s)
Chars 3946 - 3976 [exact~(fun~n~a~=>~glue~_~n~a).] 0.002 secs (0.002u,0.s)
Chars 3981 - 3982 [*] 0. secs (0.u,0.s)
Chars 3983 - 4049 [(intros~n~a;~rewrite~ap_idmap,...] 0.067 secs (0.052u,0.014s)
Chars 4056 - 4118 [(rewrite~(@Colimit_rec_beta_co...] 0.028 secs (0.023u,0.004s)
Chars 3513 - 3540 [srapply~isequiv_adjointify.] 0. secs (0.u,0.s)
Chars 3545 - 3587 [(srapply~Colimit_rec;~srapply~...] 0. secs (0.u,0.s)
Chars 3594 - 3636 [exact~(fun~n~a~=>~inj~(succ_se...] 0. secs (0.u,0.s)
Chars 3643 - 3703 [(intros~n~m~p~a;~destruct~p;~e...] 0.001 secs (0.001u,0.s)
Chars 3708 - 3733 [srapply~seq_colimit_uniq.] 0. secs (0.u,0.s)
Chars 3740 - 3770 [exact~(fun~n~a~=>~glue~_~n~a).] 0.001 secs (0.001u,0.s)
Chars 3777 - 3843 [(intros~n~a;~rewrite~ap_idmap,...] 0.005 secs (0.005u,0.s)
Chars 3850 - 3909 [(rewrite~colim_succ_seq_to_col...] 0.003 secs (0.003u,0.s)
Chars 3914 - 3939 [srapply~seq_colimit_uniq.] 0. secs (0.u,0.s)
Chars 3946 - 3976 [exact~(fun~n~a~=>~glue~_~n~a).] 0.001 secs (0.001u,0.s)
Chars 3983 - 4049 [(intros~n~a;~rewrite~ap_idmap,...] 0.004 secs (0.004u,0.s)
Chars 4056 - 4118 [(rewrite~(@Colimit_rec_beta_co...] 0.003 secs (0.003u,0.s)
Chars 4119 - 4127 [Defined.] 0.087 secs (0.083u,0.003s)
Chars 4129 - 4268 [Definition~equiv_colim_succ_se...] 0.002 secs (0.002u,0.s)
Chars 4400 - 4483 [Definition~colim_shift_seq_to_...] 0. secs (0.u,0.s)
Chars 4484 - 4490 [Proof.] 0. secs (0.u,0.s)
All solutions:
occurrence 0: transitivity through dot y 1

occurrence 1: transitivity through 
dot 1 y


     = 1024
     : Z
Chars 5441 - 5457 [(unfold~amal_eta).] 40.011 secs (0.001u,0.002s)
Chars 5462 - 5480 [(apply~path_Tr,~tr).] 0.001 secs (0.001u,0.s)
Chars 5485 - 5535 [exact~(cglue~(inl~(inl~(inl~(i...] 0.002 secs (0.002u,0.s)
Chars 5441 - 5457 [(unfold~amal_eta).] 0. secs (0.u,0.s)
Chars 5462 - 5480 [(apply~path_Tr,~tr).] 0. secs (0.u,0.s)
Chars 5485 - 5535 [exact~(cglue~(inl~(inl~(inl~(i...] 0. secs (0.u,0.s)
Chars 5538 - 5546 [Defined.] 0.001 secs (0.001u,0.s)
Chars 5550 - 5688 [Definition~amal_mu_K~(x~y~:~Wo...] 0.001 secs (0.001u,0.s)
Chars 5691 - 5697 [Proof.] 0. secs (0.u,0.s)
Chars 2036 - 2045 [(intros~E).] 40.012 secs (0.u,0.002s)
Chars 2046 - 2080 [(rewrite~(commutativity~(f:=jo...] 0.003 secs (0.003u,0.s)
Chars 2083 - 2106 [(apply~join_le_compat_r).] 0. secs (0.u,0.s)
Chars 2109 - 2117 [trivial.] 0. secs (0.u,0.s)
Chars 2036 - 2045 [(intros~E).] 0. secs (0.u,0.s)
Chars 2046 - 2080 [(rewrite~(commutativity~(f:=jo...] 0. secs (0.u,0.s)
Chars 2083 - 2106 [(apply~join_le_compat_r).] 0. secs (0.u,0.s)
Chars 2109 - 2117 [trivial.] 0. secs (0.u,0.s)
Chars 2120 - 2124 [Qed.] 0. secs (0.u,0.s)
Chars 2128 - 2170 [Lemma~join_l~x~y~:~y~≤~x~->~x~...] 0. secs (0.u,0.s)
Chars 2173 - 2179 [Proof.] 0. secs (0.u,0.s)
Chars 3639 - 3660 [(intros~A~B~C~A_B~B_C).] 40.081 secs (0.u,0.018s)
Chars 3663 - 3669 [split.] 0. secs (0.u,0.s)
Chars 3672 - 3673 [-] 0. secs (0.u,0.s)
Chars 3674 - 3683 [(intros~a).] 0. secs (0.u,0.s)
Chars 3684 - 3694 [(apply~B_C).] 0. secs (0.u,0.s)
Chars 3695 - 3705 [(apply~A_B).] 0. secs (0.u,0.s)
Chars 3706 - 3714 [exact~a.] 0. secs (0.u,0.s)
Chars 3717 - 3718 [-] 0. secs (0.u,0.s)
Chars 3719 - 3728 [(intros~c).] 0. secs (0.u,0.s)
Chars 3729 - 3739 [(apply~A_B).] 0. secs (0.u,0.s)
Chars 3740 - 3750 [(apply~B_C).] 0. secs (0.u,0.s)
Chars 3751 - 3759 [exact~c.] 0. secs (0.u,0.s)
Chars 3639 - 3660 [(intros~A~B~C~A_B~B_C).] 0. secs (0.u,0.s)
Chars 3663 - 3669 [split.] 0. secs (0.u,0.s)
Chars 3674 - 3683 [(intros~a).] 0. secs (0.u,0.s)
Chars 3684 - 3694 [(apply~B_C).] 0. secs (0.u,0.s)
Chars 3695 - 3705 [(apply~A_B).] 0. secs (0.u,0.s)
Chars 3706 - 3714 [exact~a.] 0. secs (0.u,0.s)
Chars 3719 - 3728 [(intros~c).] 0. secs (0.u,0.s)
Chars 3729 - 3739 [(apply~A_B).] 0. secs (0.u,0.s)
Chars 3740 - 3750 [(apply~B_C).] 0. secs (0.u,0.s)
Chars 3751 - 3759 [exact~c.] 0. secs (0.u,0.s)
Chars 3760 - 3764 [Qed.] 0. secs (0.u,0.s)
Chars 3767 - 3880 [Lemma~transitive_Isomorphism~:...] 0.001 secs (0.001u,0.s)
Chars 3881 - 3887 [Proof.] 0. secs (0.u,0.s)
Chars 1586 - 1592 [intro.] 40.072 secs (0.u,0.018s)
Chars 1595 - 1622 [(apply~symmetric_neq,~lt_ne).] 0. secs (0.u,0.s)
Chars 1625 - 1636 [assumption.] 0. secs (0.u,0.s)
Chars 1586 - 1592 [intro.] 0. secs (0.u,0.s)
Chars 1595 - 1622 [(apply~symmetric_neq,~lt_ne).] 0. secs (0.u,0.s)
Chars 1625 - 1636 [assumption.] 0. secs (0.u,0.s)
Chars 1639 - 1643 [Qed.] 0. secs (0.u,0.s)
Chars 1647 - 1687 [Lemma~eq_not_lt~x~y~:~x~=~y~->...] 0. secs (0.u,0.s)
Chars 1690 - 1696 [Proof.] 0. secs (0.u,0.s)
Chars 5124 - 5137 [econstructor.] 40.08 secs (0.u,0.018s)
Chars 5138 - 5158 [(apply~quote_mult_ok).] 0.001 secs (0.001u,0.s)
Chars 5124 - 5137 [econstructor.] 0. secs (0.u,0.s)
Chars 5138 - 5158 [(apply~quote_mult_ok).] 0. secs (0.u,0.s)
Chars 5161 - 5169 [Defined.] 0. secs (0.u,0.s)
Chars 5173 - 5325 [Lemma~quote_neg_ok@{}~(V~:~Typ...] 0.001 secs (0.001u,0.s)
Chars 5328 - 5334 [Proof.] 0. secs (0.u,0.s)
Chars 4493 - 4535 [(srapply~Colimit_rec;~srapply~...] 40.076 secs (0.002u,0.018s)
Chars 4538 - 4539 [+] 0. secs (0.u,0.s)
Chars 4540 - 4577 [exact~(fun~k~a~=>~inj~A~(k~+~n...] 0. secs (0.u,0.s)
Chars 4580 - 4581 [+] 0. secs (0.u,0.s)
Chars 4582 - 4633 [(intros~k~l~p;~destruct~p;~exa...] 0.003 secs (0.002u,0.001s)
Chars 4493 - 4535 [(srapply~Colimit_rec;~srapply~...] 0. secs (0.u,0.s)
Chars 4540 - 4577 [exact~(fun~k~a~=>~inj~A~(k~+~n...] 0. secs (0.u,0.s)
Chars 4582 - 4633 [(intros~k~l~p;~destruct~p;~exa...] 0.001 secs (0.u,0.s)
Chars 4634 - 4642 [Defined.] 0.001 secs (0.001u,0.s)
Chars 4644 - 4792 [Definition~colim_shift_seq_to_...] 0.002 secs (0.002u,0.s)
Chars 4793 - 4799 [Proof.] 0. secs (0.u,0.s)
Chars 4802 - 4834 [srapply~Colimit_rec_beta_colimp.] 0.058 secs (0.004u,0.019s)
Chars 4802 - 4834 [srapply~Colimit_rec_beta_colimp.] 0. secs (0.u,0.s)
Chars 4835 - 4843 [Defined.] 0.002 secs (0.001u,0.s)
Chars 4845 - 5022 [Definition~colim_shift_seq_to_...] 0.003 secs (0.003u,0.s)
Chars 5023 - 5029 [Proof.] 0. secs (0.u,0.s)
Chars 5032 - 5056 [(destruct~p;~reflexivity).] 0.058 secs (0.002u,0.017s)
Chars 5032 - 5056 [(destruct~p;~reflexivity).] 0. secs (0.u,0.s)
Chars 5057 - 5065 [Defined.] 0.002 secs (0.002u,0.s)
Chars 5067 - 5185 [#[local]~Definition~J~{X}~{Y}~...] 0.001 secs (0.001u,0.s)
Chars 5186 - 5192 [Proof.] 0. secs (0.u,0.s)
Chars 5195 - 5219 [(destruct~p;~reflexivity).] 0.076 secs (0.001u,0.017s)
Chars 5195 - 5219 [(destruct~p;~reflexivity).] 0. secs (0.u,0.s)
Chars 5220 - 5228 [Defined.] 0. secs (0.u,0.s)
Chars 5230 - 5346 [#[local]~Definition~K~{X}~{Y}~...] 0.001 secs (0.001u,0.s)
Chars 5347 - 5353 [Proof.] 0. secs (0.u,0.s)
Chars 5356 - 5380 [(destruct~p;~reflexivity).] 0.053 secs (0.002u,0.016s)
Chars 5356 - 5380 [(destruct~p;~reflexivity).] 0. secs (0.u,0.s)
Chars 5381 - 5389 [Defined.] 0. secs (0.u,0.s)
Chars 5391 - 5664 [#[local]~Definition~L~{X}~{Y}~...] 0.011 secs (0.007u,0.003s)
Chars 5665 - 5671 [Proof.] 0. secs (0.u,0.s)
Chars 5674 - 5729 [(destruct~p;~rewrite~!concat_1...] 2.731 secs (0.018u,0.017s)
Chars 5674 - 5729 [(destruct~p;~rewrite~!concat_1...] 0.003 secs (0.001u,0.002s)
Chars 5730 - 5738 [Defined.] 0.026 secs (0.013u,0.013s)
Chars 5740 - 5854 [#[global]~Instance~isequiv_col...] 0. secs (0.u,0.s)
Chars 5855 - 5861 [Proof.] 0. secs (0.u,0.s)
     = 9086410%N
     : N
All solutions:
occurrence 0: transitivity through forall x y z : nat,
                                   Nat.max (x + y) (x + z)
2 possible(s) substitution(s)
0:	[x: a; y: b; z: c; ]
1:	[x: a; y: c; z: b; ]


Chars 1699 - 1708 [(intros~E).] 14.578 secs (0.u,0.017s)
Chars 1711 - 1721 [(rewrite~E).] 0. secs (0.u,0.s)
Chars 1724 - 1750 [(apply~(irreflexivity~(<))).] 0.001 secs (0.001u,0.s)
Chars 1699 - 1708 [(intros~E).] 0. secs (0.u,0.s)
Chars 1711 - 1721 [(rewrite~E).] 0. secs (0.u,0.s)
Chars 1724 - 1750 [(apply~(irreflexivity~(<))).] 0. secs (0.u,0.s)
Chars 1753 - 1757 [Qed.] 0. secs (0.u,0.s)
Chars 1758 - 1775 [End~strict_order.] 0.002 secs (0.002u,0.s)
Chars 1777 - 1798 [Section~pseudo_order.] 0. secs (0.u,0.s)
Chars 1801 - 1826 [Context~`{PseudoOrder~A}.] 0. secs (0.u,0.s)
Chars 1830 - 1873 [#[local]Existing~Instance~pseu...] 0. secs (0.u,0.s)
Chars 1877 - 1931 [Lemma~apart_total_lt~x~y~:~x~≶...] 0. secs (0.u,0.s)
Chars 1934 - 1940 [Proof.] 0. secs (0.u,0.s)
All solutions:
occurrence 0: transitivity through (c * b + a + 0)%nat

occurrence 1: transitivity through 
(a + b * (c + 0))%nat

occurrence 2: transitivity through 
(a + c * (b + 0))%nat


All solutions:
occurrence 0: transitivity through (c + b + a + 0)%nat


All solutions:
occurrence 0: transitivity through ((c + b + a) * 1)%nat

occurrence 1: transitivity through 
(c + a + b * 1)%nat

occurrence 2: transitivity through 
(a + (c + b) * 1)%nat

occurrence 3: transitivity through 
(b + a + c * 1)%nat

occurrence 4: transitivity through 
(c + (b + a) * 1)%nat

occurrence 5: transitivity through 
(c + b + a * 1)%nat

occurrence 6: transitivity through 
(b + (c + a) * 1)%nat


All solutions:
occurrence 0: transitivity through forall x y : nat, (x * x + y * x + c)%nat
1 possible(s) substitution(s)
0:	[x: a; y: b; ]


All solutions:
occurrence 0: transitivity through forall x y : nat, (x * x + y * x + c)%nat
1 possible(s) substitution(s)
0:	[x: a; y: b; ]

occurrence 1: transitivity through ((a * b + a * a + c) * (1 * 1 + 0 * 1))%nat

occurrence 2: transitivity through 
(a * b + c + a * a * (1 * 1 + 0 * 1))%nat

occurrence 3: transitivity through 
(c + (a * b + a * a) * (1 * 1 + 0 * 1))%nat

occurrence 4: transitivity through 
(a * a + c + a * b * (1 * 1 + 0 * 1))%nat

occurrence 5: transitivity through 
(a * b + (a * a + c) * (1 * 1 + 0 * 1))%nat

occurrence 6: transitivity through 
(a * b + a * a + c * (1 * 1 + 0 * 1))%nat

occurrence 7: transitivity through 
(a * a + (a * b + c) * (1 * 1 + 0 * 1))%nat


All solutions:
occurrence 0: transitivity through ((a * b + a * a + c) * 1)%nat

occurrence 1: transitivity through 
(a * b + c + a * a * 1)%nat

occurrence 2: transitivity through 
(c + (a * b + a * a) * 1)%nat

occurrence 3: transitivity through 
(a * a + c + a * b * 1)%nat

occurrence 4: transitivity through 
(a * b + (a * a + c) * 1)%nat

occurrence 5: transitivity through 
(a * b + a * a + c * 1)%nat

occurrence 6: transitivity through 
(a * a + (a * b + c) * 1)%nat


Chars 5337 - 5343 [(simpl).] 14.846 secs (0.u,0.017s)
Chars 5344 - 5364 [(apply~ap,~eval_quote).] 0.001 secs (0.001u,0.s)
Chars 5337 - 5343 [(simpl).] 0. secs (0.u,0.s)
Chars 5344 - 5364 [(apply~ap,~eval_quote).] 0. secs (0.u,0.s)
Chars 5367 - 5371 [Qed.] 0. secs (0.u,0.s)
Chars 5375 - 5507 [#[local]~Instance~quote_neg~~(...] 0. secs (0.u,0.s)
Chars 5510 - 5516 [Proof.] 0. secs (0.u,0.s)
Chars 5702 - 5718 [(unfold~amal_eta).] 40.013 secs (0.u,0.004s)
Chars 5723 - 5741 [(apply~path_Tr,~tr).] 0.001 secs (0.001u,0.s)
Chars 5746 - 5796 [exact~(cglue~(inl~(inl~(inl~(i...] 0.002 secs (0.002u,0.s)
Chars 5702 - 5718 [(unfold~amal_eta).] 0. secs (0.u,0.s)
Chars 5723 - 5741 [(apply~path_Tr,~tr).] 0. secs (0.u,0.s)
Chars 5746 - 5796 [exact~(cglue~(inl~(inl~(inl~(i...] 0. secs (0.u,0.s)
Chars 5799 - 5807 [Defined.] 0.001 secs (0.001u,0.s)
Chars 5811 - 5927 [Definition~amal_tau~(x~y~:~Wor...] 0.001 secs (0.001u,0.s)
Chars 5930 - 5936 [Proof.] 0. secs (0.u,0.s)
Chars 2182 - 2191 [(intros~E).] 40.012 secs (0.u,0.003s)
Chars 2192 - 2219 [(apply~(antisymmetry~(≤))).] 0.002 secs (0.001u,0.s)
Chars 2222 - 2223 [-] 0. secs (0.u,0.s)
Chars 2224 - 2247 [(apply~join_lub;~trivial).] 0.001 secs (0.001u,0.s)
Chars 2248 - 2266 [(apply~reflexivity).] 0.002 secs (0.002u,0.s)
Chars 2269 - 2270 [-] 0. secs (0.u,0.s)
Chars 2271 - 2287 [(apply~join_ub_l).] 0. secs (0.u,0.s)
Chars 2182 - 2191 [(intros~E).] 0. secs (0.u,0.s)
Chars 2192 - 2219 [(apply~(antisymmetry~(≤))).] 0. secs (0.u,0.s)
Chars 2224 - 2247 [(apply~join_lub;~trivial).] 0. secs (0.u,0.s)
Chars 2248 - 2266 [(apply~reflexivity).] 0. secs (0.u,0.s)
Chars 2271 - 2287 [(apply~join_ub_l).] 0. secs (0.u,0.s)
Chars 2290 - 2294 [Qed.] 0. secs (0.u,0.s)
Chars 2298 - 2340 [Lemma~join_r~x~y~:~x~≤~y~->~x~...] 0. secs (0.u,0.s)
Chars 2343 - 2349 [Proof.] 0. secs (0.u,0.s)
Chars 3890 - 3924 [(intros~[A~R__A]~[B~R__B]~[C~R...] 40.083 secs (0.002u,0.018s)
Chars 3927 - 3948 [(intros~[f~Hf]~[g~Hg]).] 0.002 secs (0.002u,0.s)
Chars 3951 - 3979 [exists~(equiv_compose'~g~f).] 0.001 secs (0.001u,0.s)
Chars 3982 - 3994 [(intros~a~a').] 0. secs (0.u,0.s)
Chars 3997 - 4003 [split.] 0. secs (0.u,0.s)
Chars 4006 - 4007 [-] 0. secs (0.u,0.s)
Chars 4008 - 4020 [(intros~a_a').] 0. secs (0.u,0.s)
Chars 4021 - 4030 [(apply~Hg).] 0. secs (0.u,0.s)
Chars 4031 - 4040 [(apply~Hf).] 0. secs (0.u,0.s)
Chars 4041 - 4052 [exact~a_a'.] 0. secs (0.u,0.s)
Chars 4055 - 4056 [-] 0. secs (0.u,0.s)
Chars 4057 - 4073 [(intros~gfa_gfa').] 0. secs (0.u,0.s)
Chars 4074 - 4083 [(apply~Hf).] 0. secs (0.u,0.s)
Chars 4084 - 4093 [(apply~Hg).] 0. secs (0.u,0.s)
Chars 4094 - 4109 [exact~gfa_gfa'.] 0. secs (0.u,0.s)
Chars 3890 - 3924 [(intros~[A~R__A]~[B~R__B]~[C~R...] 0. secs (0.u,0.s)
Chars 3927 - 3948 [(intros~[f~Hf]~[g~Hg]).] 0. secs (0.u,0.s)
Chars 3951 - 3979 [exists~(equiv_compose'~g~f).] 0. secs (0.u,0.s)
Chars 3982 - 3994 [(intros~a~a').] 0. secs (0.u,0.s)
Chars 3997 - 4003 [split.] 0. secs (0.u,0.s)
Chars 4008 - 4020 [(intros~a_a').] 0. secs (0.u,0.s)
Chars 4021 - 4030 [(apply~Hg).] 0. secs (0.u,0.s)
Chars 4031 - 4040 [(apply~Hf).] 0. secs (0.u,0.s)
Chars 4041 - 4052 [exact~a_a'.] 0. secs (0.u,0.s)
Chars 4057 - 4073 [(intros~gfa_gfa').] 0. secs (0.u,0.s)
Chars 4074 - 4083 [(apply~Hf).] 0. secs (0.u,0.s)
Chars 4084 - 4093 [(apply~Hg).] 0. secs (0.u,0.s)
Chars 4094 - 4109 [exact~gfa_gfa'.] 0. secs (0.u,0.s)
Chars 4110 - 4118 [Defined.] 0.001 secs (0.001u,0.s)
Chars 4121 - 4194 [#[global]Instance~isomorphism_...] 0. secs (0.u,0.s)
Chars 4195 - 4201 [Proof.] 0. secs (0.u,0.s)
'expQnat_R' is now a registered translation.
'exp_seqpoly_R' is now a registered translation.
Chars 2352 - 2361 [(intros~E).] 21.434 secs (0.u,0.003s)
Chars 2362 - 2396 [(rewrite~(commutativity~(f:=jo...] 0.003 secs (0.003u,0.s)
Chars 2399 - 2412 [(apply~join_l).] 0. secs (0.u,0.s)
Chars 2415 - 2423 [trivial.] 0. secs (0.u,0.s)
Chars 2352 - 2361 [(intros~E).] 0. secs (0.u,0.s)
Chars 2362 - 2396 [(rewrite~(commutativity~(f:=jo...] 0. secs (0.u,0.s)
Chars 2399 - 2412 [(apply~join_l).] 0. secs (0.u,0.s)
Chars 2415 - 2423 [trivial.] 0. secs (0.u,0.s)
Chars 2426 - 2430 [Qed.] 0. secs (0.u,0.s)
Chars 2434 - 2486 [Lemma~join_sl_le_spec~x~y~:~x~...] 0. secs (0.u,0.s)
Chars 2489 - 2495 [Proof.] 0. secs (0.u,0.s)
Chars 5864 - 5916 [(induction~n~as~[|~n~e];~srapp...] 40.086 secs (0.u,0.018s)
Chars 5919 - 5920 [-] 0. secs (0.u,0.s)
Chars 5921 - 5980 [(srapply~equiv_functor_colimit...] 0.03 secs (0.021u,0.008s)
Chars 5985 - 5986 [+] 0. secs (0.u,0.s)
Chars 5987 - 6012 [srapply~Build_DiagramMap.] 0.001 secs (0.001u,0.s)
Chars 6019 - 6020 [*] 0. secs (0.u,0.s)
Chars 6021 - 6066 [exact~(fun~k~=>~coe~(ap~A~(nat...] 0.001 secs (0.u,0.s)
Chars 6073 - 6074 [*] 0. secs (0.u,0.s)
Chars 6075 - 6155 [(intros~k~l~p~a;~destruct~p;~s...] 0.005 secs (0.004u,0.s)
Chars 6164 - 6211 [srapply~(ap10~(ap~coe~(ap~(ap~...] 0.004 secs (0.002u,0.001s)
Chars 6216 - 6217 [+] 0. secs (0.u,0.s)
Chars 6218 - 6248 [(intro~k;~srapply~isequiv_path).] 0.005 secs (0.005u,0.s)
Chars 6251 - 6252 [-] 0. secs (0.u,0.s)
Chars 6253 - 6288 [(symmetry;~srapply~seq_colimit...] 0.013 secs (0.013u,0.s)
Chars 6293 - 6294 [+] 0. secs (0.u,0.s)
Chars 6295 - 6333 [(intros~k~a;~exact~(J~(nat_add...] 0.006 secs (0.006u,0.s)
Chars 6338 - 6339 [+] 0. secs (0.u,0.s)
Chars 6340 - 6407 [(intros~k~a;~rewrite~!Colimit_...] 0.2 secs (0.163u,0.036s)
Chars 6410 - 6411 [-] 0. secs (0.u,0.s)
Chars 6412 - 6462 [transitivity~(Colimit~(succ_se...] 0.001 secs (0.001u,0.s)
Chars 6467 - 6468 [+] 0. secs (0.u,0.s)
Chars 6469 - 6528 [(srapply~equiv_functor_colimit...] 0.025 secs (0.025u,0.s)
Chars 6535 - 6536 [*] 0. secs (0.u,0.s)
Chars 6537 - 6562 [srapply~Build_DiagramMap.] 0.001 secs (0.001u,0.s)
Chars 6571 - 6572 [{] 0. secs (0.u,0.s)
Chars 6573 - 6621 [exact~(fun~k~=>~coe~(ap~A~(nat...] 0.001 secs (0.001u,0.s)
Chars 6622 - 6623 [}] 0. secs (0.u,0.s)
Chars 6632 - 6633 [{] 0. secs (0.u,0.s)
Chars 6634 - 6716 [(intros~k~l~p~a;~destruct~p;~r...] 0.005 secs (0.005u,0.s)
Chars 6727 - 6774 [srapply~(ap10~(ap~coe~(ap~(ap~...] 0.003 secs (0.003u,0.s)
Chars 6775 - 6776 [}] 0. secs (0.u,0.s)
Chars 6783 - 6784 [*] 0. secs (0.u,0.s)
Chars 6785 - 6815 [(intro~k;~srapply~isequiv_path).] 0.005 secs (0.005u,0.s)
Chars 6820 - 6821 [+] 0. secs (0.u,0.s)
Chars 6822 - 6905 [srefine~~(transitivity~(equiv_...] 0.001 secs (0.001u,0.s)
Chars 6908 - 6909 [-] 0. secs (0.u,0.s)
Chars 6910 - 6945 [(symmetry;~srapply~seq_colimit...] 0.017 secs (0.017u,0.s)
Chars 6950 - 6951 [+] 0. secs (0.u,0.s)
Chars 6952 - 6993 [(intros~k~a;~exact~(J~(nat_add...] 0.008 secs (0.008u,0.s)
Chars 6998 - 6999 [+] 0. secs (0.u,0.s)
Chars 7000 - 7051 [(intros~k~a;~rewrite~Colimit_r...] 0.147 secs (0.145u,0.001s)
Chars 7058 - 7131 [(rewrite~2!(ap_compose'~_~_~(g...] 0.377 secs (0.369u,0.007s)
Chars 7138 - 7218 [(rewrite~colim_succ_seq_to_col...] 0.277 secs (0.27u,0.006s)
Chars 7225 - 7289 [(rewrite~(colim_succ_seq_to_co...] 0.105 secs (0.104u,0.001s)
Chars 7296 - 7365 [(rewrite~colim_shift_seq_to_co...] 0.132 secs (0.128u,0.003s)
Chars 5864 - 5916 [(induction~n~as~[|~n~e];~srapp...] 0. secs (0.u,0.s)
Chars 5921 - 5980 [(srapply~equiv_functor_colimit...] 0. secs (0.u,0.s)
Chars 5987 - 6012 [srapply~Build_DiagramMap.] 0. secs (0.u,0.s)
Chars 6021 - 6066 [exact~(fun~k~=>~coe~(ap~A~(nat...] 0. secs (0.u,0.s)
Chars 6075 - 6155 [(intros~k~l~p~a;~destruct~p;~s...] 0.001 secs (0.001u,0.s)
Chars 6164 - 6211 [srapply~(ap10~(ap~coe~(ap~(ap~...] 0. secs (0.u,0.s)
Chars 6218 - 6248 [(intro~k;~srapply~isequiv_path).] 0.002 secs (0.002u,0.s)
Chars 6253 - 6288 [(symmetry;~srapply~seq_colimit...] 0.002 secs (0.002u,0.s)
Chars 6295 - 6333 [(intros~k~a;~exact~(J~(nat_add...] 0.003 secs (0.003u,0.s)
Chars 6340 - 6407 [(intros~k~a;~rewrite~!Colimit_...] 0.016 secs (0.016u,0.s)
Chars 6412 - 6462 [transitivity~(Colimit~(succ_se...] 0. secs (0.u,0.s)
Chars 6469 - 6528 [(srapply~equiv_functor_colimit...] 0. secs (0.u,0.s)
Chars 6537 - 6562 [srapply~Build_DiagramMap.] 0. secs (0.u,0.s)
Chars 6573 - 6621 [exact~(fun~k~=>~coe~(ap~A~(nat...] 0. secs (0.u,0.s)
Chars 6634 - 6716 [(intros~k~l~p~a;~destruct~p;~r...] 0.001 secs (0.001u,0.s)
Chars 6727 - 6774 [srapply~(ap10~(ap~coe~(ap~(ap~...] 0. secs (0.u,0.s)
Chars 6785 - 6815 [(intro~k;~srapply~isequiv_path).] 0.003 secs (0.003u,0.s)
Chars 6822 - 6905 [srefine~~(transitivity~(equiv_...] 0. secs (0.u,0.s)
Chars 6910 - 6945 [(symmetry;~srapply~seq_colimit...] 0.004 secs (0.003u,0.s)
Chars 6952 - 6993 [(intros~k~a;~exact~(J~(nat_add...] 0.005 secs (0.005u,0.s)
Chars 7000 - 7051 [(intros~k~a;~rewrite~Colimit_r...] 0.054 secs (0.052u,0.002s)
Chars 7058 - 7131 [(rewrite~2!(ap_compose'~_~_~(g...] 0.002 secs (0.002u,0.s)
Chars 7138 - 7218 [(rewrite~colim_succ_seq_to_col...] 0.014 secs (0.014u,0.s)
Chars 7225 - 7289 [(rewrite~(colim_succ_seq_to_co...] 0.012 secs (0.012u,0.s)
Chars 7296 - 7365 [(rewrite~colim_shift_seq_to_co...] 0.02 secs (0.019u,0.s)
Chars 7366 - 7374 [Defined.] 1.079 secs (1.064u,0.015s)
Chars 7376 - 7536 [Definition~equiv_colim_shift_s...] 0.009 secs (0.009u,0.s)
Chars 7593 - 7700 [Definition~contr_colim_contr_s...] 0. secs (0.u,0.s)
Chars 7701 - 7707 [Proof.] 0. secs (0.u,0.s)
Chars 1943 - 1950 [(intros).] 40.068 secs (0.u,0.017s)
Chars 1953 - 1978 [(apply~apart_iff_total_lt).] 0.001 secs (0.001u,0.s)
Chars 1981 - 1992 [assumption.] 0. secs (0.u,0.s)
Chars 1943 - 1950 [(intros).] 0. secs (0.u,0.s)
Chars 1953 - 1978 [(apply~apart_iff_total_lt).] 0. secs (0.u,0.s)
Chars 1981 - 1992 [assumption.] 0. secs (0.u,0.s)
Chars 1995 - 1999 [Qed.] 0. secs (0.u,0.s)
Chars 2003 - 2054 [Lemma~pseudo_order_lt_apart~x~...] 0. secs (0.u,0.s)
Chars 2057 - 2063 [Proof.] 0. secs (0.u,0.s)
Discriminated database
Unfoldable variable definitions: all
Unfoldable constant definitions: all except: CRelationClasses.Antisymmetric
  Antisymmetric Associative CRelationClasses.Asymmetric Asymmetric
  Commutative Idempotent CRelationClasses.Irreflexive Irreflexive
  CMorphisms.Normalizes Normalizes CRelationClasses.PartialOrder PartialOrder
  CMorphisms.Proper Proper CMorphisms.ProperProxy ProperProxy
  CRelationClasses.Reflexive Reflexive ssrclasses.Reflexive
  CRelationClasses.Symmetric Symmetric CRelationClasses.Transitive Transitive
  Unconvertible all Basics.arrow arrows Basics.compose Basics.const
  Basics.flip CMorphisms.forall_relation forall_relation id iff Basics.impl
  not pointwise_lifting CMorphisms.pointwise_relation pointwise_relation
  predicate_equivalence predicate_implication
  CRelationClasses.relation_equivalence relation_equivalence
  CMorphisms.respectful respectful CRelationClasses.subrelation subrelation
Cut: emp
For any goal ->   
For Symmetric ->   exact iff_Symmetric(level 0, pattern 
                   Symmetric iff, id 0)
                   simple apply @eq_Symmetric(level 0, pattern 
                   Symmetric eq, id 0)
                   simple apply @Equivalence.equiv_symmetric(level 1, pattern 
                   Symmetric Equivalence.equiv, id 0)
                   simple apply @Equivalence_Symmetric(level 1, pattern 
                   Symmetric ?META257, id 0)
                   (*external*) (class_apply @flip_Symmetric)(level 3, pattern 
                   Symmetric (Basics.flip _), id 0)
                   (*external*) (class_apply @complement_Symmetric)(level 3, pattern 
                   Symmetric (complement _), id 0)
                   simple apply @PER_Symmetric(level 3, pattern 
                   Symmetric ?META239, id 0)
                   simple apply @Equivalence.pointwise_symmetric(level 9, pattern 
                   Symmetric (pointwise_relation ?META411 ?META413), id 0) 
For Antisymmetric ->   simple eapply @partial_order_antisym(level 2, pattern 
                       Antisymmetric ?META316 ?META317 
                         ?META319, id 0)
                       (*external*) (class_apply @flip_Antisymmetric)(level 3, pattern 
                       Antisymmetric _ (Basics.flip _), id 0) 
For CMorphisms.Normalizes ->   (*external*) CMorphisms.normalizes(level 1, pattern 
                               CMorphisms.Normalizes _ _ _, id 0) 
For CMorphisms.ProperProxy ->   (*external*) (class_apply
                                               @CMorphisms.eq_proper_proxy ||
                                                class_apply
                                                 @CMorphisms.reflexive_proper_proxy)(level 1, pattern 
                                CMorphisms.ProperProxy _ _, id 0)
                                (*external*) (not_evar R;
                                               class_apply
                                                @CMorphisms.proper_proper_proxy)(level 2, pattern 
                                CMorphisms.ProperProxy 
                                  ?R _, id 0) 
For Unconvertible ->   (*external*) unconvertible(level 0, pattern 
                       Unconvertible _ _ _, id 0) 
For Associative ->   exact aac_Zmax_Assoc(level 0, pattern 
                     Associative eq BinIntDef.Z.max, id 0)
                     exact aac_Zmin_Assoc(level 0, pattern 
                     Associative eq BinIntDef.Z.min, id 0)
                     exact aac_Zmult_Assoc(level 0, pattern 
                     Associative eq BinIntDef.Z.mul, id 0)
                     exact aac_Zplus_Assoc(level 0, pattern 
                     Associative eq BinIntDef.Z.add, id 0) 
For CRelationClasses.Reflexive ->   exact CRelationClasses.iffT_Reflexive(level 0, pattern 
                                    CRelationClasses.Reflexive
                                      CRelationClasses.iffT, id 0)
                                    exact CRelationClasses.arrow_Reflexive(level 0, pattern 
                                    CRelationClasses.Reflexive
                                      CRelationClasses.arrow, id 0)
                                    exact CRelationClasses.iff_Reflexive(level 0, pattern 
                                    CRelationClasses.Reflexive iff, id 0)
                                    exact CRelationClasses.impl_Reflexive(level 0, pattern 
                                    CRelationClasses.Reflexive Basics.impl, id 0)
                                    simple apply @CRelationClasses.eq_Reflexive(level 0, pattern 
                                    CRelationClasses.Reflexive eq, id 0)
                                    simple apply @CMorphisms.reflexive_eq_dom_reflexive(level 1, pattern 
                                    CRelationClasses.Reflexive
                                      (CMorphisms.respectful eq ?META303), id 0)
                                    (*external*) (
                                    class_apply
                                     @CRelationClasses.irreflexivity)(level 1, pattern 
                                    CRelationClasses.Reflexive
                                      (CRelationClasses.complement _), id 0)
                                    simple apply @CRelationClasses.Equivalence_Reflexive(level 1, pattern 
                                    CRelationClasses.Reflexive 
                                      ?META203, id 0)
                                    simple apply @CRelationClasses.PreOrder_Reflexive(level 2, pattern 
                                    CRelationClasses.Reflexive 
                                      ?META161, id 0)
                                    (*external*) (
                                    apply CRelationClasses.flip_Reflexive)(level 3, pattern 
                                    CRelationClasses.Reflexive
                                      (CRelationClasses.flip _), id 0) 
For ssrclasses.Reflexive ->   exact ssrclasses.iff_Reflexive(level 0, pattern 
                              ssrclasses.Reflexive iff, id 0)
                              simple apply @ssrclasses.eq_Reflexive(level 0, pattern 
                              ssrclasses.Reflexive eq, id 0)
                              simple apply @ssrsetoid.compat_Reflexive(level 12, pattern 
                              ssrclasses.Reflexive 
                                ?META268, id 0) 
For Commutative ->   exact aac_Zmax_Comm(level 0, pattern 
                     Commutative eq BinIntDef.Z.max, id 0)
                     exact aac_Zmin_Comm(level 0, pattern 
                     Commutative eq BinIntDef.Z.min, id 0)
                     exact aac_Zmult_Comm(level 0, pattern 
                     Commutative eq BinIntDef.Z.mul, id 0)
                     exact aac_Zplus_Comm(level 0, pattern 
                     Commutative eq BinIntDef.Z.add, id 0) 
For Reflexive ->   exact iff_Reflexive(level 0, pattern 
                   Reflexive iff, id 0)
                   exact impl_Reflexive(level 0, pattern 
                   Reflexive Basics.impl, id 0)
                   simple apply @eq_Reflexive(level 0, pattern 
                   Reflexive eq, id 0)
                   simple apply @Equivalence.equiv_reflexive(level 1, pattern 
                   Reflexive Equivalence.equiv, id 0)
                   simple apply @reflexive_eq_dom_reflexive(level 1, pattern 
                   Reflexive (respectful eq ?META358), id 0)
                   (*external*) (class_apply @irreflexivity)(level 1, pattern 
                   Reflexive (complement _), id 0)
                   simple apply @Equivalence_Reflexive(level 1, pattern 
                   Reflexive ?META251, id 0)
                   simple apply @PreOrder_Reflexive(level 2, pattern 
                   Reflexive ?META209, id 0)
                   (*external*) (apply flip_Reflexive)(level 3, pattern 
                   Reflexive (Basics.flip _), id 0)
                   exact Z.divide_reflexive(level 5, pattern 
                   Reflexive Z.divide, id 0)
                   exact N.divide_reflexive(level 5, pattern 
                   Reflexive N.divide, id 0)
                   exact Nat.divide_reflexive(level 5, pattern 
                   Reflexive Nat.divide, id 0)
                   simple apply @Equivalence.pointwise_reflexive(level 9, pattern 
                   Reflexive (pointwise_relation ?META403 ?META405), id 0) 
For CRelationClasses.Asymmetric ->   simple apply @CRelationClasses.StrictOrder_Asymmetric(level 1, pattern 
                                     CRelationClasses.Asymmetric 
                                       ?META185, id 0)
                                     (*external*) (
                                     class_apply
                                      @CRelationClasses.flip_Asymmetric)(level 3, pattern 
                                     CRelationClasses.Asymmetric
                                       (CRelationClasses.flip _), id 0) 
For CRelationClasses.Irreflexive ->   simple apply @CRelationClasses.StrictOrder_Irreflexive(level 1, pattern 
                                      CRelationClasses.Irreflexive 
                                        ?META173, id 0)
                                      (*external*) (
                                      class_apply
                                       @CRelationClasses.flip_Irreflexive)(level 3, pattern 
                                      CRelationClasses.Irreflexive
                                        (CRelationClasses.flip _), id 0)
                                      (*external*) (
                                      class_apply
                                       @CRelationClasses.complement_Irreflexive)(level 3, pattern 
                                      CRelationClasses.Irreflexive
                                        (CRelationClasses.complement _), id 0)
                                      
For Proper ->   exact Qminmax.Q.min_compat(level 0, pattern 
                Proper
                  (QArith_base.Qeq ==> QArith_base.Qeq ==> QArith_base.Qeq)
                  Qminmax.Qmin, id 0)
                exact Qminmax.Q.max_compat(level 0, pattern 
                Proper
                  (QArith_base.Qeq ==> QArith_base.Qeq ==> QArith_base.Qeq)
                  Qminmax.Qmax, id 0)
                exact Qminmax.Q.Proper_instance_0(level 0, pattern 
                Proper (QArith_base.Qeq ==> QArith_base.Qeq ==> iff)
                  QArith_base.Qle, id 0)
                exact Qminmax.Q.OT.lt_compat(level 0, pattern 
                Proper (QArith_base.Qeq ==> QArith_base.Qeq ==> iff)
                  QArith_base.Qlt, id 0)
                exact QOrderedType.QOrder.TO.lt_compat(level 0, pattern 
                Proper (QArith_base.Qeq ==> QArith_base.Qeq ==> iff)
                  QArith_base.Qlt, id 0)
                exact QOrderedType.Q_as_OT.lt_compat(level 0, pattern 
                Proper (QArith_base.Qeq ==> QArith_base.Qeq ==> iff)
                  QArith_base.Qlt, id 0)
                simple apply FMapPositive.PositiveMap.ME.ltk_compat'(level 0, pattern 
                Proper
                  (FMapPositive.PositiveMap.ME.eqke (elt:=?META923) ==>
                   FMapPositive.PositiveMap.ME.eqke (elt:=?META923) ==> iff)
                  (FMapPositive.PositiveMap.ME.ltk (elt:=?META923)), id 0)
                simple apply FMapPositive.PositiveMap.ME.ltk_compat(level 0, pattern 
                Proper
                  (FMapPositive.PositiveMap.ME.eqk (elt:=?META921) ==>
                   FMapPositive.PositiveMap.ME.eqk (elt:=?META921) ==> iff)
                  (FMapPositive.PositiveMap.ME.ltk (elt:=?META921)), id 0)
                exact FMapPositive.PositiveMap.ME.MO.lt_compat(level 0, pattern 
                Proper (eq ==> eq ==> iff)
                  OrderedTypeEx.PositiveOrderedTypeBits.bits_lt, id 0)
                simple apply SetoidList.rev_eqlistA_compat(level 0, pattern 
                Proper
                  (SetoidList.eqlistA ?META812 ==>
                   SetoidList.eqlistA ?META812) (List.rev (A:=?META811)), id 0)
                simple apply SetoidList.app_eqlistA_compat(level 0, pattern 
                Proper
                  (SetoidList.eqlistA ?META808 ==>
                   SetoidList.eqlistA ?META808 ==>
                   SetoidList.eqlistA ?META808) (app (A:=?META807)), id 0)
                simple apply Permutation.Permutation_flat_map(level 0, pattern 
                Proper
                  (Permutation.Permutation (A:=?META1109) ==>
                   Permutation.Permutation (A:=?META1110))
                  (List.flat_map ?META1111), id 0)
                simple apply Permutation.Permutation_map'(level 0, pattern 
                Proper
                  (Permutation.Permutation (A:=?META1103) ==>
                   Permutation.Permutation (A:=?META1104))
                  (List.map ?META1105), id 0)
                simple apply Permutation.Permutation_NoDup'(level 0, pattern 
                Proper (Permutation.Permutation (A:=?META1101) ==> iff)
                  (List.NoDup (A:=?META1101)), id 0)
                simple apply Permutation.Permutation_Exists(level 0, pattern 
                Proper
                  (Permutation.Permutation (A:=?META1097) ==> Basics.impl)
                  (List.Exists ?META1098), id 0)
                simple apply Permutation.Permutation_Forall(level 0, pattern 
                Proper
                  (Permutation.Permutation (A:=?META1093) ==> Basics.impl)
                  (List.Forall ?META1094), id 0)
                simple apply Permutation.Permutation_rev'(level 0, pattern 
                Proper
                  (Permutation.Permutation (A:=?META1089) ==>
                   Permutation.Permutation (A:=?META1089))
                  (List.rev (A:=?META1089)), id 0)
                simple apply Permutation.Permutation_app'(level 0, pattern 
                Proper
                  (Permutation.Permutation (A:=?META1087) ==>
                   Permutation.Permutation (A:=?META1087) ==>
                   Permutation.Permutation (A:=?META1087))
                  (app (A:=?META1087)), id 0)
                simple apply Permutation.Permutation_in'(level 0, pattern 
                Proper
                  (respectful eq
                     (Permutation.Permutation (A:=?META1085) ==> iff))
                  (List.In (A:=?META1085)), id 0)
                simple apply Permutation.Permutation_cons(level 0, pattern 
                Proper
                  (respectful eq
                     (Permutation.Permutation (A:=?META1083) ==>
                      Permutation.Permutation (A:=?META1083))) cons, id 0)
                exact Qreduction.Qminus'_comp_Proper(level 0, pattern 
                Proper
                  (QArith_base.Qeq ==> QArith_base.Qeq ==> QArith_base.Qeq)
                  Qreduction.Qminus', id 0)
                exact Qreduction.Qmult'_comp_Proper(level 0, pattern 
                Proper
                  (QArith_base.Qeq ==> QArith_base.Qeq ==> QArith_base.Qeq)
                  Qreduction.Qmult', id 0)
                exact Qreduction.Qplus'_comp_Proper(level 0, pattern 
                Proper
                  (QArith_base.Qeq ==> QArith_base.Qeq ==> QArith_base.Qeq)
                  Qreduction.Qplus', id 0)
                exact Qreduction.Qred_comp_Proper(level 0, pattern 
                Proper (QArith_base.Qeq ==> QArith_base.Qeq) Qreduction.Qred, id 0)
                exact QArith_base.Qpower_comp(level 0, pattern 
                Proper (QArith_base.Qeq ==> eq ==> QArith_base.Qeq)
                  QArith_base.Qpower, id 0)
                exact QArith_base.Qpower_positive_comp(level 0, pattern 
                Proper (QArith_base.Qeq ==> eq ==> QArith_base.Qeq)
                  QArith_base.Qpower_positive, id 0)
                exact QArith_base.Qleb_comp(level 0, pattern 
                Proper (QArith_base.Qeq ==> QArith_base.Qeq ==> eq)
                  QArith_base.Qle_bool, id 0)
                exact QArith_base.Qeqb_comp(level 0, pattern 
                Proper (QArith_base.Qeq ==> QArith_base.Qeq ==> eq)
                  QArith_base.Qeq_bool, id 0)
                exact QArith_base.Qlt_compat(level 0, pattern 
                Proper (QArith_base.Qeq ==> QArith_base.Qeq ==> iff)
                  QArith_base.Qlt, id 0)
                exact QArith_base.Qle_comp(level 0, pattern 
                Proper (QArith_base.Qeq ==> QArith_base.Qeq ==> iff)
                  QArith_base.Qle, id 0)
                exact QArith_base.Qcompare_comp(level 0, pattern 
                Proper (QArith_base.Qeq ==> QArith_base.Qeq ==> eq)
                  QArith_base.Qcompare, id 0)
                exact QArith_base.Qdiv_comp(level 0, pattern 
                Proper
                  (QArith_base.Qeq ==> QArith_base.Qeq ==> QArith_base.Qeq)
                  QArith_base.Qdiv, id 0)
                exact QArith_base.Qinv_comp(level 0, pattern 
                Proper (QArith_base.Qeq ==> QArith_base.Qeq) QArith_base.Qinv, id 0)
                exact QArith_base.Qmult_comp(level 0, pattern 
                Proper
                  (QArith_base.Qeq ==> QArith_base.Qeq ==> QArith_base.Qeq)
                  QArith_base.Qmult, id 0)
                exact QArith_base.Qminus_comp(level 0, pattern 
                Proper
                  (QArith_base.Qeq ==> QArith_base.Qeq ==> QArith_base.Qeq)
                  QArith_base.Qminus, id 0)
                exact QArith_base.Qopp_comp(level 0, pattern 
                Proper (QArith_base.Qeq ==> QArith_base.Qeq) QArith_base.Qopp, id 0)
                exact QArith_base.Qplus_comp(level 0, pattern 
                Proper
                  (QArith_base.Qeq ==> QArith_base.Qeq ==> QArith_base.Qeq)
                  QArith_base.Qplus, id 0)
                exact Z.ones_wd(level 0, pattern Proper (eq ==> eq) Z.ones, id 0)
                exact Z.lnot_wd(level 0, pattern Proper (eq ==> eq) Z.lnot, id 0)
                exact Z.clearbit_wd(level 0, pattern 
                Proper (eq ==> eq ==> eq) Z.clearbit, id 0)
                exact Z.setbit_wd(level 0, pattern 
                Proper (eq ==> eq ==> eq) Z.setbit, id 0)
                exact Z.ldiff_wd(level 0, pattern 
                Proper (eq ==> eq ==> eq) Z.ldiff, id 0)
                exact Z.lor_wd(level 0, pattern Proper 
                                                 (eq ==> eq ==> eq) Z.lor, id 0)
                exact Z.land_wd(level 0, pattern Proper 
                                                 (eq ==> eq ==> eq) Z.land, id 0)
                exact Z.lxor_wd(level 0, pattern Proper 
                                                 (eq ==> eq ==> eq) Z.lxor, id 0)
                exact Z.div2_wd(level 0, pattern Proper (eq ==> eq) Z.div2, id 0)
                exact Z.shiftl_wd(level 0, pattern 
                Proper (eq ==> eq ==> eq) Z.shiftl, id 0)
                exact Z.shiftr_wd(level 0, pattern 
                Proper (eq ==> eq ==> eq) Z.shiftr, id 0)
                exact Z.testbit_eqf(level 0, pattern 
                Proper (eq ==> Z.eqf) Z.testbit, id 0)
                exact Z.b2z_wd(level 0, pattern Proper (eq ==> eq) Z.b2z, id 0)
                exact Z.eqb_compat(level 0, pattern 
                Proper (eq ==> eq ==> eq) Z.eqb, id 0)
                exact Z.lcm_wd(level 0, pattern Proper 
                                                 (eq ==> eq ==> eq) Z.lcm, id 0)
                exact Z.Bezout_wd(level 0, pattern 
                Proper (eq ==> eq ==> eq ==> iff) Z.Bezout, id 0)
                exact Z.gcd_wd(level 0, pattern Proper 
                                                 (eq ==> eq ==> eq) Z.gcd, id 0)
                exact Z.divide_wd(level 0, pattern 
                Proper (eq ==> eq ==> iff) Z.divide, id 0)
                exact Z.log2_up_wd(level 0, pattern 
                Proper (eq ==> eq) Z.log2_up, id 0)
                exact Z.log2_wd(level 0, pattern Proper (eq ==> eq) Z.log2, id 0)
                exact Z.sqrt_up_wd(level 0, pattern 
                Proper (eq ==> eq) Z.sqrt_up, id 0)
                exact Z.sqrt_wd(level 0, pattern Proper (eq ==> eq) Z.sqrt, id 0)
                exact Z.odd_wd(level 0, pattern Proper (eq ==> eq) Z.odd, id 0)
                exact Z.even_wd(level 0, pattern Proper (eq ==> eq) Z.even, id 0)
                exact Z.Odd_wd(level 0, pattern Proper (eq ==> iff) Z.Odd, id 0)
                exact Z.Even_wd(level 0, pattern Proper (eq ==> iff) Z.Even, id 0)
                exact Z.sgn_wd(level 0, pattern Proper (eq ==> eq) Z.sgn, id 0)
                exact Z.abs_wd(level 0, pattern Proper (eq ==> eq) Z.abs, id 0)
                exact Z.min_compat(level 0, pattern 
                Proper (eq ==> eq ==> eq) Z.min, id 0)
                exact Z.max_compat(level 0, pattern 
                Proper (eq ==> eq ==> eq) Z.max, id 0)
                exact Z.Proper_instance_0(level 0, pattern 
                Proper (eq ==> eq ==> iff) Z.le, id 0)
                exact Z.le_wd(level 0, pattern Proper 
                                                 (eq ==> eq ==> iff) Z.le, id 0)
                exact N.lnot_wd(level 0, pattern Proper 
                                                 (eq ==> eq ==> eq) N.lnot, id 0)
                exact N.ones_wd(level 0, pattern Proper (eq ==> eq) N.ones, id 0)
                exact N.clearbit_wd(level 0, pattern 
                Proper (eq ==> eq ==> eq) N.clearbit, id 0)
                exact N.setbit_wd(level 0, pattern 
                Proper (eq ==> eq ==> eq) N.setbit, id 0)
                exact N.ldiff_wd(level 0, pattern 
                Proper (eq ==> eq ==> eq) N.ldiff, id 0)
                exact N.lor_wd(level 0, pattern Proper 
                                                 (eq ==> eq ==> eq) N.lor, id 0)
                exact N.land_wd(level 0, pattern Proper 
                                                 (eq ==> eq ==> eq) N.land, id 0)
                exact N.lxor_wd(level 0, pattern Proper 
                                                 (eq ==> eq ==> eq) N.lxor, id 0)
                exact N.div2_wd(level 0, pattern Proper (eq ==> eq) N.div2, id 0)
                exact N.shiftl_wd(level 0, pattern 
                Proper (eq ==> eq ==> eq) N.shiftl, id 0)
                exact N.shiftr_wd(level 0, pattern 
                Proper (eq ==> eq ==> eq) N.shiftr, id 0)
                exact N.testbit_eqf(level 0, pattern 
                Proper (eq ==> N.eqf) N.testbit, id 0)
                exact N.b2n_proper(level 0, pattern 
                Proper (eq ==> eq) N.b2n, id 0)
                exact N.eqb_compat(level 0, pattern 
                Proper (eq ==> eq ==> eq) N.eqb, id 0)
                exact N.lcm_wd(level 0, pattern Proper 
                                                 (eq ==> eq ==> eq) N.lcm, id 0)
                exact N.Bezout_wd(level 0, pattern 
                Proper (eq ==> eq ==> eq ==> iff) N.Bezout, id 0)
                exact N.gcd_wd(level 0, pattern Proper 
                                                 (eq ==> eq ==> eq) N.gcd, id 0)
                exact N.divide_wd(level 0, pattern 
                Proper (eq ==> eq ==> iff) N.divide, id 0)
                exact N.log2_up_wd(level 0, pattern 
                Proper (eq ==> eq) N.log2_up, id 0)
                exact N.log2_wd(level 0, pattern Proper (eq ==> eq) N.log2, id 0)
                exact N.sqrt_up_wd(level 0, pattern 
                Proper (eq ==> eq) N.sqrt_up, id 0)
                exact N.Private_NZSqrt.sqrt_wd(level 0, pattern 
                Proper (eq ==> eq) N.sqrt, id 0)
                exact N.odd_wd(level 0, pattern Proper (eq ==> eq) N.odd, id 0)
                exact N.even_wd(level 0, pattern Proper (eq ==> eq) N.even, id 0)
                exact N.Odd_wd(level 0, pattern Proper (eq ==> iff) N.Odd, id 0)
                exact N.Even_wd(level 0, pattern Proper (eq ==> iff) N.Even, id 0)
                exact N.min_compat(level 0, pattern 
                Proper (eq ==> eq ==> eq) N.min, id 0)
                exact N.max_compat(level 0, pattern 
                Proper (eq ==> eq ==> eq) N.max, id 0)
                exact N.Proper_instance_0(level 0, pattern 
                Proper (eq ==> eq ==> iff) N.le, id 0)
                exact N.lt_alt_wd(level 0, pattern 
                Proper (eq ==> eq ==> iff) N.lt_alt, id 0)
                exact N.le_alt_wd(level 0, pattern 
                Proper (eq ==> eq ==> iff) N.le_alt, id 0)
                exact N.le_wd(level 0, pattern Proper 
                                                 (eq ==> eq ==> iff) N.le, id 0)
                simple apply @N.recursion_wd(level 0, pattern 
                Proper
                  (respectful ?META763
                     ((eq ==> respectful ?META763 ?META763) ==>
                      respectful eq ?META763)) N.recursion, id 0)
                exact Pos.min_compat(level 0, pattern 
                Proper (eq ==> eq ==> eq) Pos.min, id 0)
                exact Pos.max_compat(level 0, pattern 
                Proper (eq ==> eq ==> eq) Pos.max, id 0)
                exact Pos.Proper_instance_0(level 0, pattern 
                Proper (eq ==> eq ==> iff) Pos.le, id 0)
                exact Pos.lt_compat(level 0, pattern 
                Proper (eq ==> eq ==> iff) Pos.lt, id 0)
                exact Pos.eqb_compat(level 0, pattern 
                Proper (eq ==> eq ==> eq) Pos.eqb, id 0)
                exact Nat.lnot_wd(level 0, pattern 
                Proper (eq ==> eq ==> eq) Nat.lnot, id 0)
                exact Nat.ones_wd(level 0, pattern 
                Proper (eq ==> eq) Nat.ones, id 0)
                exact Nat.clearbit_wd(level 0, pattern 
                Proper (eq ==> eq ==> eq) Nat.clearbit, id 0)
                exact Nat.setbit_wd(level 0, pattern 
                Proper (eq ==> eq ==> eq) Nat.setbit, id 0)
                exact Nat.ldiff_wd(level 0, pattern 
                Proper (eq ==> eq ==> eq) Nat.ldiff, id 0)
                exact Nat.lor_wd(level 0, pattern 
                Proper (eq ==> eq ==> eq) Nat.lor, id 0)
                exact Nat.land_wd(level 0, pattern 
                Proper (eq ==> eq ==> eq) Nat.land, id 0)
                exact Nat.lxor_wd(level 0, pattern 
                Proper (eq ==> eq ==> eq) Nat.lxor, id 0)
                exact Nat.div2_wd(level 0, pattern 
                Proper (eq ==> eq) Nat.div2, id 0)
                exact Nat.shiftl_wd(level 0, pattern 
                Proper (eq ==> eq ==> eq) Nat.shiftl, id 0)
                exact Nat.shiftr_wd(level 0, pattern 
                Proper (eq ==> eq ==> eq) Nat.shiftr, id 0)
                exact Nat.testbit_eqf(level 0, pattern 
                Proper (eq ==> Nat.eqf) Nat.testbit, id 0)
                exact Nat.b2n_proper(level 0, pattern 
                Proper (eq ==> eq) Nat.b2n, id 0)
                exact Nat.eqb_compat(level 0, pattern 
                Proper (eq ==> eq ==> eq) Nat.eqb, id 0)
                exact Nat.lcm_wd(level 0, pattern 
                Proper (eq ==> eq ==> eq) Nat.lcm, id 0)
                exact Nat.Bezout_wd(level 0, pattern 
                Proper (eq ==> eq ==> eq ==> iff) Nat.Bezout, id 0)
                exact Nat.gcd_wd(level 0, pattern 
                Proper (eq ==> eq ==> eq) Nat.gcd, id 0)
                exact Nat.divide_wd(level 0, pattern 
                Proper (eq ==> eq ==> iff) Nat.divide, id 0)
                exact Nat.log2_up_wd(level 0, pattern 
                Proper (eq ==> eq) Nat.log2_up, id 0)
                exact Nat.log2_wd(level 0, pattern 
                Proper (eq ==> eq) Nat.log2, id 0)
                exact Nat.sqrt_up_wd(level 0, pattern 
                Proper (eq ==> eq) Nat.sqrt_up, id 0)
                exact Nat.Private_NZSqrt.sqrt_wd(level 0, pattern 
                Proper (eq ==> eq) Nat.sqrt, id 0)
                exact Nat.odd_wd(level 0, pattern 
                Proper (eq ==> eq) Nat.odd, id 0)
                exact Nat.even_wd(level 0, pattern 
                Proper (eq ==> eq) Nat.even, id 0)
                exact Nat.Odd_wd(level 0, pattern 
                Proper (eq ==> iff) Nat.Odd, id 0)
                exact Nat.Even_wd(level 0, pattern 
                Proper (eq ==> iff) Nat.Even, id 0)
                exact Nat.min_compat(level 0, pattern 
                Proper (eq ==> eq ==> eq) Nat.min, id 0)
                exact Nat.max_compat(level 0, pattern 
                Proper (eq ==> eq ==> eq) Nat.max, id 0)
                exact Nat.Proper_instance_0(level 0, pattern 
                Proper (eq ==> eq ==> iff) le, id 0)
                exact Nat.lt_alt_wd(level 0, pattern 
                Proper (eq ==> eq ==> iff) Nat.lt_alt, id 0)
                exact Nat.le_alt_wd(level 0, pattern 
                Proper (eq ==> eq ==> iff) Nat.le_alt, id 0)
                exact Nat.le_wd(level 0, pattern Proper 
                                                 (eq ==> eq ==> iff) le, id 0)
                simple apply @Nat.recursion_wd(level 0, pattern 
                Proper
                  (respectful ?META686
                     ((eq ==> respectful ?META686 ?META686) ==>
                      respectful eq ?META686)) Nat.recursion, id 0)
                exact Nat.testbit_wd(level 0, pattern 
                Proper (eq ==> eq ==> eq) Init.Nat.testbit, id 0)
                exact Nat.lt_wd(level 0, pattern Proper 
                                                 (eq ==> eq ==> iff) lt, id 0)
                exact Nat.mod_wd(level 0, pattern 
                Proper (eq ==> eq ==> eq) Init.Nat.modulo, id 0)
                exact Nat.div_wd(level 0, pattern 
                Proper (eq ==> eq ==> eq) Init.Nat.div, id 0)
                exact Nat.pow_wd(level 0, pattern 
                Proper (eq ==> eq ==> eq) Init.Nat.pow, id 0)
                exact Nat.mul_wd(level 0, pattern 
                Proper (eq ==> eq ==> eq) Init.Nat.mul, id 0)
                exact Nat.sub_wd(level 0, pattern 
                Proper (eq ==> eq ==> eq) Init.Nat.sub, id 0)
                exact Nat.add_wd(level 0, pattern 
                Proper (eq ==> eq ==> eq) Init.Nat.add, id 0)
                exact Nat.pred_wd(level 0, pattern 
                Proper (eq ==> eq) Init.Nat.pred, id 0)
                exact Nat.succ_wd(level 0, pattern 
                Proper (eq ==> eq) S, id 0)
                simple apply @Morphisms_Prop.well_founded_morphism(level 0, pattern 
                Proper (relation_equivalence ==> iff)
                  (well_founded (A:=?META733)), id 0)
                simple apply @Morphisms_Prop.Acc_rel_morphism(level 0, pattern 
                Proper (relation_equivalence ==> respectful eq iff)
                  (Acc (A:=?META731)), id 0)
                simple apply @Morphisms_Prop.all_iff_morphism(level 0, pattern 
                Proper (pointwise_relation ?META691 iff ==> iff)
                  (all (A:=?META691)), id 0)
                simple apply @Morphisms_Prop.ex_iff_morphism(level 0, pattern 
                Proper (pointwise_relation ?META559 iff ==> iff)
                  (ex (A:=?META559)), id 0)
                exact Morphisms_Prop.iff_iff_iff_impl_morphism(level 0, pattern 
                Proper (iff ==> iff ==> iff) Basics.impl, id 0)
                exact Morphisms_Prop.or_iff_morphism(level 0, pattern 
                Proper (iff ==> iff ==> iff) or, id 0)
                exact Morphisms_Prop.and_iff_morphism(level 0, pattern 
                Proper (iff ==> iff ==> iff) and, id 0)
                exact Morphisms_Prop.not_iff_morphism(level 0, pattern 
                Proper (iff ==> iff) not, id 0)
                simple apply @proper_proper(level 0, pattern 
                Proper (relation_equivalence ==> respectful eq iff) Proper, id 0)
                simple apply @respectful_morphism(level 0, pattern 
                Proper
                  (relation_equivalence ==>
                   relation_equivalence ==> relation_equivalence) respectful, id 0)
                simple apply @compose_proper(level 0, pattern 
                Proper
                  (respectful ?META348 ?META349 ==>
                   respectful ?META347 ?META348 ==>
                   respectful ?META347 ?META349) Basics.compose, id 0)
                simple apply @proper_subrelation_proper(level 0, pattern 
                Proper (subrelation ==> respectful eq Basics.impl) Proper, id 0)
                simple apply SetoidList.equivlistA_app_proper(level 1, pattern 
                Proper
                  (SetoidList.equivlistA ?META792 ==>
                   SetoidList.equivlistA ?META792 ==>
                   SetoidList.equivlistA ?META792) 
                  (app (A:=?META791)), id 0)
                simple apply SetoidList.equivlistA_cons_proper(level 1, pattern 
                Proper
                  (respectful ?META786
                     (SetoidList.equivlistA ?META786 ==>
                      SetoidList.equivlistA ?META786)) cons, id 0)
                simple apply SetoidList.InA_compat(level 1, pattern 
                Proper
                  (respectful ?META780
                     (SetoidList.equivlistA ?META780 ==> iff))
                  (SetoidList.InA ?META780), id 0)
                simple apply @Morphisms_Prop.all_flip_impl_morphism(level 1, pattern 
                Proper
                  (pointwise_relation ?META719 (Basics.flip Basics.impl) ==>
                   Basics.flip Basics.impl) (all (A:=?META719)), id 0)
                simple apply @Morphisms_Prop.all_impl_morphism(level 1, pattern 
                Proper
                  (pointwise_relation ?META705 Basics.impl ==> Basics.impl)
                  (all (A:=?META705)), id 0)
                simple apply @Morphisms_Prop.ex_flip_impl_morphism(level 1, pattern 
                Proper
                  (pointwise_relation ?META635 (Basics.flip Basics.impl) ==>
                   Basics.flip Basics.impl) (ex (A:=?META635)), id 0)
                simple apply @Morphisms_Prop.ex_impl_morphism(level 1, pattern 
                Proper
                  (pointwise_relation ?META597 Basics.impl ==> Basics.impl)
                  (ex (A:=?META597)), id 0)
                exact Morphisms_Prop.or_impl_morphism(level 1, pattern 
                Proper (Basics.impl ==> Basics.impl ==> Basics.impl) or, id 0)
                exact Morphisms_Prop.and_impl_morphism(level 1, pattern 
                Proper (Basics.impl ==> Basics.impl ==> Basics.impl) and, id 0)
                exact Morphisms_Prop.not_impl_morphism(level 1, pattern 
                Proper (Basics.impl --> Basics.impl) not, id 0)
                (*external*) (apply @flip_proper)(level 1, pattern 
                Proper _ (Basics.flip _), id 0)
                (*external*) (apply @complement_proper)(level 1, pattern 
                Proper _ (complement _), id 0)
                simple apply @PER_morphism(level 1, pattern 
                Proper (respectful ?META339 (respectful ?META339 iff))
                  ?META339, id 0)
                simple apply @trans_contra_co_morphism(level 1, pattern 
                Proper
                  (respectful (Basics.flip ?META287)
                     (respectful ?META287 Basics.impl)) 
                  ?META287, id 0)
                simple apply @subrelation_id_proper(level 1, pattern 
                Proper (respectful ?META267 ?META268) id, id 0)
                simple apply SetoidList.InfA_compat(level 2, pattern 
                Proper
                  (respectful ?META798 (SetoidList.eqlistA ?META798 ==> iff))
                  (Sorted.HdRel ?META800), id 0)
                simple apply @Morphisms_Prop.Acc_pt_morphism(level 2, pattern 
                Proper (respectful ?META722 iff) (Acc ?META723), id 0)
                (*external*) (class_apply @proper_flip_proper)(level 2, pattern 
                Proper (Basics.flip _) _, id 0)
                simple apply @trans_co_eq_inv_impl_morphism(level 2, pattern 
                Proper
                  (respectful ?META333
                     (respectful eq (Basics.flip Basics.impl))) 
                  ?META333, id 0)
                simple apply @per_partial_app_morphism(level 2, pattern 
                Proper (respectful ?META325 iff) (?META325 ?META327), id 0)
                simple eapply @PartialOrder_proper(level 3, pattern 
                Proper (respectful ?META371 (respectful ?META371 iff))
                  ?META373, id 0)
                simple apply @trans_sym_contra_impl_morphism(level 3, pattern 
                Proper (respectful (Basics.flip ?META317) Basics.impl)
                  (?META317 ?META319), id 0)
                simple apply @trans_sym_co_inv_impl_morphism(level 3, pattern 
                Proper (respectful ?META309 (Basics.flip Basics.impl))
                  (?META309 ?META311), id 0)
                simple apply @trans_co_impl_morphism(level 3, pattern 
                Proper (respectful ?META301 Basics.impl) 
                  (?META301 ?META303), id 0)
                simple apply @trans_contra_inv_impl_morphism(level 3, pattern 
                Proper
                  (respectful (Basics.flip ?META293)
                     (Basics.flip Basics.impl)) (?META293 ?META295), id 0)
                (*external*) partial_application_tactic(level 4, pattern 
                Proper _ _, id 0)
                (*external*) proper_subrelation(level 5, pattern 
                Proper ?H _, id 0)
                (*external*) proper_normalization(level 6, pattern 
                Proper _ _, id 0)
                (*external*) proper_reflexive(level 7, pattern 
                Proper _ _, id 0)
                exact Permutation.Permutation_list_max(level 10, pattern 
                Proper (Permutation.Permutation (A:=nat) ==> eq)
                  List.list_max, id 0)
                exact Permutation.Permutation_list_sum(level 10, pattern 
                Proper (Permutation.Permutation (A:=nat) ==> eq)
                  List.list_sum, id 0)
                simple apply Permutation.Permutation_length'(level 10, pattern 
                Proper (Permutation.Permutation (A:=?META1091) ==> eq)
                  (length (A:=?META1091)), id 0) 
For Asymmetric ->   simple apply @StrictOrder_Asymmetric(level 1, pattern 
                    Asymmetric ?META233, id 0)
                    (*external*) (class_apply @flip_Asymmetric)(level 3, pattern 
                    Asymmetric (Basics.flip _), id 0) 
For Irreflexive ->   simple apply @StrictOrder_Irreflexive(level 1, pattern 
                     Irreflexive ?META221, id 0)
                     (*external*) (class_apply @flip_Irreflexive)(level 3, pattern 
                     Irreflexive (Basics.flip _), id 0)
                     (*external*) (class_apply @complement_Irreflexive)(level 3, pattern 
                     Irreflexive (complement _), id 0) 
For CRelationClasses.Transitive ->   exact CRelationClasses.iffT_Transitive(level 0, pattern 
                                     CRelationClasses.Transitive
                                       CRelationClasses.iffT, id 0)
                                     exact CRelationClasses.arrow_Transitive(level 0, pattern 
                                     CRelationClasses.Transitive
                                       CRelationClasses.arrow, id 0)
                                     exact CRelationClasses.iff_Transitive(level 0, pattern 
                                     CRelationClasses.Transitive iff, id 0)
                                     exact CRelationClasses.impl_Transitive(level 0, pattern 
                                     CRelationClasses.Transitive Basics.impl, id 0)
                                     simple apply @CRelationClasses.eq_Transitive(level 0, pattern 
                                     CRelationClasses.Transitive eq, id 0)
                                     simple apply @CRelationClasses.Equivalence_Transitive(level 1, pattern 
                                     CRelationClasses.Transitive 
                                       ?META215, id 0)
                                     simple apply @CRelationClasses.StrictOrder_Transitive(level 1, pattern 
                                     CRelationClasses.Transitive 
                                       ?META179, id 0)
                                     simple apply @CRelationClasses.PreOrder_Transitive(level 2, pattern 
                                     CRelationClasses.Transitive 
                                       ?META167, id 0)
                                     (*external*) (
                                     class_apply
                                      @CRelationClasses.flip_Transitive)(level 3, pattern 
                                     CRelationClasses.Transitive
                                       (CRelationClasses.flip _), id 0)
                                     simple apply @CRelationClasses.PER_Transitive(level 3, pattern 
                                     CRelationClasses.Transitive 
                                       ?META197, id 0) 
For CMorphisms.Proper ->   simple apply @CMorphisms.proper_proper(level 0, pattern 
                           CMorphisms.Proper
                             (CMorphisms.respectful
                                CRelationClasses.relation_equivalence
                                (CMorphisms.respectful eq
                                   CRelationClasses.iffT)) CMorphisms.Proper, id 0)
                           simple apply @CMorphisms.respectful_morphism(level 0, pattern 
                           CMorphisms.Proper
                             (CMorphisms.respectful
                                CRelationClasses.relation_equivalence
                                (CMorphisms.respectful
                                   CRelationClasses.relation_equivalence
                                   CRelationClasses.relation_equivalence))
                             CMorphisms.respectful, id 0)
                           simple apply CMorphisms.compose_proper(level 0, pattern 
                           CMorphisms.Proper
                             (CMorphisms.respectful
                                (CMorphisms.respectful ?META294 ?META295)
                                (CMorphisms.respectful
                                   (CMorphisms.respectful ?META293 ?META294)
                                   (CMorphisms.respectful ?META293 ?META295)))
                             Basics.compose, id 0)
                           simple apply @CMorphisms.proper_subrelation_proper_arrow(level 0, pattern 
                           CMorphisms.Proper
                             (CMorphisms.respectful
                                CRelationClasses.subrelation
                                (CMorphisms.respectful eq
                                   CRelationClasses.arrow)) CMorphisms.Proper, id 0)
                           (*external*) (apply @CMorphisms.flip_proper)(level 1, pattern 
                           CMorphisms.Proper _ (CRelationClasses.flip _), id 0)
                           simple apply @CMorphisms.PER_type_morphism(level 1, pattern 
                           CMorphisms.Proper
                             (CMorphisms.respectful 
                                ?META285
                                (CMorphisms.respectful 
                                   ?META285 CRelationClasses.iffT)) 
                             ?META285, id 0)
                           simple apply @CMorphisms.trans_contra_co_type_morphism(level 1, pattern 
                           CMorphisms.Proper
                             (CMorphisms.respectful
                                (CRelationClasses.flip ?META233)
                                (CMorphisms.respectful 
                                   ?META233 CRelationClasses.arrow)) 
                             ?META233, id 0)
                           simple apply @CMorphisms.subrelation_id_proper(level 1, pattern 
                           CMorphisms.Proper
                             (CMorphisms.respectful ?META213 ?META214) id, id 0)
                           (*external*) (class_apply
                                          @CMorphisms.proper_flip_proper)(level 2, pattern 
                           CMorphisms.Proper (CRelationClasses.flip _) _, id 0)
                           simple apply @CMorphisms.trans_co_eq_inv_arrow_morphism(level 2, pattern 
                           CMorphisms.Proper
                             (CMorphisms.respectful 
                                ?META279
                                (CMorphisms.respectful eq
                                   (CRelationClasses.flip
                                      CRelationClasses.arrow))) 
                             ?META279, id 0)
                           simple apply @CMorphisms.per_partial_app_type_morphism(level 2, pattern 
                           CMorphisms.Proper
                             (CMorphisms.respectful 
                                ?META271 CRelationClasses.iffT)
                             (?META271 ?META273), id 0)
                           simple eapply @CMorphisms.PartialOrder_proper_type(level 3, pattern 
                           CMorphisms.Proper
                             (CMorphisms.respectful 
                                ?META365
                                (CMorphisms.respectful 
                                   ?META365 CRelationClasses.iffT)) 
                             ?META367, id 0)
                           simple apply @CMorphisms.trans_sym_contra_arrow_morphism(level 3, pattern 
                           CMorphisms.Proper
                             (CMorphisms.respectful
                                (CRelationClasses.flip ?META263)
                                CRelationClasses.arrow) 
                             (?META263 ?META265), id 0)
                           simple apply @CMorphisms.trans_sym_co_inv_impl_type_morphism(level 3, pattern 
                           CMorphisms.Proper
                             (CMorphisms.respectful 
                                ?META255
                                (CRelationClasses.flip CRelationClasses.arrow))
                             (?META255 ?META257), id 0)
                           simple apply @CMorphisms.trans_co_impl_type_morphism(level 3, pattern 
                           CMorphisms.Proper
                             (CMorphisms.respectful 
                                ?META247 CRelationClasses.arrow)
                             (?META247 ?META249), id 0)
                           simple apply @CMorphisms.trans_contra_inv_impl_type_morphism(level 3, pattern 
                           CMorphisms.Proper
                             (CMorphisms.respectful
                                (CRelationClasses.flip ?META239)
                                (CRelationClasses.flip CRelationClasses.arrow))
                             (?META239 ?META241), id 0)
                           (*external*) CMorphisms.partial_application_tactic(level 4, pattern 
                           CMorphisms.Proper _ _, id 0)
                           (*external*) CMorphisms.proper_subrelation(level 5, pattern 
                           CMorphisms.Proper ?H _, id 0)
                           (*external*) CMorphisms.proper_normalization(level 6, pattern 
                           CMorphisms.Proper _ _, id 0)
                           (*external*) CMorphisms.proper_reflexive(level 7, pattern 
                           CMorphisms.Proper _ _, id 0) 
For CRelationClasses.subrelation ->   (*external*) (
                                      class_apply @CMorphisms.flip2)(level 1, pattern 
                                      CRelationClasses.subrelation _
                                        (CRelationClasses.flip _), id 0)
                                      (*external*) (
                                      class_apply @CMorphisms.flip1)(level 1, pattern 
                                      CRelationClasses.subrelation
                                        (CRelationClasses.flip _) _, id 0)
                                      exact CMorphisms.iffT_flip_arrow_subrelation(level 2, pattern 
                                      CRelationClasses.subrelation
                                        CRelationClasses.iffT
                                        (CRelationClasses.flip
                                           CRelationClasses.arrow), id 0)
                                      exact CMorphisms.iffT_arrow_subrelation(level 2, pattern 
                                      CRelationClasses.subrelation
                                        CRelationClasses.iffT
                                        CRelationClasses.arrow, id 0)
                                      exact CMorphisms.iff_flip_impl_subrelation(level 2, pattern 
                                      CRelationClasses.subrelation iff
                                        (CRelationClasses.flip Basics.impl), id 0)
                                      exact CMorphisms.iff_impl_subrelation(level 2, pattern 
                                      CRelationClasses.subrelation iff
                                        Basics.impl, id 0)
                                      (*external*) (
                                      CMorphisms.subrelation_tac T U)(level 3, pattern 
                                      CRelationClasses.subrelation 
                                        ?T ?U, id 0)
                                      (*external*) (
                                      apply
                                       (CMorphisms.forall_subrelation B R S);
                                       intro)(level 4, pattern 
                                      CRelationClasses.subrelation
                                        (CMorphisms.forall_relation ?R)
                                        (CMorphisms.forall_relation ?S), id 0)
                                      simple apply @CMorphisms.pointwise_subrelation(level 4, pattern 
                                      CRelationClasses.subrelation
                                        (CMorphisms.pointwise_relation
                                           ?META222 
                                           ?META224)
                                        (CMorphisms.pointwise_relation
                                           ?META222 
                                           ?META225), id 0)
                                      (*external*) (
                                      class_apply
                                       @CRelationClasses.subrelation_symmetric)(level 4, pattern 
                                      CRelationClasses.subrelation
                                        (CRelationClasses.flip _) _, id 0) 
For Transitive ->   exact iff_Transitive(level 0, pattern 
                    Transitive iff, id 0)
                    exact impl_Transitive(level 0, pattern 
                    Transitive Basics.impl, id 0)
                    simple apply @eq_Transitive(level 0, pattern 
                    Transitive eq, id 0)
                    simple apply @Equivalence.equiv_transitive(level 1, pattern 
                    Transitive Equivalence.equiv, id 0)
                    simple apply @Equivalence_Transitive(level 1, pattern 
                    Transitive ?META263, id 0)
                    simple apply @StrictOrder_Transitive(level 1, pattern 
                    Transitive ?META227, id 0)
                    simple apply @PreOrder_Transitive(level 2, pattern 
                    Transitive ?META215, id 0)
                    (*external*) (class_apply @flip_Transitive)(level 3, pattern 
                    Transitive (Basics.flip _), id 0)
                    simple apply @PER_Transitive(level 3, pattern 
                    Transitive ?META245, id 0)
                    exact Z.divide_transitive(level 5, pattern 
                    Transitive Z.divide, id 0)
                    exact N.divide_transitive(level 5, pattern 
                    Transitive N.divide, id 0)
                    exact Nat.divide_transitive(level 5, pattern 
                    Transitive Nat.divide, id 0)
                    simple apply @Equivalence.pointwise_transitive(level 9, pattern 
                    Transitive (pointwise_relation ?META419 ?META421), id 0) 
For CRelationClasses.PartialOrder ->   (*external*) (
                                       class_apply
                                        @CRelationClasses.PartialOrder_inverse)(level 3, pattern 
                                       CRelationClasses.PartialOrder
                                         (CRelationClasses.flip _), id 0)
                                       (*external*) (
                                       class_apply
                                        @CMorphisms.StrictOrder_PartialOrder)(level 4, pattern 
                                       CRelationClasses.PartialOrder _
                                         (CRelationClasses.relation_disjunction
                                            _ _), id 0) 
For subrelation ->   simple apply SetoidList.eqlistA_equivlistA(level 1, pattern 
                     subrelation (SetoidList.eqlistA ?META774)
                       (SetoidList.equivlistA ?META774), id 0)
                     (*external*) (class_apply @flip2)(level 1, pattern 
                     subrelation _ (Basics.flip _), id 0)
                     (*external*) (class_apply @flip1)(level 1, pattern 
                     subrelation (Basics.flip _) _, id 0)
                     exact iff_flip_impl_subrelation(level 2, pattern 
                     subrelation iff (Basics.flip Basics.impl), id 0)
                     exact iff_impl_subrelation(level 2, pattern 
                     subrelation iff Basics.impl, id 0)
                     (*external*) (subrelation_tac T U)(level 3, pattern 
                     subrelation ?T ?U, id 0)
                     (*external*) (apply (forall_subrelation B R S); intro)(level 4, pattern 
                     subrelation (forall_relation ?R) 
                       (forall_relation ?S), id 0)
                     simple apply @pointwise_subrelation(level 4, pattern 
                     subrelation (pointwise_relation ?META276 ?META278)
                       (pointwise_relation ?META276 ?META279), id 0)
                     (*external*) (class_apply @subrelation_symmetric)(level 4, pattern 
                     subrelation (Basics.flip _) _, id 0) 
For Normalizes ->   (*external*) normalizes(level 1, pattern 
                    Normalizes _ _ _, id 0) 
For Idempotent ->   exact aac_Zmax_Idem(level 0, pattern 
                    Idempotent eq BinIntDef.Z.max, id 0)
                    exact aac_Zmin_Idem(level 0, pattern 
                    Idempotent eq BinIntDef.Z.min, id 0) 
For ProperProxy ->   (*external*) (class_apply @eq_proper_proxy ||
                                     class_apply @reflexive_proper_proxy)(level 1, pattern 
                     ProperProxy _ _, id 0)
                     (*external*) (not_evar R;
                                    class_apply @proper_proper_proxy)(level 2, pattern 
                     ProperProxy ?R _, id 0) 
For PartialOrder ->   exact Z.le_partialorder(level 0, pattern 
                      PartialOrder eq Z.le, id 0)
                      exact N.le_partialorder(level 0, pattern 
                      PartialOrder eq N.le, id 0)
                      exact Pos.le_partorder(level 0, pattern 
                      PartialOrder eq Pos.le, id 0)
                      exact Nat.le_partialorder(level 0, pattern 
                      PartialOrder eq le, id 0)
                      simple apply @subrelation_partial_order(level 0, pattern 
                      PartialOrder relation_equivalence subrelation, id 0)
                      (*external*) (class_apply @PartialOrder_inverse)(level 3, pattern 
                      PartialOrder (Basics.flip _), id 0)
                      (*external*) (class_apply @StrictOrder_PartialOrder)(level 4, pattern 
                      PartialOrder _ (relation_disjunction _ _), id 0) 
For CRelationClasses.Symmetric ->   exact CRelationClasses.iffT_Symmetric(level 0, pattern 
                                    CRelationClasses.Symmetric
                                      CRelationClasses.iffT, id 0)
                                    exact CRelationClasses.iff_Symmetric(level 0, pattern 
                                    CRelationClasses.Symmetric iff, id 0)
                                    simple apply @CRelationClasses.eq_Symmetric(level 0, pattern 
                                    CRelationClasses.Symmetric eq, id 0)
                                    simple apply @CRelationClasses.Equivalence_Symmetric(level 1, pattern 
                                    CRelationClasses.Symmetric 
                                      ?META209, id 0)
                                    (*external*) (
                                    class_apply
                                     @CRelationClasses.flip_Symmetric)(level 3, pattern 
                                    CRelationClasses.Symmetric
                                      (CRelationClasses.flip _), id 0)
                                    (*external*) (
                                    class_apply
                                     @CRelationClasses.complement_Symmetric)(level 3, pattern 
                                    CRelationClasses.Symmetric
                                      (CRelationClasses.complement _), id 0)
                                    simple apply @CRelationClasses.PER_Symmetric(level 3, pattern 
                                    CRelationClasses.Symmetric 
                                      ?META191, id 0) 
For CRelationClasses.Antisymmetric ->   simple eapply @CRelationClasses.partial_order_antisym(level 2, pattern 
                                        CRelationClasses.Antisymmetric
                                          ?META265 
                                          ?META267, id 0)
                                        (*external*) (
                                        class_apply
                                         @CRelationClasses.flip_Antisymmetric)(level 3, pattern 
                                        CRelationClasses.Antisymmetric
                                          (CRelationClasses.flip _), id 0) 
For ZifyClasses.BinRel ->   exact ZifyInst.Op_eqZ(level 0, pattern 
                            ZifyClasses.BinRel eq, id 0)
                            exact ZifyInst.Op_Z_le(level 0, pattern 
                            ZifyClasses.BinRel Z.le, id 0)
                            exact ZifyInst.Op_Z_gt(level 0, pattern 
                            ZifyClasses.BinRel Z.gt, id 0)
                            exact ZifyInst.Op_Z_lt(level 0, pattern 
                            ZifyClasses.BinRel Z.lt, id 0)
                            exact ZifyInst.Op_Z_ge(level 0, pattern 
                            ZifyClasses.BinRel Z.ge, id 0)
                            exact ZifyInst.Op_eq_N(level 0, pattern 
                            ZifyClasses.BinRel eq, id 0)
                            exact ZifyInst.Op_N_le(level 0, pattern 
                            ZifyClasses.BinRel N.le, id 0)
                            exact ZifyInst.Op_N_gt(level 0, pattern 
                            ZifyClasses.BinRel N.gt, id 0)
                            exact ZifyInst.Op_N_lt(level 0, pattern 
                            ZifyClasses.BinRel N.lt, id 0)
                            exact ZifyInst.Op_N_ge(level 0, pattern 
                            ZifyClasses.BinRel N.ge, id 0)
                            exact ZifyInst.Op_eq_pos(level 0, pattern 
                            ZifyClasses.BinRel eq, id 0)
                            exact ZifyInst.Op_pos_le(level 0, pattern 
                            ZifyClasses.BinRel Pos.le, id 0)
                            exact ZifyInst.Op_pos_gt(level 0, pattern 
                            ZifyClasses.BinRel Pos.gt, id 0)
                            exact ZifyInst.Op_pos_lt(level 0, pattern 
                            ZifyClasses.BinRel Pos.lt, id 0)
                            exact ZifyInst.Op_pos_ge(level 0, pattern 
                            ZifyClasses.BinRel Pos.ge, id 0)
                            exact ZifyInst.Op_Nat_eq(level 0, pattern 
                            ZifyClasses.BinRel Nat.eq, id 0)
                            exact ZifyInst.Op_eq_nat(level 0, pattern 
                            ZifyClasses.BinRel eq, id 0)
                            exact ZifyInst.Op_Nat_le(level 0, pattern 
                            ZifyClasses.BinRel Nat.le, id 0)
                            exact ZifyInst.Op_le(level 0, pattern 
                            ZifyClasses.BinRel le, id 0)
                            exact ZifyInst.Op_gt(level 0, pattern 
                            ZifyClasses.BinRel gt, id 0)
                            exact ZifyInst.Op_Nat_lt(level 0, pattern 
                            ZifyClasses.BinRel Nat.lt, id 0)
                            exact ZifyInst.Op_lt(level 0, pattern 
                            ZifyClasses.BinRel lt, id 0)
                            exact ZifyInst.Op_ge(level 0, pattern 
                            ZifyClasses.BinRel ge, id 0) 
For SetoidTactics.DefaultRelation ->   simple apply @SetoidTactics.equivalence_default(level 4, pattern 
                                       SetoidTactics.DefaultRelation 
                                         ?META473, id 0) 
For ZifyClasses.InjTyp ->   exact ZifyInst.Inj_N_Z(level 0, pattern 
                            ZifyClasses.InjTyp N Z, id 0)
                            exact ZifyInst.Inj_pos_Z(level 0, pattern 
                            ZifyClasses.InjTyp positive Z, id 0)
                            exact ZifyInst.Inj_nat_Z(level 0, pattern 
                            ZifyClasses.InjTyp nat Z, id 0)
                            exact ZifyInst.Inj_Z_Z(level 0, pattern 
                            ZifyClasses.InjTyp Z Z, id 0) 
For CRelationClasses.PreOrder ->   simple apply @CRelationClasses.relation_implication_preorder(level 0, pattern 
                                   CRelationClasses.PreOrder
                                     CRelationClasses.subrelation, id 0)
                                   (*external*) (class_apply
                                                 @CRelationClasses.flip_PreOrder)(level 3, pattern 
                                   CRelationClasses.PreOrder
                                     (CRelationClasses.flip _), id 0)
                                   (*external*) (class_apply
                                                 @CMorphisms.StrictOrder_PreOrder)(level 4, pattern 
                                   CRelationClasses.PreOrder
                                     (CRelationClasses.relation_disjunction _
                                        _), id 0) 
For CRelationClasses.Equivalence ->   simple apply @CRelationClasses.relation_equivalence_equivalence(level 0, pattern 
                                      CRelationClasses.Equivalence
                                        CRelationClasses.relation_equivalence, id 0)
                                      exact CRelationClasses.iff_equivalence(level 0, pattern 
                                      CRelationClasses.Equivalence iff, id 0)
                                      simple apply @CRelationClasses.eq_equivalence(level 10, pattern 
                                      CRelationClasses.Equivalence eq, id 0) 
For PreOrder ->   exact preorder_Zle(level 0, pattern 
                  PreOrder Z.le, id 0)
                  exact Z.le_preorder(level 0, pattern 
                  PreOrder Z.le, id 0)
                  exact N.le_preorder(level 0, pattern 
                  PreOrder N.le, id 0)
                  exact Pos.le_preorder(level 0, pattern 
                  PreOrder Pos.le, id 0)
                  exact Nat.le_preorder(level 0, pattern 
                  PreOrder le, id 0)
                  simple apply @relation_implication_preorder(level 0, pattern 
                  PreOrder subrelation, id 0)
                  simple apply @predicate_implication_preorder(level 0, pattern 
                  PreOrder predicate_implication, id 0)
                  (*external*) (class_apply @flip_PreOrder)(level 3, pattern 
                  PreOrder (Basics.flip _), id 0)
                  (*external*) (class_apply @StrictOrder_PreOrder)(level 4, pattern 
                  PreOrder (relation_disjunction _ _), id 0)
                  simple apply @Equivalence_PreOrder(level 10, pattern 
                  PreOrder ?META275, id 0) 
For CRelationClasses.PER ->   simple apply @CRelationClasses.Equivalence_PER(level 10, pattern 
                              CRelationClasses.PER 
                                ?META221, id 0) 
For ZifyClasses.BinOpSpec ->   exact ZifyInst.ZminSpec(level 0, pattern 
                               ZifyClasses.BinOpSpec BinIntDef.Z.min, id 0)
                               exact ZifyInst.ZmaxSpec(level 0, pattern 
                               ZifyClasses.BinOpSpec BinIntDef.Z.max, id 0) 
For Equivalence ->   exact Qminmax.Q.OT.eq_equiv(level 0, pattern 
                     Equivalence QArith_base.Qeq, id 0)
                     exact QOrderedType.QOrder.TO.eq_equiv(level 0, pattern 
                     Equivalence QArith_base.Qeq, id 0)
                     simple apply FMapPositive.PositiveMap.eqke_equiv(level 0, pattern 
                     Equivalence
                       (FMapPositive.PositiveMap.eq_key_elt (A:=?META1651)), id 0)
                     simple apply FMapPositive.PositiveMap.eqk_equiv(level 0, pattern 
                     Equivalence
                       (FMapPositive.PositiveMap.eq_key (A:=?META1649)), id 0)
                     simple apply FMapPositive.PositiveMap.ME.eqke_equiv(level 0, pattern 
                     Equivalence
                       (FMapPositive.PositiveMap.ME.eqke (elt:=?META917)), id 0)
                     simple apply FMapPositive.PositiveMap.ME.eqk_equiv(level 0, pattern 
                     Equivalence
                       (FMapPositive.PositiveMap.ME.eqk (elt:=?META915)), id 0)
                     exact FMapPositive.PositiveMap.ME.MO.eq_equiv(level 0, pattern 
                     Equivalence eq, id 0)
                     simple apply Permutation.Permutation_Equivalence(level 0, pattern 
                     Equivalence (Permutation.Permutation (A:=?META1081)), id 0)
                     exact QArith_base.Q_Setoid(level 0, pattern 
                     Equivalence QArith_base.Qeq, id 0)
                     exact Ndigits.eqf_equiv(level 0, pattern 
                     Equivalence Ndigits.eqf, id 0)
                     exact Z.eqf_equiv(level 0, pattern 
                     Equivalence Z.eqf, id 0)
                     exact N.eqf_equiv(level 0, pattern 
                     Equivalence N.eqf, id 0)
                     exact Nat.eqf_equiv(level 0, pattern 
                     Equivalence Nat.eqf, id 0)
                     simple apply @relation_equivalence_equivalence(level 0, pattern 
                     Equivalence relation_equivalence, id 0)
                     simple apply @predicate_equivalence_equivalence(level 0, pattern 
                     Equivalence predicate_equivalence, id 0)
                     exact iff_equivalence(level 0, pattern 
                     Equivalence iff, id 0)
                     simple apply SetoidList.eqlistA_equiv(level 1, pattern 
                     Equivalence (SetoidList.eqlistA ?META768), id 0)
                     simple apply SetoidList.equivlist_equiv(level 1, pattern 
                     Equivalence (SetoidList.equivlistA ?META762), id 0)
                     simple apply @Equivalence.pointwise_equivalence(level 9, pattern 
                     Equivalence (pointwise_relation ?META427 ?META429), id 0)
                     simple apply @eq_equivalence(level 10, pattern 
                     Equivalence eq, id 0)
                     simple apply Permutation.Permutation_transp_equiv(level 100, pattern 
                     Equivalence
                       (Permutation.Permutation_transp (A:=?META1115)), id 0) 
For PER ->   simple apply @Equivalence_PER(level 10, pattern 
             PER ?META269, id 0) 
For Unit ->   exact aac_zero_Zplus(level 0, pattern 
              Unit eq BinIntDef.Z.add 0, id 0)
              exact aac_one(level 0, pattern Unit eq BinIntDef.Z.mul 1, id 0) 
For CRelationClasses.StrictOrder ->   (*external*) (
                                      class_apply
                                       @CRelationClasses.flip_StrictOrder)(level 3, pattern 
                                      CRelationClasses.StrictOrder
                                        (CRelationClasses.flip _), id 0)
                                      (*external*) (
                                      class_apply
                                       @CMorphisms.PartialOrder_StrictOrder)(level 4, pattern 
                                      CRelationClasses.StrictOrder
                                        (CRelationClasses.relation_conjunction
                                           _ _), id 0) 
For ZifyClasses.Saturate ->   exact ZifyInst.SatPowNonneg(level 0, pattern 
                              ZifyClasses.Saturate BinIntDef.Z.pow, id 0)
                              exact ZifyInst.SatPowPos(level 0, pattern 
                              ZifyClasses.Saturate BinIntDef.Z.pow, id 0) 
For AAC_lift ->   exact lift_le_eq(level 0, pattern 
                  AAC_lift Z.le eq, id 0)
                  simple apply @aac_lift_subrelation(level 3, pattern 
                  AAC_lift ?META1678 ?META1679, id 0)
                  simple apply @aac_lift_proper(level 4, pattern 
                  AAC_lift ?META1690 ?META1691, id 0) 
For DeclConstant.GT ->   simple apply @DeclConstant.GT_O(level 1, pattern 
                         DeclConstant.GT ?META727, id 0)
                         simple apply @DeclConstant.GT_APP1(level 2, pattern 
                         DeclConstant.GT (?META734 ?META735), id 0)
                         simple apply @DeclConstant.GT_APP2(level 3, pattern 
                         DeclConstant.GT (?META747 ?META748 ?META749), id 0) 
For CRelationClasses.RewriteRelation ->   simple apply @CRelationClasses.RewriteRelation_instance_2(level 0, pattern 
                                          CRelationClasses.RewriteRelation
                                            CRelationClasses.relation_equivalence, id 0)
                                          exact CRelationClasses.RewriteRelation_instance_1(level 0, pattern 
                                          CRelationClasses.RewriteRelation
                                            iff, id 0)
                                          exact CRelationClasses.RewriteRelation_instance_0(level 0, pattern 
                                          CRelationClasses.RewriteRelation
                                            Basics.impl, id 0)
                                          simple apply @CRelationClasses.equivalence_rewrite_crelation(level 1, pattern 
                                          CRelationClasses.RewriteRelation
                                            ?META227, id 0) 
For StrictOrder ->   exact Qminmax.Q.OT.lt_strorder(level 0, pattern 
                     StrictOrder QArith_base.Qlt, id 0)
                     exact QOrderedType.QOrder.TO.lt_strorder(level 0, pattern 
                     StrictOrder QArith_base.Qlt, id 0)
                     exact QOrderedType.Q_as_OT.lt_strorder(level 0, pattern 
                     StrictOrder QArith_base.Qlt, id 0)
                     simple apply FMapPositive.PositiveMap.ltk_strorder(level 0, pattern 
                     StrictOrder
                       (FMapPositive.PositiveMap.lt_key (A:=?META1653)), id 0)
                     simple apply FMapPositive.PositiveMap.ME.ltk_strorder(level 0, pattern 
                     StrictOrder
                       (FMapPositive.PositiveMap.ME.ltk (elt:=?META919)), id 0)
                     exact FMapPositive.PositiveMap.ME.MO.lt_strorder(level 0, pattern 
                     StrictOrder
                       OrderedTypeEx.PositiveOrderedTypeBits.bits_lt, id 0)
                     exact Z.lt_strorder(level 0, pattern 
                     StrictOrder Z.lt, id 0)
                     exact N.lt_strorder(level 0, pattern 
                     StrictOrder N.lt, id 0)
                     exact Pos.lt_strorder(level 0, pattern 
                     StrictOrder Pos.lt, id 0)
                     exact Nat.lt_strorder(level 0, pattern 
                     StrictOrder lt, id 0)
                     (*external*) (class_apply @flip_StrictOrder)(level 3, pattern 
                     StrictOrder (Basics.flip _), id 0)
                     (*external*) (class_apply @PartialOrder_StrictOrder)(level 4, pattern 
                     StrictOrder (relation_conjunction _ _), id 0) 
For ZifyClasses.UnOpSpec ->   exact ZifyInst.ZabsSpec(level 0, pattern 
                              ZifyClasses.UnOpSpec BinIntDef.Z.abs, id 0)
                              exact ZifyInst.ZsgnSpec(level 0, pattern 
                              ZifyClasses.UnOpSpec BinIntDef.Z.sgn, id 0) 
For DeclConstant.DeclaredConstant ->   exact DeclConstant.DQ(level 0, pattern 
                                       DeclConstant.DeclaredConstant
                                         QArith_base.Qmake, id 0)
                                       exact DeclConstant.DZpow(level 0, pattern 
                                       DeclConstant.DeclaredConstant
                                         BinIntDef.Z.pow, id 0)
                                       exact DeclConstant.DZpow_pos(level 0, pattern 
                                       DeclConstant.DeclaredConstant
                                         BinIntDef.Z.pow_pos, id 0)
                                       exact DeclConstant.DZneg(level 0, pattern 
                                       DeclConstant.DeclaredConstant 
                                         (-1), id 0)
                                       exact DeclConstant.DZpos(level 0, pattern 
                                       DeclConstant.DeclaredConstant Z.pos, id 0)
                                       exact DeclConstant.DZO(level 0, pattern 
                                       DeclConstant.DeclaredConstant 0, id 0)
                                       exact DeclConstant.DxO(level 0, pattern 
                                       DeclConstant.DeclaredConstant xO, id 0)
                                       exact DeclConstant.DxI(level 0, pattern 
                                       DeclConstant.DeclaredConstant xI, id 0)
                                       exact DeclConstant.DxH(level 0, pattern 
                                       DeclConstant.DeclaredConstant
                                         1%positive, id 0)
                                       exact DeclConstant.DS(level 0, pattern 
                                       DeclConstant.DeclaredConstant S, id 0)
                                       exact DeclConstant.DO(level 0, pattern 
                                       DeclConstant.DeclaredConstant 0%nat, id 0)
                                       
For RewriteRelation ->   simple apply @RewriteRelation_instance_2(level 0, pattern 
                         RewriteRelation relation_equivalence, id 0)
                         exact RewriteRelation_instance_1(level 0, pattern 
                         RewriteRelation iff, id 0)
                         exact RewriteRelation_instance_0(level 0, pattern 
                         RewriteRelation Basics.impl, id 0)
                         simple apply @equivalence_rewrite_relation(level 1, pattern 
                         RewriteRelation ?META281, id 0) 
For ZifyClasses.UnOp ->   exact ZifyInst.Op_Z_to_pos(level 0, pattern 
                          ZifyClasses.UnOp BinIntDef.Z.to_pos, id 0)
                          exact ZifyInst.Op_Z_to_nat(level 0, pattern 
                          ZifyClasses.UnOp BinIntDef.Z.to_nat, id 0)
                          exact ZifyInst.Op_Z_quot2(level 0, pattern 
                          ZifyClasses.UnOp BinIntDef.Z.quot2, id 0)
                          exact ZifyInst.Op_Z_div2(level 0, pattern 
                          ZifyClasses.UnOp BinIntDef.Z.div2, id 0)
                          exact ZifyInst.Op_Z_square(level 0, pattern 
                          ZifyClasses.UnOp BinIntDef.Z.square, id 0)
                          exact ZifyInst.Op_Z_succ_double(level 0, pattern 
                          ZifyClasses.UnOp BinIntDef.Z.succ_double, id 0)
                          exact ZifyInst.Op_Z_pred_double(level 0, pattern 
                          ZifyClasses.UnOp BinIntDef.Z.pred_double, id 0)
                          exact ZifyInst.Op_Z_double(level 0, pattern 
                          ZifyClasses.UnOp BinIntDef.Z.double, id 0)
                          exact ZifyInst.Op_Z_sgn(level 0, pattern 
                          ZifyClasses.UnOp BinIntDef.Z.sgn, id 0)
                          exact ZifyInst.Op_Z_abs(level 0, pattern 
                          ZifyClasses.UnOp BinIntDef.Z.abs, id 0)
                          exact ZifyInst.Op_Z_opp(level 0, pattern 
                          ZifyClasses.UnOp BinIntDef.Z.opp, id 0)
                          exact ZifyInst.Op_Z_pred(level 0, pattern 
                          ZifyClasses.UnOp BinIntDef.Z.pred, id 0)
                          exact ZifyInst.Op_Z_succ(level 0, pattern 
                          ZifyClasses.UnOp BinIntDef.Z.succ, id 0)
                          exact ZifyInst.Op_N_square(level 0, pattern 
                          ZifyClasses.UnOp BinNatDef.N.square, id 0)
                          exact ZifyInst.Op_N_div2(level 0, pattern 
                          ZifyClasses.UnOp BinNatDef.N.div2, id 0)
                          exact ZifyInst.Op_N_succ_pos(level 0, pattern 
                          ZifyClasses.UnOp BinNatDef.N.succ_pos, id 0)
                          exact ZifyInst.Op_N_double(level 0, pattern 
                          ZifyClasses.UnOp BinNatDef.N.double, id 0)
                          exact ZifyInst.Op_N_succ_double(level 0, pattern 
                          ZifyClasses.UnOp BinNatDef.N.succ_double, id 0)
                          exact ZifyInst.Op_N_succ(level 0, pattern 
                          ZifyClasses.UnOp BinNatDef.N.succ, id 0)
                          exact ZifyInst.Op_N_pred(level 0, pattern 
                          ZifyClasses.UnOp BinNatDef.N.pred, id 0)
                          exact ZifyInst.Op_N_pos(level 0, pattern 
                          ZifyClasses.UnOp N.pos, id 0)
                          exact ZifyInst.Op_Z_abs_N(level 0, pattern 
                          ZifyClasses.UnOp BinIntDef.Z.abs_N, id 0)
                          exact ZifyInst.Op_N_of_nat(level 0, pattern 
                          ZifyClasses.UnOp BinNatDef.N.of_nat, id 0)
                          exact ZifyInst.Op_N_Npos(level 0, pattern 
                          ZifyClasses.UnOp N.pos, id 0)
                          exact ZifyInst.Op_Z_of_nat(level 0, pattern 
                          ZifyClasses.UnOp BinIntDef.Z.of_nat, id 0)
                          exact ZifyInst.Op_xI(level 0, pattern 
                          ZifyClasses.UnOp xI, id 0)
                          exact ZifyInst.Op_xO(level 0, pattern 
                          ZifyClasses.UnOp xO, id 0)
                          exact ZifyInst.Op_Pos_Ndouble(level 0, pattern 
                          ZifyClasses.UnOp BinPosDef.Pos.Ndouble, id 0)
                          exact ZifyInst.Op_Pos_Nsucc_double(level 0, pattern 
                          ZifyClasses.UnOp BinPosDef.Pos.Nsucc_double, id 0)
                          exact ZifyInst.Op_pos_square(level 0, pattern 
                          ZifyClasses.UnOp BinPosDef.Pos.square, id 0)
                          exact ZifyInst.Op_pos_of_nat(level 0, pattern 
                          ZifyClasses.UnOp BinPosDef.Pos.of_nat, id 0)
                          exact ZifyInst.Op_pos_of_succ_nat(level 0, pattern 
                          ZifyClasses.UnOp BinPosDef.Pos.of_succ_nat, id 0)
                          exact ZifyInst.Op_pos_predN(level 0, pattern 
                          ZifyClasses.UnOp BinPosDef.Pos.pred_N, id 0)
                          exact ZifyInst.Op_pos_pred(level 0, pattern 
                          ZifyClasses.UnOp BinPosDef.Pos.pred, id 0)
                          exact ZifyInst.Op_pos_pred_double(level 0, pattern 
                          ZifyClasses.UnOp BinPosDef.Pos.pred_double, id 0)
                          exact ZifyInst.Op_pos_succ(level 0, pattern 
                          ZifyClasses.UnOp BinPosDef.Pos.succ, id 0)
                          exact ZifyInst.Op_Z_pos(level 0, pattern 
                          ZifyClasses.UnOp Z.pos, id 0)
                          exact ZifyInst.Op_Z_neg(level 0, pattern 
                          ZifyClasses.UnOp (-1), id 0)
                          exact ZifyInst.Op_Z_to_N(level 0, pattern 
                          ZifyClasses.UnOp BinIntDef.Z.to_N, id 0)
                          exact ZifyInst.Op_Z_of_N(level 0, pattern 
                          ZifyClasses.UnOp BinIntDef.Z.of_N, id 0)
                          exact ZifyInst.Op_N_to_nat(level 0, pattern 
                          ZifyClasses.UnOp BinNatDef.N.to_nat, id 0)
                          exact ZifyInst.Op_pos_to_nat(level 0, pattern 
                          ZifyClasses.UnOp BinPosDef.Pos.to_nat, id 0)
                          exact ZifyInst.Op_Z_abs_nat(level 0, pattern 
                          ZifyClasses.UnOp BinIntDef.Z.abs_nat, id 0)
                          exact ZifyInst.Op_S(level 0, pattern 
                          ZifyClasses.UnOp S, id 0)
                          exact ZifyInst.Op_pred(level 0, pattern 
                          ZifyClasses.UnOp Init.Nat.pred, id 0) 
For ZifyClasses.BinOp ->   exact ZifyInst.Op_Z_pow_pos(level 0, pattern 
                           ZifyClasses.BinOp BinIntDef.Z.pow_pos, id 0)
                           exact ZifyInst.Op_Z_pow(level 0, pattern 
                           ZifyClasses.BinOp BinIntDef.Z.pow, id 0)
                           exact ZifyInst.Op_Z_quot(level 0, pattern 
                           ZifyClasses.BinOp BinIntDef.Z.quot, id 0)
                           exact ZifyInst.Op_Z_rem(level 0, pattern 
                           ZifyClasses.BinOp BinIntDef.Z.rem, id 0)
                           exact ZifyInst.Op_Z_mod(level 0, pattern 
                           ZifyClasses.BinOp BinIntDef.Z.modulo, id 0)
                           exact ZifyInst.Op_Z_div(level 0, pattern 
                           ZifyClasses.BinOp BinIntDef.Z.div, id 0)
                           exact ZifyInst.Op_Z_sub(level 0, pattern 
                           ZifyClasses.BinOp BinIntDef.Z.sub, id 0)
                           exact ZifyInst.Op_Z_mul(level 0, pattern 
                           ZifyClasses.BinOp BinIntDef.Z.mul, id 0)
                           exact ZifyInst.Op_Z_max(level 0, pattern 
                           ZifyClasses.BinOp BinIntDef.Z.max, id 0)
                           exact ZifyInst.Op_Z_min(level 0, pattern 
                           ZifyClasses.BinOp BinIntDef.Z.min, id 0)
                           exact ZifyInst.Op_Z_add(level 0, pattern 
                           ZifyClasses.BinOp BinIntDef.Z.add, id 0)
                           exact ZifyInst.Op_N_pow(level 0, pattern 
                           ZifyClasses.BinOp BinNatDef.N.pow, id 0)
                           exact ZifyInst.Op_N_mod(level 0, pattern 
                           ZifyClasses.BinOp BinNatDef.N.modulo, id 0)
                           exact ZifyInst.Op_N_div(level 0, pattern 
                           ZifyClasses.BinOp BinNatDef.N.div, id 0)
                           exact ZifyInst.Op_N_sub(level 0, pattern 
                           ZifyClasses.BinOp BinNatDef.N.sub, id 0)
                           exact ZifyInst.Op_N_mul(level 0, pattern 
                           ZifyClasses.BinOp BinNatDef.N.mul, id 0)
                           exact ZifyInst.Op_N_max(level 0, pattern 
                           ZifyClasses.BinOp BinNatDef.N.max, id 0)
                           exact ZifyInst.Op_N_min(level 0, pattern 
                           ZifyClasses.BinOp BinNatDef.N.min, id 0)
                           exact ZifyInst.Op_N_add(level 0, pattern 
                           ZifyClasses.BinOp BinNatDef.N.add, id 0)
                           exact ZifyInst.Op_pos_pow(level 0, pattern 
                           ZifyClasses.BinOp BinPosDef.Pos.pow, id 0)
                           exact ZifyInst.Op_pos_max(level 0, pattern 
                           ZifyClasses.BinOp BinPosDef.Pos.max, id 0)
                           exact ZifyInst.Op_pos_min(level 0, pattern 
                           ZifyClasses.BinOp BinPosDef.Pos.min, id 0)
                           exact ZifyInst.Op_pos_mul(level 0, pattern 
                           ZifyClasses.BinOp BinPosDef.Pos.mul, id 0)
                           exact ZifyInst.Op_pos_sub(level 0, pattern 
                           ZifyClasses.BinOp BinPosDef.Pos.sub, id 0)
                           exact ZifyInst.Op_pos_add_carry(level 0, pattern 
                           ZifyClasses.BinOp BinPosDef.Pos.add_carry, id 0)
                           exact ZifyInst.Op_pos_add(level 0, pattern 
                           ZifyClasses.BinOp BinPosDef.Pos.add, id 0)
                           exact ZifyInst.Op_max(level 0, pattern 
                           ZifyClasses.BinOp Init.Nat.max, id 0)
                           exact ZifyInst.Op_min(level 0, pattern 
                           ZifyClasses.BinOp Init.Nat.min, id 0)
                           exact ZifyInst.Op_mul(level 0, pattern 
                           ZifyClasses.BinOp Init.Nat.mul, id 0)
                           exact ZifyInst.Op_sub(level 0, pattern 
                           ZifyClasses.BinOp Init.Nat.sub, id 0)
                           exact ZifyInst.Op_plus(level 0, pattern 
                           ZifyClasses.BinOp Init.Nat.add, id 0) 
For ZifyClasses.CstOp ->   exact ZifyInst.Op_Z_Z0(level 0, pattern 
                           ZifyClasses.CstOp 0, id 0)
                           exact ZifyInst.Op_N_N0(level 0, pattern 
                           ZifyClasses.CstOp 0%N, id 0)
                           exact ZifyInst.Op_xH(level 0, pattern 
                           ZifyClasses.CstOp 1%positive, id 0)
                           exact ZifyInst.Op_O(level 0, pattern 
                           ZifyClasses.CstOp 0%nat, id 0) 

(lift_reflexivity
   (let env_sym :=
      sigma_get
        {|
          Internal.Sym.ar := 0;
          Internal.Sym.value := b;
          Internal.Sym.morph := proper_eq b
        |}
        (sigma_add 1%positive
           {|
             Internal.Sym.ar := 0;
             Internal.Sym.value := a;
             Internal.Sym.morph := proper_eq a
           |} (sigma_empty Internal.Sym.pack)) in
    let env_bin :=
      sigma_get
        {|
          Internal.Bin.value := Z.max;
          Internal.Bin.compat := Z.max_compat;
          Internal.Bin.assoc := aac_Zmax_Assoc;
          Internal.Bin.comm := Some aac_Zmax_Comm;
          Internal.Bin.idem := Some aac_Zmax_Idem
        |}
        (sigma_add 2%positive
           {|
             Internal.Bin.value := Z.add;
             Internal.Bin.compat := reflexive_proper Z.add;
             Internal.Bin.assoc := aac_Zplus_Assoc;
             Internal.Bin.comm := Some aac_Zplus_Comm;
             Internal.Bin.idem := None
           |} (sigma_empty Internal.Bin.pack)) in
    let env_units :=
      sigma_get
        {|
          Internal.u_value := 0;
          Internal.u_desc :=
            {| Internal.uf_idx := 2; Internal.uf_desc := aac_zero_Zplus |}
            :: nil
        |} (sigma_empty (Internal.unit_pack env_bin)) in
    let tty := Internal.T env_sym in
    let rsum := Internal.sum (e_sym:=env_sym) in
    let rprd := Internal.prd (e_sym:=env_sym) in
    let rsym := Internal.sym (e_sym:=env_sym) in
    let vnil := Internal.vnil env_sym in
    let vcons := Internal.vcons (e_sym:=env_sym) in
    let eval := Internal.eval (e_sym:=env_sym) env_units in
    let left :=
      rsum 1%positive
        (Utils.cons
           (rsum 2%positive
              (Utils.cons (rsym 1%positive vnil, 1%positive)
                 (Utils.nil (rsym 2%positive vnil, 1%positive))), 1%positive)
           (Utils.nil
              (rsum 2%positive
                 (Utils.cons (rsym 2%positive vnil, 1%positive)
                    (Utils.nil (rsym 1%positive vnil, 1%positive))),
              1%positive))) in
    let right :=
      rsum 2%positive
        (Utils.cons (rsym 1%positive vnil, 1%positive)
           (Utils.nil (rsym 2%positive vnil, 1%positive))) in
    Internal.decide env_units left right
      (eq_refl
       :
       Internal.compare (Internal.norm env_units left)
         (Internal.norm env_units right) = Eq)
    <:
    Z.max (a + b) (b + a) = a + b))
Chars 5519 - 5542 [exists~(Neg~(quote~n)).] 40.096 secs (0.001u,0.018s)
Chars 5545 - 5564 [(apply~quote_neg_ok).] 0. secs (0.u,0.s)
Chars 5519 - 5542 [exists~(Neg~(quote~n)).] 0. secs (0.u,0.s)
Chars 5545 - 5564 [(apply~quote_neg_ok).] 0. secs (0.u,0.s)
Chars 5567 - 5575 [Defined.] 0. secs (0.u,0.s)
Chars 5579 - 5675 [#[local]~Instance~quote_old_va...] 0. secs (0.u,0.s)
Chars 5678 - 5684 [Proof.] 0. secs (0.u,0.s)
Chars 5941 - 5957 [(unfold~amal_eta).] 40.012 secs (0.001u,0.002s)
Chars 5962 - 5980 [(apply~path_Tr,~tr).] 0.001 secs (0.001u,0.s)
Chars 5985 - 6025 [exact~(cglue~(inl~(inl~(inr~(x...] 0.001 secs (0.001u,0.s)
Chars 5941 - 5957 [(unfold~amal_eta).] 0. secs (0.u,0.s)
Chars 5962 - 5980 [(apply~path_Tr,~tr).] 0. secs (0.u,0.s)
Chars 5985 - 6025 [exact~(cglue~(inl~(inl~(inr~(x...] 0. secs (0.u,0.s)
Chars 6028 - 6036 [Defined.] 0.001 secs (0.001u,0.s)
Chars 6040 - 6140 [Definition~amal_omega_H~(x~y~:...] 0.001 secs (0.001u,0.s)
Chars 6143 - 6149 [Proof.] 0. secs (0.u,0.s)
All solutions:
occurrence 0: transitivity through (Z.abs a + - Z.abs b + 0)%Z

occurrence 1: transitivity through 
(Z.abs a + - (Z.abs b + 0))%Z

occurrence 2: transitivity through 
(Z.abs a + - Z.abs (b + 0))%Z

occurrence 3: transitivity through 
(- Z.abs b + Z.abs (a + 0))%Z


NMult : EMonoid N.mul 1 eq
     : EMonoid N.mul 1 eq
Chars 4204 - 4252 [(intros~[A~R__A]~[B~R__B]~[C~R...] 40.082 secs (0.002u,0.019s)
Chars 4255 - 4283 [exists~(equiv_compose'~g~f).] 0.001 secs (0.001u,0.s)
Chars 4286 - 4298 [(intros~a~a').] 0. secs (0.u,0.s)
Chars 4301 - 4334 [transitivity~(R__B~(f~a)~(f~a')).] 0.001 secs (0.001u,0.s)
Chars 4335 - 4336 [{] 0. secs (0.u,0.s)
Chars 4341 - 4350 [(apply~Hf).] 0. secs (0.u,0.s)
Chars 4353 - 4354 [}] 0. secs (0.u,0.s)
Chars 4357 - 4366 [(apply~Hg).] 0. secs (0.u,0.s)
Chars 4204 - 4252 [(intros~[A~R__A]~[B~R__B]~[C~R...] 0. secs (0.u,0.s)
Chars 4255 - 4283 [exists~(equiv_compose'~g~f).] 0. secs (0.u,0.s)
Chars 4286 - 4298 [(intros~a~a').] 0. secs (0.u,0.s)
Chars 4301 - 4334 [transitivity~(R__B~(f~a)~(f~a')).] 0. secs (0.u,0.s)
Chars 4341 - 4350 [(apply~Hf).] 0. secs (0.u,0.s)
Chars 4357 - 4366 [(apply~Hg).] 0. secs (0.u,0.s)
Chars 4367 - 4371 [Qed.] 0.001 secs (0.u,0.s)
Chars 4377 - 4467 [Definition~equiv_path_Ordinal~...] 0. secs (0.u,0.s)
Chars 4468 - 4474 [Proof.] 0. secs (0.u,0.s)
Chars 2066 - 2073 [(intros).] 11.837 secs (0.u,0.017s)
Chars 2076 - 2101 [(apply~apart_iff_total_lt).] 0.001 secs (0.001u,0.s)
Chars 2104 - 2109 [auto.] 0. secs (0.u,0.s)
Chars 2066 - 2073 [(intros).] 0. secs (0.u,0.s)
Chars 2076 - 2101 [(apply~apart_iff_total_lt).] 0. secs (0.u,0.s)
Chars 2104 - 2109 [auto.] 0. secs (0.u,0.s)
Chars 2112 - 2116 [Qed.] 0. secs (0.u,0.s)
Chars 2120 - 2176 [Lemma~pseudo_order_lt_apart_fl...] 0. secs (0.u,0.s)
Chars 2179 - 2185 [Proof.] 0. secs (0.u,0.s)
Chars 2188 - 2195 [(intros).] 0.052 secs (0.u,0.019s)
Chars 2198 - 2223 [(apply~apart_iff_total_lt).] 0.001 secs (0.001u,0.s)
Chars 2226 - 2231 [auto.] 0. secs (0.u,0.s)
Chars 2188 - 2195 [(intros).] 0. secs (0.u,0.s)
Chars 2198 - 2223 [(apply~apart_iff_total_lt).] 0. secs (0.u,0.s)
Chars 2226 - 2231 [auto.] 0. secs (0.u,0.s)
Chars 2234 - 2238 [Qed.] 0. secs (0.u,0.s)
Chars 2242 - 2304 [Lemma~not_lt_apart_lt_flip~x~y...] 0. secs (0.u,0.s)
Chars 2307 - 2313 [Proof.] 0. secs (0.u,0.s)
Chars 2498 - 2514 [(split;~intros~E).] 40.014 secs (0.u,0.003s)
Chars 2517 - 2518 [-] 0. secs (0.u,0.s)
Chars 2519 - 2532 [(apply~join_r).] 0. secs (0.u,0.s)
Chars 2533 - 2541 [trivial.] 0. secs (0.u,0.s)
Chars 2544 - 2545 [-] 0. secs (0.u,0.s)
Chars 2546 - 2558 [(rewrite~<-~E).] 0. secs (0.u,0.s)
Chars 2559 - 2575 [(apply~join_ub_l).] 0. secs (0.u,0.s)
Chars 2498 - 2514 [(split;~intros~E).] 0. secs (0.u,0.s)
Chars 2519 - 2532 [(apply~join_r).] 0. secs (0.u,0.s)
Chars 2533 - 2541 [trivial.] 0. secs (0.u,0.s)
Chars 2546 - 2558 [(rewrite~<-~E).] 0. secs (0.u,0.s)
Chars 2559 - 2575 [(apply~join_ub_l).] 0. secs (0.u,0.s)
Chars 2578 - 2582 [Qed.] 0. secs (0.u,0.s)
Chars 2586 - 2659 [#[global]Instance~join_le_pres...] 0. secs (0.u,0.s)
Chars 2662 - 2668 [Proof.] 0. secs (0.u,0.s)
Chars 5687 - 5719 [exists~(Var~(inl~(lookup~x~v))).] 34.588 secs (0.001u,0.019s)
Chars 5722 - 5743 [(apply~lookup_correct).] 0. secs (0.u,0.s)
Chars 5687 - 5719 [exists~(Var~(inl~(lookup~x~v))).] 0. secs (0.u,0.s)
Chars 5722 - 5743 [(apply~lookup_correct).] 0. secs (0.u,0.s)
Chars 5746 - 5754 [Defined.] 0. secs (0.u,0.s)
Chars 5758 - 5845 [#[local]~Instance~quote_new_va...] 0. secs (0.u,0.s)
Chars 5848 - 5854 [Proof.] 0. secs (0.u,0.s)
Chars 7710 - 7794 [(intro~h_seqcontr;~~~pose~(uni...] 40.077 secs (0.001u,0.018s)
Chars 7797 - 7839 [srapply~(contr_equiv'~(Colimit...] 0.015 secs (0.007u,0.007s)
Chars 7842 - 7843 [-] 0. secs (0.u,0.s)
Chars 7844 - 7884 [(symmetry;~srapply~equiv_funct...] 0.007 secs (0.006u,0.s)
Chars 7889 - 7943 [(srapply~Build_diagram_equiv;~...] 0.018 secs (0.012u,0.005s)
Chars 7948 - 7949 [*] 0. secs (0.u,0.s)
Chars 7950 - 7972 [exact~(fun~_~_~=>~tt).] 0. secs (0.u,0.s)
Chars 7977 - 7978 [*] 0. secs (0.u,0.s)
Chars 7979 - 8019 [(intros~n~m~p~a;~destruct~p;~r...] 0.002 secs (0.001u,0.s)
Chars 8022 - 8023 [-] 0. secs (0.u,0.s)
Chars 8024 - 8097 [(srapply~(Build_Contr~_~(inj~u...] 0.003 secs (0.002u,0.s)
Chars 8102 - 8127 [srapply~seq_colimit_uniq.] 0.003 secs (0.002u,0.s)
Chars 8132 - 8133 [*] 0. secs (0.u,0.s)
Chars 8134 - 8182 [(intros~n~a;~destruct~a;~induc...] 0.002 secs (0.002u,0.s)
Chars 8189 - 8190 [+] 0. secs (0.u,0.s)
Chars 8191 - 8203 [reflexivity.] 0. secs (0.u,0.s)
Chars 8210 - 8211 [+] 0. secs (0.u,0.s)
Chars 8212 - 8243 [exact~(glue~unit_seq~n~tt~@~r).] 0.001 secs (0.001u,0.s)
Chars 8248 - 8249 [*] 0. secs (0.u,0.s)
Chars 8250 - 8322 [(intro~n;~destruct~a;~rewrite~...] 0.028 secs (0.026u,0.001s)
Chars 7710 - 7794 [(intro~h_seqcontr;~~~pose~(uni...] 0. secs (0.u,0.s)
Chars 7797 - 7839 [srapply~(contr_equiv'~(Colimit...] 0. secs (0.u,0.s)
Chars 7844 - 7884 [(symmetry;~srapply~equiv_funct...] 0. secs (0.u,0.s)
Chars 7889 - 7943 [(srapply~Build_diagram_equiv;~...] 0. secs (0.u,0.s)
Chars 7950 - 7972 [exact~(fun~_~_~=>~tt).] 0. secs (0.u,0.s)
Chars 7979 - 8019 [(intros~n~m~p~a;~destruct~p;~r...] 0. secs (0.u,0.s)
Chars 8024 - 8097 [(srapply~(Build_Contr~_~(inj~u...] 0. secs (0.u,0.s)
Chars 8102 - 8127 [srapply~seq_colimit_uniq.] 0. secs (0.u,0.s)
Chars 8134 - 8182 [(intros~n~a;~destruct~a;~induc...] 0. secs (0.u,0.s)
Chars 8191 - 8203 [reflexivity.] 0. secs (0.u,0.s)
Chars 8212 - 8243 [exact~(glue~unit_seq~n~tt~@~r).] 0. secs (0.u,0.s)
Chars 8250 - 8322 [(intro~n;~destruct~a;~rewrite~...] 0.005 secs (0.005u,0.s)
Chars 8323 - 8331 [Defined.] 0.018 secs (0.013u,0.004s)
Chars 8370 - 8497 [Record~FibSequence~(A~:~Sequen...] 0.002 secs (0.u,0.001s)
Chars 8499 - 8548 [Coercion~fibSequence~:~FibSequ...] 0. secs (0.u,0.s)
Chars 8550 - 8576 [Arguments~fibSequence~{A}.] 0. secs (0.u,0.s)
Chars 8577 - 8606 [Arguments~fibSequenceArr~{A}.] 0. secs (0.u,0.s)
Chars 8608 - 8651 [Notation~"b~^+f"~:=~(fibSequen...] 0. secs (0.u,0.s)
Chars 8714 - 8768 [Definition~sig_seq~{A}~(B~:~Fi...] 0. secs (0.u,0.s)
Chars 8769 - 8775 [Proof.] 0. secs (0.u,0.s)
Chars 8778 - 8801 [srapply~Build_Sequence.] 0.943 secs (0.001u,0.017s)
Chars 8804 - 8805 [-] 0. secs (0.u,0.s)
Chars 8806 - 8843 [exact~(fun~n~=>~{a~:~A~n~&~B~(...] 0.001 secs (0.001u,0.s)
Chars 8846 - 8847 [-] 0. secs (0.u,0.s)
Chars 8848 - 8882 [(intros~n~[a~b];~exact~((a)~^+...] 0.002 secs (0.002u,0.s)
Chars 8778 - 8801 [srapply~Build_Sequence.] 0. secs (0.u,0.s)
Chars 8806 - 8843 [exact~(fun~n~=>~{a~:~A~n~&~B~(...] 0. secs (0.u,0.s)
Chars 8848 - 8882 [(intros~n~[a~b];~exact~((a)~^+...] 0. secs (0.u,0.s)
Chars 8883 - 8891 [Defined.] 0. secs (0.u,0.s)
Chars 9029 - 9132 [Definition~seq_colim_sum_to_se...] 0. secs (0.u,0.s)
Chars 9133 - 9139 [Proof.] 0. secs (0.u,0.s)
Chars 6154 - 6170 [(unfold~amal_eta).] 37.213 secs (0.001u,0.003s)
Chars 6175 - 6193 [(apply~path_Tr,~tr).] 0.001 secs (0.001u,0.s)
Chars 6198 - 6230 [exact~(cglue~(inl~(inr~(x,~y)))).] 0.001 secs (0.001u,0.s)
Chars 6154 - 6170 [(unfold~amal_eta).] 0. secs (0.u,0.s)
Chars 6175 - 6193 [(apply~path_Tr,~tr).] 0. secs (0.u,0.s)
Chars 6198 - 6230 [exact~(cglue~(inl~(inr~(x,~y)))).] 0. secs (0.u,0.s)
Chars 6233 - 6241 [Defined.] 0.001 secs (0.001u,0.s)
Chars 6245 - 6345 [Definition~amal_omega_K~(x~y~:...] 0.001 secs (0.001u,0.s)
Chars 6348 - 6354 [Proof.] 0. secs (0.u,0.s)
Chars 2316 - 2331 [(intros~nlt~neq).] 37.079 secs (0.001u,0.018s)
Chars 2332 - 2364 [(apply~apart_iff_total_lt~in~n...] 0.001 secs (0.001u,0.s)
Chars 2367 - 2380 [(destruct~neq).] 0. secs (0.u,0.s)
Chars 2383 - 2384 [-] 0. secs (0.u,0.s)
Chars 2385 - 2403 [(destruct~nlt;~auto).] 0. secs (0.u,0.s)
Chars 2406 - 2407 [-] 0. secs (0.u,0.s)
Chars 2408 - 2413 [auto.] 0. secs (0.u,0.s)
Chars 2316 - 2331 [(intros~nlt~neq).] 0. secs (0.u,0.s)
Chars 2332 - 2364 [(apply~apart_iff_total_lt~in~n...] 0. secs (0.u,0.s)
Chars 2367 - 2380 [(destruct~neq).] 0. secs (0.u,0.s)
Chars 2385 - 2403 [(destruct~nlt;~auto).] 0. secs (0.u,0.s)
Chars 2408 - 2413 [auto.] 0. secs (0.u,0.s)
Chars 2416 - 2420 [Qed.] 0. secs (0.u,0.s)
Chars 2424 - 2551 [Lemma~pseudo_order_cotrans_twi...] 0.001 secs (0.001u,0.s)
Chars 2554 - 2560 [Proof.] 0. secs (0.u,0.s)
Chars 4477 - 4496 [(unfold~Isomorphism).] 40.077 secs (0.u,0.017s)
Chars 4497 - 4520 [rapply~symmetric_equiv.] 0.001 secs (0.001u,0.s)
Chars 4523 - 4586 [transitivity~(equiv_Ordinal_to...] 0.002 secs (0.u,0.001s)
Chars 4587 - 4588 [{] 0. secs (0.u,0.s)
Chars 4593 - 4609 [(apply~equiv_ap').] 0.018 secs (0.015u,0.002s)
Chars 4612 - 4613 [}] 0. secs (0.u,0.s)
Chars 4616 - 4687 [transitivity~((equiv_Ordinal_t...] 0.003 secs (0.002u,0.s)
Chars 4688 - 4689 [{] 0. secs (0.u,0.s)
Chars 4694 - 4710 [exists~pr1_path.] 0.001 secs (0.001u,0.s)
Chars 4711 - 4746 [exact~(isequiv_pr1_path_hprop~...] 0.006 secs (0.005u,0.s)
Chars 4749 - 4750 [}] 0. secs (0.u,0.s)
Chars 4753 - 4812 [transitivity~(exist~Relation~A...] 0.003 secs (0.003u,0.s)
Chars 4813 - 4814 [{] 0. secs (0.u,0.s)
Chars 4819 - 4831 [reflexivity.] 0.001 secs (0.001u,0.s)
Chars 4834 - 4835 [}] 0. secs (0.u,0.s)
Chars 4838 - 4889 [transitivity~{p~:~A~=~B~:>~Typ...] 0.003 secs (0.003u,0.s)
Chars 4890 - 4891 [{] 0. secs (0.u,0.s)
Chars 4896 - 4905 [symmetry.] 0.001 secs (0.001u,0.s)
Chars 4910 - 5046 [exact~~(equiv_path_sigma~Relat...] 0.004 secs (0.004u,0.s)
Chars 5049 - 5050 [}] 0. secs (0.u,0.s)
Chars 5053 - 5082 [srapply~equiv_functor_sigma'.] 0.001 secs (0.001u,0.s)
Chars 5085 - 5086 [-] 0. secs (0.u,0.s)
Chars 5087 - 5116 [exact~(equiv_equiv_path~A~B).] 0.001 secs (0.001u,0.s)
Chars 5119 - 5120 [-] 0. secs (0.u,0.s)
Chars 5121 - 5125 [(cbn).] 0.001 secs (0.001u,0.s)
Chars 5126 - 5135 [(intros~p).] 0. secs (0.u,0.s)
Chars 5140 - 5164 [nrapply~equiv_iff_hprop.] 0.003 secs (0.003u,0.s)
Chars 5169 - 5170 [+] 0. secs (0.u,0.s)
Chars 5171 - 5246 [(apply~(istrunc_equiv_istrunc~...] 0.002 secs (0.002u,0.s)
Chars 5247 - 5248 [{] 0. secs (0.u,0.s)
Chars 5257 - 5304 [transitivity~(forall~b~:~B,~(p...] 0.003 secs (0.002u,0.s)
Chars 5305 - 5306 [{] 0. secs (0.u,0.s)
Chars 5317 - 5357 [(apply~equiv_functor_forall_id...] 0.001 secs (0.001u,0.s)
Chars 5358 - 5381 [(apply~equiv_path_arrow).] 0.001 secs (0.001u,0.s)
Chars 5390 - 5391 [}] 0. secs (0.u,0.s)
Chars 5400 - 5423 [(apply~equiv_path_arrow).] 0.001 secs (0.001u,0.s)
Chars 5430 - 5431 [}] 0. secs (0.u,0.s)
Chars 5438 - 5446 [exact~_.] 0.047 secs (0.042u,0.004s)
Chars 5451 - 5452 [+] 0. secs (0.u,0.s)
Chars 5453 - 5461 [exact~_.] 0.04 secs (0.034u,0.005s)
Chars 5467 - 5468 [+] 0. secs (0.u,0.s)
Chars 5469 - 5484 [(intros~<-~a~a').] 0.001 secs (0.001u,0.s)
Chars 5491 - 5515 [(rewrite~transport_arrow).] 0.002 secs (0.002u,0.s)
Chars 5516 - 5548 [(rewrite~transport_arrow_tocon...] 0.001 secs (0.u,0.s)
Chars 5555 - 5583 [(repeat~rewrite~transport_Vp).] 0.018 secs (0.014u,0.003s)
Chars 5584 - 5596 [reflexivity.] 0.001 secs (0.001u,0.s)
Chars 5601 - 5602 [+] 0. secs (0.u,0.s)
Chars 5603 - 5613 [(intros~H0).] 0. secs (0.u,0.s)
Chars 5620 - 5640 [(by_extensionality~b).] 0.002 secs (0.002u,0.s)
Chars 5641 - 5662 [(by_extensionality~b').] 0.002 secs (0.002u,0.s)
Chars 5669 - 5693 [(rewrite~transport_arrow).] 0.001 secs (0.001u,0.s)
Chars 5694 - 5726 [(rewrite~transport_arrow_tocon...] 0.001 secs (0.001u,0.s)
Chars 5733 - 5766 [(apply~path_iff_ishprop_uncurr...] 0.005 secs (0.005u,0.s)
Chars 5773 - 5836 [specialize~(H0~(transport~idma...] 0.001 secs (0.001u,0.s)
Chars 5843 - 5877 [(repeat~rewrite~transport_pV~i...] 0.004 secs (0.003u,0.s)
Chars 5878 - 5887 [exact~H0.] 0. secs (0.u,0.s)
Chars 4477 - 4496 [(unfold~Isomorphism).] 0. secs (0.u,0.s)
Chars 4497 - 4520 [rapply~symmetric_equiv.] 0. secs (0.u,0.s)
Chars 4523 - 4586 [transitivity~(equiv_Ordinal_to...] 0. secs (0.u,0.s)
Chars 4593 - 4609 [(apply~equiv_ap').] 0. secs (0.u,0.s)
Chars 4616 - 4687 [transitivity~((equiv_Ordinal_t...] 0. secs (0.u,0.s)
Chars 4694 - 4710 [exists~pr1_path.] 0. secs (0.u,0.s)
Chars 4711 - 4746 [exact~(isequiv_pr1_path_hprop~...] 0. secs (0.u,0.s)
Chars 4753 - 4812 [transitivity~(exist~Relation~A...] 0. secs (0.u,0.s)
Chars 4819 - 4831 [reflexivity.] 0. secs (0.u,0.s)
Chars 4838 - 4889 [transitivity~{p~:~A~=~B~:>~Typ...] 0. secs (0.u,0.s)
Chars 4896 - 4905 [symmetry.] 0. secs (0.u,0.s)
Chars 4910 - 5046 [exact~~(equiv_path_sigma~Relat...] 0. secs (0.u,0.s)
Chars 5053 - 5082 [srapply~equiv_functor_sigma'.] 0. secs (0.u,0.s)
Chars 5087 - 5116 [exact~(equiv_equiv_path~A~B).] 0. secs (0.u,0.s)
Chars 5121 - 5125 [(cbn).] 0. secs (0.u,0.s)
Chars 5126 - 5135 [(intros~p).] 0. secs (0.u,0.s)
Chars 5140 - 5164 [nrapply~equiv_iff_hprop.] 0. secs (0.u,0.s)
Chars 5171 - 5246 [(apply~(istrunc_equiv_istrunc~...] 0. secs (0.u,0.s)
Chars 5257 - 5304 [transitivity~(forall~b~:~B,~(p...] 0. secs (0.u,0.s)
Chars 5317 - 5357 [(apply~equiv_functor_forall_id...] 0. secs (0.u,0.s)
Chars 5358 - 5381 [(apply~equiv_path_arrow).] 0. secs (0.u,0.s)
Chars 5400 - 5423 [(apply~equiv_path_arrow).] 0. secs (0.u,0.s)
Chars 5438 - 5446 [exact~_.] 0. secs (0.u,0.s)
Chars 5453 - 5461 [exact~_.] 0. secs (0.u,0.s)
Chars 5469 - 5484 [(intros~<-~a~a').] 0. secs (0.u,0.s)
Chars 5491 - 5515 [(rewrite~transport_arrow).] 0. secs (0.u,0.s)
Chars 5516 - 5548 [(rewrite~transport_arrow_tocon...] 0. secs (0.u,0.s)
Chars 5555 - 5583 [(repeat~rewrite~transport_Vp).] 0. secs (0.u,0.s)
Chars 5584 - 5596 [reflexivity.] 0. secs (0.u,0.s)
Chars 5603 - 5613 [(intros~H0).] 0. secs (0.u,0.s)
Chars 5620 - 5640 [(by_extensionality~b).] 0. secs (0.u,0.s)
Chars 5641 - 5662 [(by_extensionality~b').] 0. secs (0.u,0.s)
Chars 5669 - 5693 [(rewrite~transport_arrow).] 0. secs (0.u,0.s)
Chars 5694 - 5726 [(rewrite~transport_arrow_tocon...] 0. secs (0.u,0.s)
Chars 5733 - 5766 [(apply~path_iff_ishprop_uncurr...] 0. secs (0.u,0.s)
Chars 5773 - 5836 [specialize~(H0~(transport~idma...] 0. secs (0.u,0.s)
Chars 5843 - 5877 [(repeat~rewrite~transport_pV~i...] 0. secs (0.u,0.s)
Chars 5878 - 5887 [exact~H0.] 0. secs (0.u,0.s)
Chars 5888 - 5892 [Qed.] 0.012 secs (0.011u,0.s)
Chars 5895 - 6026 [Lemma~path_Ordinal~`{Univalenc...] 0.001 secs (0.001u,0.s)
Chars 6027 - 6033 [Proof.] 0. secs (0.u,0.s)
Chars 5857 - 5879 [exists~(Var~(inr~tt)).] 15.57 secs (0.u,0.019s)
Chars 5882 - 5894 [reflexivity.] 0. secs (0.u,0.s)
Chars 5857 - 5879 [exists~(Var~(inr~tt)).] 0. secs (0.u,0.s)
Chars 5882 - 5894 [reflexivity.] 0. secs (0.u,0.s)
Chars 5897 - 5905 [Defined.] 0. secs (0.u,0.s)
Chars 5907 - 5917 [End~Quote.] 0.019 secs (0.017u,0.002s)
Chars 5919 - 6018 [Definition~quote'~:~~~forall~x...] 0. secs (0.u,0.s)
Chars 6020 - 6159 [Definition~eval_quote'~:~~~for...] 0. secs (0.u,0.s)
Chars 6161 - 6416 [Class~EqQuote~{V~:~Type0}~(l~:...] 0.002 secs (0.001u,0.001s)
Chars 6418 - 6704 [Lemma~eq_quote_ok~(V~:~Type0)~...] 0.003 secs (0.002u,0.s)
Chars 6705 - 6711 [Proof.] 0. secs (0.u,0.s)
Chars 6034 - 6046 [(intros~f~H0).] 11.093 secs (0.001u,0.018s)
Chars 6047 - 6072 [(apply~equiv_path_Ordinal).] 0.001 secs (0.001u,0.s)
Chars 6073 - 6082 [exists~f.] 0. secs (0.u,0.s)
Chars 6083 - 6092 [exact~H0.] 0. secs (0.u,0.s)
Chars 6034 - 6046 [(intros~f~H0).] 0. secs (0.u,0.s)
Chars 6047 - 6072 [(apply~equiv_path_Ordinal).] 0. secs (0.u,0.s)
Chars 6073 - 6082 [exists~f.] 0. secs (0.u,0.s)
Chars 6083 - 6092 [exact~H0.] 0. secs (0.u,0.s)
Chars 6093 - 6097 [Qed.] 0.001 secs (0.001u,0.s)
Chars 6099 - 6194 [Lemma~trichotomy_ordinal~`{Exc...] 0.001 secs (0.001u,0.s)
Chars 6195 - 6201 [Proof.] 0. secs (0.u,0.s)
Chars 2671 - 2682 [(red;~intros).] 40.012 secs (0.u,0.003s)
Chars 2685 - 2700 [(apply~join_lub).] 0. secs (0.u,0.s)
Chars 2703 - 2704 [-] 0. secs (0.u,0.s)
Chars 2705 - 2721 [(apply~join_ub_l).] 0. secs (0.u,0.s)
Chars 2724 - 2725 [-] 0. secs (0.u,0.s)
Chars 2726 - 2749 [(apply~join_le_compat_l).] 0. secs (0.u,0.s)
Chars 2750 - 2758 [trivial.] 0. secs (0.u,0.s)
Chars 2671 - 2682 [(red;~intros).] 0. secs (0.u,0.s)
Chars 2685 - 2700 [(apply~join_lub).] 0. secs (0.u,0.s)
Chars 2705 - 2721 [(apply~join_ub_l).] 0. secs (0.u,0.s)
Chars 2726 - 2749 [(apply~join_le_compat_l).] 0. secs (0.u,0.s)
Chars 2750 - 2758 [trivial.] 0. secs (0.u,0.s)
Chars 2761 - 2765 [Qed.] 0. secs (0.u,0.s)
Chars 2769 - 2842 [#[global]Instance~join_le_pres...] 0. secs (0.u,0.s)
Chars 2845 - 2851 [Proof.] 0. secs (0.u,0.s)
     = 10946%N
     : N
Chars 9142 - 9184 [(srapply~Colimit_rec;~srapply~...] 40.09 secs (0.001u,0.019s)
Chars 9187 - 9188 [-] 0. secs (0.u,0.s)
Chars 9189 - 9223 [(intros~n~[a~_];~exact~(inj~_~...] 0.001 secs (0.u,0.001s)
Chars 9226 - 9227 [-] 0. secs (0.u,0.s)
Chars 9228 - 9279 [(intros~n~m~p~[a~b];~destruct~...] 0.004 secs (0.004u,0.s)
Chars 9142 - 9184 [(srapply~Colimit_rec;~srapply~...] 0. secs (0.u,0.s)
Chars 9189 - 9223 [(intros~n~[a~_];~exact~(inj~_~...] 0. secs (0.u,0.s)
Chars 9228 - 9279 [(intros~n~m~p~[a~b];~destruct~...] 0.001 secs (0.001u,0.s)
Chars 9280 - 9288 [Defined.] 0.002 secs (0.001u,0.s)
Chars 9391 - 9464 [Definition~fib_seq_to_seq~{A}~...] 0. secs (0.u,0.s)
Chars 9465 - 9471 [Proof.] 0. secs (0.u,0.s)
Chars 9474 - 9541 [(srapply~Build_Sequence;~intro...] 0.266 secs (0.003u,0.018s)
Chars 9544 - 9545 [*] 0. secs (0.u,0.s)
Chars 9546 - 9567 [exact~(fun~x~=>~B~x).] 0. secs (0.u,0.s)
Chars 9570 - 9571 [*] 0. secs (0.u,0.s)
Chars 9572 - 9596 [exact~(fun~x~=>~h~(x)~^++).] 0. secs (0.u,0.s)
Chars 9599 - 9600 [*] 0. secs (0.u,0.s)
Chars 9601 - 9625 [exact~(fun~x~b~=>~(b)~^+f).] 0.001 secs (0.001u,0.s)
Chars 9628 - 9629 [*] 0. secs (0.u,0.s)
Chars 9630 - 9654 [exact~(fun~x~=>~h~(x)~^++).] 0.001 secs (0.001u,0.s)
Chars 9474 - 9541 [(srapply~Build_Sequence;~intro...] 0. secs (0.u,0.s)
Chars 9546 - 9567 [exact~(fun~x~=>~B~x).] 0. secs (0.u,0.s)
Chars 9572 - 9596 [exact~(fun~x~=>~h~(x)~^++).] 0. secs (0.u,0.s)
Chars 9601 - 9625 [exact~(fun~x~b~=>~(b)~^+f).] 0. secs (0.u,0.s)
Chars 9630 - 9654 [exact~(fun~x~=>~h~(x)~^++).] 0. secs (0.u,0.s)
Chars 9655 - 9663 [Defined.] 0.001 secs (0.u,0.s)
Chars 9753 - 9884 [Definition~fib_seq_to_seq'~{A}...] 0.002 secs (0.002u,0.s)
Chars 9886 - 10001 [Definition~equiv_fib_seq_to_se...] 0. secs (0.u,0.s)
Chars 10002 - 10008 [Proof.] 0. secs (0.u,0.s)
Chars 6359 - 6375 [(unfold~amal_eta).] 40.012 secs (0.u,0.004s)
Chars 6380 - 6398 [(apply~path_Tr,~tr).] 0.001 secs (0.001u,0.s)
Chars 6403 - 6429 [exact~(cglue~(inr~(x,~y))).] 0.001 secs (0.001u,0.s)
Chars 6359 - 6375 [(unfold~amal_eta).] 0. secs (0.u,0.s)
Chars 6380 - 6398 [(apply~path_Tr,~tr).] 0. secs (0.u,0.s)
Chars 6403 - 6429 [exact~(cglue~(inr~(x,~y))).] 0. secs (0.u,0.s)
Chars 6432 - 6440 [Defined.] 0.001 secs (0.001u,0.s)
Chars 6497 - 7274 [Definition~amal_type_ind~(P~:~...] 0.009 secs (0.009u,0.s)
Chars 7277 - 7283 [Proof.] 0. secs (0.u,0.s)
Chars 2563 - 2573 [(intros~E1).] 40.074 secs (0.001u,0.016s)
Chars 2576 - 2666 [(apply~(merely_destruct~(cotra...] 0.005 secs (0.005u,0.s)
Chars 2669 - 2743 [(apply~(merely_destruct~(cotra...] 0.005 secs (0.005u,0.s)
Chars 2563 - 2573 [(intros~E1).] 0. secs (0.u,0.s)
Chars 2576 - 2666 [(apply~(merely_destruct~(cotra...] 0. secs (0.u,0.s)
Chars 2669 - 2743 [(apply~(merely_destruct~(cotra...] 0.001 secs (0.001u,0.s)
Chars 2746 - 2750 [Qed.] 0.001 secs (0.001u,0.s)
Chars 2754 - 2878 [Lemma~pseudo_order_lt_ext~x₁~y...] 0.001 secs (0.001u,0.s)
Chars 2881 - 2887 [Proof.] 0. secs (0.u,0.s)
Chars 6712 - 6721 [(intros~E).] 40.103 secs (0.001u,0.016s)
Chars 6722 - 6765 [(rewrite~<-~(eval_quote~n),~<-...] 0.002 secs (0.002u,0.s)
Chars 6766 - 6912 [(path_via~(eval~(merge~v~(merg...] 0.052 secs (0.036u,0.015s)
Chars 6913 - 6914 [-] 0. secs (0.u,0.s)
Chars 6915 - 6932 [(rewrite~eval_map).] 0.001 secs (0.001u,0.s)
Chars 6933 - 6948 [(apply~eval_ext).] 0.001 secs (0.u,0.001s)
Chars 6951 - 6976 [(intros~[?|~?];~reflexivity).] 0.003 secs (0.003u,0.s)
Chars 6977 - 6978 [-] 0. secs (0.u,0.s)
Chars 6979 - 6996 [(rewrite~eval_map).] 0.002 secs (0.002u,0.s)
Chars 6997 - 7012 [(apply~eval_ext).] 0.001 secs (0.u,0.s)
Chars 7015 - 7044 [(intros~[[?|~?]|~?];~reflexivi...] 0.004 secs (0.004u,0.s)
Chars 6712 - 6721 [(intros~E).] 0. secs (0.u,0.s)
Chars 6722 - 6765 [(rewrite~<-~(eval_quote~n),~<-...] 0. secs (0.u,0.s)
Chars 6766 - 6912 [(path_via~(eval~(merge~v~(merg...] 0.001 secs (0.001u,0.s)
Chars 6915 - 6932 [(rewrite~eval_map).] 0. secs (0.u,0.s)
Chars 6933 - 6948 [(apply~eval_ext).] 0. secs (0.u,0.s)
Chars 6951 - 6976 [(intros~[?|~?];~reflexivity).] 0.001 secs (0.001u,0.s)
Chars 6979 - 6996 [(rewrite~eval_map).] 0. secs (0.u,0.s)
Chars 6997 - 7012 [(apply~eval_ext).] 0. secs (0.u,0.s)
Chars 7015 - 7044 [(intros~[[?|~?]|~?];~reflexivi...] 0.002 secs (0.002u,0.s)
Chars 7045 - 7049 [Qed.] 0.003 secs (0.003u,0.s)
Chars 7051 - 7237 [#[local]~Instance~eq_quote~~(V...] 0. secs (0.u,0.s)
Chars 7238 - 7244 [Proof.] 0. secs (0.u,0.s)
     = 0
     : int31
Chars 6204 - 6213 [revert~b.] 40.086 secs (0.u,0.018s)
Chars 6214 - 6258 [(induction~(well_foundedness~a...] 0.002 secs (0.002u,0.s)
Chars 6259 - 6268 [(intros~b).] 0. secs (0.u,0.s)
Chars 6271 - 6315 [(induction~(well_foundedness~b...] 0.003 secs (0.002u,0.s)
Chars 6318 - 6410 [(destruct~(LEM~(merely~(exists...] 0.007 secs (0.007u,0.s)
Chars 6413 - 6414 [-] 0. secs (0.u,0.s)
Chars 6415 - 6425 [revert~H1.] 0. secs (0.u,0.s)
Chars 6426 - 6443 [rapply~Trunc_rec.] 0.01 secs (0.005u,0.004s)
Chars 6444 - 6467 [(intros~[b'~[b'_b~Hb']]).] 0.002 secs (0.002u,0.s)
Chars 6472 - 6483 [revert~Hb'.] 0. secs (0.u,0.s)
Chars 6484 - 6501 [rapply~Trunc_rec.] 0.01 secs (0.01u,0.s)
Chars 6502 - 6523 [(intros~[a_b'|~b'_a]).] 0.001 secs (0.001u,0.s)
Chars 6528 - 6529 [+] 0. secs (0.u,0.s)
Chars 6530 - 6539 [(apply~tr).] 0.001 secs (0.001u,0.s)
Chars 6540 - 6545 [left.] 0. secs (0.u,0.s)
Chars 6546 - 6559 [(rewrite~a_b').] 0. secs (0.u,0.s)
Chars 6560 - 6571 [exact~b'_b.] 0. secs (0.u,0.s)
Chars 6576 - 6577 [+] 0. secs (0.u,0.s)
Chars 6578 - 6587 [(apply~tr).] 0.001 secs (0.001u,0.s)
Chars 6588 - 6593 [left.] 0. secs (0.u,0.s)
Chars 6594 - 6622 [(transitivity~b';~assumption).] 0.003 secs (0.003u,0.s)
Chars 6625 - 6626 [-] 0. secs (0.u,0.s)
Chars 6627 - 6719 [(destruct~(LEM~(merely~(exists...] 0.008 secs (0.006u,0.001s)
Chars 6724 - 6725 [+] 0. secs (0.u,0.s)
Chars 6726 - 6736 [revert~H2.] 0. secs (0.u,0.s)
Chars 6737 - 6754 [rapply~Trunc_rec.] 0.011 secs (0.009u,0.001s)
Chars 6755 - 6778 [(intros~[a'~[a'_a~Ha']]).] 0.002 secs (0.002u,0.s)
Chars 6785 - 6796 [revert~Ha'.] 0. secs (0.u,0.s)
Chars 6797 - 6814 [rapply~Trunc_rec.] 0.011 secs (0.01u,0.s)
Chars 6815 - 6836 [(intros~[a'_b|~b_a']).] 0.014 secs (0.011u,0.002s)
Chars 6843 - 6844 [*] 0. secs (0.u,0.s)
Chars 6845 - 6854 [(apply~tr).] 0.001 secs (0.001u,0.s)
Chars 6855 - 6861 [right.] 0.001 secs (0.u,0.s)
Chars 6862 - 6871 [(apply~tr).] 0.001 secs (0.001u,0.s)
Chars 6872 - 6878 [right.] 0. secs (0.u,0.s)
Chars 6879 - 6895 [(rewrite~<-~a'_b).] 0.001 secs (0.001u,0.s)
Chars 6896 - 6907 [exact~a'_a.] 0. secs (0.u,0.s)
Chars 6914 - 6915 [*] 0. secs (0.u,0.s)
Chars 6916 - 6925 [(apply~tr).] 0.001 secs (0.001u,0.s)
Chars 6926 - 6932 [right.] 0.001 secs (0.001u,0.s)
Chars 6933 - 6942 [(apply~tr).] 0.001 secs (0.001u,0.s)
Chars 6943 - 6949 [right.] 0. secs (0.u,0.s)
Chars 6950 - 6978 [(transitivity~a';~assumption).] 0.004 secs (0.004u,0.s)
Chars 6983 - 6984 [+] 0. secs (0.u,0.s)
Chars 6985 - 6994 [(apply~tr).] 0.001 secs (0.001u,0.s)
Chars 6995 - 7001 [right.] 0.001 secs (0.001u,0.s)
Chars 7002 - 7011 [(apply~tr).] 0.001 secs (0.u,0.s)
Chars 7012 - 7017 [left.] 0. secs (0.u,0.s)
Chars 7024 - 7045 [(apply~extensionality).] 0.002 secs (0.001u,0.s)
Chars 7046 - 7055 [(intros~c).] 0. secs (0.u,0.s)
Chars 7056 - 7062 [split.] 0.001 secs (0.001u,0.s)
Chars 7069 - 7070 [*] 0. secs (0.u,0.s)
Chars 7071 - 7082 [(intros~c_a).] 0. secs (0.u,0.s)
Chars 7083 - 7113 [(apply~LEM_to_DNE;~try~exact~_).] 0.006 secs (0.006u,0.s)
Chars 7114 - 7129 [(intros~not_c_b).] 0. secs (0.u,0.s)
Chars 7138 - 7147 [(apply~H2).] 0. secs (0.u,0.s)
Chars 7148 - 7157 [(apply~tr).] 0.001 secs (0.001u,0.s)
Chars 7158 - 7167 [exists~c.] 0.001 secs (0.001u,0.s)
Chars 7168 - 7174 [split.] 0.001 secs (0.001u,0.s)
Chars 7183 - 7185 [--] 0. secs (0.u,0.s)
Chars 7186 - 7196 [exact~c_a.] 0. secs (0.u,0.s)
Chars 7205 - 7207 [--] 0. secs (0.u,0.s)
Chars 7208 - 7243 [refine~(Trunc_rec~_~(IHa~c~c_a...] 0.003 secs (0.003u,0.s)
Chars 7244 - 7262 [(intros~[c_b|~H3]).] 0.001 secs (0.001u,0.s)
Chars 7274 - 7276 [++] 0. secs (0.u,0.s)
Chars 7277 - 7293 [(apply~Empty_rec).] 0.001 secs (0.001u,0.s)
Chars 7294 - 7314 [exact~(not_c_b~c_b).] 0. secs (0.u,0.s)
Chars 7326 - 7328 [++] 0. secs (0.u,0.s)
Chars 7329 - 7338 [exact~H3.] 0.001 secs (0.001u,0.s)
Chars 7345 - 7346 [*] 0. secs (0.u,0.s)
Chars 7347 - 7358 [(intros~c_b).] 0. secs (0.u,0.s)
Chars 7359 - 7389 [(apply~LEM_to_DNE;~try~exact~_).] 0.006 secs (0.005u,0.001s)
Chars 7390 - 7405 [(intros~not_c_a).] 0. secs (0.u,0.s)
Chars 7414 - 7423 [(apply~H1).] 0. secs (0.u,0.s)
Chars 7424 - 7433 [(apply~tr).] 0.001 secs (0.001u,0.s)
Chars 7434 - 7443 [exists~c.] 0.001 secs (0.001u,0.s)
Chars 7444 - 7450 [split.] 0.001 secs (0.001u,0.s)
Chars 7459 - 7461 [--] 0. secs (0.u,0.s)
Chars 7462 - 7472 [exact~c_b.] 0. secs (0.u,0.s)
Chars 7481 - 7483 [--] 0. secs (0.u,0.s)
Chars 7484 - 7517 [refine~(Trunc_rec~_~(IHb~c~c_b)).] 0.003 secs (0.003u,0.s)
Chars 7518 - 7536 [(intros~[a_c|~H3]).] 0.001 secs (0.001u,0.s)
Chars 7548 - 7550 [++] 0. secs (0.u,0.s)
Chars 7551 - 7560 [(apply~tr).] 0.001 secs (0.001u,0.s)
Chars 7561 - 7567 [right.] 0.001 secs (0.u,0.s)
Chars 7568 - 7578 [exact~a_c.] 0. secs (0.u,0.s)
Chars 7590 - 7592 [++] 0. secs (0.u,0.s)
Chars 7593 - 7617 [refine~(Trunc_rec~_~H3).] 0.004 secs (0.004u,0.s)
Chars 7618 - 7637 [(intros~[a_c|~c_a]).] 0.001 secs (0.001u,0.s)
Chars 7652 - 7654 [**] 0. secs (0.u,0.s)
Chars 7655 - 7664 [(apply~tr).] 0.001 secs (0.001u,0.s)
Chars 7665 - 7670 [left.] 0.001 secs (0.001u,0.s)
Chars 7671 - 7681 [exact~a_c.] 0. secs (0.u,0.s)
Chars 7696 - 7698 [**] 0. secs (0.u,0.s)
Chars 7699 - 7708 [(apply~tr).] 0.001 secs (0.001u,0.s)
Chars 7709 - 7715 [right.] 0.001 secs (0.001u,0.s)
Chars 7716 - 7732 [(apply~Empty_rec).] 0.001 secs (0.001u,0.s)
Chars 7733 - 7753 [exact~(not_c_a~c_a).] 0. secs (0.u,0.s)
Chars 6204 - 6213 [revert~b.] 0. secs (0.u,0.s)
Chars 6214 - 6258 [(induction~(well_foundedness~a...] 0. secs (0.u,0.s)
Chars 6259 - 6268 [(intros~b).] 0. secs (0.u,0.s)
Chars 6271 - 6315 [(induction~(well_foundedness~b...] 0. secs (0.u,0.s)
Chars 6318 - 6410 [(destruct~(LEM~(merely~(exists...] 0.001 secs (0.u,0.s)
Chars 6415 - 6425 [revert~H1.] 0. secs (0.u,0.s)
Chars 6426 - 6443 [rapply~Trunc_rec.] 0. secs (0.u,0.s)
Chars 6444 - 6467 [(intros~[b'~[b'_b~Hb']]).] 0. secs (0.u,0.s)
Chars 6472 - 6483 [revert~Hb'.] 0. secs (0.u,0.s)
Chars 6484 - 6501 [rapply~Trunc_rec.] 0. secs (0.u,0.s)
Chars 6502 - 6523 [(intros~[a_b'|~b'_a]).] 0. secs (0.u,0.s)
Chars 6530 - 6539 [(apply~tr).] 0. secs (0.u,0.s)
Chars 6540 - 6545 [left.] 0. secs (0.u,0.s)
Chars 6546 - 6559 [(rewrite~a_b').] 0. secs (0.u,0.s)
Chars 6560 - 6571 [exact~b'_b.] 0. secs (0.u,0.s)
Chars 6578 - 6587 [(apply~tr).] 0. secs (0.u,0.s)
Chars 6588 - 6593 [left.] 0. secs (0.u,0.s)
Chars 6594 - 6622 [(transitivity~b';~assumption).] 0.001 secs (0.001u,0.s)
Chars 6627 - 6719 [(destruct~(LEM~(merely~(exists...] 0.001 secs (0.u,0.s)
Chars 6726 - 6736 [revert~H2.] 0. secs (0.u,0.s)
Chars 6737 - 6754 [rapply~Trunc_rec.] 0. secs (0.u,0.s)
Chars 6755 - 6778 [(intros~[a'~[a'_a~Ha']]).] 0. secs (0.u,0.s)
Chars 6785 - 6796 [revert~Ha'.] 0. secs (0.u,0.s)
Chars 6797 - 6814 [rapply~Trunc_rec.] 0. secs (0.u,0.s)
Chars 6815 - 6836 [(intros~[a'_b|~b_a']).] 0. secs (0.u,0.s)
Chars 6845 - 6854 [(apply~tr).] 0. secs (0.u,0.s)
Chars 6855 - 6861 [right.] 0. secs (0.u,0.s)
Chars 6862 - 6871 [(apply~tr).] 0. secs (0.u,0.s)
Chars 6872 - 6878 [right.] 0. secs (0.u,0.s)
Chars 6879 - 6895 [(rewrite~<-~a'_b).] 0. secs (0.u,0.s)
Chars 6896 - 6907 [exact~a'_a.] 0. secs (0.u,0.s)
Chars 6916 - 6925 [(apply~tr).] 0. secs (0.u,0.s)
Chars 6926 - 6932 [right.] 0. secs (0.u,0.s)
Chars 6933 - 6942 [(apply~tr).] 0. secs (0.u,0.s)
Chars 6943 - 6949 [right.] 0. secs (0.u,0.s)
Chars 6950 - 6978 [(transitivity~a';~assumption).] 0.001 secs (0.001u,0.s)
Chars 6985 - 6994 [(apply~tr).] 0. secs (0.u,0.s)
Chars 6995 - 7001 [right.] 0. secs (0.u,0.s)
Chars 7002 - 7011 [(apply~tr).] 0. secs (0.u,0.s)
Chars 7012 - 7017 [left.] 0. secs (0.u,0.s)
Chars 7024 - 7045 [(apply~extensionality).] 0. secs (0.u,0.s)
Chars 7046 - 7055 [(intros~c).] 0. secs (0.u,0.s)
Chars 7056 - 7062 [split.] 0. secs (0.u,0.s)
Chars 7071 - 7082 [(intros~c_a).] 0. secs (0.u,0.s)
Chars 7083 - 7113 [(apply~LEM_to_DNE;~try~exact~_).] 0.001 secs (0.001u,0.s)
Chars 7114 - 7129 [(intros~not_c_b).] 0. secs (0.u,0.s)
Chars 7138 - 7147 [(apply~H2).] 0. secs (0.u,0.s)
Chars 7148 - 7157 [(apply~tr).] 0. secs (0.u,0.s)
Chars 7158 - 7167 [exists~c.] 0. secs (0.u,0.s)
Chars 7168 - 7174 [split.] 0. secs (0.u,0.s)
Chars 7186 - 7196 [exact~c_a.] 0. secs (0.u,0.s)
Chars 7208 - 7243 [refine~(Trunc_rec~_~(IHa~c~c_a...] 0. secs (0.u,0.s)
Chars 7244 - 7262 [(intros~[c_b|~H3]).] 0. secs (0.u,0.s)
Chars 7277 - 7293 [(apply~Empty_rec).] 0. secs (0.u,0.s)
Chars 7294 - 7314 [exact~(not_c_b~c_b).] 0. secs (0.u,0.s)
Chars 7329 - 7338 [exact~H3.] 0. secs (0.u,0.s)
Chars 7347 - 7358 [(intros~c_b).] 0. secs (0.u,0.s)
Chars 7359 - 7389 [(apply~LEM_to_DNE;~try~exact~_).] 0.001 secs (0.001u,0.s)
Chars 7390 - 7405 [(intros~not_c_a).] 0. secs (0.u,0.s)
Chars 7414 - 7423 [(apply~H1).] 0. secs (0.u,0.s)
Chars 7424 - 7433 [(apply~tr).] 0. secs (0.u,0.s)
Chars 7434 - 7443 [exists~c.] 0. secs (0.u,0.s)
Chars 7444 - 7450 [split.] 0. secs (0.u,0.s)
Chars 7462 - 7472 [exact~c_b.] 0. secs (0.u,0.s)
Chars 7484 - 7517 [refine~(Trunc_rec~_~(IHb~c~c_b)).] 0. secs (0.u,0.s)
Chars 7518 - 7536 [(intros~[a_c|~H3]).] 0. secs (0.u,0.s)
Chars 7551 - 7560 [(apply~tr).] 0. secs (0.u,0.s)
Chars 7561 - 7567 [right.] 0. secs (0.u,0.s)
Chars 7568 - 7578 [exact~a_c.] 0. secs (0.u,0.s)
Chars 7593 - 7617 [refine~(Trunc_rec~_~H3).] 0. secs (0.u,0.s)
Chars 7618 - 7637 [(intros~[a_c|~c_a]).] 0. secs (0.u,0.s)
Chars 7655 - 7664 [(apply~tr).] 0. secs (0.u,0.s)
Chars 7665 - 7670 [left.] 0. secs (0.u,0.s)
Chars 7671 - 7681 [exact~a_c.] 0. secs (0.u,0.s)
Chars 7699 - 7708 [(apply~tr).] 0. secs (0.u,0.s)
Chars 7709 - 7715 [right.] 0. secs (0.u,0.s)
Chars 7716 - 7732 [(apply~Empty_rec).] 0. secs (0.u,0.s)
Chars 7733 - 7753 [exact~(not_c_a~c_a).] 0. secs (0.u,0.s)
Chars 7754 - 7758 [Qed.] 0.013 secs (0.011u,0.002s)
Chars 7760 - 7939 [Lemma~ordinal_has_minimal_hsol...] 0.001 secs (0.001u,0.s)
Chars 7940 - 7946 [Proof.] 0. secs (0.u,0.s)
Chars 2854 - 2861 [(intros).] 40.012 secs (0.u,0.003s)
Chars 2862 - 2895 [(apply~maps.order_preserving_f...] 0.002 secs (0.001u,0.s)
Chars 2854 - 2861 [(intros).] 0. secs (0.u,0.s)
Chars 2862 - 2895 [(apply~maps.order_preserving_f...] 0. secs (0.u,0.s)
Chars 2898 - 2902 [Qed.] 0. secs (0.u,0.s)
Chars 2906 - 3015 [Lemma~join_le_compat~x₁~x₂~y₁~...] 0.001 secs (0.001u,0.s)
Chars 3018 - 3024 [Proof.] 0. secs (0.u,0.s)
Chars 10011 - 10039 [srapply~Build_diagram_equiv.] 40.181 secs (0.067u,0.034s)
Chars 10042 - 10043 [+] 0. secs (0.u,0.s)
Chars 10044 - 10069 [srapply~Build_DiagramMap.] 0.001 secs (0.001u,0.s)
Chars 10074 - 10075 [*] 0. secs (0.u,0.s)
Chars 10076 - 10119 [(intro~n;~revert~x;~induction~...] 0.001 secs (0.001u,0.s)
Chars 10126 - 10127 [-] 0. secs (0.u,0.s)
Chars 10128 - 10151 [exact~(fun~_~=>~idmap).] 0. secs (0.u,0.s)
Chars 10158 - 10159 [-] 0. secs (0.u,0.s)
Chars 10160 - 10224 [exact~(fun~x~=>~coe~(ap~B~(seq...] 0.002 secs (0.002u,0.s)
Chars 10229 - 10230 [*] 0. secs (0.u,0.s)
Chars 10231 - 10291 [(intros~n~m~p;~destruct~p;~rev...] 0.013 secs (0.012u,0.s)
Chars 10298 - 10299 [-] 0. secs (0.u,0.s)
Chars 10300 - 10326 [exact~(fun~_~_~=>~idpath).] 0.002 secs (0.002u,0.s)
Chars 10333 - 10334 [-] 0. secs (0.u,0.s)
Chars 10335 - 10384 [exact~(fun~x~b~=>~K~_~_~_~@~ap...] 0.014 secs (0.012u,0.001s)
Chars 10387 - 10388 [+] 0. secs (0.u,0.s)
Chars 10389 - 10432 [(intro~n;~revert~x;~induction~...] 0.051 secs (0.04u,0.01s)
Chars 10437 - 10438 [*] 0. secs (0.u,0.s)
Chars 10439 - 10472 [exact~(fun~_~=>~isequiv_idmap~_).] 0.006 secs (0.005u,0.s)
Chars 10477 - 10478 [*] 0. secs (0.u,0.s)
Chars 10479 - 10512 [(intro~x;~srapply~isequiv_comp...] 0.048 secs (0.043u,0.004s)
Chars 10011 - 10039 [srapply~Build_diagram_equiv.] 0. secs (0.u,0.s)
Chars 10044 - 10069 [srapply~Build_DiagramMap.] 0. secs (0.u,0.s)
Chars 10076 - 10119 [(intro~n;~revert~x;~induction~...] 0. secs (0.u,0.s)
Chars 10128 - 10151 [exact~(fun~_~=>~idmap).] 0. secs (0.u,0.s)
Chars 10160 - 10224 [exact~(fun~x~=>~coe~(ap~B~(seq...] 0. secs (0.u,0.s)
Chars 10231 - 10291 [(intros~n~m~p;~destruct~p;~rev...] 0.004 secs (0.004u,0.s)
Chars 10300 - 10326 [exact~(fun~_~_~=>~idpath).] 0. secs (0.u,0.s)
Chars 10335 - 10384 [exact~(fun~x~b~=>~K~_~_~_~@~ap...] 0.001 secs (0.001u,0.s)
Chars 10389 - 10432 [(intro~n;~revert~x;~induction~...] 0.017 secs (0.015u,0.001s)
Chars 10439 - 10472 [exact~(fun~_~=>~isequiv_idmap~_).] 0.005 secs (0.004u,0.s)
Chars 10479 - 10512 [(intro~x;~srapply~isequiv_comp...] 0.02 secs (0.018u,0.002s)
Chars 10513 - 10521 [Defined.] 0.063 secs (0.053u,0.009s)
Chars 10588 - 10677 [Definition~fib_seq_to_type_fam...] 0. secs (0.u,0.s)
Chars 10678 - 10684 [Proof.] 0. secs (0.u,0.s)
Chars 7288 - 7319 [(snrapply~Trunc_ind;~[~exact~_...] 40.019 secs (0.008u,0.003s)
Chars 7324 - 7342 [snrapply~Coeq_ind.] 0.004 secs (0.004u,0.s)
Chars 7347 - 7358 [1:~exact~e.] 0.001 secs (0.001u,0.s)
Chars 7363 - 7371 [intro~a.] 0.001 secs (0.001u,0.s)
Chars 7376 - 7411 [nrapply~(dp_path_transport^-1)...] 0.005 secs (0.005u,0.s)
Chars 7416 - 7462 [(destruct~a~as~[[[[a|~a]|~a]|~...] 0.007 secs (0.007u,0.s)
Chars 7467 - 7468 [+] 0. secs (0.u,0.s)
Chars 7469 - 7499 [(destruct~a~as~[[[x~h1]~h2]~y]).] 0.031 secs (0.027u,0.003s)
Chars 7506 - 7523 [(apply~dp_compose).] 0.006 secs (0.006u,0.s)
Chars 7530 - 7551 [exact~(mh~x~y~h1~h2).] 0.003 secs (0.003u,0.s)
Chars 7556 - 7557 [+] 0. secs (0.u,0.s)
Chars 7558 - 7588 [(destruct~a~as~[[[x~k1]~k2]~y]).] 0.008 secs (0.008u,0.s)
Chars 7595 - 7612 [(apply~dp_compose).] 0.006 secs (0.006u,0.s)
Chars 7619 - 7640 [exact~(mk~x~y~k1~k2).] 0.004 secs (0.004u,0.s)
Chars 7645 - 7646 [+] 0. secs (0.u,0.s)
Chars 7647 - 7671 [(destruct~a~as~[[x~z]~y]).] 0.006 secs (0.006u,0.s)
Chars 7678 - 7695 [(apply~dp_compose).] 0.006 secs (0.006u,0.s)
Chars 7702 - 7718 [exact~(t~x~y~z).] 0.003 secs (0.003u,0.s)
Chars 7723 - 7724 [+] 0. secs (0.u,0.s)
Chars 7725 - 7745 [(destruct~a~as~[x~y]).] 0.004 secs (0.004u,0.s)
Chars 7752 - 7769 [(apply~dp_compose).] 0.005 secs (0.005u,0.s)
Chars 7776 - 7791 [exact~(oh~x~y).] 0.003 secs (0.002u,0.s)
Chars 7796 - 7797 [+] 0. secs (0.u,0.s)
Chars 7798 - 7818 [(destruct~a~as~[x~y]).] 0.003 secs (0.003u,0.s)
Chars 7825 - 7842 [(apply~dp_compose).] 0.005 secs (0.005u,0.s)
Chars 7849 - 7864 [exact~(ok~x~y).] 0.003 secs (0.003u,0.s)
Chars 7288 - 7319 [(snrapply~Trunc_ind;~[~exact~_...] 0.002 secs (0.002u,0.s)
Chars 7324 - 7342 [snrapply~Coeq_ind.] 0.001 secs (0.u,0.s)
Chars 7347 - 7358 [1:~exact~e.] 0.001 secs (0.001u,0.s)
Chars 7363 - 7371 [intro~a.] 0.001 secs (0.001u,0.s)
Chars 7376 - 7411 [nrapply~(dp_path_transport^-1)...] 0.001 secs (0.001u,0.s)
Chars 7416 - 7462 [(destruct~a~as~[[[[a|~a]|~a]|~...] 0.001 secs (0.001u,0.s)
Chars 7469 - 7499 [(destruct~a~as~[[[x~h1]~h2]~y]).] 0.001 secs (0.001u,0.s)
Chars 7506 - 7523 [(apply~dp_compose).] 0.001 secs (0.001u,0.s)
Chars 7530 - 7551 [exact~(mh~x~y~h1~h2).] 0.001 secs (0.001u,0.s)
Chars 7558 - 7588 [(destruct~a~as~[[[x~k1]~k2]~y]).] 0.001 secs (0.001u,0.s)
Chars 7595 - 7612 [(apply~dp_compose).] 0.001 secs (0.001u,0.s)
Chars 7619 - 7640 [exact~(mk~x~y~k1~k2).] 0.013 secs (0.012u,0.s)
Chars 7647 - 7671 [(destruct~a~as~[[x~z]~y]).] 0.001 secs (0.001u,0.s)
Chars 7678 - 7695 [(apply~dp_compose).] 0.001 secs (0.001u,0.s)
Chars 7702 - 7718 [exact~(t~x~y~z).] 0.001 secs (0.001u,0.s)
Chars 7725 - 7745 [(destruct~a~as~[x~y]).] 0.001 secs (0.001u,0.s)
Chars 7752 - 7769 [(apply~dp_compose).] 0.001 secs (0.001u,0.s)
Chars 7776 - 7791 [exact~(oh~x~y).] 0.001 secs (0.001u,0.s)
Chars 7798 - 7818 [(destruct~a~as~[x~y]).] 0.001 secs (0.001u,0.s)
Chars 7825 - 7842 [(apply~dp_compose).] 0.001 secs (0.001u,0.s)
Chars 7849 - 7864 [exact~(ok~x~y).] 0.001 secs (0.001u,0.s)
Chars 7867 - 7875 [Defined.] 0.019 secs (0.019u,0.s)
Chars 7879 - 8016 [Definition~amal_type_ind_hprop...] 0. secs (0.u,0.s)
Chars 8019 - 8025 [Proof.] 0. secs (0.u,0.s)
Chars 2890 - 2899 [(intros~E).] 40.072 secs (0.u,0.018s)
Chars 2902 - 3042 [(apply~(merely_destruct~(pseud...] 0.008 secs (0.008u,0.s)
Chars 2890 - 2899 [(intros~E).] 0. secs (0.u,0.s)
Chars 2902 - 3042 [(apply~(merely_destruct~(pseud...] 0.002 secs (0.002u,0.s)
Chars 3045 - 3049 [Qed.] 0.001 secs (0.u,0.s)
Chars 3053 - 3118 [#[global]Instance~pseudoorder_...] 0. secs (0.u,0.s)
Chars 3121 - 3127 [Proof.] 0. secs (0.u,0.s)
Chars 7245 - 7258 [econstructor.] 40.078 secs (0.001u,0.018s)
Chars 7259 - 7268 [(intros~E).] 0. secs (0.u,0.s)
Chars 7269 - 7320 [(apply~(@eq_quote_ok~_~_~_~_~_...] 0.001 secs (0.u,0.s)
Chars 7321 - 7363 [(etransitivity;~[~etransitivit...] 0.004 secs (0.003u,0.s)
Chars 7364 - 7365 [-] 0. secs (0.u,0.s)
Chars 7366 - 7385 [(rewrite~2!eval_map).] 0.003 secs (0.003u,0.s)
Chars 7386 - 7401 [(apply~eval_ext).] 0.001 secs (0.001u,0.s)
Chars 7402 - 7427 [(intros~[?|~?];~reflexivity).] 0.003 secs (0.002u,0.s)
Chars 7428 - 7429 [-] 0. secs (0.u,0.s)
Chars 7430 - 7459 [(rewrite~(eval_map~sum_assoc)).] 0.003 secs (0.002u,0.s)
Chars 7462 - 7477 [(apply~eval_ext).] 0.001 secs (0.001u,0.s)
Chars 7478 - 7507 [(intros~[[?|~?]|~?];~reflexivi...] 0.004 secs (0.004u,0.s)
Chars 7245 - 7258 [econstructor.] 0. secs (0.u,0.s)
Chars 7259 - 7268 [(intros~E).] 0. secs (0.u,0.s)
Chars 7269 - 7320 [(apply~(@eq_quote_ok~_~_~_~_~_...] 0. secs (0.u,0.s)
Chars 7321 - 7363 [(etransitivity;~[~etransitivit...] 0.001 secs (0.u,0.s)
Chars 7366 - 7385 [(rewrite~2!eval_map).] 0. secs (0.u,0.s)
Chars 7386 - 7401 [(apply~eval_ext).] 0. secs (0.u,0.s)
Chars 7402 - 7427 [(intros~[?|~?];~reflexivity).] 0.001 secs (0.001u,0.s)
Chars 7430 - 7459 [(rewrite~(eval_map~sum_assoc)).] 0. secs (0.u,0.s)
Chars 7462 - 7477 [(apply~eval_ext).] 0. secs (0.u,0.s)
Chars 7478 - 7507 [(intros~[[?|~?]|~?];~reflexivi...] 0.002 secs (0.002u,0.s)
Chars 7508 - 7516 [Defined.] 0.003 secs (0.003u,0.s)
Chars 7518 - 7571 [Definition~sum_forget~{A}~{B}~...] 0. secs (0.u,0.s)
Chars 7572 - 7578 [Proof.] 0. secs (0.u,0.s)
Chars 7949 - 7959 [(intros~H').] 40.079 secs (0.u,0.019s)
Chars 7960 - 7997 [(eapply~merely_destruct;~try~a...] 0.002 secs (0.002u,0.s)
Chars 8000 - 8014 [(intros~[a~Ha]).] 0.001 secs (0.001u,0.s)
Chars 8015 - 8058 [(induction~(well_foundedness~a...] 0.003 secs (0.002u,0.s)
Chars 8061 - 8121 [(destruct~(LEM~(merely~(exists...] 0.033 secs (0.024u,0.008s)
Chars 8124 - 8125 [-] 0. secs (0.u,0.s)
Chars 8126 - 8162 [(eapply~merely_destruct;~try~a...] 0.003 secs (0.002u,0.s)
Chars 8163 - 8177 [(intros~[b~Hb]).] 0.001 secs (0.001u,0.s)
Chars 8178 - 8201 [(apply~(IH~b);~apply~Hb).] 0.002 secs (0.001u,0.s)
Chars 8204 - 8205 [-] 0. secs (0.u,0.s)
Chars 8206 - 8215 [(apply~tr).] 0.001 secs (0.001u,0.s)
Chars 8216 - 8225 [exists~a.] 0. secs (0.u,0.s)
Chars 8226 - 8246 [(split;~try~apply~Ha).] 0.001 secs (0.001u,0.s)
Chars 8247 - 8259 [(intros~b~Hb).] 0. secs (0.u,0.s)
Chars 8264 - 8300 [specialize~(trichotomy_ordinal...] 0.001 secs (0.001u,0.s)
Chars 8301 - 8311 [(intros~H1).] 0. secs (0.u,0.s)
Chars 8316 - 8353 [(eapply~merely_destruct;~try~a...] 0.003 secs (0.003u,0.s)
Chars 8358 - 8373 [(intros~[H2|~H2]).] 0.001 secs (0.001u,0.s)
Chars 8374 - 8375 [{] 0. secs (0.u,0.s)
Chars 8376 - 8385 [(apply~tr).] 0.001 secs (0.001u,0.s)
Chars 8386 - 8395 [now~left.] 0.002 secs (0.002u,0.s)
Chars 8396 - 8397 [}] 0. secs (0.u,0.s)
Chars 8402 - 8439 [(eapply~merely_destruct;~try~a...] 0.004 secs (0.003u,0.s)
Chars 8444 - 8459 [(intros~[H3|~H3]).] 0.001 secs (0.001u,0.s)
Chars 8460 - 8461 [{] 0. secs (0.u,0.s)
Chars 8462 - 8471 [(apply~tr).] 0.001 secs (0.001u,0.s)
Chars 8472 - 8482 [now~right.] 0.003 secs (0.002u,0.001s)
Chars 8483 - 8484 [}] 0. secs (0.u,0.s)
Chars 8489 - 8512 [(apply~Empty_rec,~H,~tr).] 0.001 secs (0.001u,0.s)
Chars 8513 - 8522 [exists~b.] 0.001 secs (0.001u,0.s)
Chars 8523 - 8533 [now~split.] 0.003 secs (0.002u,0.s)
Chars 7949 - 7959 [(intros~H').] 0. secs (0.u,0.s)
Chars 7960 - 7997 [(eapply~merely_destruct;~try~a...] 0. secs (0.u,0.s)
Chars 8000 - 8014 [(intros~[a~Ha]).] 0. secs (0.u,0.s)
Chars 8015 - 8058 [(induction~(well_foundedness~a...] 0. secs (0.u,0.s)
Chars 8061 - 8121 [(destruct~(LEM~(merely~(exists...] 0. secs (0.u,0.s)
Chars 8126 - 8162 [(eapply~merely_destruct;~try~a...] 0.001 secs (0.001u,0.s)
Chars 8163 - 8177 [(intros~[b~Hb]).] 0. secs (0.u,0.s)
Chars 8178 - 8201 [(apply~(IH~b);~apply~Hb).] 0.001 secs (0.001u,0.s)
Chars 8206 - 8215 [(apply~tr).] 0. secs (0.u,0.s)
Chars 8216 - 8225 [exists~a.] 0. secs (0.u,0.s)
Chars 8226 - 8246 [(split;~try~apply~Ha).] 0.001 secs (0.001u,0.s)
Chars 8247 - 8259 [(intros~b~Hb).] 0. secs (0.u,0.s)
Chars 8264 - 8300 [specialize~(trichotomy_ordinal...] 0. secs (0.u,0.s)
Chars 8301 - 8311 [(intros~H1).] 0. secs (0.u,0.s)
Chars 8316 - 8353 [(eapply~merely_destruct;~try~a...] 0.001 secs (0.u,0.s)
Chars 8358 - 8373 [(intros~[H2|~H2]).] 0. secs (0.u,0.s)
Chars 8376 - 8385 [(apply~tr).] 0. secs (0.u,0.s)
Chars 8386 - 8395 [now~left.] 0. secs (0.u,0.s)
Chars 8402 - 8439 [(eapply~merely_destruct;~try~a...] 0.001 secs (0.001u,0.s)
Chars 8444 - 8459 [(intros~[H3|~H3]).] 0. secs (0.u,0.s)
Chars 8462 - 8471 [(apply~tr).] 0. secs (0.u,0.s)
Chars 8472 - 8482 [now~right.] 0. secs (0.u,0.s)
Chars 8489 - 8512 [(apply~Empty_rec,~H,~tr).] 0. secs (0.u,0.s)
Chars 8513 - 8522 [exists~b.] 0. secs (0.u,0.s)
Chars 8523 - 8533 [now~split.] 0. secs (0.u,0.s)
Chars 8534 - 8538 [Qed.] 0.005 secs (0.005u,0.s)
Chars 8870 - 9105 [Class~IsSimulation~{A~B~:~Type...] 0.005 secs (0.002u,0.002s)
Chars 9106 - 9154 [Arguments~simulation_is_hom~{_...] 0. secs (0.u,0.s)
Chars 9157 - 9271 [#[global]~Instance~ishprop_IsS...] 0.001 secs (0.001u,0.s)
Chars 9272 - 9278 [Proof.] 0. secs (0.u,0.s)
Chars 3027 - 3040 [(intros~E1~E2).] 40.012 secs (0.u,0.003s)
Chars 3041 - 3070 [transitivity~(x₁~⊔~y₂).] 0.008 secs (0.008u,0.s)
Chars 3073 - 3074 [-] 0. secs (0.u,0.s)
Chars 3075 - 3111 [(apply~(order_preserving~(x₁⊔))).] 0.001 secs (0.001u,0.s)
Chars 3112 - 3120 [trivial.] 0. secs (0.u,0.s)
Chars 3123 - 3124 [-] 0. secs (0.u,0.s)
Chars 3125 - 3169 [(apply~(order_preserving~(⊔y₂)...] 0.001 secs (0.001u,0.s)
Chars 3027 - 3040 [(intros~E1~E2).] 0. secs (0.u,0.s)
Chars 3041 - 3070 [transitivity~(x₁~⊔~y₂).] 0. secs (0.u,0.s)
Chars 3075 - 3111 [(apply~(order_preserving~(x₁⊔))).] 0. secs (0.u,0.s)
Chars 3112 - 3120 [trivial.] 0. secs (0.u,0.s)
Chars 3125 - 3169 [(apply~(order_preserving~(⊔y₂)...] 0. secs (0.u,0.s)
Chars 3172 - 3176 [Qed.] 0. secs (0.u,0.s)
Chars 3180 - 3238 [Lemma~join_le~x~y~z~:~x~≤~z~->...] 0. secs (0.u,0.s)
Chars 3241 - 3247 [Proof.] 0. secs (0.u,0.s)
Chars 10687 - 10729 [(srapply~Colimit_rec;~srapply~...] 40.091 secs (0.002u,0.02s)
Chars 10732 - 10733 [-] 0. secs (0.u,0.s)
Chars 10734 - 10786 [exact~(fun~n~a~=>~Colimit~(fib...] 0.001 secs (0.001u,0.s)
Chars 10789 - 10790 [-] 0. secs (0.u,0.s)
Chars 10791 - 10849 [(intros~n~m~p~a;~destruct~p;~a...] 0.003 secs (0.002u,0.s)
Chars 10854 - 10921 [exact~(equiv_colim_succ_seq_to...] 0.002 secs (0.002u,0.s)
Chars 10687 - 10729 [(srapply~Colimit_rec;~srapply~...] 0. secs (0.u,0.s)
Chars 10734 - 10786 [exact~(fun~n~a~=>~Colimit~(fib...] 0. secs (0.u,0.s)
Chars 10791 - 10849 [(intros~n~m~p~a;~destruct~p;~a...] 0. secs (0.u,0.s)
Chars 10854 - 10921 [exact~(equiv_colim_succ_seq_to...] 0. secs (0.u,0.s)
Chars 10922 - 10930 [Defined.] 0.002 secs (0.002u,0.s)
Chars 10932 - 11103 [Definition~fib_seq_to_type_fam...] 0.006 secs (0.005u,0.s)
Chars 11104 - 11110 [Proof.] 0. secs (0.u,0.s)
Chars 8030 - 8052 [srapply~amal_type_ind.] 40.125 secs (0.112u,0.004s)
Chars 8057 - 8068 [1:~exact~e.] 0. secs (0.u,0.s)
Chars 8073 - 8124 [all:~(intros;~apply~dp_path_tr...] 0.012 secs (0.012u,0.s)
Chars 8030 - 8052 [srapply~amal_type_ind.] 0. secs (0.u,0.s)
Chars 8057 - 8068 [1:~exact~e.] 0. secs (0.u,0.s)
Chars 8073 - 8124 [all:~(intros;~apply~dp_path_tr...] 0.004 secs (0.004u,0.s)
Chars 8127 - 8135 [Defined.] 0.005 secs (0.005u,0.s)
Chars 8224 - 8804 [Definition~amal_type_rec~(P~:~...] 0.007 secs (0.007u,0.s)
Chars 8807 - 8813 [Proof.] 0. secs (0.u,0.s)
Chars 3130 - 3136 [split.] 40.103 secs (0.u,0.018s)
Chars 3139 - 3140 [-] 0. secs (0.u,0.s)
Chars 3141 - 3149 [(apply~_).] 0.04 secs (0.035u,0.005s)
Chars 3152 - 3153 [-] 0. secs (0.u,0.s)
Chars 3154 - 3165 [(intros~x~E).] 0. secs (0.u,0.s)
Chars 3170 - 3212 [(destruct~(pseudo_order_antisy...] 0.001 secs (0.u,0.s)
Chars 3215 - 3216 [-] 0. secs (0.u,0.s)
Chars 3217 - 3236 [(intros~x~y~z~E1~E2).] 0. secs (0.u,0.s)
Chars 3241 - 3307 [(apply~(merely_destruct~(cotra...] 0.014 secs (0.014u,0.s)
Chars 3312 - 3354 [(destruct~(pseudo_order_antisy...] 0.002 secs (0.u,0.001s)
Chars 3130 - 3136 [split.] 0. secs (0.u,0.s)
Chars 3141 - 3149 [(apply~_).] 0. secs (0.u,0.s)
Chars 3154 - 3165 [(intros~x~E).] 0. secs (0.u,0.s)
Chars 3170 - 3212 [(destruct~(pseudo_order_antisy...] 0. secs (0.u,0.s)
Chars 3217 - 3236 [(intros~x~y~z~E1~E2).] 0. secs (0.u,0.s)
Chars 3241 - 3307 [(apply~(merely_destruct~(cotra...] 0. secs (0.u,0.s)
Chars 3312 - 3354 [(destruct~(pseudo_order_antisy...] 0. secs (0.u,0.s)
Chars 3357 - 3361 [Qed.] 0.001 secs (0.001u,0.s)
Chars 3365 - 3421 [#[global]Instance~nlt_trans~:~...] 0. secs (0.u,0.s)
Chars 3424 - 3430 [Proof.] 0. secs (0.u,0.s)
Chars 7579 - 7598 [(intros~[[]|~?];~auto).] 40.081 secs (0.001u,0.017s)
Chars 7579 - 7598 [(intros~[[]|~?];~auto).] 0. secs (0.u,0.s)
Chars 7599 - 7607 [Defined.] 0. secs (0.u,0.s)
Chars 7609 - 7835 [Lemma~quote_equality~{V~:~Type...] 0.001 secs (0.001u,0.s)
Chars 7836 - 7842 [Proof.] 0. secs (0.u,0.s)
Chars 9281 - 9310 [(eapply~istrunc_equiv_istrunc).] 40.111 secs (0.u,0.02s)
Chars 9313 - 9314 [-] 0. secs (0.u,0.s)
Chars 9315 - 9321 [issig.] 0.026 secs (0.022u,0.003s)
Chars 9324 - 9325 [-] 0. secs (0.u,0.s)
Chars 9326 - 9334 [exact~_.] 0.039 secs (0.036u,0.002s)
Chars 9281 - 9310 [(eapply~istrunc_equiv_istrunc).] 0. secs (0.u,0.s)
Chars 9315 - 9321 [issig.] 0. secs (0.u,0.s)
Chars 9326 - 9334 [exact~_.] 0.017 secs (0.017u,0.s)
Chars 9335 - 9339 [Qed.] 0.01 secs (0.009u,0.s)
Chars 9342 - 9550 [#[global]~Instance~isinjective...] 0.001 secs (0.001u,0.s)
Chars 9551 - 9557 [Proof.] 0. secs (0.u,0.s)
Chars 3252 - 3267 [(apply~join_lub).] 40.013 secs (0.u,0.003s)
Chars 3252 - 3267 [(apply~join_lub).] 0. secs (0.u,0.s)
Chars 3270 - 3274 [Qed.] 0. secs (0.u,0.s)
Chars 3278 - 3297 [Section~total_join.] 0. secs (0.u,0.s)
Chars 3300 - 3329 [Context~`{!TotalRelation~le}.] 0. secs (0.u,0.s)
Chars 3333 - 3414 [Lemma~total_join_either~`{!Tot...] 0. secs (0.u,0.s)
Chars 3417 - 3423 [Proof.] 0. secs (0.u,0.s)
Chars 7843 - 7854 [(intros~?~E).] 14.251 secs (0.001u,0.019s)
Chars 7855 - 7897 [(rewrite~<-~(eval_quote~l),~<-...] 0.002 secs (0.002u,0.s)
Chars 7898 - 7951 [(path_via~(eval~heap~(expr_map...] 0.004 secs (0.003u,0.s)
Chars 7952 - 7969 [(rewrite~eval_map).] 0.001 secs (0.001u,0.s)
Chars 7970 - 7985 [(apply~eval_ext).] 0.001 secs (0.001u,0.s)
Chars 7986 - 8000 [(intros~[[]|~?]).] 0.001 secs (0.001u,0.s)
Chars 8001 - 8013 [reflexivity.] 0. secs (0.u,0.s)
Chars 7843 - 7854 [(intros~?~E).] 0. secs (0.u,0.s)
Chars 7855 - 7897 [(rewrite~<-~(eval_quote~l),~<-...] 0. secs (0.u,0.s)
Chars 7898 - 7951 [(path_via~(eval~heap~(expr_map...] 0. secs (0.u,0.s)
Chars 7952 - 7969 [(rewrite~eval_map).] 0. secs (0.u,0.s)
Chars 7970 - 7985 [(apply~eval_ext).] 0. secs (0.u,0.s)
Chars 7986 - 8000 [(intros~[[]|~?]).] 0. secs (0.u,0.s)
Chars 8001 - 8013 [reflexivity.] 0. secs (0.u,0.s)
Chars 8014 - 8018 [Qed.] 0.001 secs (0.001u,0.s)
Chars 8020 - 8033 [End~contents.] 0.069 secs (0.063u,0.005s)
Chars 8035 - 8059 [Module~Export~Instances.] 0. secs (0.u,0.s)
Chars 8062 - 8182 [#[global]~Existing~Instances~l...] 0.001 secs (0.001u,0.s)
Chars 8185 - 8228 [#[global]Existing~Instance~quo...] 0. secs (0.u,0.s)
Chars 8231 - 8274 [#[global]Existing~Instance~quo...] 0. secs (0.u,0.s)
Chars 8275 - 8289 [End~Instances.] 0. secs (0.u,0.s)
Chars 8291 - 8303 [End~Quoting.] 0.091 secs (0.075u,0.016s)
Chars 11113 - 11170 [srapply~(ap~_~(Colimit_rec_bet...] 40.118 secs (0.005u,0.018s)
Chars 11173 - 11225 [srapply~(transport_idmap_path_...] 0.004 secs (0.002u,0.002s)
Chars 11113 - 11170 [srapply~(ap~_~(Colimit_rec_bet...] 0. secs (0.u,0.s)
Chars 11173 - 11225 [srapply~(transport_idmap_path_...] 0.001 secs (0.001u,0.s)
Chars 11226 - 11234 [Defined.] 0.017 secs (0.013u,0.003s)
Chars 11236 - 11344 [#[local]~Definition~Delta~{X}~...] 0.001 secs (0.u,0.001s)
Chars 11345 - 11351 [Proof.] 0. secs (0.u,0.s)
Chars 8818 - 8841 [snrapply~amal_type_ind.] 40.019 secs (0.008u,0.002s)
Chars 8846 - 8857 [1:~exact~_.] 0.002 secs (0.002u,0.s)
Chars 8862 - 8873 [1:~exact~e.] 0. secs (0.u,0.s)
Chars 8878 - 8906 [all:~(intros;~apply~dp_const).] 0.022 secs (0.022u,0.s)
Chars 8911 - 8923 [1:~(apply~eh).] 0.001 secs (0.001u,0.s)
Chars 8928 - 8940 [1:~(apply~ek).] 0.001 secs (0.001u,0.s)
Chars 8945 - 8956 [1:~(apply~t).] 0.001 secs (0.001u,0.s)
Chars 8961 - 8973 [1:~(apply~oh).] 0.001 secs (0.001u,0.s)
Chars 8978 - 8987 [(apply~ok).] 0.001 secs (0.001u,0.s)
Chars 8818 - 8841 [snrapply~amal_type_ind.] 0. secs (0.u,0.s)
Chars 8846 - 8857 [1:~exact~_.] 0. secs (0.u,0.s)
Chars 8862 - 8873 [1:~exact~e.] 0. secs (0.u,0.s)
Chars 8878 - 8906 [all:~(intros;~apply~dp_const).] 0.009 secs (0.009u,0.s)
Chars 8911 - 8923 [1:~(apply~eh).] 0. secs (0.u,0.s)
Chars 8928 - 8940 [1:~(apply~ek).] 0. secs (0.u,0.s)
Chars 8945 - 8956 [1:~(apply~t).] 0. secs (0.u,0.s)
Chars 8961 - 8973 [1:~(apply~oh).] 0. secs (0.u,0.s)
Chars 8978 - 8987 [(apply~ok).] 0. secs (0.u,0.s)
Chars 8990 - 8998 [Defined.] 0.003 secs (0.003u,0.s)
Chars 9184 - 9232 [#[global]Instance~sgop_amal_ty...] 0. secs (0.u,0.s)
Chars 9235 - 9241 [Proof.] 0. secs (0.u,0.s)
Chars 9246 - 9267 [(intros~x~y;~revert~x).] 7.078 secs (0.u,0.003s)
Chars 9272 - 9314 [(srapply~amal_type_rec;~intros...] 0.085 secs (0.085u,0.s)
Chars 9319 - 9320 [{] 0. secs (0.u,0.s)
Chars 9321 - 9353 [(srapply~amal_type_rec;~intros...] 0.075 secs (0.075u,0.s)
Chars 9360 - 9389 [1:~exact~(amal_eta~(x~++~y)).] 0. secs (0.u,0.s)
Chars 9396 - 9397 [{] 0. secs (0.u,0.s)
Chars 9398 - 9413 [(intros~z~h1~h2).] 0. secs (0.u,0.s)
Chars 9422 - 9466 [refine~((ap~amal_eta~_~@~_)~@~...] 0.001 secs (0.001u,0.s)
Chars 9475 - 9503 [1,~3:~(apply~word_concat_w_ww).] 0.001 secs (0.001u,0.s)
Chars 9512 - 9529 [rapply~amal_mu_H.] 0.001 secs (0.001u,0.s)
Chars 9530 - 9531 [}] 0. secs (0.u,0.s)
Chars 9538 - 9539 [{] 0. secs (0.u,0.s)
Chars 9540 - 9555 [(intros~z~k1~k2).] 0. secs (0.u,0.s)
Chars 9564 - 9608 [refine~((ap~amal_eta~_~@~_)~@~...] 0.001 secs (0.001u,0.s)
Chars 9617 - 9645 [1,~3:~(apply~word_concat_w_ww).] 0.001 secs (0.001u,0.s)
Chars 9654 - 9671 [rapply~amal_mu_K.] 0.001 secs (0.001u,0.s)
Chars 9672 - 9673 [}] 0. secs (0.u,0.s)
Chars 9680 - 9681 [{] 0. secs (0.u,0.s)
Chars 9682 - 9693 [(intros~w~z).] 0. secs (0.u,0.s)
Chars 9702 - 9746 [refine~((ap~amal_eta~_~@~_)~@~...] 0.001 secs (0.001u,0.s)
Chars 9755 - 9783 [1,~3:~(apply~word_concat_w_ww).] 0.001 secs (0.001u,0.s)
Chars 9792 - 9807 [(apply~amal_tau).] 0.005 secs (0.004u,0.s)
Chars 9808 - 9809 [}] 0. secs (0.u,0.s)
Chars 9816 - 9817 [{] 0. secs (0.u,0.s)
Chars 9818 - 9827 [(intros~z).] 0. secs (0.u,0.s)
Chars 9836 - 9880 [refine~((ap~amal_eta~_~@~_)~@~...] 0.001 secs (0.001u,0.s)
Chars 9889 - 9917 [1,~3:~(apply~word_concat_w_ww).] 0.001 secs (0.001u,0.s)
Chars 9926 - 9945 [(apply~amal_omega_H).] 0. secs (0.u,0.s)
Chars 9946 - 9947 [}] 0. secs (0.u,0.s)
Chars 9954 - 9955 [{] 0. secs (0.u,0.s)
Chars 9956 - 9965 [(intros~z).] 0. secs (0.u,0.s)
Chars 9974 - 10018 [refine~((ap~amal_eta~_~@~_)~@~...] 0.001 secs (0.001u,0.s)
Chars 10027 - 10055 [1,~3:~(apply~word_concat_w_ww).] 0.001 secs (0.001u,0.s)
Chars 10064 - 10083 [(apply~amal_omega_K).] 0. secs (0.u,0.s)
Chars 10084 - 10085 [}] 0. secs (0.u,0.s)
Chars 10086 - 10087 [}] 0. secs (0.u,0.s)
Chars 10092 - 10093 [{] 0. secs (0.u,0.s)
Chars 10094 - 10121 [(intros~r~y~h1~h2;~revert~r).] 0.01 secs (0.01u,0.s)
Chars 10128 - 10160 [(rapply~amal_type_ind_hprop;~c...] 0.233 secs (0.233u,0.s)
Chars 10167 - 10297 [(intros~z;~~~change~~~~~(amal_...] 0.066 secs (0.065u,0.s)
Chars 10304 - 10348 [refine~((ap~amal_eta~_^~@~_)~@...] 0.001 secs (0.001u,0.s)
Chars 10355 - 10383 [1,~3:~(apply~word_concat_w_ww).] 0.001 secs (0.001u,0.s)
Chars 10390 - 10460 [refine~((ap~amal_eta~(ap~(app~...] 0.002 secs (0.002u,0.s)
Chars 10467 - 10495 [1,~3:~(apply~word_concat_w_ww).] 0.001 secs (0.001u,0.s)
Chars 10502 - 10518 [(apply~amal_mu_H).] 0. secs (0.u,0.s)
Chars 10519 - 10520 [}] 0. secs (0.u,0.s)
Chars 10525 - 10526 [{] 0. secs (0.u,0.s)
Chars 10527 - 10554 [(intros~r~y~k1~k2;~revert~r).] 0.012 secs (0.012u,0.s)
Chars 9560 - 9569 [(intros~a).] 26.455 secs (0.u,0.019s)
Chars 9570 - 9614 [(induction~(well_foundedness~a...] 0.002 secs (0.002u,0.s)
Chars 9617 - 9626 [(intros~b).] 0. secs (0.u,0.s)
Chars 9629 - 9642 [revert~a~IHa.] 0. secs (0.u,0.s)
Chars 9643 - 9687 [(induction~(well_foundedness~b...] 0.002 secs (0.001u,0.s)
Chars 9688 - 9701 [(intros~a~IHa).] 0. secs (0.u,0.s)
Chars 9704 - 9717 [(intros~fa_fb).] 0. secs (0.u,0.s)
Chars 9718 - 9749 [(apply~extensionality;~intros~c).] 0.002 secs (0.002u,0.s)
Chars 9750 - 9756 [split.] 0. secs (0.u,0.s)
Chars 9759 - 9760 [-] 0. secs (0.u,0.s)
Chars 9761 - 9772 [(intros~c_a).] 0. secs (0.u,0.s)
Chars 9777 - 9845 [(assert~(fc_fa~:~f~c~<~f~a)~by...] 0.001 secs (0.001u,0.s)
Chars 9850 - 9918 [(assert~(fc_fb~:~f~c~<~f~b)~by...] 0.001 secs (0.001u,0.s)
Chars 9923 - 10030 [(assert~(H1~:~hexists~(fun~c'~...] 0.002 secs (0.001u,0.s)
Chars 10035 - 10059 [refine~(Trunc_rec~_~H1).] 0.004 secs (0.004u,0.s)
Chars 10060 - 10088 [(intros~(c',~(c'_b,~fc'_fc))).] 0.001 secs (0.001u,0.s)
Chars 10093 - 10115 [(assert~(c~=~c')~as~->).] 0.001 secs (0.u,0.s)
Chars 10116 - 10117 [{] 0. secs (0.u,0.s)
Chars 10124 - 10134 [(apply~IHa).] 0. secs (0.u,0.s)
Chars 10141 - 10142 [+] 0. secs (0.u,0.s)
Chars 10143 - 10153 [exact~c_a.] 0. secs (0.u,0.s)
Chars 10160 - 10161 [+] 0. secs (0.u,0.s)
Chars 10162 - 10171 [symmetry.] 0.001 secs (0.001u,0.s)
Chars 10172 - 10185 [exact~fc'_fc.] 0. secs (0.u,0.s)
Chars 10190 - 10191 [}] 0. secs (0.u,0.s)
Chars 10196 - 10207 [exact~c'_b.] 0. secs (0.u,0.s)
Chars 10210 - 10211 [-] 0. secs (0.u,0.s)
Chars 10212 - 10223 [(intros~c_b).] 0. secs (0.u,0.s)
Chars 10228 - 10296 [(assert~(fc_fb~:~f~c~<~f~b)~by...] 0.001 secs (0.001u,0.s)
Chars 10301 - 10366 [(assert~(fc_fa~:~f~c~<~f~a)~by...] 0.001 secs (0.001u,0.s)
Chars 10371 - 10478 [(assert~(H1~:~hexists~(fun~c'~...] 0.003 secs (0.002u,0.001s)
Chars 10483 - 10507 [refine~(Trunc_rec~_~H1).] 0.004 secs (0.004u,0.s)
Chars 10508 - 10536 [(intros~(c',~(c'_a,~fc'_fc))).] 0.001 secs (0.001u,0.s)
Chars 10541 - 10563 [(assert~(c'~=~c)~as~<-).] 0.001 secs (0.001u,0.s)
Chars 10568 - 10569 [+] 0. secs (0.u,0.s)
Chars 10570 - 10580 [(apply~IHb).] 0. secs (0.u,0.s)
Chars 10587 - 10588 [*] 0. secs (0.u,0.s)
Chars 10589 - 10599 [exact~c_b.] 0. secs (0.u,0.s)
Chars 10606 - 10607 [*] 0. secs (0.u,0.s)
Chars 10608 - 10624 [(intros~a'~a'_c').] 0. secs (0.u,0.s)
Chars 10625 - 10635 [(apply~IHa).] 0. secs (0.u,0.s)
Chars 10636 - 10668 [exact~(transitivity~a'_c'~c'_a).] 0.002 secs (0.001u,0.s)
Chars 10675 - 10676 [*] 0. secs (0.u,0.s)
Chars 10677 - 10690 [exact~fc'_fc.] 0. secs (0.u,0.s)
Chars 10695 - 10696 [+] 0. secs (0.u,0.s)
Chars 10697 - 10708 [exact~c'_a.] 0. secs (0.u,0.s)
Chars 9560 - 9569 [(intros~a).] 0. secs (0.u,0.s)
Chars 9570 - 9614 [(induction~(well_foundedness~a...] 0. secs (0.u,0.s)
Chars 9617 - 9626 [(intros~b).] 0. secs (0.u,0.s)
Chars 9629 - 9642 [revert~a~IHa.] 0. secs (0.u,0.s)
Chars 9643 - 9687 [(induction~(well_foundedness~b...] 0. secs (0.u,0.s)
Chars 9688 - 9701 [(intros~a~IHa).] 0. secs (0.u,0.s)
Chars 9704 - 9717 [(intros~fa_fb).] 0. secs (0.u,0.s)
Chars 9718 - 9749 [(apply~extensionality;~intros~c).] 0. secs (0.u,0.s)
Chars 9750 - 9756 [split.] 0. secs (0.u,0.s)
Chars 9761 - 9772 [(intros~c_a).] 0. secs (0.u,0.s)
Chars 9777 - 9845 [(assert~(fc_fa~:~f~c~<~f~a)~by...] 0. secs (0.u,0.s)
Chars 9850 - 9918 [(assert~(fc_fb~:~f~c~<~f~b)~by...] 0. secs (0.u,0.s)
Chars 9923 - 10030 [(assert~(H1~:~hexists~(fun~c'~...] 0. secs (0.u,0.s)
Chars 10035 - 10059 [refine~(Trunc_rec~_~H1).] 0. secs (0.u,0.s)
Chars 10060 - 10088 [(intros~(c',~(c'_b,~fc'_fc))).] 0. secs (0.u,0.s)
Chars 10093 - 10115 [(assert~(c~=~c')~as~->).] 0. secs (0.u,0.s)
Chars 10124 - 10134 [(apply~IHa).] 0. secs (0.u,0.s)
Chars 3433 - 3446 [(intros~x~y~z).] 40.078 secs (0.u,0.018s)
Chars 10143 - 10153 [exact~c_a.] 0. secs (0.u,0.s)
Chars 10162 - 10171 [symmetry.] 0. secs (0.u,0.s)
Chars 3449 - 3465 [(intros~E1~E2~E3).] 0. secs (0.u,0.s)
Chars 10172 - 10185 [exact~fc'_fc.] 0. secs (0.u,0.s)
Chars 10196 - 10207 [exact~c'_b.] 0. secs (0.u,0.s)
Chars 10212 - 10223 [(intros~c_b).] 0. secs (0.u,0.s)
Chars 10228 - 10296 [(assert~(fc_fb~:~f~c~<~f~b)~by...] 0. secs (0.u,0.s)
Chars 10301 - 10366 [(assert~(fc_fa~:~f~c~<~f~a)~by...] 0. secs (0.u,0.s)
Chars 10371 - 10478 [(assert~(H1~:~hexists~(fun~c'~...] 0. secs (0.u,0.s)
Chars 10483 - 10507 [refine~(Trunc_rec~_~H1).] 0. secs (0.u,0.s)
Chars 10508 - 10536 [(intros~(c',~(c'_a,~fc'_fc))).] 0. secs (0.u,0.s)
Chars 3468 - 3543 [(apply~(merely_destruct~(cotra...] 0.004 secs (0.003u,0.s)
Chars 10541 - 10563 [(assert~(c'~=~c)~as~<-).] 0. secs (0.u,0.s)
Chars 3433 - 3446 [(intros~x~y~z).] 0. secs (0.u,0.s)
Chars 3449 - 3465 [(intros~E1~E2~E3).] 0. secs (0.u,0.s)
Chars 10570 - 10580 [(apply~IHb).] 0. secs (0.u,0.s)
Chars 10589 - 10599 [exact~c_b.] 0. secs (0.u,0.s)
Chars 3468 - 3543 [(apply~(merely_destruct~(cotra...] 0. secs (0.u,0.s)
Chars 10608 - 10624 [(intros~a'~a'_c').] 0. secs (0.u,0.s)
Chars 3546 - 3550 [Qed.] 0. secs (0.u,0.s)
Chars 10625 - 10635 [(apply~IHa).] 0. secs (0.u,0.s)
Chars 3554 - 3616 [#[global]Instance~nlt_antisymm...] 0. secs (0.u,0.s)
Chars 10636 - 10668 [exact~(transitivity~a'_c'~c'_a).] 0. secs (0.u,0.s)
Chars 3619 - 3625 [Proof.] 0. secs (0.u,0.s)
Chars 10677 - 10690 [exact~fc'_fc.] 0. secs (0.u,0.s)
Chars 10697 - 10708 [exact~c'_a.] 0. secs (0.u,0.s)
Chars 10709 - 10713 [Qed.] 0.003 secs (0.003u,0.s)
Chars 10716 - 10945 [Lemma~simulation_is_minimal~{A...] 0.002 secs (0.002u,0.s)
Chars 10946 - 10952 [Proof.] 0. secs (0.u,0.s)
Chars 10561 - 10593 [(rapply~amal_type_ind_hprop;~c...] 0.238 secs (0.237u,0.s)
Chars 10600 - 10730 [(intros~z;~~~change~~~~~(amal_...] 0.066 secs (0.065u,0.s)
Chars 10737 - 10781 [refine~((ap~amal_eta~_^~@~_)~@...] 0.001 secs (0.001u,0.s)
Chars 10788 - 10816 [1,~3:~(apply~word_concat_w_ww).] 0.001 secs (0.001u,0.s)
Chars 10823 - 10893 [refine~((ap~amal_eta~(ap~(app~...] 0.002 secs (0.002u,0.s)
Chars 10900 - 10928 [1,~3:~(apply~word_concat_w_ww).] 0.001 secs (0.001u,0.s)
Chars 10935 - 10951 [(apply~amal_mu_K).] 0. secs (0.u,0.s)
Chars 10952 - 10953 [}] 0. secs (0.u,0.s)
Chars 10958 - 10959 [{] 0. secs (0.u,0.s)
Chars 10960 - 10983 [(intros~r~y~z;~revert~r).] 0.013 secs (0.013u,0.s)
Chars 10990 - 11022 [(rapply~amal_type_ind_hprop;~c...] 0.234 secs (0.233u,0.s)
Chars 11029 - 11144 [(intros~w;~~~change~~~~~(amal_...] 0.057 secs (0.057u,0.s)
Chars 11151 - 11195 [refine~((ap~amal_eta~_^~@~_)~@...] 0.001 secs (0.001u,0.s)
Chars 11202 - 11230 [1,~3:~(apply~word_concat_w_ww).] 0.001 secs (0.001u,0.s)
Chars 11237 - 11307 [refine~((ap~amal_eta~(ap~(app~...] 0.009 secs (0.009u,0.s)
Chars 11314 - 11342 [1,~3:~(apply~word_concat_w_ww).] 0.001 secs (0.001u,0.s)
Chars 11349 - 11364 [(apply~amal_tau).] 0. secs (0.u,0.s)
Chars 11365 - 11366 [}] 0. secs (0.u,0.s)
Chars 11371 - 11372 [{] 0. secs (0.u,0.s)
Chars 11373 - 11394 [(intros~r~z;~revert~r).] 0.015 secs (0.015u,0.s)
Chars 11401 - 11433 [(rapply~amal_type_ind_hprop;~c...] 0.204 secs (0.203u,0.s)
Chars 11440 - 11535 [(intros~w;~~~change~~~~~(amal_...] 0.058 secs (0.056u,0.002s)
Chars 11542 - 11586 [refine~((ap~amal_eta~_^~@~_)~@...] 0.001 secs (0.001u,0.s)
Chars 11593 - 11621 [1,~3:~(apply~word_concat_w_ww).] 0.001 secs (0.001u,0.s)
Chars 11628 - 11669 [refine~(ap~amal_eta~(ap~(app~x...] 0.001 secs (0.001u,0.s)
Chars 11676 - 11702 [1:~(apply~word_concat_w_ww).] 0. secs (0.u,0.s)
Chars 11709 - 11728 [(apply~amal_omega_H).] 0. secs (0.u,0.s)
Chars 11729 - 11730 [}] 0. secs (0.u,0.s)
Chars 11735 - 11736 [{] 0. secs (0.u,0.s)
Chars 11737 - 11758 [(intros~r~z;~revert~r).] 0.016 secs (0.016u,0.s)
Chars 11765 - 11797 [(rapply~amal_type_ind_hprop;~c...] 0.212 secs (0.21u,0.001s)
Chars 11804 - 11899 [(intros~w;~~~change~~~~~(amal_...] 0.047 secs (0.047u,0.s)
Chars 11906 - 11950 [refine~((ap~amal_eta~_^~@~_)~@...] 0.001 secs (0.001u,0.s)
Chars 11957 - 11985 [1,~3:~(apply~word_concat_w_ww).] 0.001 secs (0.001u,0.s)
Chars 11992 - 12033 [refine~(ap~amal_eta~(ap~(app~x...] 0.006 secs (0.006u,0.s)
Chars 12040 - 12066 [1:~(apply~word_concat_w_ww).] 0. secs (0.u,0.s)
Chars 12073 - 12092 [(apply~amal_omega_K).] 0. secs (0.u,0.s)
Chars 12093 - 12094 [}] 0. secs (0.u,0.s)
Chars 9246 - 9267 [(intros~x~y;~revert~x).] 0. secs (0.u,0.s)
Chars 9272 - 9314 [(srapply~amal_type_rec;~intros...] 0.003 secs (0.002u,0.s)
Chars 9321 - 9353 [(srapply~amal_type_rec;~intros...] 0.001 secs (0.001u,0.s)
Chars 9360 - 9389 [1:~exact~(amal_eta~(x~++~y)).] 0. secs (0.u,0.s)
Chars 9398 - 9413 [(intros~z~h1~h2).] 0. secs (0.u,0.s)
Chars 9422 - 9466 [refine~((ap~amal_eta~_~@~_)~@~...] 0. secs (0.u,0.s)
Chars 9475 - 9503 [1,~3:~(apply~word_concat_w_ww).] 0. secs (0.u,0.s)
Chars 9512 - 9529 [rapply~amal_mu_H.] 0. secs (0.u,0.s)
Chars 9540 - 9555 [(intros~z~k1~k2).] 0. secs (0.u,0.s)
Chars 9564 - 9608 [refine~((ap~amal_eta~_~@~_)~@~...] 0. secs (0.u,0.s)
Chars 9617 - 9645 [1,~3:~(apply~word_concat_w_ww).] 0. secs (0.u,0.s)
Chars 9654 - 9671 [rapply~amal_mu_K.] 0. secs (0.u,0.s)
Chars 9682 - 9693 [(intros~w~z).] 0. secs (0.u,0.s)
Chars 9702 - 9746 [refine~((ap~amal_eta~_~@~_)~@~...] 0. secs (0.u,0.s)
Chars 9755 - 9783 [1,~3:~(apply~word_concat_w_ww).] 0. secs (0.u,0.s)
Chars 9792 - 9807 [(apply~amal_tau).] 0. secs (0.u,0.s)
Chars 9818 - 9827 [(intros~z).] 0. secs (0.u,0.s)
Chars 9836 - 9880 [refine~((ap~amal_eta~_~@~_)~@~...] 0. secs (0.u,0.s)
Chars 9889 - 9917 [1,~3:~(apply~word_concat_w_ww).] 0. secs (0.u,0.s)
Chars 9926 - 9945 [(apply~amal_omega_H).] 0. secs (0.u,0.s)
Chars 9956 - 9965 [(intros~z).] 0. secs (0.u,0.s)
Chars 9974 - 10018 [refine~((ap~amal_eta~_~@~_)~@~...] 0. secs (0.u,0.s)
Chars 10027 - 10055 [1,~3:~(apply~word_concat_w_ww).] 0. secs (0.u,0.s)
Chars 10064 - 10083 [(apply~amal_omega_K).] 0. secs (0.u,0.s)
Chars 10094 - 10121 [(intros~r~y~h1~h2;~revert~r).] 0.008 secs (0.008u,0.s)
Chars 10128 - 10160 [(rapply~amal_type_ind_hprop;~c...] 0.012 secs (0.012u,0.s)
Chars 10167 - 10297 [(intros~z;~~~change~~~~~(amal_...] 0.055 secs (0.054u,0.s)
Chars 10304 - 10348 [refine~((ap~amal_eta~_^~@~_)~@...] 0. secs (0.u,0.s)
Chars 10355 - 10383 [1,~3:~(apply~word_concat_w_ww).] 0. secs (0.u,0.s)
Chars 10390 - 10460 [refine~((ap~amal_eta~(ap~(app~...] 0. secs (0.u,0.s)
Chars 10467 - 10495 [1,~3:~(apply~word_concat_w_ww).] 0. secs (0.u,0.s)
Chars 10502 - 10518 [(apply~amal_mu_H).] 0. secs (0.u,0.s)
Chars 10527 - 10554 [(intros~r~y~k1~k2;~revert~r).] 0.008 secs (0.008u,0.s)
Chars 10561 - 10593 [(rapply~amal_type_ind_hprop;~c...] 0.012 secs (0.012u,0.s)
Chars 10600 - 10730 [(intros~z;~~~change~~~~~(amal_...] 0.058 secs (0.058u,0.s)
Chars 10737 - 10781 [refine~((ap~amal_eta~_^~@~_)~@...] 0. secs (0.u,0.s)
Chars 10788 - 10816 [1,~3:~(apply~word_concat_w_ww).] 0. secs (0.u,0.s)
Chars 10823 - 10893 [refine~((ap~amal_eta~(ap~(app~...] 0. secs (0.u,0.s)
Chars 10900 - 10928 [1,~3:~(apply~word_concat_w_ww).] 0. secs (0.u,0.s)
Chars 10935 - 10951 [(apply~amal_mu_K).] 0. secs (0.u,0.s)
Chars 10960 - 10983 [(intros~r~y~z;~revert~r).] 0.008 secs (0.008u,0.s)
Chars 10990 - 11022 [(rapply~amal_type_ind_hprop;~c...] 0.012 secs (0.012u,0.s)
Chars 11029 - 11144 [(intros~w;~~~change~~~~~(amal_...] 0.048 secs (0.047u,0.s)
Chars 11151 - 11195 [refine~((ap~amal_eta~_^~@~_)~@...] 0. secs (0.u,0.s)
Chars 11202 - 11230 [1,~3:~(apply~word_concat_w_ww).] 0. secs (0.u,0.s)
Chars 11237 - 11307 [refine~((ap~amal_eta~(ap~(app~...] 0. secs (0.u,0.s)
Chars 11314 - 11342 [1,~3:~(apply~word_concat_w_ww).] 0. secs (0.u,0.s)
Chars 11349 - 11364 [(apply~amal_tau).] 0. secs (0.u,0.s)
Chars 11373 - 11394 [(intros~r~z;~revert~r).] 0.008 secs (0.008u,0.s)
Chars 11401 - 11433 [(rapply~amal_type_ind_hprop;~c...] 0.01 secs (0.01u,0.s)
Chars 11440 - 11535 [(intros~w;~~~change~~~~~(amal_...] 0.048 secs (0.047u,0.s)
Chars 11542 - 11586 [refine~((ap~amal_eta~_^~@~_)~@...] 0. secs (0.u,0.s)
Chars 11593 - 11621 [1,~3:~(apply~word_concat_w_ww).] 0. secs (0.u,0.s)
Chars 11628 - 11669 [refine~(ap~amal_eta~(ap~(app~x...] 0. secs (0.u,0.s)
Chars 11676 - 11702 [1:~(apply~word_concat_w_ww).] 0. secs (0.u,0.s)
Chars 11709 - 11728 [(apply~amal_omega_H).] 0. secs (0.u,0.s)
Chars 11737 - 11758 [(intros~r~z;~revert~r).] 0.008 secs (0.008u,0.s)
Chars 11765 - 11797 [(rapply~amal_type_ind_hprop;~c...] 0.01 secs (0.01u,0.s)
Chars 11804 - 11899 [(intros~w;~~~change~~~~~(amal_...] 0.049 secs (0.047u,0.001s)
Chars 11906 - 11950 [refine~((ap~amal_eta~_^~@~_)~@...] 0. secs (0.u,0.s)
Chars 11957 - 11985 [1,~3:~(apply~word_concat_w_ww).] 0. secs (0.u,0.s)
Chars 11992 - 12033 [refine~(ap~amal_eta~(ap~(app~x...] 0. secs (0.u,0.s)
Chars 12040 - 12066 [1:~(apply~word_concat_w_ww).] 0. secs (0.u,0.s)
Chars 12073 - 12092 [(apply~amal_omega_K).] 0. secs (0.u,0.s)
Chars 12097 - 12105 [Defined.] 0.286 secs (0.285u,0.s)
Chars 12157 - 12211 [#[global]Instance~monunit_amal...] 0. secs (0.u,0.s)
Chars 12214 - 12220 [Proof.] 0. secs (0.u,0.s)
'C[[::]]
     : nat
'C[[:: 8]]
     : nat
Chars 3426 - 3459 [(destruct~(total~le~x~y)~as~[E...] 40.015 secs (0.002u,0.003s)
Chars 3462 - 3463 [-] 0. secs (0.u,0.s)
Chars 3464 - 3470 [right.] 0. secs (0.u,0.s)
Chars 3471 - 3486 [(apply~join_r,~E).] 0. secs (0.u,0.s)
Chars 3489 - 3490 [-] 0. secs (0.u,0.s)
Chars 3491 - 3496 [left.] 0. secs (0.u,0.s)
Chars 3497 - 3512 [(apply~join_l,~E).] 0. secs (0.u,0.s)
Chars 3426 - 3459 [(destruct~(total~le~x~y)~as~[E...] 0. secs (0.u,0.s)
Chars 3464 - 3470 [right.] 0. secs (0.u,0.s)
Chars 3471 - 3486 [(apply~join_r,~E).] 0. secs (0.u,0.s)
Chars 3491 - 3496 [left.] 0. secs (0.u,0.s)
Chars 3497 - 3512 [(apply~join_l,~E).] 0. secs (0.u,0.s)
Chars 3515 - 3519 [Qed.] 0. secs (0.u,0.s)
Chars 3523 - 3615 [Definition~max~x~y~:=~match~to...] 0.001 secs (0.001u,0.s)
Chars 3619 - 3665 [Lemma~total_join_max~x~y~:~joi...] 0. secs (0.u,0.s)
Chars 3668 - 3674 [Proof.] 0. secs (0.u,0.s)
Chars 11354 - 11392 [(destruct~p;~destruct~psi;~ref...] 40.111 secs (0.003u,0.018s)
Chars 11354 - 11392 [(destruct~p;~destruct~psi;~ref...] 0. secs (0.u,0.s)
Chars 11393 - 11401 [Defined.] 0.001 secs (0.001u,0.s)
Chars 11403 - 11525 [#[local]~Definition~Delta_proj...] 0.001 secs (0.001u,0.s)
Chars 11526 - 11532 [Proof.] 0. secs (0.u,0.s)
Chars 11535 - 11573 [(destruct~p;~destruct~psi;~ref...] 0.074 secs (0.004u,0.019s)
Chars 11535 - 11573 [(destruct~p;~destruct~psi;~ref...] 0.001 secs (0.001u,0.s)
Chars 11574 - 11582 [Defined.] 0.001 secs (0.001u,0.s)
Chars 11700 - 11835 [Definition~seq_colim_sum_to_su...] 0.001 secs (0.u,0.s)
Chars 11836 - 11842 [Proof.] 0. secs (0.u,0.s)
Chars 3628 - 3645 [(intros~x~y~H1~H2).] 40.081 secs (0.u,0.018s)
Chars 3648 - 3666 [(apply~tight_apart).] 0.001 secs (0.001u,0.s)
Chars 3667 - 3678 [(intros~nap).] 0. secs (0.u,0.s)
Chars 3679 - 3711 [(apply~apart_iff_total_lt~in~n...] 0.001 secs (0.001u,0.s)
Chars 3714 - 3732 [(destruct~nap;~auto).] 0.001 secs (0.u,0.s)
Chars 10955 - 10969 [(intros~a~b~H1).] 40.08 secs (0.u,0.019s)
Chars 3628 - 3645 [(intros~x~y~H1~H2).] 0. secs (0.u,0.s)
Chars 3648 - 3666 [(apply~tight_apart).] 0. secs (0.u,0.s)
Chars 3667 - 3678 [(intros~nap).] 0. secs (0.u,0.s)
Chars 3679 - 3711 [(apply~apart_iff_total_lt~in~n...] 0. secs (0.u,0.s)
Chars 3714 - 3732 [(destruct~nap;~auto).] 0. secs (0.u,0.s)
Chars 3735 - 3739 [Qed.] 0. secs (0.u,0.s)
Chars 3743 - 3812 [Lemma~ne_total_lt~`{!TrivialAp...] 0.001 secs (0.001u,0.s)
Chars 3815 - 3821 [Proof.] 0. secs (0.u,0.s)
Chars 10972 - 11027 [refine~(Trunc_rec~_~(simulatio...] 0.024 secs (0.022u,0.002s)
Chars 11028 - 11029 [{] 0. secs (0.u,0.s)
Chars 11034 - 11054 [(apply~hprop_allpath).] 0. secs (0.u,0.s)
Chars 11055 - 11089 [(intros~(a1,~(?,~p))~(a2,~(?,~...] 0.004 secs (0.004u,0.s)
Chars 11094 - 11122 [(apply~path_sigma_hprop;~cbn).] 0.026 secs (0.023u,0.002s)
Chars 11123 - 11143 [(apply~(injective~f)).] 0.017 secs (0.012u,0.004s)
Chars 11144 - 11152 [exact~p.] 0. secs (0.u,0.s)
Chars 11155 - 11156 [}] 0. secs (0.u,0.s)
Chars 11159 - 11171 [exact~idmap.] 0. secs (0.u,0.s)
Chars 10955 - 10969 [(intros~a~b~H1).] 0. secs (0.u,0.s)
Chars 10972 - 11027 [refine~(Trunc_rec~_~(simulatio...] 0. secs (0.u,0.s)
Chars 11034 - 11054 [(apply~hprop_allpath).] 0. secs (0.u,0.s)
Chars 11055 - 11089 [(intros~(a1,~(?,~p))~(a2,~(?,~...] 0. secs (0.u,0.s)
Chars 11094 - 11122 [(apply~path_sigma_hprop;~cbn).] 0. secs (0.u,0.s)
Chars 11123 - 11143 [(apply~(injective~f)).] 0. secs (0.u,0.s)
Chars 11144 - 11152 [exact~p.] 0. secs (0.u,0.s)
Chars 11159 - 11171 [exact~idmap.] 0. secs (0.u,0.s)
Chars 3824 - 3862 [(intros~neq;~apply~trivial_apa...] 0.078 secs (0.u,0.02s)
Chars 11172 - 11176 [Qed.] 0.001 secs (0.001u,0.s)
Chars 3865 - 3886 [(apply~apart_total_lt).] 0. secs (0.u,0.s)
Chars 3887 - 3898 [assumption.] 0. secs (0.u,0.s)
Chars 3824 - 3862 [(intros~neq;~apply~trivial_apa...] 0. secs (0.u,0.s)
Chars 11179 - 11351 [Lemma~path_simulation~`{Funext...] 0.001 secs (0.001u,0.s)
Chars 3865 - 3886 [(apply~apart_total_lt).] 0. secs (0.u,0.s)
Chars 11352 - 11358 [Proof.] 0. secs (0.u,0.s)
Chars 3887 - 3898 [assumption.] 0. secs (0.u,0.s)
Chars 3901 - 3905 [Qed.] 0. secs (0.u,0.s)
Chars 3909 - 3999 [#[global]~Instance~lt_trichoto...] 0. secs (0.u,0.s)
Chars 4002 - 4008 [Proof.] 0. secs (0.u,0.s)
Chars 12225 - 12246 [exact~(amal_eta~nil).] 40.013 secs (0.001u,0.003s)
Chars 12225 - 12246 [exact~(amal_eta~nil).] 0. secs (0.u,0.s)
Chars 12249 - 12257 [Defined.] 0. secs (0.u,0.s)
Chars 12261 - 12313 [#[global]Instance~negate_amal_...] 0. secs (0.u,0.s)
Chars 12316 - 12322 [Proof.] 0. secs (0.u,0.s)
Chars 12327 - 12349 [srapply~amal_type_rec.] 1.14 secs (0.067u,0.003s)
Chars 12354 - 12355 [{] 0. secs (0.u,0.s)
Chars 12356 - 12365 [(intros~w).] 0. secs (0.u,0.s)
Chars 12372 - 12406 [exact~(amal_eta~(word_inverse~...] 0. secs (0.u,0.s)
Chars 12407 - 12408 [}] 0. secs (0.u,0.s)
Chars 12413 - 12414 [{] 0. secs (0.u,0.s)
Chars 12415 - 12437 [(hnf;~intros~x~y~h1~h2).] 0. secs (0.u,0.s)
Chars 12444 - 12488 [refine~((ap~amal_eta~_~@~_)~@~...] 0.001 secs (0.001u,0.s)
Chars 12495 - 12554 [1,~3:~refine~(word_inverse_ww~...] 0.002 secs (0.002u,0.s)
Chars 12561 - 12586 [1:~(apply~word_inverse_ww).] 0. secs (0.u,0.s)
Chars 12593 - 12594 [{] 0. secs (0.u,0.s)
Chars 12595 - 12628 [refine~(word_inverse_ww~_~_~@~_).] 0. secs (0.u,0.s)
Chars 12637 - 12653 [(apply~ap;~simpl).] 0.001 secs (0.001u,0.s)
Chars 12662 - 12689 [rapply~(ap~(fun~s~=>~[s])).] 0.001 secs (0.u,0.s)
Chars 12698 - 12707 [(apply~ap).] 0. secs (0.u,0.s)
Chars 12716 - 12735 [(apply~negate_sg_op).] 0. secs (0.u,0.s)
Chars 12736 - 12737 [}] 0. secs (0.u,0.s)
Chars 12744 - 12750 [(simpl).] 0.001 secs (0.001u,0.s)
Chars 12757 - 12801 [refine~((ap~amal_eta~_^~@~_)~@...] 0.001 secs (0.001u,0.s)
Chars 12808 - 12836 [1,~3:~(apply~word_concat_w_ww).] 0.001 secs (0.001u,0.s)
Chars 12843 - 12859 [(apply~amal_mu_H).] 0. secs (0.u,0.s)
Chars 12860 - 12861 [}] 0. secs (0.u,0.s)
Chars 12866 - 12867 [{] 0. secs (0.u,0.s)
Chars 12868 - 12890 [(hnf;~intros~x~y~k1~k2).] 0. secs (0.u,0.s)
Chars 12897 - 12941 [refine~((ap~amal_eta~_~@~_)~@~...] 0.001 secs (0.001u,0.s)
Chars 12948 - 13007 [1,~3:~refine~(word_inverse_ww~...] 0.002 secs (0.002u,0.s)
Chars 13014 - 13039 [1:~(apply~word_inverse_ww).] 0. secs (0.u,0.s)
Chars 13046 - 13047 [{] 0. secs (0.u,0.s)
Chars 13048 - 13081 [refine~(word_inverse_ww~_~_~@~_).] 0. secs (0.u,0.s)
Chars 13090 - 13106 [(apply~ap;~simpl).] 0.001 secs (0.001u,0.s)
Chars 13115 - 13142 [rapply~(ap~(fun~s~=>~[s])).] 0.001 secs (0.001u,0.s)
Chars 13151 - 13160 [(apply~ap).] 0. secs (0.u,0.s)
Chars 13169 - 13188 [(apply~negate_sg_op).] 0.001 secs (0.001u,0.s)
Chars 13189 - 13190 [}] 0. secs (0.u,0.s)
Chars 13197 - 13203 [(simpl).] 0.001 secs (0.001u,0.s)
Chars 13210 - 13254 [refine~((ap~amal_eta~_^~@~_)~@...] 0.001 secs (0.001u,0.s)
Chars 13261 - 13289 [1,~3:~(apply~word_concat_w_ww).] 0.001 secs (0.001u,0.s)
Chars 13296 - 13312 [(apply~amal_mu_K).] 0.007 secs (0.006u,0.001s)
Chars 13313 - 13314 [}] 0. secs (0.u,0.s)
Chars 13319 - 13320 [{] 0. secs (0.u,0.s)
Chars 13321 - 13339 [(hnf;~intros~x~y~z).] 0.001 secs (0.u,0.s)
Chars 13346 - 13390 [refine~((ap~amal_eta~_~@~_)~@~...] 0.001 secs (0.001u,0.s)
Chars 13397 - 13456 [1,~3:~refine~(word_inverse_ww~...] 0.002 secs (0.002u,0.s)
Chars 13463 - 13489 [1,~2:~(cbn;~refine~(ap~_~_)).] 0.002 secs (0.002u,0.s)
Chars 13496 - 13528 [1,~2:~rapply~(ap~(fun~s~=>~[s])).] 0.002 secs (0.002u,0.s)
Chars 13535 - 13549 [1,~2:~(apply~ap).] 0.001 secs (0.001u,0.s)
Chars 13556 - 13590 [1,~2:~(symmetry;~apply~grp_hom...] 0.002 secs (0.002u,0.s)
Chars 13597 - 13641 [refine~((ap~amal_eta~_^~@~_)~@...] 0.001 secs (0.001u,0.s)
Chars 13648 - 13676 [1,~3:~(apply~word_concat_w_ww).] 0.001 secs (0.001u,0.s)
Chars 13683 - 13698 [(apply~amal_tau).] 0. secs (0.u,0.s)
Chars 13699 - 13700 [}] 0. secs (0.u,0.s)
Chars 13705 - 13706 [{] 0. secs (0.u,0.s)
Chars 13707 - 13723 [(hnf;~intros~x~z).] 0. secs (0.u,0.s)
Chars 13730 - 13774 [refine~((ap~amal_eta~_~@~_)~@~...] 0.001 secs (0.001u,0.s)
Chars 13781 - 13808 [1,~3:~(apply~word_inverse_ww).] 0. secs (0.u,0.s)
Chars 13815 - 13842 [refine~(ap~amal_eta~_~@~_).] 0.001 secs (0.001u,0.s)
Chars 13849 - 13850 [{] 0. secs (0.u,0.s)
Chars 13851 - 13883 [refine~(ap~(fun~s~=>~s~++~_)~_).] 0.001 secs (0.u,0.s)
Chars 13892 - 13914 [(apply~word_inverse_ww).] 0. secs (0.u,0.s)
Chars 13915 - 13916 [}] 0. secs (0.u,0.s)
Chars 13923 - 13951 [refine~(ap~amal_eta~_^~@~_).] 0.001 secs (0.001u,0.s)
Chars 13958 - 13984 [1:~(apply~word_concat_w_ww).] 0. secs (0.u,0.s)
Chars 13991 - 13997 [(simpl).] 0. secs (0.u,0.s)
Chars 14004 - 14028 [(rewrite~negate_mon_unit).] 0.001 secs (0.001u,0.s)
Chars 14035 - 14054 [(apply~amal_omega_H).] 0. secs (0.u,0.s)
Chars 14055 - 14056 [}] 0. secs (0.u,0.s)
Chars 14061 - 14062 [{] 0. secs (0.u,0.s)
Chars 14063 - 14079 [(hnf;~intros~x~z).] 0. secs (0.u,0.s)
Chars 14086 - 14130 [refine~((ap~amal_eta~_~@~_)~@~...] 0.001 secs (0.001u,0.s)
Chars 14137 - 14164 [1,~3:~(apply~word_inverse_ww).] 0. secs (0.u,0.s)
Chars 14171 - 14198 [refine~(ap~amal_eta~_~@~_).] 0.001 secs (0.001u,0.s)
Chars 14205 - 14206 [{] 0. secs (0.u,0.s)
Chars 14207 - 14239 [refine~(ap~(fun~s~=>~s~++~_)~_).] 0.001 secs (0.001u,0.s)
Chars 14248 - 14270 [(apply~word_inverse_ww).] 0. secs (0.u,0.s)
Chars 14271 - 14272 [}] 0. secs (0.u,0.s)
Chars 14279 - 14307 [refine~(ap~amal_eta~_^~@~_).] 0.001 secs (0.001u,0.s)
Chars 14314 - 14340 [1:~(apply~word_concat_w_ww).] 0. secs (0.u,0.s)
Chars 14347 - 14353 [(simpl).] 0. secs (0.u,0.s)
Chars 14360 - 14384 [(rewrite~negate_mon_unit).] 0.001 secs (0.001u,0.s)
Chars 14391 - 14410 [(apply~amal_omega_K).] 0. secs (0.u,0.s)
Chars 14411 - 14412 [}] 0. secs (0.u,0.s)
Chars 12327 - 12349 [srapply~amal_type_rec.] 0. secs (0.u,0.s)
Chars 12356 - 12365 [(intros~w).] 0. secs (0.u,0.s)
Chars 12372 - 12406 [exact~(amal_eta~(word_inverse~...] 0. secs (0.u,0.s)
Chars 12415 - 12437 [(hnf;~intros~x~y~h1~h2).] 0. secs (0.u,0.s)
Chars 12444 - 12488 [refine~((ap~amal_eta~_~@~_)~@~...] 0. secs (0.u,0.s)
Chars 12495 - 12554 [1,~3:~refine~(word_inverse_ww~...] 0. secs (0.u,0.s)
Chars 12561 - 12586 [1:~(apply~word_inverse_ww).] 0. secs (0.u,0.s)
Chars 12595 - 12628 [refine~(word_inverse_ww~_~_~@~_).] 0. secs (0.u,0.s)
Chars 12637 - 12653 [(apply~ap;~simpl).] 0. secs (0.u,0.s)
Chars 12662 - 12689 [rapply~(ap~(fun~s~=>~[s])).] 0. secs (0.u,0.s)
Chars 12698 - 12707 [(apply~ap).] 0. secs (0.u,0.s)
Chars 12716 - 12735 [(apply~negate_sg_op).] 0. secs (0.u,0.s)
Chars 12744 - 12750 [(simpl).] 0. secs (0.u,0.s)
Chars 12757 - 12801 [refine~((ap~amal_eta~_^~@~_)~@...] 0. secs (0.u,0.s)
Chars 12808 - 12836 [1,~3:~(apply~word_concat_w_ww).] 0. secs (0.u,0.s)
Chars 12843 - 12859 [(apply~amal_mu_H).] 0. secs (0.u,0.s)
Chars 12868 - 12890 [(hnf;~intros~x~y~k1~k2).] 0. secs (0.u,0.s)
Chars 12897 - 12941 [refine~((ap~amal_eta~_~@~_)~@~...] 0. secs (0.u,0.s)
Chars 12948 - 13007 [1,~3:~refine~(word_inverse_ww~...] 0. secs (0.u,0.s)
Chars 13014 - 13039 [1:~(apply~word_inverse_ww).] 0. secs (0.u,0.s)
Chars 13048 - 13081 [refine~(word_inverse_ww~_~_~@~_).] 0. secs (0.u,0.s)
Chars 13090 - 13106 [(apply~ap;~simpl).] 0. secs (0.u,0.s)
Chars 13115 - 13142 [rapply~(ap~(fun~s~=>~[s])).] 0. secs (0.u,0.s)
Chars 13151 - 13160 [(apply~ap).] 0. secs (0.u,0.s)
Chars 13169 - 13188 [(apply~negate_sg_op).] 0. secs (0.u,0.s)
Chars 13197 - 13203 [(simpl).] 0. secs (0.u,0.s)
Chars 13210 - 13254 [refine~((ap~amal_eta~_^~@~_)~@...] 0. secs (0.u,0.s)
Chars 13261 - 13289 [1,~3:~(apply~word_concat_w_ww).] 0. secs (0.u,0.s)
Chars 13296 - 13312 [(apply~amal_mu_K).] 0. secs (0.u,0.s)
Chars 13321 - 13339 [(hnf;~intros~x~y~z).] 0. secs (0.u,0.s)
Chars 13346 - 13390 [refine~((ap~amal_eta~_~@~_)~@~...] 0. secs (0.u,0.s)
Chars 13397 - 13456 [1,~3:~refine~(word_inverse_ww~...] 0. secs (0.u,0.s)
Chars 13463 - 13489 [1,~2:~(cbn;~refine~(ap~_~_)).] 0. secs (0.u,0.s)
Chars 13496 - 13528 [1,~2:~rapply~(ap~(fun~s~=>~[s])).] 0. secs (0.u,0.s)
Chars 13535 - 13549 [1,~2:~(apply~ap).] 0. secs (0.u,0.s)
Chars 13556 - 13590 [1,~2:~(symmetry;~apply~grp_hom...] 0. secs (0.u,0.s)
Chars 13597 - 13641 [refine~((ap~amal_eta~_^~@~_)~@...] 0. secs (0.u,0.s)
Chars 13648 - 13676 [1,~3:~(apply~word_concat_w_ww).] 0. secs (0.u,0.s)
Chars 13683 - 13698 [(apply~amal_tau).] 0. secs (0.u,0.s)
Chars 13707 - 13723 [(hnf;~intros~x~z).] 0. secs (0.u,0.s)
Chars 13730 - 13774 [refine~((ap~amal_eta~_~@~_)~@~...] 0. secs (0.u,0.s)
Chars 13781 - 13808 [1,~3:~(apply~word_inverse_ww).] 0. secs (0.u,0.s)
Chars 13815 - 13842 [refine~(ap~amal_eta~_~@~_).] 0. secs (0.u,0.s)
Chars 13851 - 13883 [refine~(ap~(fun~s~=>~s~++~_)~_).] 0. secs (0.u,0.s)
Chars 13892 - 13914 [(apply~word_inverse_ww).] 0. secs (0.u,0.s)
Chars 13923 - 13951 [refine~(ap~amal_eta~_^~@~_).] 0. secs (0.u,0.s)
Chars 13958 - 13984 [1:~(apply~word_concat_w_ww).] 0. secs (0.u,0.s)
Chars 13991 - 13997 [(simpl).] 0. secs (0.u,0.s)
Chars 14004 - 14028 [(rewrite~negate_mon_unit).] 0. secs (0.u,0.s)
Chars 14035 - 14054 [(apply~amal_omega_H).] 0. secs (0.u,0.s)
Chars 14063 - 14079 [(hnf;~intros~x~z).] 0. secs (0.u,0.s)
Chars 14086 - 14130 [refine~((ap~amal_eta~_~@~_)~@~...] 0. secs (0.u,0.s)
Chars 14137 - 14164 [1,~3:~(apply~word_inverse_ww).] 0. secs (0.u,0.s)
Chars 14171 - 14198 [refine~(ap~amal_eta~_~@~_).] 0. secs (0.u,0.s)
Chars 14207 - 14239 [refine~(ap~(fun~s~=>~s~++~_)~_).] 0. secs (0.u,0.s)
Chars 14248 - 14270 [(apply~word_inverse_ww).] 0. secs (0.u,0.s)
Chars 14279 - 14307 [refine~(ap~amal_eta~_^~@~_).] 0. secs (0.u,0.s)
Chars 14314 - 14340 [1:~(apply~word_concat_w_ww).] 0. secs (0.u,0.s)
Chars 14347 - 14353 [(simpl).] 0. secs (0.u,0.s)
Chars 14360 - 14384 [(rewrite~negate_mon_unit).] 0. secs (0.u,0.s)
Chars 14391 - 14410 [(apply~amal_omega_K).] 0. secs (0.u,0.s)
Chars 14415 - 14423 [Defined.] 0.015 secs (0.015u,0.s)
Chars 14427 - 14482 [#[global]Instance~associative_...] 0. secs (0.u,0.s)
Chars 14485 - 14491 [Proof.] 0. secs (0.u,0.s)
Chars 3677 - 3721 [(unfold~max;~destruct~(total~l...] 40.014 secs (0.002u,0.003s)
Chars 3724 - 3725 [-] 0. secs (0.u,0.s)
Chars 3726 - 3741 [(apply~join_r,~E).] 0. secs (0.u,0.s)
Chars 3744 - 3745 [-] 0. secs (0.u,0.s)
Chars 3746 - 3761 [(apply~join_l,~E).] 0. secs (0.u,0.s)
Chars 3677 - 3721 [(unfold~max;~destruct~(total~l...] 0. secs (0.u,0.s)
Chars 3726 - 3741 [(apply~join_r,~E).] 0. secs (0.u,0.s)
Chars 3746 - 3761 [(apply~join_l,~E).] 0. secs (0.u,0.s)
Chars 3764 - 3768 [Qed.] 0. secs (0.u,0.s)
Chars 3771 - 3786 [End~total_join.] 0.001 secs (0.001u,0.s)
Chars 3790 - 3828 [Lemma~join_idempotent~x~:~x~⊔~...] 0. secs (0.u,0.s)
Chars 3831 - 3837 [Proof.] 0. secs (0.u,0.s)
Chars 3842 - 3871 [(assert~(le1~:~x~⊔~x~≤~x)).] 0.348 secs (0.u,0.003s)
Chars 3876 - 3877 [{] 0. secs (0.u,0.s)
Chars 3884 - 3931 [(refine~(join_lub~_~_~_~_~_);~...] 0.005 secs (0.005u,0.s)
Chars 3936 - 3937 [}] 0. secs (0.u,0.s)
Chars 3942 - 3971 [(assert~(le2~:~x~≤~x~⊔~x)).] 0. secs (0.u,0.s)
Chars 3976 - 3977 [{] 0. secs (0.u,0.s)
Chars 3984 - 4007 [refine~(join_ub_l~_~_).] 0. secs (0.u,0.s)
Chars 4012 - 4013 [}] 0. secs (0.u,0.s)
Chars 4018 - 4054 [refine~(antisymmetry~_~_~_~le1...] 0.002 secs (0.002u,0.s)
Chars 3842 - 3871 [(assert~(le1~:~x~⊔~x~≤~x)).] 0. secs (0.u,0.s)
Chars 3884 - 3931 [(refine~(join_lub~_~_~_~_~_);~...] 0. secs (0.u,0.s)
Chars 3942 - 3971 [(assert~(le2~:~x~≤~x~⊔~x)).] 0. secs (0.u,0.s)
Chars 3984 - 4007 [refine~(join_ub_l~_~_).] 0. secs (0.u,0.s)
Chars 4018 - 4054 [refine~(antisymmetry~_~_~_~le1...] 0. secs (0.u,0.s)
Chars 4057 - 4061 [Qed.] 0. secs (0.u,0.s)
Chars 4062 - 4089 [End~join_semilattice_order.] 0.025 secs (0.024u,0.s)
Chars 4091 - 4124 [Section~bounded_join_semilattice.] 0. secs (0.u,0.s)
Chars 4127 - 4204 [Context~`{JoinSemiLatticeOrder...] 0. secs (0.u,0.s)
Chars 4208 - 4241 [Lemma~above_bottom~x~:~⊥~≤~x.] 0. secs (0.u,0.s)
Chars 4244 - 4250 [Proof.] 0. secs (0.u,0.s)
Chars 11845 - 11887 [(srapply~Colimit_rec;~srapply~...] 40.106 secs (0.003u,0.019s)
Chars 11890 - 11891 [-] 0. secs (0.u,0.s)
Chars 11892 - 11956 [(intros~n~[a~b];~exact~(inj~A~...] 0.003 secs (0.003u,0.s)
Chars 11959 - 11960 [-] 0. secs (0.u,0.s)
Chars 11961 - 12044 [(intros~n~m~p~[a~b];~destruct~...] 0.01 secs (0.01u,0.s)
Chars 12049 - 12105 [srapply~(Delta~_~(fib_seq_to_t...] 0.008 secs (0.008u,0.s)
Chars 11845 - 11887 [(srapply~Colimit_rec;~srapply~...] 0. secs (0.u,0.s)
Chars 11892 - 11956 [(intros~n~[a~b];~exact~(inj~A~...] 0. secs (0.u,0.s)
Chars 11961 - 12044 [(intros~n~m~p~[a~b];~destruct~...] 0.002 secs (0.002u,0.s)
Chars 12049 - 12105 [srapply~(Delta~_~(fib_seq_to_t...] 0. secs (0.u,0.s)
Chars 12106 - 12114 [Defined.] 0.01 secs (0.008u,0.001s)
Chars 12116 - 12386 [Definition~seq_colim_sum_to_su...] 0.042 secs (0.038u,0.004s)
Chars 12387 - 12393 [Proof.] 0. secs (0.u,0.s)
Chars 12396 - 12428 [srapply~Colimit_rec_beta_colimp.] 1.035 secs (0.011u,0.021s)
Chars 12396 - 12428 [srapply~Colimit_rec_beta_colimp.] 0.001 secs (0.001u,0.s)
Chars 12429 - 12437 [Defined.] 0.021 secs (0.018u,0.002s)
Chars 12531 - 12556 [Section~SeqColimitSumInd.] 0. secs (0.u,0.s)
Chars 12560 - 12606 [Context~`{Univalence}~{A}~(B~:...] 0. secs (0.u,0.s)
Chars 12609 - 12659 [Context~(E~:~sig~(fib_seq_to_t...] 0. secs (0.u,0.s)
Chars 12662 - 12753 [Context~~(e~:~forall~n~a~b,~~~...] 0.002 secs (0.002u,0.s)
Chars 12756 - 12885 [Context~~(t~:~forall~n~a~b,~~~...] 0.006 secs (0.006u,0.s)
Chars 12977 - 13039 [#[local]Definition~Q~k~:~foral...] 0.002 secs (0.002u,0.s)
Chars 13042 - 13048 [Proof.] 0. secs (0.u,0.s)
Chars 11361 - 11389 [(apply~path_forall;~intros~a).] 40.08 secs (0.001u,0.018s)
Chars 11392 - 11435 [(induction~(well_foundedness~a...] 0.002 secs (0.002u,0.s)
Chars 11438 - 11473 [(apply~(extensionality~(f~a)~(...] 0.001 secs (0.001u,0.s)
Chars 4011 - 4022 [(intros~x~y).] 40.082 secs (0.u,0.018s)
Chars 11476 - 11485 [(intros~b).] 0. secs (0.u,0.s)
Chars 11488 - 11494 [split.] 0. secs (0.u,0.s)
Chars 11497 - 11498 [-] 0. secs (0.u,0.s)
Chars 11499 - 11511 [(intros~b_fa).] 0. secs (0.u,0.s)
Chars 11516 - 11576 [(destruct~(simulation_is_minim...] 0.004 secs (0.004u,0.s)
Chars 11581 - 11601 [(rewrite~(IH~_~a'_a)).] 0.001 secs (0.001u,0.s)
Chars 11602 - 11630 [(apply~(simulation_is_hom~g)).] 0.001 secs (0.001u,0.s)
Chars 11631 - 11642 [exact~a'_a.] 0. secs (0.u,0.s)
Chars 11645 - 11646 [-] 0. secs (0.u,0.s)
Chars 11647 - 11659 [(intros~b_ga).] 0. secs (0.u,0.s)
Chars 11664 - 11724 [(destruct~(simulation_is_minim...] 0.005 secs (0.004u,0.s)
Chars 4025 - 4067 [(destruct~(dec~(x~=~y))~as~[?|...] 0.016 secs (0.013u,0.002s)
Chars 11729 - 11752 [(rewrite~<-~(IH~_~a'_a)).] 0.001 secs (0.001u,0.s)
Chars 11753 - 11781 [(apply~(simulation_is_hom~f)).] 0.001 secs (0.001u,0.s)
Chars 11782 - 11793 [exact~a'_a.] 0. secs (0.u,0.s)
Chars 4070 - 4103 [(destruct~(ne_total_lt~x~y);~a...] 0.004 secs (0.004u,0.s)
Chars 11361 - 11389 [(apply~path_forall;~intros~a).] 0. secs (0.u,0.s)
Chars 11392 - 11435 [(induction~(well_foundedness~a...] 0. secs (0.u,0.s)
Chars 4011 - 4022 [(intros~x~y).] 0. secs (0.u,0.s)
Chars 11438 - 11473 [(apply~(extensionality~(f~a)~(...] 0. secs (0.u,0.s)
Chars 11476 - 11485 [(intros~b).] 0. secs (0.u,0.s)
Chars 4025 - 4067 [(destruct~(dec~(x~=~y))~as~[?|...] 0. secs (0.u,0.s)
Chars 11488 - 11494 [split.] 0. secs (0.u,0.s)
Chars 11499 - 11511 [(intros~b_fa).] 0. secs (0.u,0.s)
Chars 4070 - 4103 [(destruct~(ne_total_lt~x~y);~a...] 0. secs (0.u,0.s)
Chars 11516 - 11576 [(destruct~(simulation_is_minim...] 0. secs (0.u,0.s)
Chars 11581 - 11601 [(rewrite~(IH~_~a'_a)).] 0. secs (0.u,0.s)
Chars 11602 - 11630 [(apply~(simulation_is_hom~g)).] 0. secs (0.u,0.s)
Chars 4106 - 4110 [Qed.] 0.001 secs (0.001u,0.s)
Chars 11631 - 11642 [exact~a'_a.] 0. secs (0.u,0.s)
Chars 11647 - 11659 [(intros~b_ga).] 0. secs (0.u,0.s)
Chars 11664 - 11724 [(destruct~(simulation_is_minim...] 0. secs (0.u,0.s)
Chars 11729 - 11752 [(rewrite~<-~(IH~_~a'_a)).] 0. secs (0.u,0.s)
Chars 11753 - 11781 [(apply~(simulation_is_hom~f)).] 0. secs (0.u,0.s)
Chars 11782 - 11793 [exact~a'_a.] 0. secs (0.u,0.s)
Chars 11794 - 11798 [Qed.] 0.002 secs (0.001u,0.s)
Chars 11801 - 11979 [#[global]~Instance~is_simulati...] 0.002 secs (0.002u,0.s)
Chars 11980 - 11986 [Proof.] 0. secs (0.u,0.s)
Chars 4111 - 4128 [End~pseudo_order.] 0.015 secs (0.013u,0.001s)
Chars 4130 - 4157 [Section~full_partial_order.] 0. secs (0.u,0.s)
Chars 4160 - 4190 [Context~`{FullPartialOrder~A}.] 0. secs (0.u,0.s)
Chars 4194 - 4234 [#[local]Existing~Instance~stri...] 0. secs (0.u,0.s)
Chars 4381 - 4457 [Instance~strict_po_apart_ne~~x...] 0. secs (0.u,0.s)
Chars 4460 - 4466 [Proof.] 0. secs (0.u,0.s)
Chars 4469 - 4485 [(intros;~apply~_).] 0.073 secs (0.002u,0.017s)
Chars 4469 - 4485 [(intros;~apply~_).] 0. secs (0.u,0.s)
Chars 4488 - 4492 [Qed.] 0. secs (0.u,0.s)
Chars 4496 - 4559 [#[global]Instance~fullpartialo...] 0. secs (0.u,0.s)
Chars 4562 - 4568 [Proof.] 0. secs (0.u,0.s)
Chars 14496 - 14507 [(intros~x~y).] 40.015 secs (0.u,0.004s)
Chars 14512 - 14558 [(rapply~amal_type_ind_hprop;~i...] 0.026 secs (0.026u,0.s)
Chars 14563 - 14609 [(rapply~amal_type_ind_hprop;~i...] 0.036 secs (0.035u,0.s)
Chars 14614 - 14650 [(rapply~amal_type_ind_hprop;~i...] 0.025 secs (0.025u,0.s)
Chars 14655 - 14677 [nrapply~(ap~amal_eta).] 0.178 secs (0.178u,0.s)
Chars 14682 - 14706 [rapply~word_concat_w_ww.] 0. secs (0.u,0.s)
Chars 14496 - 14507 [(intros~x~y).] 0. secs (0.u,0.s)
Chars 14512 - 14558 [(rapply~amal_type_ind_hprop;~i...] 0. secs (0.u,0.s)
Chars 14563 - 14609 [(rapply~amal_type_ind_hprop;~i...] 0. secs (0.u,0.s)
Chars 14614 - 14650 [(rapply~amal_type_ind_hprop;~i...] 0. secs (0.u,0.s)
Chars 14655 - 14677 [nrapply~(ap~amal_eta).] 0. secs (0.u,0.s)
Chars 14682 - 14706 [rapply~word_concat_w_ww.] 0. secs (0.u,0.s)
Chars 14709 - 14717 [Defined.] 0.007 secs (0.007u,0.s)
Chars 14721 - 14795 [#[global]~Instance~leftidentit...] 0. secs (0.u,0.s)
Chars 14798 - 14804 [Proof.] 0. secs (0.u,0.s)
Chars 4253 - 4275 [(apply~join_sl_le_spec).] 28.542 secs (22.542u,0.024s)
Chars 4253 - 4275 [(apply~join_sl_le_spec).] 40.007 secs (0.u,0.003s)
Chars 4278 - 4300 [(rewrite~left_identity).] 0.002 secs (0.002u,0.s)
Chars 4303 - 4315 [reflexivity.] 0. secs (0.u,0.s)
Chars 4253 - 4275 [(apply~join_sl_le_spec).] 0. secs (0.u,0.s)
Chars 4278 - 4300 [(rewrite~left_identity).] 0. secs (0.u,0.s)
Chars 4303 - 4315 [reflexivity.] 0. secs (0.u,0.s)
Chars 4318 - 4322 [Qed.] 0. secs (0.u,0.s)
Chars 4326 - 4370 [Lemma~below_bottom~x~:~x~≤~⊥~-...] 0. secs (0.u,0.s)
Chars 4373 - 4379 [Proof.] 0. secs (0.u,0.s)
Debug:
In environment
c : int -> int -> rat
c_ann : c.Ann c
c_Sn := c.Sn_ c_ann : c.Sn c
c_Sk := c.Sk_ c_ann : c.Sk c
a := fun n : int => \sum_(0 <= k < n + 1 :> int) c n k : int -> rat
n : int
pi12 : 2 <= n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: c.P_horner a n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
c : int -> int -> rat
c_ann : c.Ann c
c_Sn := c.Sn_ c_ann : c.Sn c
c_Sk := c.Sk_ c_ann : c.Sk c
a := fun n : int => \sum_(0 <= k < n + 1 :> int) c n k : int -> rat
n : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: c.P_horner a n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
c : int -> int -> rat
c_ann : c.Ann c
c_Sn := c.Sn_ c_ann : c.Sn c
c_Sk := c.Sk_ c_ann : c.Sk c
a := fun n : int => \sum_(0 <= k < n + 1 :> int) c n k : int -> rat
n : int
pi12 : 2 <= n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: c.P_horner a n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
c : int -> int -> rat
c_ann : c.Ann c
c_Sn := c.Sn_ c_ann : c.Sn c
c_Sk := c.Sk_ c_ann : c.Sk c
a := fun n : int => \sum_(0 <= k < n + 1 :> int) c n k : int -> rat
n : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: c.P_horner a n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
c : int -> int -> rat
c_ann : c.Ann c
c_Sn := c.Sn_ c_ann : c.Sn c
c_Sk := c.Sk_ c_ann : c.Sk c
a := fun n : int => \sum_(0 <= k < n + 1 :> int) c n k : int -> rat
n : int
m : 2 <= n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: c.P_horner a n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Chars 13053 - 13077 [(induction~k~as~[|~k~h]).] 40.101 secs (0.003u,0.018s)
Chars 13082 - 13083 [-] 0. secs (0.u,0.s)
Chars 13084 - 13092 [exact~e.] 0.001 secs (0.001u,0.s)
Chars 13097 - 13098 [-] 0. secs (0.u,0.s)
Chars 13099 - 13186 [(intros~n~a~b;~exact~~~(Delta~...] 0.009 secs (0.008u,0.s)
Chars 13053 - 13077 [(induction~k~as~[|~k~h]).] 0.001 secs (0.001u,0.s)
Chars 13084 - 13092 [exact~e.] 0.001 secs (0.001u,0.s)
Chars 13099 - 13186 [(intros~n~a~b;~exact~~~(Delta~...] 0.002 secs (0.002u,0.s)
Chars 13189 - 13197 [Defined.] 0.005 secs (0.004u,0.001s)
Chars 13310 - 13523 [#[local]~Definition~Eta~{X}~{Y...] 0.005 secs (0.004u,0.001s)
Chars 13526 - 13532 [Proof.] 0. secs (0.u,0.s)
Debug:
In environment
c : int -> int -> rat
c_ann : c.Ann c
c_Sn := c.Sn_ c_ann : c.Sn c
c_Sk := c.Sk_ c_ann : c.Sk c
a := fun n : int => \sum_(0 <= k < n + 1 :> int) c n k : int -> rat
n : int
pi12 : 2 <= n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: c.P_horner a n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
c : int -> int -> rat
c_ann : c.Ann c
c_Sn := c.Sn_ c_ann : c.Sn c
c_Sk := c.Sk_ c_ann : c.Sk c
a := fun n : int => \sum_(0 <= k < n + 1 :> int) c n k : int -> rat
n : int
p1 : 2 <= n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: c.P_horner a n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
c : int -> int -> rat
c_ann : c.Ann c
c_Sn := c.Sn_ c_ann : c.Sn c
c_Sk := c.Sk_ c_ann : c.Sk c
a := fun n : int => \sum_(0 <= k < n + 1 :> int) c n k : int -> rat
n : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: c.P_horner a n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Chars 11989 - 12001 [constructor.] 40.179 secs (0.u,0.019s)
Chars 12004 - 12005 [-] 0. secs (0.u,0.s)
Chars 12006 - 12023 [(intros~a~a'~a_a').] 0. secs (0.u,0.s)
Chars 12024 - 12034 [(apply~f.2).] 0.001 secs (0.001u,0.s)
Chars 12035 - 12046 [exact~a_a'.] 0. secs (0.u,0.s)
Chars 12049 - 12050 [-] 0. secs (0.u,0.s)
Chars 12051 - 12067 [(intros~a~b~b_fa).] 0. secs (0.u,0.s)
Chars 12068 - 12077 [(apply~tr).] 0. secs (0.u,0.s)
Chars 12078 - 12096 [exists~((f.1)^-1~b).] 0.002 secs (0.002u,0.s)
Chars 12097 - 12103 [split.] 0. secs (0.u,0.s)
Chars 12108 - 12109 [+] 0. secs (0.u,0.s)
Chars 12110 - 12120 [(apply~f.2).] 0.001 secs (0.001u,0.s)
Chars 12121 - 12137 [(rewrite~eisretr).] 0.001 secs (0.001u,0.s)
Chars 12138 - 12149 [exact~b_fa.] 0. secs (0.u,0.s)
Chars 12154 - 12155 [+] 0. secs (0.u,0.s)
Chars 12156 - 12170 [(apply~eisretr).] 0. secs (0.u,0.s)
Chars 11989 - 12001 [constructor.] 0. secs (0.u,0.s)
Chars 12006 - 12023 [(intros~a~a'~a_a').] 0. secs (0.u,0.s)
Chars 12024 - 12034 [(apply~f.2).] 0. secs (0.u,0.s)
Chars 12035 - 12046 [exact~a_a'.] 0. secs (0.u,0.s)
Chars 12051 - 12067 [(intros~a~b~b_fa).] 0. secs (0.u,0.s)
Chars 12068 - 12077 [(apply~tr).] 0. secs (0.u,0.s)
Chars 12078 - 12096 [exists~((f.1)^-1~b).] 0. secs (0.u,0.s)
Chars 12097 - 12103 [split.] 0. secs (0.u,0.s)
Chars 12110 - 12120 [(apply~f.2).] 0. secs (0.u,0.s)
Chars 12121 - 12137 [(rewrite~eisretr).] 0. secs (0.u,0.s)
Chars 12138 - 12149 [exact~b_fa.] 0. secs (0.u,0.s)
Chars 12156 - 12170 [(apply~eisretr).] 0. secs (0.u,0.s)
Chars 12171 - 12175 [Qed.] 0.002 secs (0.002u,0.s)
Chars 12178 - 12274 [#[global]~Instance~ishprop_Iso...] 0. secs (0.u,0.s)
Chars 12275 - 12281 [Proof.] 0. secs (0.u,0.s)
Chars 4571 - 4590 [(split;~try~apply~_).] 40.132 secs (0.039u,0.024s)
Chars 4593 - 4594 [-] 0. secs (0.u,0.s)
Chars 4595 - 4619 [(apply~strict_po_mere_lt).] 0.001 secs (0.001u,0.s)
Chars 4622 - 4623 [-] 0. secs (0.u,0.s)
Chars 4624 - 4633 [(intros~x).] 0. secs (0.u,0.s)
Chars 4634 - 4638 [(red).] 0. secs (0.u,0.s)
Chars 4639 - 4675 [(intros~E;~apply~lt_iff_le_apa...] 0.001 secs (0.001u,0.s)
Chars 4680 - 4700 [(destruct~E~as~[_~?]).] 0. secs (0.u,0.s)
Chars 4705 - 4735 [(apply~(irreflexivity~(≶)~x)).] 0.024 secs (0.02u,0.004s)
Chars 4740 - 4751 [assumption.] 0. secs (0.u,0.s)
Chars 4571 - 4590 [(split;~try~apply~_).] 0. secs (0.u,0.s)
Chars 4595 - 4619 [(apply~strict_po_mere_lt).] 0. secs (0.u,0.s)
Chars 4624 - 4633 [(intros~x).] 0. secs (0.u,0.s)
Chars 4634 - 4638 [(red).] 0. secs (0.u,0.s)
Chars 4639 - 4675 [(intros~E;~apply~lt_iff_le_apa...] 0. secs (0.u,0.s)
Chars 4680 - 4700 [(destruct~E~as~[_~?]).] 0. secs (0.u,0.s)
Chars 4705 - 4735 [(apply~(irreflexivity~(≶)~x)).] 0. secs (0.u,0.s)
Chars 4740 - 4751 [assumption.] 0. secs (0.u,0.s)
Chars 4754 - 4758 [Qed.] 0. secs (0.u,0.s)
Chars 4762 - 4821 [Lemma~lt_le~x~y~:~PropHolds~(x...] 0. secs (0.u,0.s)
Chars 4824 - 4830 [Proof.] 0. secs (0.u,0.s)
Debug:
In environment
c : int -> int -> rat
c_ann : c.Ann c
c_Sn := c.Sn_ c_ann : c.Sn c
c_Sk := c.Sk_ c_ann : c.Sk c
a := fun n : int => \sum_(0 <= k < n + 1 :> int) c n k : int -> rat
n : int
m : 2 <= n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: c.P_horner a n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Chars 14809 - 14845 [(rapply~amal_type_ind_hprop;~i...] 40.048 secs (0.031u,0.005s)
Chars 14850 - 14862 [reflexivity.] 0.006 secs (0.006u,0.s)
Chars 14809 - 14845 [(rapply~amal_type_ind_hprop;~i...] 0. secs (0.u,0.s)
Chars 14850 - 14862 [reflexivity.] 0. secs (0.u,0.s)
Chars 14865 - 14873 [Defined.] 0.006 secs (0.005u,0.s)
Chars 14877 - 14953 [#[global]~Instance~rightidenti...] 0. secs (0.u,0.s)
Chars 14956 - 14962 [Proof.] 0. secs (0.u,0.s)
Debug:
In environment
c : int -> int -> rat
c_ann : c.Ann c
c_Sn := c.Sn_ c_ann : c.Sn c
c_Sk := c.Sk_ c_ann : c.Sk c
a := fun n : int => \sum_(0 <= k < n + 1 :> int) c n k : int -> rat
n : int
pi12 : 2 <= n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: c.P_horner a n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
c : int -> int -> rat
c_ann : c.Ann c
c_Sn := c.Sn_ c_ann : c.Sn c
c_Sk := c.Sk_ c_ann : c.Sk c
a := fun n : int => \sum_(0 <= k < n + 1 :> int) c n k : int -> rat
n : int
pi12 : 2 <= n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: c.P_horner a n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
     = fun x : nat =>
       mexistT MTele_Ty (mTele (fun _ : nat => mBase)) (fun y : nat => x = y)
     : nat -> m:{ y & MTele_Ty y}
Debug:
In environment
c : int -> int -> rat
c_ann : c.Ann c
c_Sn := c.Sn_ c_ann : c.Sn c
c_Sk := c.Sk_ c_ann : c.Sk c
a := fun n : int => \sum_(0 <= k < n + 1 :> int) c n k : int -> rat
n : int
p1 : 2 <= n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: c.P_horner a n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
     = fun _ : nat =>
       mexistT@{Mtac2.meta.MTeleMatch.296 Mtac2.meta.MTeleMatch.297}
         MTele_Ty@{Mtac2.meta.MTeleMatch.312 Mtac2.meta.MTeleMatch.297
         Mtac2.meta.MTeleMatch.298 Mtac2.meta.MTeleMatch.299
         Mtac2.meta.MTeleMatch.319}
         (mTele@{Mtac2.meta.MTeleMatch.312}
            (fun _ : nat => mBase@{Mtac2.meta.MTeleMatch.312}))
         (fun _ : nat => nat)
     : nat ->
       m:{ y &
       MTele_Ty@{Mtac2.meta.MTeleMatch.312 Mtac2.meta.MTeleMatch.297
         Mtac2.meta.MTeleMatch.298 Mtac2.meta.MTeleMatch.299
         Mtac2.meta.MTeleMatch.319} y}
(* {Mtac2.meta.MTeleMatch.332 Mtac2.meta.MTeleMatch.331
    Mtac2.meta.MTeleMatch.330 Mtac2.meta.MTeleMatch.329
    Mtac2.meta.MTeleMatch.328 Mtac2.meta.MTeleMatch.327
    Mtac2.meta.MTeleMatch.326 Mtac2.meta.MTeleMatch.325
    Mtac2.meta.MTeleMatch.324 Mtac2.meta.MTeleMatch.323
    Mtac2.meta.MTeleMatch.322 Mtac2.meta.MTeleMatch.321
    Mtac2.meta.MTeleMatch.320 Mtac2.meta.MTeleMatch.319
    Mtac2.meta.MTeleMatch.318 Mtac2.meta.MTeleMatch.317
    Mtac2.meta.MTeleMatch.316 Mtac2.meta.MTeleMatch.313
    Mtac2.meta.MTeleMatch.312 Mtac2.meta.MTeleMatch.310
    Mtac2.meta.MTeleMatch.309 Mtac2.meta.MTeleMatch.308
    Mtac2.meta.MTeleMatch.307 Mtac2.meta.MTeleMatch.306
    Mtac2.meta.MTeleMatch.305 Mtac2.meta.MTeleMatch.304
    Mtac2.meta.MTeleMatch.303 Mtac2.meta.MTeleMatch.302
    Mtac2.meta.MTeleMatch.301 Mtac2.meta.MTeleMatch.300
    Mtac2.meta.MTeleMatch.299 Mtac2.meta.MTeleMatch.298
    Mtac2.meta.MTeleMatch.297 Mtac2.meta.MTeleMatch.296
    Mtac2.meta.MTeleMatch.295 Mtac2.meta.MTeleMatch.294} |=
     Set < Mtac2.meta.MTeleMatch.299
     Set < Mtac2.meta.MTeleMatch.300
     Set < Mtac2.meta.MTeleMatch.301
     Set < Mtac2.meta.MTeleMatch.309
     Mtac2.meta.MTeleMatch.297 < Mtac2.meta.MTeleMatch.298
     Mtac2.meta.MTeleMatch.303 < Mtac2.meta.MTeleMatch.306
     Mtac2.meta.MTeleMatch.304 < Mtac2.meta.MTeleMatch.303
     Mtac2.meta.MTeleMatch.309 < Mtac2.meta.MTeleMatch.308
     Mtac2.meta.MTeleMatch.310 < Mtac2.meta.MTeleMatch.309
     Mtac2.meta.MTeleMatch.312 < Mtac2.meta.MTeleMatch.296
     Mtac2.meta.MTeleMatch.312 < Mtac2.meta.MTeleMatch.303
     Mtac2.meta.MTeleMatch.319 < Mtac2.meta.MTeleMatch.299
     Mtac2.meta.MTeleMatch.319 < Mtac2.meta.MTeleMatch.303
     Mtac2.meta.MTeleMatch.294 <= Mtac2.meta.MTeleMatch.295
     Mtac2.meta.MTeleMatch.294 <= Mtac2.meta.MTeleMatch.300
     Mtac2.meta.MTeleMatch.294 <= Mtac2.meta.MTeleMatch.316
     Mtac2.meta.MTeleMatch.296 <= Mtac2.meta.MTeleMatch.295
     Mtac2.meta.MTeleMatch.296 <= Mtac2.meta.MTeleMatch.313
     Mtac2.meta.MTeleMatch.297 <= Mtac2.meta.MTeleMatch.295
     Mtac2.meta.MTeleMatch.297 <= Mtac2.meta.MTeleMatch.313
     Mtac2.meta.MTeleMatch.299 <= Mtac2.meta.MTeleMatch.297
     Mtac2.meta.MTeleMatch.301 <= Mtac2.meta.MTeleMatch.303
     Mtac2.meta.MTeleMatch.312 <= Mtac2.meta.MTeleMatch.297
     Mtac2.meta.MTeleMatch.313 <= Mtac2.meta.MTeleMatch.316 *)
[DEBUG] (fun _ : nat =>
 mexistT@{Mtac2.meta.MTeleMatch.336 Mtac2.meta.MTeleMatch.337}
   MTele_Ty@{Mtac2.meta.MTeleMatch.352 Mtac2.meta.MTeleMatch.337
   Mtac2.meta.MTeleMatch.338 Mtac2.meta.MTeleMatch.339
   Mtac2.meta.MTeleMatch.351}
   (mTele@{Mtac2.meta.MTeleMatch.352}
      (fun _ : nat => mBase@{Mtac2.meta.MTeleMatch.352}))
   (fun _ : nat => nat))
     = ("incr",
       (["c"], [], bedrock_func_body:(
         $"v" = load($"c");
         $"one" = $1;
         $"v" = $"v" + $1;
         store($"c", $"v"))))
     : bedrock_func
Chars 4382 - 4391 [(intros~E).] 40.012 secs (0.u,0.002s)
Chars 4394 - 4421 [(apply~join_sl_le_spec~in~E).] 0. secs (0.u,0.s)
Chars 4422 - 4450 [(rewrite~right_identity~in~E).] 0.002 secs (0.002u,0.s)
Chars 4453 - 4461 [trivial.] 0. secs (0.u,0.s)
Chars 4382 - 4391 [(intros~E).] 0. secs (0.u,0.s)
Chars 4394 - 4421 [(apply~join_sl_le_spec~in~E).] 0. secs (0.u,0.s)
Chars 4422 - 4450 [(rewrite~right_identity~in~E).] 0. secs (0.u,0.s)
Chars 4453 - 4461 [trivial.] 0. secs (0.u,0.s)
Chars 4464 - 4468 [Qed.] 0. secs (0.u,0.s)
Chars 4469 - 4498 [End~bounded_join_semilattice.] 0.001 secs (0.001u,0.s)
Chars 4500 - 4531 [Section~meet_semilattice_order.] 0. secs (0.u,0.s)
Chars 4534 - 4568 [Context~`{MeetSemiLatticeOrder...] 0. secs (0.u,0.s)
Chars 4572 - 4618 [Lemma~meet_lb_3_r~x~y~z~:~(x~⊓...] 0. secs (0.u,0.s)
Chars 4621 - 4627 [Proof.] 0. secs (0.u,0.s)
     = 57
     : N
     = 14137
     : N
Chars 13537 - 13603 [(symmetry~in~theta;~destruct~t...] 40.11 secs (0.015u,0.021s)
Chars 13604 - 13616 [reflexivity.] 0.003 secs (0.003u,0.s)
Chars 13537 - 13603 [(symmetry~in~theta;~destruct~t...] 0.009 secs (0.005u,0.003s)
Chars 13604 - 13616 [reflexivity.] 0.001 secs (0.001u,0.s)
Chars 13619 - 13627 [Defined.] 0.002 secs (0.002u,0.s)
Chars 13631 - 13919 [#[local]~Definition~Epsilon~{X...] 0.011 secs (0.009u,0.001s)
Chars 13922 - 13928 [Proof.] 0. secs (0.u,0.s)
clear  H  :  (False -> True)
clear  H  :  (False -> True)
     = Gt
     : comparison
     = Lt
     : comparison
testMmatch@{i j} = 
fun x : Type@{i} => x
     : Type@{i} -> Type@{max(i,j)}
(* i j |=  *)

Arguments testMmatch _%type_scope
testMmatch'@{i j} = 
fun x : Type@{i} => x
     : Type@{i} -> Type@{j}
(* i j |= i <= j *)

Arguments testMmatch' _%type_scope
testret@{u u0} = 
fun x : Type@{u} => x
     : Type@{u} -> Type@{u0}
(* u u0 |= u <= u0 *)

Arguments testret _%type_scope
testexact@{u u0} : Type@{u} -> Type@{u0}
(* u u0 |= u <= u0 *)

testexact is universe polymorphic
Arguments testexact _%type_scope
testexact is opaque
Expands to: Constant Mtac2Tests.bug_universes.testexact
Chars 12284 - 12316 [(apply~hprop_allpath;~intros~f...] 40.088 secs (0.u,0.019s)
Chars 12317 - 12345 [(apply~path_sigma_hprop;~cbn).] 0.047 secs (0.035u,0.011s)
Chars 12348 - 12365 [(apply~path_equiv).] 0.001 secs (0.u,0.s)
Chars 12366 - 12397 [(apply~path_simulation;~exact~_).] 0.003 secs (0.002u,0.s)
Chars 12284 - 12316 [(apply~hprop_allpath;~intros~f...] 0. secs (0.u,0.s)
Chars 12317 - 12345 [(apply~path_sigma_hprop;~cbn).] 0. secs (0.u,0.s)
Chars 12348 - 12365 [(apply~path_equiv).] 0. secs (0.u,0.s)
Chars 12366 - 12397 [(apply~path_simulation;~exact~_).] 0. secs (0.u,0.s)
Chars 12398 - 12402 [Qed.] 0.002 secs (0.001u,0.001s)
Chars 12405 - 12469 [#[global]Instance~ishset_Ordin...] 0. secs (0.u,0.s)
Chars 12470 - 12476 [Proof.] 0. secs (0.u,0.s)
Chars 4833 - 4839 [intro.] 40.1 secs (0.u,0.019s)
Chars 4842 - 4864 [(apply~lt_iff_le_apart).] 0.001 secs (0.001u,0.s)
Chars 4867 - 4878 [assumption.] 0. secs (0.u,0.s)
Chars 4833 - 4839 [intro.] 0. secs (0.u,0.s)
Chars 4842 - 4864 [(apply~lt_iff_le_apart).] 0. secs (0.u,0.s)
Chars 4867 - 4878 [assumption.] 0. secs (0.u,0.s)
Chars 4881 - 4885 [Qed.] 0. secs (0.u,0.s)
Chars 4889 - 4938 [Lemma~not_le_not_lt~x~y~:~~~(x...] 0. secs (0.u,0.s)
Chars 4941 - 4947 [Proof.] 0. secs (0.u,0.s)
Chars 14967 - 15003 [(rapply~amal_type_ind_hprop;~i...] 40.038 secs (0.024u,0.004s)
Chars 15008 - 15030 [nrapply~(ap~amal_eta).] 0.075 secs (0.074u,0.s)
Chars 15035 - 15059 [(apply~word_concat_w_nil).] 0. secs (0.u,0.s)
Chars 14967 - 15003 [(rapply~amal_type_ind_hprop;~i...] 0. secs (0.u,0.s)
Chars 15008 - 15030 [nrapply~(ap~amal_eta).] 0. secs (0.u,0.s)
Chars 15035 - 15059 [(apply~word_concat_w_nil).] 0. secs (0.u,0.s)
Chars 15062 - 15070 [Defined.] 0.006 secs (0.006u,0.s)
Chars 15074 - 15160 [Lemma~amal_eta_word_concat_Vw~...] 0. secs (0.u,0.s)
Chars 15163 - 15169 [Proof.] 0. secs (0.u,0.s)
Chars 13933 - 13973 [(destruct~theta;~destruct~q;~r...] 12.295 secs (0.008u,0.027s)
Chars 13933 - 13973 [(destruct~theta;~destruct~q;~r...] 0.006 secs (0.004u,0.001s)
Chars 13976 - 13984 [Defined.] 0.002 secs (0.u,0.001s)
Chars 14075 - 14196 [#[local]~Definition~R~k~:~~~fo...] 0.024 secs (0.016u,0.007s)
Chars 14199 - 14205 [Proof.] 0. secs (0.u,0.s)
Chars 4950 - 4963 [(intros~E1~E2).] 14.547 secs (0.u,0.019s)
Chars 4966 - 4975 [(apply~E1).] 0. secs (0.u,0.s)
Chars 4976 - 4988 [(apply~lt_le).] 0. secs (0.u,0.s)
Chars 4989 - 5000 [assumption.] 0. secs (0.u,0.s)
Chars 4950 - 4963 [(intros~E1~E2).] 0. secs (0.u,0.s)
Chars 4966 - 4975 [(apply~E1).] 0. secs (0.u,0.s)
Chars 4976 - 4988 [(apply~lt_le).] 0. secs (0.u,0.s)
Chars 4989 - 5000 [assumption.] 0. secs (0.u,0.s)
Chars 5003 - 5007 [Qed.] 0. secs (0.u,0.s)
Chars 5011 - 5049 [Lemma~lt_apart~x~y~:~x~<~y~->~...] 0. secs (0.u,0.s)
Chars 5052 - 5058 [Proof.] 0. secs (0.u,0.s)
Chars 5061 - 5067 [intro.] 0.054 secs (0.u,0.018s)
Chars 5070 - 5092 [(apply~lt_iff_le_apart).] 0.002 secs (0.002u,0.s)
Chars 5095 - 5106 [assumption.] 0. secs (0.u,0.s)
Chars 5061 - 5067 [intro.] 0. secs (0.u,0.s)
Chars 5070 - 5092 [(apply~lt_iff_le_apart).] 0. secs (0.u,0.s)
Chars 5095 - 5106 [assumption.] 0. secs (0.u,0.s)
Chars 5109 - 5113 [Qed.] 0. secs (0.u,0.s)
Chars 5117 - 5160 [Lemma~lt_apart_flip~x~y~:~x~<~...] 0. secs (0.u,0.s)
Chars 5163 - 5169 [Proof.] 0. secs (0.u,0.s)
[DEBUG] b
[DEBUG] nat
[DEBUG] b
[DEBUG] nat
[DEBUG] b
[DEBUG] nat
(fun (x : nat) (z : bool) (y : nat) =>
 match
   reduce (RedWhd [rl:RedBeta; RedDelta; RedMatch])
     match
       meq_refl in (_ =m= y0)
       return (y0 =m= (forall z0 : nat, (fun n : nat => n > y) z0))
     with
     | meq_refl => meq_refl
     end in (_ =m= Q) return Q
 with
 | meq_refl =>
     match
       reduce (RedWhd [rl:RedBeta; RedDelta; RedMatch])
         match
           meq_refl in (_ =m= y0)
           return
             (y0 =m=
              (forall z0 : nat, (fun n : nat => forall x0 : nat, x0 > n) z0))
         with
         | meq_refl => meq_refl
         end in (_ =m= Q) return Q
     with
     | meq_refl =>
         match
           reduce (RedWhd [rl:RedBeta; RedDelta; RedMatch])
             match
               meq_refl in (_ =m= y0)
               return
                 (y0 =m=
                  (forall z0 : bool,
                   (fun _ : bool => forall y1 x0 : nat, x0 > y1) z0))
             with
             | meq_refl => meq_refl
             end in (_ =m= Q) return Q
         with
         | meq_refl => ?Goal
         end z
     end y
 end x)
Chars 4630 - 4646 [(apply~meet_lb_r).] 40.012 secs (0.u,0.003s)
Chars 4630 - 4646 [(apply~meet_lb_r).] 0. secs (0.u,0.s)
Chars 4649 - 4653 [Qed.] 0. secs (0.u,0.s)
Chars 4657 - 4703 [Lemma~meet_lb_3_m~x~y~z~:~(x~⊓...] 0. secs (0.u,0.s)
Chars 4706 - 4712 [Proof.] 0. secs (0.u,0.s)
Chars 12479 - 12490 [(intros~A~B).] 40.164 secs (0.u,0.019s)
Chars 12493 - 12541 [(apply~(istrunc_equiv_istrunc~...] 0.001 secs (0.001u,0.s)
Chars 12542 - 12543 [{] 0. secs (0.u,0.s)
Chars 12548 - 12573 [(apply~equiv_path_Ordinal).] 0. secs (0.u,0.s)
Chars 12576 - 12577 [}] 0. secs (0.u,0.s)
Chars 12580 - 12588 [exact~_.] 0.002 secs (0.002u,0.s)
Chars 12479 - 12490 [(intros~A~B).] 0. secs (0.u,0.s)
Chars 12493 - 12541 [(apply~(istrunc_equiv_istrunc~...] 0. secs (0.u,0.s)
Chars 12548 - 12573 [(apply~equiv_path_Ordinal).] 0. secs (0.u,0.s)
Chars 12580 - 12588 [exact~_.] 0. secs (0.u,0.s)
Chars 12589 - 12593 [Qed.] 0. secs (0.u,0.s)
Chars 12597 - 12873 [Lemma~isordinal_simulation~{A~...] 0.001 secs (0.001u,0.s)
Chars 12874 - 12880 [Proof.] 0. secs (0.u,0.s)
Chars 15174 - 15197 [(induction~x~as~[|~x~xs]).] 40.019 secs (0.001u,0.003s)
Chars 15202 - 15217 [1:~reflexivity.] 0. secs (0.u,0.s)
Chars 15222 - 15242 [(destruct~x~as~[h|~k]).] 0.001 secs (0.001u,0.s)
Chars 15247 - 15248 [+] 0. secs (0.u,0.s)
Chars 15249 - 15326 [(change~(amal_eta~(word_invers...] 0.002 secs (0.002u,0.s)
Chars 15333 - 15357 [(rewrite~word_inverse_ww).] 0.001 secs (0.001u,0.s)
Chars 15364 - 15392 [(rewrite~<-~word_concat_w_ww).] 0.001 secs (0.001u,0.s)
Chars 15399 - 15430 [refine~(amal_mu_H~_~_~_~_~@~_).] 0.001 secs (0.001u,0.s)
Chars 15437 - 15458 [(rewrite~left_inverse).] 0.003 secs (0.003u,0.s)
Chars 15465 - 15486 [(rewrite~amal_omega_H).] 0.001 secs (0.001u,0.s)
Chars 15493 - 15504 [(apply~IHxs).] 0. secs (0.u,0.s)
Chars 15509 - 15510 [+] 0. secs (0.u,0.s)
Chars 15511 - 15588 [(change~(amal_eta~(word_invers...] 0.002 secs (0.002u,0.s)
Chars 15595 - 15619 [(rewrite~word_inverse_ww).] 0.001 secs (0.001u,0.s)
Chars 15626 - 15654 [(rewrite~<-~word_concat_w_ww).] 0.001 secs (0.001u,0.s)
Chars 15661 - 15692 [refine~(amal_mu_K~_~_~_~_~@~_).] 0.001 secs (0.001u,0.s)
Chars 15699 - 15720 [(rewrite~left_inverse).] 0.003 secs (0.003u,0.s)
Chars 15727 - 15748 [(rewrite~amal_omega_K).] 0.001 secs (0.001u,0.s)
Chars 15755 - 15766 [(apply~IHxs).] 0. secs (0.u,0.s)
Chars 15174 - 15197 [(induction~x~as~[|~x~xs]).] 0. secs (0.u,0.s)
Chars 15202 - 15217 [1:~reflexivity.] 0. secs (0.u,0.s)
Chars 15222 - 15242 [(destruct~x~as~[h|~k]).] 0. secs (0.u,0.s)
Chars 15249 - 15326 [(change~(amal_eta~(word_invers...] 0. secs (0.u,0.s)
Chars 15333 - 15357 [(rewrite~word_inverse_ww).] 0. secs (0.u,0.s)
Chars 15364 - 15392 [(rewrite~<-~word_concat_w_ww).] 0. secs (0.u,0.s)
Chars 15399 - 15430 [refine~(amal_mu_H~_~_~_~_~@~_).] 0. secs (0.u,0.s)
Chars 15437 - 15458 [(rewrite~left_inverse).] 0. secs (0.u,0.s)
Chars 15465 - 15486 [(rewrite~amal_omega_H).] 0. secs (0.u,0.s)
Chars 15493 - 15504 [(apply~IHxs).] 0. secs (0.u,0.s)
Chars 15511 - 15588 [(change~(amal_eta~(word_invers...] 0. secs (0.u,0.s)
Chars 15595 - 15619 [(rewrite~word_inverse_ww).] 0. secs (0.u,0.s)
Chars 15626 - 15654 [(rewrite~<-~word_concat_w_ww).] 0. secs (0.u,0.s)
Chars 15661 - 15692 [refine~(amal_mu_K~_~_~_~_~@~_).] 0. secs (0.u,0.s)
Chars 15699 - 15720 [(rewrite~left_inverse).] 0. secs (0.u,0.s)
Chars 15727 - 15748 [(rewrite~amal_omega_K).] 0. secs (0.u,0.s)
Chars 15755 - 15766 [(apply~IHxs).] 0. secs (0.u,0.s)
Chars 15769 - 15777 [Defined.] 0.002 secs (0.002u,0.s)
Chars 15781 - 15867 [Lemma~amal_eta_word_concat_wV~...] 0. secs (0.u,0.s)
Chars 15870 - 15876 [Proof.] 0. secs (0.u,0.s)
Chars 14210 - 14234 [(induction~k~as~[|~k~h]).] 40.123 secs (0.005u,0.022s)
Chars 14239 - 14240 [-] 0. secs (0.u,0.s)
Chars 14241 - 14277 [(intros~n~a~b;~srapply~(_~@~t~...] 0.006 secs (0.006u,0.s)
Chars 14284 - 14349 [srapply~(Eta~(seq_colim_sum_to...] 0.028 secs (0.024u,0.003s)
Chars 14354 - 14355 [-] 0. secs (0.u,0.s)
Chars 14356 - 14406 [(intros~n~a~b;~srefine~(_~@~ap...] 0.009 secs (0.007u,0.002s)
Chars 14413 - 14490 [srapply~(Epsilon~(glue~A~n~a)~...] 0.043 secs (0.023u,0.019s)
Chars 14210 - 14234 [(induction~k~as~[|~k~h]).] 0.002 secs (0.002u,0.s)
Chars 14241 - 14277 [(intros~n~a~b;~srapply~(_~@~t~...] 0.003 secs (0.002u,0.s)
Chars 14284 - 14349 [srapply~(Eta~(seq_colim_sum_to...] 0.002 secs (0.002u,0.s)
Chars 14356 - 14406 [(intros~n~a~b;~srefine~(_~@~ap...] 0.005 secs (0.003u,0.001s)
Chars 14413 - 14490 [srapply~(Epsilon~(glue~A~n~a)~...] 0.003 secs (0.002u,0.s)
Chars 14493 - 14501 [Defined.] 0.085 secs (0.06u,0.025s)
Chars 14587 - 14639 [#[local]Definition~F~n~a~:~for...] 0. secs (0.u,0.s)
Chars 14642 - 14648 [Proof.] 0. secs (0.u,0.s)
Chars 5172 - 5178 [intro.] 40.091 secs (0.001u,0.018s)
Chars 5181 - 5213 [(apply~symmetry,~lt_iff_le_apa...] 0.003 secs (0.003u,0.s)
Chars 5216 - 5227 [assumption.] 0. secs (0.u,0.s)
Chars 5172 - 5178 [intro.] 0. secs (0.u,0.s)
Chars 5181 - 5213 [(apply~symmetry,~lt_iff_le_apa...] 0. secs (0.u,0.s)
Chars 5216 - 5227 [assumption.] 0. secs (0.u,0.s)
Chars 5230 - 5234 [Qed.] 0. secs (0.u,0.s)
Chars 5238 - 5285 [Lemma~le_not_lt_flip~x~y~:~y~≤...] 0. secs (0.u,0.s)
Chars 5288 - 5294 [Proof.] 0. secs (0.u,0.s)
Chars 4715 - 4738 [transitivity~(x~⊓~y).] 40.02 secs (0.007u,0.003s)
Chars 4741 - 4742 [-] 0. secs (0.u,0.s)
Chars 4743 - 4759 [(apply~meet_lb_l).] 0. secs (0.u,0.s)
Chars 4762 - 4763 [-] 0. secs (0.u,0.s)
Chars 4764 - 4780 [(apply~meet_lb_r).] 0. secs (0.u,0.s)
Chars 4715 - 4738 [transitivity~(x~⊓~y).] 0. secs (0.u,0.s)
Chars 4743 - 4759 [(apply~meet_lb_l).] 0. secs (0.u,0.s)
Chars 4764 - 4780 [(apply~meet_lb_r).] 0. secs (0.u,0.s)
Chars 4783 - 4787 [Qed.] 0. secs (0.u,0.s)
Chars 4791 - 4837 [Lemma~meet_lb_3_l~x~y~z~:~(x~⊓...] 0. secs (0.u,0.s)
Chars 4840 - 4846 [Proof.] 0. secs (0.u,0.s)
Chars 4849 - 4889 [(transitivity~(x~⊓~y);~apply~m...] 0.172 secs (0.009u,0.003s)
Chars 4849 - 4889 [(transitivity~(x~⊓~y);~apply~m...] 0. secs (0.u,0.s)
Chars 4892 - 4896 [Qed.] 0. secs (0.u,0.s)
Chars 4900 - 4954 [Lemma~meet_lb_3_assoc_l~x~y~z~...] 0. secs (0.u,0.s)
Chars 4957 - 4963 [Proof.] 0. secs (0.u,0.s)
Chars 4966 - 4982 [(apply~meet_lb_l).] 0.074 secs (0.u,0.003s)
Chars 4966 - 4982 [(apply~meet_lb_l).] 0. secs (0.u,0.s)
Chars 4985 - 4989 [Qed.] 0. secs (0.u,0.s)
Chars 4993 - 5047 [Lemma~meet_lb_3_assoc_m~x~y~z~...] 0. secs (0.u,0.s)
Chars 5050 - 5056 [Proof.] 0. secs (0.u,0.s)
     = ("fnv1a",
       (["data"; "len"], ["hash"], bedrock_func_body:(
         $"p" = $16777619;
         $"hash" = $2166136261;
         $"from" = $0;
         $"_gs_from0" = $0;
         $"_gs_to0" = $"len";
         while $"_gs_from0" < $"_gs_to0" {
           {$"b" = load1($"data" + $1 * $"_gs_from0");
            $"hash" = ($"hash" ^ $"b") * $16777619;
            $(cmd.unset "b")};
           $"_gs_from0" = $"_gs_from0" + $1
         })))
     : bedrock_func
     = ("fnv1a",
       (["data"; "len"], ["hash"], bedrock_func_body:(
         $"p" = $1099511628211;
         $"hash" = $14695981039346656037;
         $"from" = $0;
         $"_gs_from0" = $0;
         $"_gs_to0" = $"len";
         while $"_gs_from0" < $"_gs_to0" {
           {$"b" = load1($"data" + $1 * $"_gs_from0");
            $"hash" = ($"hash" ^ $"b") * $1099511628211;
            $(cmd.unset "b")};
           $"_gs_from0" = $"_gs_from0" + $1
         })))
     : bedrock_func
Chars 12883 - 12895 [constructor.] 40.085 secs (0.u,0.019s)
Chars 12898 - 12899 [-] 0. secs (0.u,0.s)
Chars 12900 - 12908 [exact~_.] 0. secs (0.u,0.s)
Chars 12911 - 12912 [-] 0. secs (0.u,0.s)
Chars 12913 - 12921 [exact~_.] 0. secs (0.u,0.s)
Chars 12924 - 12925 [-] 0. secs (0.u,0.s)
Chars 12926 - 12941 [(intros~a~a'~H1).] 0. secs (0.u,0.s)
Chars 12942 - 12962 [(apply~(injective~f)).] 0.001 secs (0.u,0.s)
Chars 12963 - 12984 [(apply~extensionality).] 0.001 secs (0.001u,0.s)
Chars 12989 - 12998 [(intros~b).] 0. secs (0.u,0.s)
Chars 12999 - 13005 [split.] 0. secs (0.u,0.s)
Chars 13010 - 13011 [+] 0. secs (0.u,0.s)
Chars 13012 - 13024 [(intros~b_fa).] 0. secs (0.u,0.s)
Chars 13025 - 13082 [refine~(Trunc_rec~_~(simulatio...] 0.005 secs (0.005u,0.s)
Chars 13089 - 13111 [(intros~[a0~[a0_a~<-]]).] 0.001 secs (0.001u,0.s)
Chars 13118 - 13146 [(apply~(simulation_is_hom~f)).] 0.002 secs (0.002u,0.s)
Chars 13147 - 13156 [(apply~H1).] 0. secs (0.u,0.s)
Chars 13157 - 13168 [exact~a0_a.] 0.001 secs (0.001u,0.s)
Chars 13173 - 13174 [+] 0. secs (0.u,0.s)
Chars 13175 - 13188 [(intros~b_fa').] 0. secs (0.u,0.s)
Chars 13189 - 13247 [refine~(Trunc_rec~_~(simulatio...] 0.007 secs (0.005u,0.002s)
Chars 13254 - 13277 [(intros~[a0~[a0_a'~<-]]).] 0.002 secs (0.002u,0.s)
Chars 13284 - 13312 [(apply~(simulation_is_hom~f)).] 0.001 secs (0.001u,0.s)
Chars 13313 - 13322 [(apply~H1).] 0.001 secs (0.001u,0.s)
Chars 13323 - 13335 [exact~a0_a'.] 0. secs (0.u,0.s)
Chars 13338 - 13339 [-] 0. secs (0.u,0.s)
Chars 13340 - 13349 [(intros~a).] 0. secs (0.u,0.s)
Chars 13350 - 13380 [remember~(f~a)~as~b~eqn:~fa_b.] 0.001 secs (0.001u,0.s)
Chars 13385 - 13399 [revert~a~fa_b.] 0. secs (0.u,0.s)
Chars 13400 - 13443 [(induction~(well_foundedness~b...] 0.002 secs (0.001u,0.s)
Chars 13444 - 13456 [(intros~a~<-).] 0.001 secs (0.001u,0.s)
Chars 13461 - 13489 [(constructor;~intros~a'~a'_a).] 0.001 secs (0.u,0.s)
Chars 13490 - 13508 [(apply~(IH~(f~a'))).] 0. secs (0.u,0.s)
Chars 13513 - 13514 [+] 0. secs (0.u,0.s)
Chars 13515 - 13543 [(apply~(simulation_is_hom~f)).] 0.001 secs (0.001u,0.s)
Chars 13544 - 13555 [exact~a'_a.] 0. secs (0.u,0.s)
Chars 13560 - 13561 [+] 0. secs (0.u,0.s)
Chars 13562 - 13574 [reflexivity.] 0. secs (0.u,0.s)
Chars 13577 - 13578 [-] 0. secs (0.u,0.s)
Chars 13579 - 13600 [(intros~a~b~c~a_b~b_c).] 0. secs (0.u,0.s)
Chars 13605 - 13632 [(assert~(fa_fc~:~f~a~<~f~c)).] 0.001 secs (0.001u,0.s)
Chars 13633 - 13634 [{] 0. secs (0.u,0.s)
Chars 13641 - 13660 [transitivity~(f~b).] 0.002 secs (0.002u,0.s)
Chars 13661 - 13662 [{] 0. secs (0.u,0.s)
Chars 13671 - 13699 [(apply~(simulation_is_hom~f)).] 0.001 secs (0.001u,0.s)
Chars 13700 - 13710 [exact~a_b.] 0. secs (0.u,0.s)
Chars 13717 - 13718 [}] 0. secs (0.u,0.s)
Chars 13725 - 13753 [(apply~(simulation_is_hom~f)).] 0.001 secs (0.001u,0.s)
Chars 13754 - 13764 [exact~b_c.] 0. secs (0.u,0.s)
Chars 13769 - 13770 [}] 0. secs (0.u,0.s)
Chars 13775 - 13833 [refine~(Trunc_rec~_~(simulatio...] 0.002 secs (0.002u,0.s)
Chars 13838 - 13864 [(intros~[a'~[a'_c~fa'_fa]]).] 0.001 secs (0.u,0.001s)
Chars 13865 - 13895 [(apply~(injective~f)~in~fa'_fa).] 0.001 secs (0.001u,0.s)
Chars 13896 - 13905 [subst~a'.] 0. secs (0.u,0.s)
Chars 13910 - 13921 [exact~a'_c.] 0. secs (0.u,0.s)
Chars 12883 - 12895 [constructor.] 0. secs (0.u,0.s)
Chars 12900 - 12908 [exact~_.] 0. secs (0.u,0.s)
Chars 12913 - 12921 [exact~_.] 0. secs (0.u,0.s)
Chars 12926 - 12941 [(intros~a~a'~H1).] 0. secs (0.u,0.s)
Chars 12942 - 12962 [(apply~(injective~f)).] 0. secs (0.u,0.s)
Chars 12963 - 12984 [(apply~extensionality).] 0. secs (0.u,0.s)
Chars 12989 - 12998 [(intros~b).] 0. secs (0.u,0.s)
Chars 12999 - 13005 [split.] 0. secs (0.u,0.s)
Chars 13012 - 13024 [(intros~b_fa).] 0. secs (0.u,0.s)
Chars 13025 - 13082 [refine~(Trunc_rec~_~(simulatio...] 0. secs (0.u,0.s)
Chars 13089 - 13111 [(intros~[a0~[a0_a~<-]]).] 0. secs (0.u,0.s)
Chars 13118 - 13146 [(apply~(simulation_is_hom~f)).] 0. secs (0.u,0.s)
Chars 13147 - 13156 [(apply~H1).] 0. secs (0.u,0.s)
Chars 13157 - 13168 [exact~a0_a.] 0. secs (0.u,0.s)
Chars 13175 - 13188 [(intros~b_fa').] 0. secs (0.u,0.s)
Chars 13189 - 13247 [refine~(Trunc_rec~_~(simulatio...] 0. secs (0.u,0.s)
Chars 13254 - 13277 [(intros~[a0~[a0_a'~<-]]).] 0. secs (0.u,0.s)
Chars 13284 - 13312 [(apply~(simulation_is_hom~f)).] 0. secs (0.u,0.s)
Chars 13313 - 13322 [(apply~H1).] 0. secs (0.u,0.s)
Chars 13323 - 13335 [exact~a0_a'.] 0. secs (0.u,0.s)
Chars 13340 - 13349 [(intros~a).] 0. secs (0.u,0.s)
Chars 13350 - 13380 [remember~(f~a)~as~b~eqn:~fa_b.] 0. secs (0.u,0.s)
Chars 13385 - 13399 [revert~a~fa_b.] 0. secs (0.u,0.s)
Chars 13400 - 13443 [(induction~(well_foundedness~b...] 0. secs (0.u,0.s)
Chars 13444 - 13456 [(intros~a~<-).] 0. secs (0.u,0.s)
Chars 13461 - 13489 [(constructor;~intros~a'~a'_a).] 0. secs (0.u,0.s)
Chars 13490 - 13508 [(apply~(IH~(f~a'))).] 0. secs (0.u,0.s)
Chars 13515 - 13543 [(apply~(simulation_is_hom~f)).] 0. secs (0.u,0.s)
Chars 13544 - 13555 [exact~a'_a.] 0. secs (0.u,0.s)
Chars 13562 - 13574 [reflexivity.] 0. secs (0.u,0.s)
Chars 13579 - 13600 [(intros~a~b~c~a_b~b_c).] 0. secs (0.u,0.s)
Chars 13605 - 13632 [(assert~(fa_fc~:~f~a~<~f~c)).] 0. secs (0.u,0.s)
Chars 13641 - 13660 [transitivity~(f~b).] 0. secs (0.u,0.s)
Chars 13671 - 13699 [(apply~(simulation_is_hom~f)).] 0. secs (0.u,0.s)
Chars 13700 - 13710 [exact~a_b.] 0. secs (0.u,0.s)
Chars 13725 - 13753 [(apply~(simulation_is_hom~f)).] 0. secs (0.u,0.s)
Chars 13754 - 13764 [exact~b_c.] 0. secs (0.u,0.s)
Chars 13775 - 13833 [refine~(Trunc_rec~_~(simulatio...] 0. secs (0.u,0.s)
Chars 13838 - 13864 [(intros~[a'~[a'_c~fa'_fa]]).] 0. secs (0.u,0.s)
Chars 13865 - 13895 [(apply~(injective~f)~in~fa'_fa).] 0. secs (0.u,0.s)
Chars 13896 - 13905 [subst~a'.] 0. secs (0.u,0.s)
Chars 13910 - 13921 [exact~a'_c.] 0. secs (0.u,0.s)
Chars 13922 - 13926 [Qed.] 0.002 secs (0.002u,0.s)
Chars 13959 - 14072 [Definition~initial_segment~`{P...] 0. secs (0.u,0.s)
Chars 14073 - 14079 [Proof.] 0. secs (0.u,0.s)
Chars 14082 - 14228 [(srefine~~~{|~~~~~ordinal_carr...] 1.949 secs (0.021u,0.026s)
Chars 14231 - 14266 [srapply~(isordinal_simulation~...] 0.06 secs (0.053u,0.006s)
Chars 14269 - 14270 [-] 0. secs (0.u,0.s)
Chars 14271 - 14281 [(unfold~lt).] 0. secs (0.u,0.s)
Chars 14282 - 14290 [exact~_.] 0.019 secs (0.014u,0.003s)
Chars 14293 - 14294 [-] 0. secs (0.u,0.s)
Chars 14295 - 14303 [exact~_.] 0. secs (0.u,0.s)
Chars 14306 - 14307 [-] 0. secs (0.u,0.s)
Chars 14308 - 14316 [exact~_.] 0. secs (0.u,0.s)
Chars 14319 - 14320 [-] 0. secs (0.u,0.s)
Chars 14321 - 14334 [(intros~x~y~p).] 0. secs (0.u,0.s)
Chars 14335 - 14358 [(apply~path_sigma_hprop).] 0.003 secs (0.003u,0.s)
Chars 14359 - 14367 [exact~p.] 0. secs (0.u,0.s)
Chars 14370 - 14371 [-] 0. secs (0.u,0.s)
Chars 14372 - 14384 [constructor.] 0. secs (0.u,0.s)
Chars 14389 - 14390 [+] 0. secs (0.u,0.s)
Chars 14391 - 14406 [(intros~x~y~x_y).] 0. secs (0.u,0.s)
Chars 14407 - 14417 [exact~x_y.] 0. secs (0.u,0.s)
Chars 14422 - 14423 [+] 0. secs (0.u,0.s)
Chars 14424 - 14451 [(intros~b~a'~a'_b;~cbn~in~*).] 0.001 secs (0.001u,0.s)
Chars 14452 - 14461 [(apply~tr).] 0.001 secs (0.001u,0.s)
Chars 14468 - 14491 [(assert~(b_a~:~b.1~<~a)).] 0.001 secs (0.001u,0.s)
Chars 14492 - 14493 [{] 0. secs (0.u,0.s)
Chars 14502 - 14540 [exact~((equiv_resize_hprop~_)^...] 0.002 secs (0.001u,0.s)
Chars 14547 - 14548 [}] 0. secs (0.u,0.s)
Chars 14555 - 14569 [srapply~exist.] 0.001 secs (0.001u,0.s)
Chars 14570 - 14571 [{] 0. secs (0.u,0.s)
Chars 14580 - 14590 [exists~a'.] 0. secs (0.u,0.s)
Chars 14599 - 14624 [(apply~equiv_resize_hprop).] 0. secs (0.u,0.s)
Chars 14625 - 14655 [exact~(transitivity~a'_b~b_a).] 0.001 secs (0.001u,0.s)
Chars 14662 - 14663 [}] 0. secs (0.u,0.s)
Chars 14670 - 14674 [(cbn).] 0.001 secs (0.001u,0.s)
Chars 14675 - 14681 [split.] 0.001 secs (0.u,0.s)
Chars 14688 - 14689 [*] 0. secs (0.u,0.s)
Chars 14690 - 14701 [exact~a'_b.] 0. secs (0.u,0.s)
Chars 14708 - 14709 [*] 0. secs (0.u,0.s)
Chars 14710 - 14722 [reflexivity.] 0. secs (0.u,0.s)
Chars 14082 - 14228 [(srefine~~~{|~~~~~ordinal_carr...] 0. secs (0.u,0.s)
Chars 14231 - 14266 [srapply~(isordinal_simulation~...] 0. secs (0.u,0.s)
Chars 14271 - 14281 [(unfold~lt).] 0. secs (0.u,0.s)
Chars 14282 - 14290 [exact~_.] 0. secs (0.u,0.s)
Chars 14295 - 14303 [exact~_.] 0. secs (0.u,0.s)
Chars 14308 - 14316 [exact~_.] 0. secs (0.u,0.s)
Chars 14321 - 14334 [(intros~x~y~p).] 0. secs (0.u,0.s)
Chars 14335 - 14358 [(apply~path_sigma_hprop).] 0. secs (0.u,0.s)
Chars 14359 - 14367 [exact~p.] 0. secs (0.u,0.s)
Chars 14372 - 14384 [constructor.] 0. secs (0.u,0.s)
Chars 14391 - 14406 [(intros~x~y~x_y).] 0. secs (0.u,0.s)
Chars 14407 - 14417 [exact~x_y.] 0. secs (0.u,0.s)
Chars 14424 - 14451 [(intros~b~a'~a'_b;~cbn~in~*).] 0.001 secs (0.001u,0.s)
Chars 14452 - 14461 [(apply~tr).] 0. secs (0.u,0.s)
Chars 14468 - 14491 [(assert~(b_a~:~b.1~<~a)).] 0. secs (0.u,0.s)
Chars 14502 - 14540 [exact~((equiv_resize_hprop~_)^...] 0. secs (0.u,0.s)
Chars 14555 - 14569 [srapply~exist.] 0. secs (0.u,0.s)
Chars 14580 - 14590 [exists~a'.] 0. secs (0.u,0.s)
Chars 14599 - 14624 [(apply~equiv_resize_hprop).] 0. secs (0.u,0.s)
Chars 14625 - 14655 [exact~(transitivity~a'_b~b_a).] 0. secs (0.u,0.s)
Chars 14670 - 14674 [(cbn).] 0. secs (0.u,0.s)
Chars 14675 - 14681 [split.] 0. secs (0.u,0.s)
Chars 14690 - 14701 [exact~a'_b.] 0. secs (0.u,0.s)
Chars 14710 - 14722 [reflexivity.] 0. secs (0.u,0.s)
Chars 14723 - 14731 [Defined.] 0.004 secs (0.002u,0.001s)
Chars 14733 - 14756 [Declare~Scope~Ordinals.] 0. secs (0.u,0.s)
Chars 14757 - 14777 [Open~Scope~Ordinals.] 0. secs (0.u,0.s)
Chars 14779 - 14859 [Notation~"↓~a"~:=~(initial_seg...] 0. secs (0.u,0.s)
Chars 14945 - 15092 [Definition~in_~`{PropResizing}...] 0.003 secs (0.003u,0.s)
Chars 15094 - 15192 [Definition~out~`{PropResizing}...] 0.002 secs (0.001u,0.s)
Chars 15194 - 15321 [Definition~initial_segment_pro...] 0.001 secs (0.001u,0.s)
Chars 15322 - 15328 [Proof.] 0. secs (0.u,0.s)
Chars 15881 - 15904 [(induction~x~as~[|~x~xs]).] 40.014 secs (0.001u,0.002s)
Chars 15909 - 15924 [1:~reflexivity.] 0. secs (0.u,0.s)
Chars 15929 - 15949 [(destruct~x~as~[h|~k]).] 0.001 secs (0.001u,0.s)
Chars 15954 - 15955 [+] 0. secs (0.u,0.s)
Chars 15956 - 15960 [(cbn).] 0. secs (0.u,0.s)
Chars 15967 - 15992 [(rewrite~word_concat_w_ww).] 0.002 secs (0.002u,0.s)
Chars 15999 - 16100 [(change~~~~(amal_eta~[inl~h]~*...] 0.009 secs (0.009u,0.s)
Chars 16107 - 16120 [(rewrite~IHxs).] 0.001 secs (0.001u,0.s)
Chars 16127 - 16164 [(rewrite~rightidentity_sgop_am...] 0.007 secs (0.007u,0.s)
Chars 16171 - 16213 [(rewrite~<-~(word_concat_w_nil...] 0.001 secs (0.001u,0.s)
Chars 16220 - 16283 [(change~(amal_eta~(([inl~h]~++...] 0.008 secs (0.008u,0.s)
Chars 16290 - 16318 [(rewrite~<-~word_concat_w_ww).] 0.001 secs (0.001u,0.s)
Chars 16325 - 16393 [(change~(amal_eta~(nil~++~[inl...] 0.002 secs (0.002u,0.s)
Chars 16400 - 16431 [refine~(amal_mu_H~_~_~_~_~@~_).] 0.001 secs (0.001u,0.s)
Chars 16438 - 16453 [refine~(_~@~_).] 0.001 secs (0.001u,0.s)
Chars 16460 - 16461 [{] 0. secs (0.u,0.s)
Chars 16462 - 16475 [(apply~ap,~ap).] 0.001 secs (0.001u,0.s)
Chars 16484 - 16514 [rapply~(ap~(fun~x~=>~x~++~_)).] 0.001 secs (0.001u,0.s)
Chars 16523 - 16550 [rapply~(ap~(fun~x~=>~[x])).] 0.001 secs (0.001u,0.s)
Chars 16559 - 16568 [(apply~ap).] 0. secs (0.u,0.s)
Chars 16577 - 16597 [(apply~right_inverse).] 0.001 secs (0.001u,0.s)
Chars 16598 - 16599 [}] 0. secs (0.u,0.s)
Chars 16606 - 16625 [(apply~amal_omega_H).] 0. secs (0.u,0.s)
Chars 16630 - 16631 [+] 0. secs (0.u,0.s)
Chars 16633 - 16637 [(cbn).] 0. secs (0.u,0.s)
Chars 16644 - 16669 [(rewrite~word_concat_w_ww).] 0.002 secs (0.002u,0.s)
Chars 16676 - 16776 [(change~~~~(amal_eta~[inr~k]~*...] 0.009 secs (0.009u,0.s)
Chars 16783 - 16796 [(rewrite~IHxs).] 0.001 secs (0.001u,0.s)
Chars 16803 - 16840 [(rewrite~rightidentity_sgop_am...] 0.007 secs (0.007u,0.s)
Chars 16847 - 16889 [(rewrite~<-~(word_concat_w_nil...] 0.001 secs (0.001u,0.s)
Chars 16896 - 16959 [(change~(amal_eta~(([inr~k]~++...] 0.008 secs (0.008u,0.s)
Chars 16966 - 16994 [(rewrite~<-~word_concat_w_ww).] 0.001 secs (0.001u,0.s)
Chars 17001 - 17069 [(change~(amal_eta~(nil~++~[inr...] 0.002 secs (0.002u,0.s)
Chars 17076 - 17107 [refine~(amal_mu_K~_~_~_~_~@~_).] 0.001 secs (0.001u,0.s)
Chars 17114 - 17129 [refine~(_~@~_).] 0. secs (0.u,0.s)
Chars 17136 - 17137 [{] 0. secs (0.u,0.s)
Chars 17138 - 17151 [(apply~ap,~ap).] 0.001 secs (0.001u,0.s)
Chars 17160 - 17190 [rapply~(ap~(fun~x~=>~x~++~_)).] 0.001 secs (0.001u,0.s)
Chars 17199 - 17226 [rapply~(ap~(fun~x~=>~[x])).] 0.001 secs (0.001u,0.s)
Chars 17235 - 17244 [(apply~ap).] 0. secs (0.u,0.s)
Chars 17253 - 17273 [(apply~right_inverse).] 0.001 secs (0.001u,0.s)
Chars 17274 - 17275 [}] 0. secs (0.u,0.s)
Chars 17282 - 17301 [(apply~amal_omega_K).] 0. secs (0.u,0.s)
Chars 15881 - 15904 [(induction~x~as~[|~x~xs]).] 0. secs (0.u,0.s)
Chars 15909 - 15924 [1:~reflexivity.] 0. secs (0.u,0.s)
Chars 15929 - 15949 [(destruct~x~as~[h|~k]).] 0. secs (0.u,0.s)
Chars 15956 - 15960 [(cbn).] 0. secs (0.u,0.s)
Chars 15967 - 15992 [(rewrite~word_concat_w_ww).] 0. secs (0.u,0.s)
Chars 15999 - 16100 [(change~~~~(amal_eta~[inl~h]~*...] 0. secs (0.u,0.s)
Chars 16107 - 16120 [(rewrite~IHxs).] 0. secs (0.u,0.s)
Chars 16127 - 16164 [(rewrite~rightidentity_sgop_am...] 0. secs (0.u,0.s)
Chars 16171 - 16213 [(rewrite~<-~(word_concat_w_nil...] 0. secs (0.u,0.s)
Chars 16220 - 16283 [(change~(amal_eta~(([inl~h]~++...] 0. secs (0.u,0.s)
Chars 16290 - 16318 [(rewrite~<-~word_concat_w_ww).] 0. secs (0.u,0.s)
Chars 16325 - 16393 [(change~(amal_eta~(nil~++~[inl...] 0. secs (0.u,0.s)
Chars 16400 - 16431 [refine~(amal_mu_H~_~_~_~_~@~_).] 0. secs (0.u,0.s)
Chars 16438 - 16453 [refine~(_~@~_).] 0. secs (0.u,0.s)
Chars 16462 - 16475 [(apply~ap,~ap).] 0. secs (0.u,0.s)
Chars 16484 - 16514 [rapply~(ap~(fun~x~=>~x~++~_)).] 0. secs (0.u,0.s)
Chars 16523 - 16550 [rapply~(ap~(fun~x~=>~[x])).] 0. secs (0.u,0.s)
Chars 16559 - 16568 [(apply~ap).] 0. secs (0.u,0.s)
Chars 16577 - 16597 [(apply~right_inverse).] 0. secs (0.u,0.s)
Chars 16606 - 16625 [(apply~amal_omega_H).] 0. secs (0.u,0.s)
Chars 16633 - 16637 [(cbn).] 0. secs (0.u,0.s)
Chars 16644 - 16669 [(rewrite~word_concat_w_ww).] 0. secs (0.u,0.s)
Chars 16676 - 16776 [(change~~~~(amal_eta~[inr~k]~*...] 0. secs (0.u,0.s)
Chars 16783 - 16796 [(rewrite~IHxs).] 0. secs (0.u,0.s)
Chars 16803 - 16840 [(rewrite~rightidentity_sgop_am...] 0. secs (0.u,0.s)
Chars 16847 - 16889 [(rewrite~<-~(word_concat_w_nil...] 0. secs (0.u,0.s)
Chars 16896 - 16959 [(change~(amal_eta~(([inr~k]~++...] 0. secs (0.u,0.s)
Chars 16966 - 16994 [(rewrite~<-~word_concat_w_ww).] 0. secs (0.u,0.s)
Chars 17001 - 17069 [(change~(amal_eta~(nil~++~[inr...] 0. secs (0.u,0.s)
Chars 17076 - 17107 [refine~(amal_mu_K~_~_~_~_~@~_).] 0. secs (0.u,0.s)
Chars 17114 - 17129 [refine~(_~@~_).] 0. secs (0.u,0.s)
Chars 17138 - 17151 [(apply~ap,~ap).] 0. secs (0.u,0.s)
Chars 17160 - 17190 [rapply~(ap~(fun~x~=>~x~++~_)).] 0. secs (0.u,0.s)
Chars 17199 - 17226 [rapply~(ap~(fun~x~=>~[x])).] 0. secs (0.u,0.s)
Chars 17235 - 17244 [(apply~ap).] 0. secs (0.u,0.s)
Chars 17253 - 17273 [(apply~right_inverse).] 0. secs (0.u,0.s)
Chars 17282 - 17301 [(apply~amal_omega_K).] 0. secs (0.u,0.s)
Chars 17304 - 17312 [Defined.] 0.029 secs (0.029u,0.s)
Chars 17316 - 17395 [#[global]~Instance~leftinverse...] 0. secs (0.u,0.s)
Chars 17398 - 17404 [Proof.] 0. secs (0.u,0.s)
Chars 14653 - 14673 [srapply~Colimit_ind.] 40.116 secs (0.01u,0.019s)
Chars 14678 - 14679 [-] 0. secs (0.u,0.s)
Chars 14680 - 14705 [exact~(fun~k~=>~Q~k~n~a).] 0.002 secs (0.002u,0.s)
Chars 14710 - 14711 [-] 0. secs (0.u,0.s)
Chars 14712 - 14754 [(intros~k~l~p;~destruct~p;~exa...] 0.011 secs (0.011u,0.s)
Chars 14653 - 14673 [srapply~Colimit_ind.] 0.001 secs (0.001u,0.s)
Chars 14680 - 14705 [exact~(fun~k~=>~Q~k~n~a).] 0.001 secs (0.001u,0.s)
Chars 14712 - 14754 [(intros~k~l~p;~destruct~p;~exa...] 0.005 secs (0.004u,0.s)
Chars 14757 - 14765 [Defined.] 0.003 secs (0.003u,0.s)
Chars 14769 - 14843 [#[local]Definition~F_beta_glue...] 0.007 secs (0.007u,0.s)
Chars 14846 - 14852 [Proof.] 0. secs (0.u,0.s)
     = ("indirect_add_three'",
       (["out"; "a"; "b"; "c"], [],
       cmd.stackalloc "v" size_in_bytes
         (cmd.seq (cmd.call [] "indirect_add" ["v"; "a"; "b"])
            (cmd.call [] "indirect_add" ["out"; "v"; "c"]))))
     : bedrock_func
Chars 5297 - 5338 [(intros~E1~E2;~apply~lt_iff_le...] 40.098 secs (0.001u,0.017s)
Chars 5341 - 5366 [(destruct~E2~as~[E2a~E2b]).] 0. secs (0.u,0.s)
Chars 5369 - 5380 [revert~E2b.] 0. secs (0.u,0.s)
Chars 5381 - 5399 [(apply~tight_apart).] 0.001 secs (0.001u,0.s)
Chars 5402 - 5440 [(apply~(antisymmetry~(≤));~ass...] 0.003 secs (0.003u,0.s)
Chars 5297 - 5338 [(intros~E1~E2;~apply~lt_iff_le...] 0. secs (0.u,0.s)
Chars 5341 - 5366 [(destruct~E2~as~[E2a~E2b]).] 0. secs (0.u,0.s)
Chars 5369 - 5380 [revert~E2b.] 0. secs (0.u,0.s)
Chars 5381 - 5399 [(apply~tight_apart).] 0. secs (0.u,0.s)
Chars 5402 - 5440 [(apply~(antisymmetry~(≤));~ass...] 0. secs (0.u,0.s)
Chars 5443 - 5447 [Qed.] 0. secs (0.u,0.s)
Chars 5451 - 5498 [Lemma~lt_not_le_flip~x~y~:~y~<...] 0. secs (0.u,0.s)
Chars 5501 - 5507 [Proof.] 0. secs (0.u,0.s)
Chars 17409 - 17445 [(rapply~amal_type_ind_hprop;~i...] 13.006 secs (0.024u,0.003s)
Chars 17450 - 17480 [(apply~amal_eta_word_concat_Vw).] 0.108 secs (0.105u,0.003s)
Chars 17409 - 17445 [(rapply~amal_type_ind_hprop;~i...] 0. secs (0.u,0.s)
Chars 17450 - 17480 [(apply~amal_eta_word_concat_Vw).] 0. secs (0.u,0.s)
Chars 17483 - 17491 [Defined.] 0.006 secs (0.006u,0.s)
Chars 17495 - 17576 [#[global]~Instance~rightinvers...] 0. secs (0.u,0.s)
Chars 17579 - 17585 [Proof.] 0. secs (0.u,0.s)
Chars 5059 - 5082 [transitivity~(y~⊓~z).] 40.021 secs (0.009u,0.002s)
Chars 5085 - 5086 [-] 0. secs (0.u,0.s)
Chars 5087 - 5103 [(apply~meet_lb_r).] 0. secs (0.u,0.s)
Chars 5106 - 5107 [-] 0. secs (0.u,0.s)
Chars 5108 - 5124 [(apply~meet_lb_l).] 0. secs (0.u,0.s)
Chars 5059 - 5082 [transitivity~(y~⊓~z).] 0. secs (0.u,0.s)
Chars 5087 - 5103 [(apply~meet_lb_r).] 0. secs (0.u,0.s)
Chars 5108 - 5124 [(apply~meet_lb_l).] 0. secs (0.u,0.s)
Chars 5127 - 5131 [Qed.] 0. secs (0.u,0.s)
Chars 5135 - 5189 [Lemma~meet_lb_3_assoc_r~x~y~z~...] 0.001 secs (0.001u,0.s)
Chars 5192 - 5198 [Proof.] 0. secs (0.u,0.s)
Chars 5201 - 5241 [(transitivity~(y~⊓~z);~apply~m...] 0.158 secs (0.008u,0.003s)
Chars 5201 - 5241 [(transitivity~(y~⊓~z);~apply~m...] 0. secs (0.u,0.s)
Chars 5244 - 5248 [Qed.] 0. secs (0.u,0.s)
Chars 5252 - 5304 [Instance~meet_sl_order_meet_sl...] 0. secs (0.u,0.s)
Chars 5307 - 5313 [Proof.] 0. secs (0.u,0.s)
Finished transaction in 28.702 secs (2.735u,0.105s) (successful)
Finished transaction in 0. secs (0.u,0.s) (successful)
Finished transaction in 4.843 secs (4.838u,0.004s) (successful)
Chars 15329 - 15338 [(intros~x).] 40.088 secs (0.u,0.019s)
Chars 15339 - 15383 [exact~((equiv_resize_hprop~_)^...] 0.004 secs (0.003u,0.001s)
Chars 15329 - 15338 [(intros~x).] 0. secs (0.u,0.s)
Chars 15339 - 15383 [exact~((equiv_resize_hprop~_)^...] 0. secs (0.u,0.s)
Chars 15384 - 15392 [Defined.] 0. secs (0.u,0.s)
Chars 15395 - 15520 [#[global]~Instance~is_simulati...] 0.001 secs (0.u,0.s)
Chars 15521 - 15527 [Proof.] 0. secs (0.u,0.s)
Chars 14857 - 14889 [srapply~Colimit_ind_beta_colimp.] 40.128 secs (0.01u,0.02s)
Chars 14857 - 14889 [srapply~Colimit_ind_beta_colimp.] 0.002 secs (0.001u,0.s)
Chars 14892 - 14900 [Defined.] 0.008 secs (0.007u,0.001s)
Chars 14904 - 15340 [#[local]~Definition~Phi~{X}~{Y...] 0.017 secs (0.015u,0.001s)
Chars 15343 - 15349 [Proof.] 0. secs (0.u,0.s)
Chars 5510 - 5523 [(intros~E1~E2).] 40.087 secs (0.u,0.018s)
Chars 5526 - 5564 [(apply~(le_not_lt_flip~y~x);~a...] 0. secs (0.u,0.s)
Chars 5510 - 5523 [(intros~E1~E2).] 0. secs (0.u,0.s)
Chars 5526 - 5564 [(apply~(le_not_lt_flip~y~x);~a...] 0. secs (0.u,0.s)
Chars 5567 - 5571 [Qed.] 0. secs (0.u,0.s)
Chars 5575 - 5627 [Lemma~lt_le_trans~x~y~z~:~x~<~...] 0. secs (0.u,0.s)
Chars 5630 - 5636 [Proof.] 0. secs (0.u,0.s)
Chars 15354 - 15425 [(destruct~theta;~destruct~q;~i...] 10.246 secs (0.196u,-0.966s)
Chars 17590 - 17626 [(rapply~amal_type_ind_hprop;~i...] 40.037 secs (0.024u,0.003s)
Chars 17631 - 17661 [(apply~amal_eta_word_concat_wV).] 0.1 secs (0.1u,0.s)
Chars 17590 - 17626 [(rapply~amal_type_ind_hprop;~i...] 0. secs (0.u,0.s)
Chars 17631 - 17661 [(apply~amal_eta_word_concat_wV).] 0. secs (0.u,0.s)
Chars 17664 - 17672 [Defined.] 0.006 secs (0.006u,0.s)
Chars 17676 - 17718 [Definition~AmalgamatedFreeProd...] 0. secs (0.u,0.s)
Chars 17721 - 17727 [Proof.] 0. secs (0.u,0.s)
Chars 5316 - 5329 [(repeat~split).] 40.014 secs (0.u,0.003s)
Chars 5332 - 5333 [-] 0. secs (0.u,0.s)
Chars 5334 - 5342 [(apply~_).] 0.005 secs (0.005u,0.s)
Chars 5345 - 5346 [-] 0. secs (0.u,0.s)
Chars 5347 - 5360 [(intros~x~y~z).] 0. secs (0.u,0.s)
Chars 5361 - 5388 [(apply~(antisymmetry~(≤))).] 0.003 secs (0.003u,0.s)
Chars 5393 - 5394 [+] 0. secs (0.u,0.s)
Chars 5395 - 5410 [(apply~meet_glb).] 0. secs (0.u,0.s)
Chars 5417 - 5418 [*] 0. secs (0.u,0.s)
Chars 5419 - 5434 [(apply~meet_glb).] 0. secs (0.u,0.s)
Chars 5443 - 5445 [**] 0. secs (0.u,0.s)
Chars 5446 - 5470 [(apply~meet_lb_3_assoc_l).] 0. secs (0.u,0.s)
Chars 5479 - 5481 [**] 0. secs (0.u,0.s)
Chars 5482 - 5506 [(apply~meet_lb_3_assoc_m).] 0. secs (0.u,0.s)
Chars 5513 - 5514 [*] 0. secs (0.u,0.s)
Chars 5515 - 5539 [(apply~meet_lb_3_assoc_r).] 0. secs (0.u,0.s)
Chars 5544 - 5545 [+] 0. secs (0.u,0.s)
Chars 5546 - 5561 [(apply~meet_glb).] 0. secs (0.u,0.s)
Chars 5568 - 5570 [**] 0. secs (0.u,0.s)
Chars 5571 - 5589 [(apply~meet_lb_3_l).] 0. secs (0.u,0.s)
Chars 5596 - 5598 [**] 0. secs (0.u,0.s)
Chars 5599 - 5614 [(apply~meet_glb).] 0. secs (0.u,0.s)
Chars 5624 - 5627 [***] 0. secs (0.u,0.s)
Chars 5628 - 5646 [(apply~meet_lb_3_m).] 0. secs (0.u,0.s)
Chars 5656 - 5659 [***] 0. secs (0.u,0.s)
Chars 5660 - 5678 [(apply~meet_lb_3_r).] 0. secs (0.u,0.s)
Chars 5681 - 5682 [-] 0. secs (0.u,0.s)
Chars 5683 - 5694 [(intros~x~y).] 0. secs (0.u,0.s)
Chars 5695 - 5789 [(apply~(antisymmetry~(≤));~app...] 0.006 secs (0.006u,0.s)
Chars 5792 - 5793 [-] 0. secs (0.u,0.s)
Chars 5794 - 5803 [(intros~x).] 0. secs (0.u,0.s)
Chars 5804 - 5808 [(red).] 0. secs (0.u,0.s)
Chars 5809 - 5836 [(apply~(antisymmetry~(≤))).] 0.003 secs (0.003u,0.s)
Chars 5841 - 5842 [+] 0. secs (0.u,0.s)
Chars 5843 - 5859 [(apply~meet_lb_l).] 0. secs (0.u,0.s)
Chars 5864 - 5865 [+] 0. secs (0.u,0.s)
Chars 5866 - 5899 [(apply~meet_glb;~apply~reflexi...] 0.006 secs (0.006u,0.s)
Chars 5316 - 5329 [(repeat~split).] 0. secs (0.u,0.s)
Chars 5334 - 5342 [(apply~_).] 0. secs (0.u,0.s)
Chars 5347 - 5360 [(intros~x~y~z).] 0. secs (0.u,0.s)
Chars 5361 - 5388 [(apply~(antisymmetry~(≤))).] 0. secs (0.u,0.s)
Chars 5395 - 5410 [(apply~meet_glb).] 0. secs (0.u,0.s)
Chars 5419 - 5434 [(apply~meet_glb).] 0. secs (0.u,0.s)
Chars 5446 - 5470 [(apply~meet_lb_3_assoc_l).] 0. secs (0.u,0.s)
Chars 5482 - 5506 [(apply~meet_lb_3_assoc_m).] 0. secs (0.u,0.s)
Chars 5515 - 5539 [(apply~meet_lb_3_assoc_r).] 0. secs (0.u,0.s)
Chars 5546 - 5561 [(apply~meet_glb).] 0. secs (0.u,0.s)
Chars 5571 - 5589 [(apply~meet_lb_3_l).] 0. secs (0.u,0.s)
Chars 5599 - 5614 [(apply~meet_glb).] 0. secs (0.u,0.s)
Chars 5628 - 5646 [(apply~meet_lb_3_m).] 0. secs (0.u,0.s)
Chars 5660 - 5678 [(apply~meet_lb_3_r).] 0. secs (0.u,0.s)
Chars 5683 - 5694 [(intros~x~y).] 0. secs (0.u,0.s)
Chars 5695 - 5789 [(apply~(antisymmetry~(≤));~app...] 0. secs (0.u,0.s)
Chars 5794 - 5803 [(intros~x).] 0. secs (0.u,0.s)
Chars 5804 - 5808 [(red).] 0. secs (0.u,0.s)
Chars 5809 - 5836 [(apply~(antisymmetry~(≤))).] 0. secs (0.u,0.s)
Chars 5843 - 5859 [(apply~meet_lb_l).] 0. secs (0.u,0.s)
Chars 5866 - 5899 [(apply~meet_glb;~apply~reflexi...] 0. secs (0.u,0.s)
Chars 5902 - 5906 [Qed.] 0.001 secs (0.001u,0.s)
Chars 5910 - 5966 [Lemma~meet_le_compat_r~x~y~z~:...] 0. secs (0.u,0.s)
Chars 5969 - 5975 [Proof.] 0. secs (0.u,0.s)
Chars 17732 - 17788 [(snrapply~(Build_Group~amal_ty...] 21.043 secs (0.023u,0.003s)
Chars 17732 - 17788 [(snrapply~(Build_Group~amal_ty...] 0.001 secs (0.001u,0.s)
Chars 17791 - 17799 [Defined.] 0.015 secs (0.015u,0.s)
Chars 17903 - 18073 [Definition~AmalgamatedFreeProd...] 0.001 secs (0.001u,0.s)
Chars 18076 - 18082 [Proof.] 0. secs (0.u,0.s)
Finished transaction in 42.482 secs (2.217u,0.084s) (successful)
Finished transaction in 0. secs (0.u,0.s) (successful)
Chars 15530 - 15541 [(unfold~out).] 40.085 secs (0.u,0.019s)
Chars 15544 - 15556 [constructor.] 0.001 secs (0.001u,0.s)
Chars 15559 - 15560 [-] 0. secs (0.u,0.s)
Chars 15561 - 15566 [auto.] 0.001 secs (0.u,0.s)
Chars 15569 - 15570 [-] 0. secs (0.u,0.s)
Chars 15571 - 15588 [(intros~x~a'~a'_x).] 0. secs (0.u,0.s)
Chars 15589 - 15598 [(apply~tr).] 0.001 secs (0.u,0.s)
Chars 15603 - 15626 [(assert~(a'_a~:~a'~<~a)).] 0.001 secs (0.001u,0.s)
Chars 15627 - 15628 [{] 0. secs (0.u,0.s)
Chars 15635 - 15656 [transitivity~(out~x).] 0.003 secs (0.001u,0.002s)
Chars 15657 - 15658 [{] 0. secs (0.u,0.s)
Chars 15667 - 15678 [assumption.] 0. secs (0.u,0.s)
Chars 15685 - 15686 [}] 0. secs (0.u,0.s)
Chars 15693 - 15724 [(apply~initial_segment_property).] 0.001 secs (0.001u,0.s)
Chars 15750 - 15751 [}] 0. secs (0.u,0.s)
Chars 15756 - 15782 [(exists~(in_~a'~a'_a);~cbn).] 0.003 secs (0.002u,0.s)
Chars 15783 - 15788 [auto.] 0.001 secs (0.001u,0.s)
Chars 15530 - 15541 [(unfold~out).] 0. secs (0.u,0.s)
Chars 15544 - 15556 [constructor.] 0. secs (0.u,0.s)
Chars 15561 - 15566 [auto.] 0. secs (0.u,0.s)
Chars 15571 - 15588 [(intros~x~a'~a'_x).] 0. secs (0.u,0.s)
Chars 15589 - 15598 [(apply~tr).] 0. secs (0.u,0.s)
Chars 15603 - 15626 [(assert~(a'_a~:~a'~<~a)).] 0. secs (0.u,0.s)
Chars 15635 - 15656 [transitivity~(out~x).] 0. secs (0.u,0.s)
Chars 15667 - 15678 [assumption.] 0. secs (0.u,0.s)
Chars 15693 - 15724 [(apply~initial_segment_property).] 0. secs (0.u,0.s)
Chars 15756 - 15782 [(exists~(in_~a'~a'_a);~cbn).] 0.001 secs (0.001u,0.s)
Chars 15783 - 15788 [auto.] 0. secs (0.u,0.s)
Chars 15789 - 15793 [Qed.] 0.004 secs (0.004u,0.s)
Chars 15796 - 15947 [#[global]~Instance~isinjective...] 0.001 secs (0.u,0.001s)
Chars 15948 - 15954 [Proof.] 0. secs (0.u,0.s)
Chars 15354 - 15425 [(destruct~theta;~destruct~q;~i...] 40.084 secs (0.048u,0.026s)
Chars 15426 - 15432 [(simpl).] 0.002 secs (0.002u,0.s)
Chars 15437 - 15480 [(intro~s;~destruct~s;~srefine~...] 0.009 secs (0.007u,0.002s)
Chars 15354 - 15425 [(destruct~theta;~destruct~q;~i...] 0.013 secs (0.013u,0.s)
Chars 15426 - 15432 [(simpl).] 0.002 secs (0.002u,0.s)
Chars 15437 - 15480 [(intro~s;~destruct~s;~srefine~...] 0.006 secs (0.005u,0.s)
Chars 15483 - 15491 [Defined.] 0.022 secs (0.015u,0.007s)
Chars 15580 - 15694 [#[local]~Definition~G~n~a~:~~~...] 0.011 secs (0.008u,0.002s)
Chars 15697 - 15703 [Proof.] 0. secs (0.u,0.s)
Chars 5639 - 5652 [(intros~E1~E2).] 34.002 secs (0.001u,0.017s)
Chars 5655 - 5677 [(apply~lt_iff_le_apart).] 0.004 secs (0.004u,0.s)
Chars 5678 - 5706 [(apply~lt_iff_le_apart~in~E1).] 0.001 secs (0.001u,0.s)
Chars 5709 - 5734 [(destruct~E1~as~[E1a~E1b]).] 0. secs (0.u,0.s)
Chars 5737 - 5743 [split.] 0. secs (0.u,0.s)
Chars 5746 - 5747 [-] 0. secs (0.u,0.s)
Chars 5748 - 5774 [(transitivity~y;~assumption).] 0.006 secs (0.006u,0.s)
Chars 5777 - 5778 [-] 0. secs (0.u,0.s)
Chars 5779 - 5850 [(apply~(merely_destruct~(cotra...] 0.006 secs (0.006u,0.s)
Chars 5855 - 5870 [(apply~lt_apart).] 0. secs (0.u,0.s)
Chars 5871 - 5892 [(apply~symmetry~in~E3).] 0.001 secs (0.001u,0.s)
Chars 5897 - 5940 [(transitivity~y;~apply~lt_iff_...] 0.01 secs (0.01u,0.s)
Chars 5639 - 5652 [(intros~E1~E2).] 0. secs (0.u,0.s)
Chars 5655 - 5677 [(apply~lt_iff_le_apart).] 0. secs (0.u,0.s)
Chars 5678 - 5706 [(apply~lt_iff_le_apart~in~E1).] 0. secs (0.u,0.s)
Chars 5709 - 5734 [(destruct~E1~as~[E1a~E1b]).] 0. secs (0.u,0.s)
Chars 5737 - 5743 [split.] 0. secs (0.u,0.s)
Chars 5748 - 5774 [(transitivity~y;~assumption).] 0. secs (0.u,0.s)
Chars 5779 - 5850 [(apply~(merely_destruct~(cotra...] 0. secs (0.u,0.s)
Chars 5855 - 5870 [(apply~lt_apart).] 0. secs (0.u,0.s)
Chars 5871 - 5892 [(apply~symmetry~in~E3).] 0. secs (0.u,0.s)
Chars 5897 - 5940 [(transitivity~y;~apply~lt_iff_...] 0. secs (0.u,0.s)
Chars 5943 - 5947 [Qed.] 0.001 secs (0.001u,0.s)
Chars 5951 - 6003 [Lemma~le_lt_trans~x~y~z~:~x~≤~...] 0. secs (0.u,0.s)
Chars 6006 - 6012 [Proof.] 0. secs (0.u,0.s)
Finished transaction in 17.184 secs (2.611u,0.083s) (successful)
Finished transaction in 0. secs (0.u,0.s) (successful)
Chars 5978 - 5987 [(intros~E).] 40.012 secs (0.u,0.002s)
Chars 5988 - 6003 [transitivity~x.] 0.023 secs (0.02u,0.002s)
Chars 6006 - 6007 [-] 0. secs (0.u,0.s)
Chars 6008 - 6024 [(apply~meet_lb_l).] 0. secs (0.u,0.s)
Chars 6027 - 6028 [-] 0. secs (0.u,0.s)
Chars 6029 - 6037 [trivial.] 0. secs (0.u,0.s)
Chars 5978 - 5987 [(intros~E).] 0. secs (0.u,0.s)
Chars 5988 - 6003 [transitivity~x.] 0. secs (0.u,0.s)
Chars 6008 - 6024 [(apply~meet_lb_l).] 0. secs (0.u,0.s)
Chars 6029 - 6037 [trivial.] 0. secs (0.u,0.s)
Chars 6040 - 6044 [Qed.] 0. secs (0.u,0.s)
Chars 6048 - 6104 [Lemma~meet_le_compat_l~x~y~z~:...] 0. secs (0.u,0.s)
Chars 6107 - 6113 [Proof.] 0. secs (0.u,0.s)
For more reductions assert : x <> 0
Chars 15708 - 15728 [srapply~Colimit_ind.] 22.086 secs (0.01u,0.021s)
Chars 15733 - 15734 [-] 0. secs (0.u,0.s)
Chars 15735 - 15761 [exact~(fun~k~b~=>~idpath).] 0.007 secs (0.006u,0.s)
Chars 15766 - 15767 [-] 0. secs (0.u,0.s)
Chars 15768 - 15795 [(intros~k~l~p~b;~destruct~p).] 0.048 secs (0.04u,0.007s)
Chars 15802 - 15876 [snrapply~(Phi~(glue~A~n~a)~(co...] 0.067 secs (0.063u,0.003s)
Chars 15883 - 15951 [(rewrite~(Colimit_ind_beta_col...] 0.158 secs (0.136u,0.022s)
Chars 15958 - 16031 [(rewrite~(Colimit_ind_beta_col...] 0.128 secs (0.128u,0.s)
Chars 16038 - 16080 [(rewrite~concat_p1,~concat_1p;...] 0.198 secs (0.195u,0.002s)
Chars 15708 - 15728 [srapply~Colimit_ind.] 0.001 secs (0.001u,0.s)
Chars 15735 - 15761 [exact~(fun~k~b~=>~idpath).] 0.001 secs (0.001u,0.s)
Chars 15768 - 15795 [(intros~k~l~p~b;~destruct~p).] 0.006 secs (0.006u,0.s)
Chars 15802 - 15876 [snrapply~(Phi~(glue~A~n~a)~(co...] 0.002 secs (0.002u,0.s)
Chars 15883 - 15951 [(rewrite~(Colimit_ind_beta_col...] 0.006 secs (0.006u,0.s)
Chars 15958 - 16031 [(rewrite~(Colimit_ind_beta_col...] 0.005 secs (0.005u,0.s)
Chars 16038 - 16080 [(rewrite~concat_p1,~concat_1p;...] 0.009 secs (0.009u,0.s)
Chars 16083 - 16091 [Defined.] 0.436 secs (0.435u,0.001s)
Chars 16095 - 16292 [#[local]~Definition~I~{X}~{Y}~...] 0.002 secs (0.001u,0.s)
Chars 16295 - 16301 [Proof.] 0. secs (0.u,0.s)
     = Lt
     : comparison
Chars 18087 - 18109 [srapply~amal_type_rec.] 40.12 secs (0.105u,0.004s)
Chars 18114 - 18115 [{] 0. secs (0.u,0.s)
Chars 18116 - 18124 [intro~w.] 0. secs (0.u,0.s)
Chars 18131 - 18161 [refine~(fold_right~_~_~_~_~w).] 0. secs (0.u,0.s)
Chars 18168 - 18169 [{] 0. secs (0.u,0.s)
Chars 18170 - 18185 [(intros~[l|~r]~x).] 0. secs (0.u,0.s)
Chars 18194 - 18195 [+] 0. secs (0.u,0.s)
Chars 18196 - 18212 [exact~(h~l~*~x).] 0. secs (0.u,0.s)
Chars 18221 - 18222 [+] 0. secs (0.u,0.s)
Chars 18223 - 18239 [exact~(k~r~*~x).] 0. secs (0.u,0.s)
Chars 18240 - 18241 [}] 0. secs (0.u,0.s)
Chars 18248 - 18263 [exact~mon_unit.] 0. secs (0.u,0.s)
Chars 18264 - 18265 [}] 0. secs (0.u,0.s)
Chars 18270 - 18271 [{] 0. secs (0.u,0.s)
Chars 18272 - 18294 [(intros~x~y~h1~h2;~hnf).] 0.001 secs (0.001u,0.s)
Chars 18301 - 18325 [(rewrite~?fold_right_app).] 0.01 secs (0.01u,0.s)
Chars 18332 - 18337 [f_ap.] 0.006 secs (0.006u,0.s)
Chars 18344 - 18350 [(simpl).] 0.001 secs (0.001u,0.s)
Chars 18357 - 18386 [(rewrite~simple_associativity).] 0.028 secs (0.028u,0.s)
Chars 18393 - 18398 [f_ap.] 0.004 secs (0.004u,0.s)
Chars 18405 - 18414 [symmetry.] 0.001 secs (0.001u,0.s)
Chars 18421 - 18449 [exact~(grp_homo_op~h~h1~h2).] 0. secs (0.u,0.s)
Chars 18450 - 18451 [}] 0. secs (0.u,0.s)
Chars 18456 - 18457 [{] 0. secs (0.u,0.s)
Chars 18458 - 18480 [(intros~x~y~k1~k2;~hnf).] 0.001 secs (0.001u,0.s)
Chars 18487 - 18511 [(rewrite~?fold_right_app).] 0.007 secs (0.007u,0.s)
Chars 18518 - 18523 [f_ap.] 0.006 secs (0.005u,0.s)
Chars 18530 - 18536 [(simpl).] 0.001 secs (0.001u,0.s)
Chars 18543 - 18572 [(rewrite~simple_associativity).] 0.028 secs (0.028u,0.s)
Chars 18579 - 18584 [f_ap.] 0.004 secs (0.003u,0.s)
Chars 18591 - 18600 [symmetry.] 0.001 secs (0.001u,0.s)
Chars 18607 - 18635 [exact~(grp_homo_op~k~k1~k2).] 0. secs (0.u,0.s)
Chars 18636 - 18637 [}] 0. secs (0.u,0.s)
Chars 18642 - 18643 [{] 0. secs (0.u,0.s)
Chars 18644 - 18662 [(intros~x~y~z;~hnf).] 0.001 secs (0.001u,0.s)
Chars 18669 - 18693 [(rewrite~?fold_right_app).] 0.008 secs (0.008u,0.s)
Chars 18700 - 18718 [(f_ap;~simpl;~f_ap).] 0.011 secs (0.011u,0.s)
Chars 18719 - 18720 [}] 0. secs (0.u,0.s)
Chars 18725 - 18726 [{] 0. secs (0.u,0.s)
Chars 18727 - 18743 [(intros~x~y;~hnf).] 0.001 secs (0.001u,0.s)
Chars 18750 - 18774 [(rewrite~?fold_right_app).] 0.005 secs (0.005u,0.s)
Chars 18781 - 18786 [f_ap.] 0.005 secs (0.005u,0.s)
Chars 18787 - 18793 [(simpl).] 0. secs (0.u,0.s)
Chars 18794 - 18816 [(rewrite~grp_homo_unit).] 0.001 secs (0.001u,0.s)
Chars 18823 - 18844 [rapply~left_identity.] 0.006 secs (0.006u,0.s)
Chars 18845 - 18846 [}] 0. secs (0.u,0.s)
Chars 18851 - 18852 [{] 0. secs (0.u,0.s)
Chars 18853 - 18869 [(intros~x~y;~hnf).] 0.001 secs (0.001u,0.s)
Chars 18876 - 18900 [(rewrite~?fold_right_app).] 0.005 secs (0.005u,0.s)
Chars 18907 - 18912 [f_ap.] 0.006 secs (0.006u,0.s)
Chars 18913 - 18919 [(simpl).] 0. secs (0.u,0.s)
Chars 18920 - 18942 [(rewrite~grp_homo_unit).] 0.001 secs (0.001u,0.s)
Chars 18949 - 18970 [rapply~left_identity.] 0.006 secs (0.006u,0.s)
Chars 18971 - 18972 [}] 0. secs (0.u,0.s)
Chars 18087 - 18109 [srapply~amal_type_rec.] 0. secs (0.u,0.s)
Chars 18116 - 18124 [intro~w.] 0. secs (0.u,0.s)
Chars 18131 - 18161 [refine~(fold_right~_~_~_~_~w).] 0. secs (0.u,0.s)
Chars 18170 - 18185 [(intros~[l|~r]~x).] 0. secs (0.u,0.s)
Chars 18196 - 18212 [exact~(h~l~*~x).] 0. secs (0.u,0.s)
Chars 18223 - 18239 [exact~(k~r~*~x).] 0. secs (0.u,0.s)
Chars 18248 - 18263 [exact~mon_unit.] 0. secs (0.u,0.s)
Chars 18272 - 18294 [(intros~x~y~h1~h2;~hnf).] 0.001 secs (0.001u,0.s)
Chars 18301 - 18325 [(rewrite~?fold_right_app).] 0. secs (0.u,0.s)
Chars 18332 - 18337 [f_ap.] 0. secs (0.u,0.s)
Chars 18344 - 18350 [(simpl).] 0. secs (0.u,0.s)
Chars 18357 - 18386 [(rewrite~simple_associativity).] 0. secs (0.u,0.s)
Chars 18393 - 18398 [f_ap.] 0. secs (0.u,0.s)
Chars 18405 - 18414 [symmetry.] 0. secs (0.u,0.s)
Chars 18421 - 18449 [exact~(grp_homo_op~h~h1~h2).] 0. secs (0.u,0.s)
Chars 18458 - 18480 [(intros~x~y~k1~k2;~hnf).] 0.001 secs (0.001u,0.s)
Chars 18487 - 18511 [(rewrite~?fold_right_app).] 0. secs (0.u,0.s)
Chars 18518 - 18523 [f_ap.] 0. secs (0.u,0.s)
Chars 18530 - 18536 [(simpl).] 0. secs (0.u,0.s)
Chars 18543 - 18572 [(rewrite~simple_associativity).] 0. secs (0.u,0.s)
Chars 18579 - 18584 [f_ap.] 0. secs (0.u,0.s)
Chars 18591 - 18600 [symmetry.] 0. secs (0.u,0.s)
Chars 18607 - 18635 [exact~(grp_homo_op~k~k1~k2).] 0. secs (0.u,0.s)
Chars 18644 - 18662 [(intros~x~y~z;~hnf).] 0.001 secs (0.001u,0.s)
Chars 18669 - 18693 [(rewrite~?fold_right_app).] 0. secs (0.u,0.s)
Chars 18700 - 18718 [(f_ap;~simpl;~f_ap).] 0.001 secs (0.001u,0.s)
Chars 18727 - 18743 [(intros~x~y;~hnf).] 0.001 secs (0.001u,0.s)
Chars 18750 - 18774 [(rewrite~?fold_right_app).] 0. secs (0.u,0.s)
Chars 18781 - 18786 [f_ap.] 0. secs (0.u,0.s)
Chars 18787 - 18793 [(simpl).] 0. secs (0.u,0.s)
Chars 18794 - 18816 [(rewrite~grp_homo_unit).] 0. secs (0.u,0.s)
Chars 18823 - 18844 [rapply~left_identity.] 0. secs (0.u,0.s)
Chars 18853 - 18869 [(intros~x~y;~hnf).] 0.001 secs (0.001u,0.s)
Chars 18876 - 18900 [(rewrite~?fold_right_app).] 0. secs (0.u,0.s)
Chars 18907 - 18912 [f_ap.] 0. secs (0.u,0.s)
Chars 18913 - 18919 [(simpl).] 0. secs (0.u,0.s)
Chars 18920 - 18942 [(rewrite~grp_homo_unit).] 0. secs (0.u,0.s)
Chars 18949 - 18970 [rapply~left_identity.] 0. secs (0.u,0.s)
Chars 18975 - 18983 [Defined.] 0.03 secs (0.029u,0.s)
Chars 18987 - 19216 [#[global]~Instance~issemigroup...] 0.001 secs (0.001u,0.s)
Chars 19219 - 19225 [Proof.] 0. secs (0.u,0.s)
Chars 15957 - 16035 [(enough~(H1~:~forall~a1~a2~:~A...] 40.092 secs (0.004u,0.019s)
Chars 16036 - 16037 [{] 0. secs (0.u,0.s)
Chars 16042 - 16057 [(intros~a1~a2~p).] 0. secs (0.u,0.s)
Chars 16058 - 16089 [(apply~extensionality;~intros~b).] 0.002 secs (0.002u,0.s)
Chars 16090 - 16096 [split.] 0. secs (0.u,0.s)
Chars 16101 - 16102 [-] 0. secs (0.u,0.s)
Chars 16103 - 16115 [(intros~b_a1).] 0. secs (0.u,0.s)
Chars 16116 - 16148 [exact~(H1~a1~a2~p~(in_~b~b_a1)).] 0.001 secs (0.001u,0.s)
Chars 16153 - 16154 [-] 0. secs (0.u,0.s)
Chars 16155 - 16167 [(intros~b_a2).] 0. secs (0.u,0.s)
Chars 16168 - 16201 [exact~(H1~a2~a1~p^~(in_~b~b_a2)).] 0.001 secs (0.001u,0.s)
Chars 16204 - 16205 [}] 0. secs (0.u,0.s)
Chars 16209 - 16226 [(intros~a1~a2~p~b).] 0. secs (0.u,0.s)
Chars 16229 - 16299 [(assert~(out~=~transport~(fun~...] 0.003 secs (0.003u,0.s)
Chars 16300 - 16301 [{] 0. secs (0.u,0.s)
Chars 16306 - 16328 [(apply~path_simulation).] 0.001 secs (0.001u,0.s)
Chars 16333 - 16334 [-] 0. secs (0.u,0.s)
Chars 16335 - 16343 [exact~_.] 0.001 secs (0.001u,0.s)
Chars 16348 - 16349 [-] 0. secs (0.u,0.s)
Chars 16350 - 16367 [(apply~transportD).] 0.001 secs (0.001u,0.s)
Chars 16368 - 16376 [exact~_.] 0.001 secs (0.001u,0.s)
Chars 16379 - 16380 [}] 0. secs (0.u,0.s)
Chars 16383 - 16415 [(rewrite~transport_arrow_tocon...] 0.002 secs (0.002u,0.s)
Chars 16416 - 16430 [(rewrite~inv_V).] 0.002 secs (0.001u,0.s)
Chars 16431 - 16462 [(apply~initial_segment_property).] 0.001 secs (0.001u,0.s)
Chars 15957 - 16035 [(enough~(H1~:~forall~a1~a2~:~A...] 0. secs (0.u,0.s)
Chars 16042 - 16057 [(intros~a1~a2~p).] 0. secs (0.u,0.s)
Chars 16058 - 16089 [(apply~extensionality;~intros~b).] 0. secs (0.u,0.s)
Chars 16090 - 16096 [split.] 0. secs (0.u,0.s)
Chars 16103 - 16115 [(intros~b_a1).] 0. secs (0.u,0.s)
Chars 16116 - 16148 [exact~(H1~a1~a2~p~(in_~b~b_a1)).] 0. secs (0.u,0.s)
Chars 16155 - 16167 [(intros~b_a2).] 0. secs (0.u,0.s)
Chars 16168 - 16201 [exact~(H1~a2~a1~p^~(in_~b~b_a2)).] 0. secs (0.u,0.s)
Chars 16209 - 16226 [(intros~a1~a2~p~b).] 0. secs (0.u,0.s)
Chars 16229 - 16299 [(assert~(out~=~transport~(fun~...] 0. secs (0.u,0.s)
Chars 16306 - 16328 [(apply~path_simulation).] 0. secs (0.u,0.s)
Chars 16335 - 16343 [exact~_.] 0. secs (0.u,0.s)
Chars 16350 - 16367 [(apply~transportD).] 0. secs (0.u,0.s)
Chars 16368 - 16376 [exact~_.] 0. secs (0.u,0.s)
Chars 16383 - 16415 [(rewrite~transport_arrow_tocon...] 0. secs (0.u,0.s)
Chars 16416 - 16430 [(rewrite~inv_V).] 0. secs (0.u,0.s)
Chars 16431 - 16462 [(apply~initial_segment_property).] 0. secs (0.u,0.s)
Chars 16463 - 16467 [Qed.] 0.005 secs (0.005u,0.s)
Chars 16472 - 16747 [Lemma~equiv_initial_segment_si...] 0.003 secs (0.002u,0.s)
Chars 16748 - 16754 [Proof.] 0. secs (0.u,0.s)
Impossibility_free
     : forall (mu : T1) (m : Hydra -> T1) (Var : Hvariant T1_wf free m),
       BoundedVariant Var mu -> False
Chars 6015 - 6028 [(intros~E2~E1).] 40.114 secs (0.u,0.018s)
Chars 6031 - 6053 [(apply~lt_iff_le_apart).] 0.004 secs (0.004u,0.s)
Chars 6054 - 6082 [(apply~lt_iff_le_apart~in~E1).] 0.001 secs (0.001u,0.s)
Chars 6085 - 6110 [(destruct~E1~as~[E1a~E1b]).] 0. secs (0.u,0.s)
Chars 6113 - 6119 [split.] 0. secs (0.u,0.s)
Chars 6122 - 6123 [-] 0. secs (0.u,0.s)
Chars 6124 - 6144 [(transitivity~y;~auto).] 0.006 secs (0.006u,0.s)
Chars 6147 - 6148 [-] 0. secs (0.u,0.s)
Chars 6149 - 6220 [(apply~(merely_destruct~(cotra...] 0.006 secs (0.006u,0.s)
Chars 6225 - 6240 [(apply~lt_apart).] 0. secs (0.u,0.s)
Chars 6241 - 6262 [(apply~symmetry~in~E3).] 0.001 secs (0.001u,0.s)
Chars 6267 - 6311 [(transitivity~y;~apply~lt_iff_...] 0.012 secs (0.011u,0.001s)
Chars 6015 - 6028 [(intros~E2~E1).] 0. secs (0.u,0.s)
Chars 6031 - 6053 [(apply~lt_iff_le_apart).] 0. secs (0.u,0.s)
Chars 6054 - 6082 [(apply~lt_iff_le_apart~in~E1).] 0. secs (0.u,0.s)
Chars 6085 - 6110 [(destruct~E1~as~[E1a~E1b]).] 0. secs (0.u,0.s)
Chars 6113 - 6119 [split.] 0. secs (0.u,0.s)
Chars 6124 - 6144 [(transitivity~y;~auto).] 0. secs (0.u,0.s)
Chars 6149 - 6220 [(apply~(merely_destruct~(cotra...] 0. secs (0.u,0.s)
Chars 6225 - 6240 [(apply~lt_apart).] 0. secs (0.u,0.s)
Chars 6241 - 6262 [(apply~symmetry~in~E3).] 0. secs (0.u,0.s)
Chars 6267 - 6311 [(transitivity~y;~apply~lt_iff_...] 0. secs (0.u,0.s)
Chars 6314 - 6318 [Qed.] 0.001 secs (0.001u,0.s)
Chars 6322 - 6394 [Lemma~lt_iff_le_ne~`{!TrivialA...] 0.001 secs (0.001u,0.s)
Chars 6397 - 6403 [Proof.] 0. secs (0.u,0.s)
Chars 6116 - 6125 [(intros~E).] 40.011 secs (0.u,0.003s)
Chars 6126 - 6160 [(rewrite~(commutativity~(f:=me...] 0.001 secs (0.001u,0.s)
Chars 6163 - 6186 [(apply~meet_le_compat_r).] 0. secs (0.u,0.s)
Chars 6189 - 6197 [trivial.] 0. secs (0.u,0.s)
Chars 6116 - 6125 [(intros~E).] 0. secs (0.u,0.s)
Chars 6126 - 6160 [(rewrite~(commutativity~(f:=me...] 0. secs (0.u,0.s)
Chars 6163 - 6186 [(apply~meet_le_compat_r).] 0. secs (0.u,0.s)
Chars 6189 - 6197 [trivial.] 0. secs (0.u,0.s)
Chars 6200 - 6204 [Qed.] 0. secs (0.u,0.s)
Chars 6208 - 6250 [Lemma~meet_l~x~y~:~x~≤~y~->~x~...] 0. secs (0.u,0.s)
Chars 6253 - 6259 [Proof.] 0. secs (0.u,0.s)
Finished transaction in 42.538 secs (2.316u,0.088s) (successful)
Finished transaction in 0. secs (0.u,0.s) (successful)
Chars 16306 - 16331 [(destruct~p;~destruct~psi).] 40.105 secs (0.005u,0.021s)
Chars 16336 - 16404 [srefine~(transitivity~(equiv_p...] 0.004 secs (0.004u,0.s)
Chars 16306 - 16331 [(destruct~p;~destruct~psi).] 0.003 secs (0.003u,0.s)
Chars 16336 - 16404 [srefine~(transitivity~(equiv_p...] 0.002 secs (0.002u,0.s)
Chars 16407 - 16415 [Defined.] 0.002 secs (0.001u,0.s)
Chars 16523 - 16578 [Definition~seq_colim_sum_ind_c...] 0. secs (0.u,0.s)
Chars 16581 - 16587 [Proof.] 0. secs (0.u,0.s)
Chars 19230 - 19336 [(intros~x;~srapply~amal_type_i...] 38.591 secs (0.147u,0.004s)
Chars 19341 - 19364 [(rewrite~fold_right_app).] 0.001 secs (0.001u,0.s)
Chars 19369 - 19597 [(set~~~(s~:=~~~~fold_right~X~(...] 0.004 secs (0.004u,0.s)
Chars 19602 - 19624 [(induction~x~as~[|~a~x]).] 0.001 secs (0.001u,0.s)
Chars 19629 - 19662 [1:~(symmetry;~apply~left_ident...] 0.008 secs (0.008u,0.s)
Chars 19667 - 19673 [(simpl).] 0.001 secs (0.001u,0.s)
Chars 19678 - 19690 [(rewrite~IHx).] 0.002 secs (0.002u,0.s)
Chars 19695 - 19734 [(destruct~a;~apply~simple_asso...] 0.037 secs (0.036u,0.s)
Chars 19230 - 19336 [(intros~x;~srapply~amal_type_i...] 0.002 secs (0.001u,0.s)
Chars 19341 - 19364 [(rewrite~fold_right_app).] 0. secs (0.u,0.s)
Chars 19369 - 19597 [(set~~~(s~:=~~~~fold_right~X~(...] 0. secs (0.u,0.s)
Chars 19602 - 19624 [(induction~x~as~[|~a~x]).] 0. secs (0.u,0.s)
Chars 19629 - 19662 [1:~(symmetry;~apply~left_ident...] 0.001 secs (0.001u,0.s)
Chars 19667 - 19673 [(simpl).] 0. secs (0.u,0.s)
Chars 19678 - 19690 [(rewrite~IHx).] 0. secs (0.u,0.s)
Chars 19695 - 19734 [(destruct~a;~apply~simple_asso...] 0.002 secs (0.002u,0.s)
Chars 19737 - 19741 [Qed.] 0.012 secs (0.012u,0.s)
Chars 19745 - 19929 [Definition~AmalgamatedFreeProd...] 0.001 secs (0.001u,0.s)
Chars 19932 - 19938 [Proof.] 0. secs (0.u,0.s)
Chars 16757 - 16783 [(apply~isomorphism_inverse).] 40.084 secs (0.001u,0.019s)
Chars 16786 - 16800 [srapply~exist.] 0.001 secs (0.001u,0.s)
Chars 16803 - 16804 [-] 0. secs (0.u,0.s)
Chars 16805 - 16830 [srapply~equiv_adjointify.] 0.001 secs (0.001u,0.s)
Chars 16835 - 16836 [+] 0. secs (0.u,0.s)
Chars 16837 - 16846 [(intros~x).] 0. secs (0.u,0.s)
Chars 16847 - 16862 [exists~(f~x.1).] 0.001 secs (0.001u,0.s)
Chars 16863 - 16888 [(apply~equiv_resize_hprop).] 0. secs (0.u,0.s)
Chars 16895 - 16920 [rapply~simulation_is_hom.] 0.008 secs (0.007u,0.s)
Chars 16921 - 16953 [(apply~(equiv_resize_hprop~_)^...] 0.006 secs (0.005u,0.s)
Chars 16954 - 16964 [exact~x.2.] 0.001 secs (0.001u,0.s)
Chars 16969 - 16970 [+] 0. secs (0.u,0.s)
Chars 16971 - 16980 [(intros~x).] 0. secs (0.u,0.s)
Chars 16987 - 17013 [(assert~(x_fa~:~x.1~<~f~a)).] 0.001 secs (0.001u,0.s)
Chars 17014 - 17015 [{] 0. secs (0.u,0.s)
Chars 17024 - 17062 [exact~((equiv_resize_hprop~_)^...] 0.011 secs (0.008u,0.003s)
Chars 17069 - 17070 [}] 0. secs (0.u,0.s)
Chars 17077 - 17136 [(destruct~(simulation_is_minim...] 0.004 secs (0.004u,0.s)
Chars 17143 - 17181 [exact~(a';~equiv_resize_hprop~...] 0.001 secs (0.001u,0.s)
Chars 17186 - 17187 [+] 0. secs (0.u,0.s)
Chars 17188 - 17192 [(cbn).] 0.003 secs (0.002u,0.s)
Chars 17193 - 17202 [(intros~x).] 0.001 secs (0.001u,0.s)
Chars 17203 - 17231 [(apply~path_sigma_hprop;~cbn).] 0.008 secs (0.006u,0.001s)
Chars 17238 - 17278 [transparent~assert~(~x_fa~:~(x...] 0.001 secs (0.u,0.s)
Chars 17279 - 17280 [{] 0. secs (0.u,0.s)
Chars 17289 - 17327 [exact~((equiv_resize_hprop~_)^...] 0.003 secs (0.003u,0.s)
Chars 17334 - 17335 [}] 0. secs (0.u,0.s)
Chars 17342 - 17387 [exact~(snd~(simulation_is_mini...] 0.001 secs (0.001u,0.s)
Chars 17392 - 17393 [+] 0. secs (0.u,0.s)
Chars 17394 - 17398 [(cbn).] 0.003 secs (0.003u,0.s)
Chars 17399 - 17408 [(intros~x).] 0.001 secs (0.001u,0.s)
Chars 17409 - 17437 [(apply~path_sigma_hprop;~cbn).] 0.008 secs (0.006u,0.001s)
Chars 17444 - 17481 [transparent~assert~(~x_a~:~(x....] 0.002 secs (0.002u,0.s)
Chars 17482 - 17483 [{] 0. secs (0.u,0.s)
Chars 17492 - 17530 [exact~((equiv_resize_hprop~_)^...] 0.003 secs (0.003u,0.s)
Chars 17537 - 17538 [}] 0. secs (0.u,0.s)
Chars 17545 - 17565 [(apply~(injective~f)).] 0.004 secs (0.003u,0.s)
Chars 17572 - 17576 [(cbn).] 0.001 secs (0.001u,0.s)
Chars 17577 - 17609 [(unfold~initial_segment_proper...] 0. secs (0.u,0.s)
Chars 17610 - 17614 [(cbn).] 0.001 secs (0.001u,0.s)
Chars 17621 - 17637 [(rewrite~eissect).] 0.002 secs (0.001u,0.s)
Chars 17644 - 17710 [exact~(snd~(simulation_is_mini...] 0.002 secs (0.002u,0.s)
Chars 17713 - 17714 [-] 0. secs (0.u,0.s)
Chars 17715 - 17719 [(cbn).] 0.013 secs (0.009u,0.003s)
Chars 17720 - 17748 [(intros~[x~x_a]~[y~y_a];~cbn).] 0.002 secs (0.002u,0.s)
Chars 17749 - 17755 [split.] 0. secs (0.u,0.s)
Chars 17760 - 17761 [+] 0. secs (0.u,0.s)
Chars 17762 - 17790 [(apply~(simulation_is_hom~f)).] 0.001 secs (0.001u,0.s)
Chars 17795 - 17796 [+] 0. secs (0.u,0.s)
Chars 17797 - 17810 [(intros~fx_fy).] 0. secs (0.u,0.s)
Chars 17817 - 17877 [(destruct~(simulation_is_minim...] 0.003 secs (0.003u,0.s)
Chars 17884 - 17918 [(apply~injective~in~p;~try~exa...] 0.004 secs (0.003u,0.s)
Chars 17919 - 17928 [subst~a'.] 0. secs (0.u,0.s)
Chars 17929 - 17940 [exact~a'_y.] 0. secs (0.u,0.s)
Chars 16757 - 16783 [(apply~isomorphism_inverse).] 0. secs (0.u,0.s)
Chars 16786 - 16800 [srapply~exist.] 0. secs (0.u,0.s)
Chars 16805 - 16830 [srapply~equiv_adjointify.] 0. secs (0.u,0.s)
Chars 16837 - 16846 [(intros~x).] 0. secs (0.u,0.s)
Chars 16847 - 16862 [exists~(f~x.1).] 0. secs (0.u,0.s)
Chars 16863 - 16888 [(apply~equiv_resize_hprop).] 0. secs (0.u,0.s)
Chars 16895 - 16920 [rapply~simulation_is_hom.] 0. secs (0.u,0.s)
Chars 16921 - 16953 [(apply~(equiv_resize_hprop~_)^...] 0. secs (0.u,0.s)
Chars 16954 - 16964 [exact~x.2.] 0. secs (0.u,0.s)
Chars 16971 - 16980 [(intros~x).] 0. secs (0.u,0.s)
Chars 16987 - 17013 [(assert~(x_fa~:~x.1~<~f~a)).] 0. secs (0.u,0.s)
Chars 17024 - 17062 [exact~((equiv_resize_hprop~_)^...] 0. secs (0.u,0.s)
Chars 17077 - 17136 [(destruct~(simulation_is_minim...] 0. secs (0.u,0.s)
Chars 17143 - 17181 [exact~(a';~equiv_resize_hprop~...] 0. secs (0.u,0.s)
Chars 17188 - 17192 [(cbn).] 0.001 secs (0.001u,0.s)
Chars 17193 - 17202 [(intros~x).] 0.001 secs (0.001u,0.s)
Chars 17203 - 17231 [(apply~path_sigma_hprop;~cbn).] 0.002 secs (0.002u,0.s)
Chars 17238 - 17278 [transparent~assert~(~x_fa~:~(x...] 0. secs (0.u,0.s)
Chars 17289 - 17327 [exact~((equiv_resize_hprop~_)^...] 0. secs (0.u,0.s)
Chars 17342 - 17387 [exact~(snd~(simulation_is_mini...] 0. secs (0.u,0.s)
Chars 17394 - 17398 [(cbn).] 0.001 secs (0.001u,0.s)
Chars 17399 - 17408 [(intros~x).] 0.001 secs (0.001u,0.s)
Chars 17409 - 17437 [(apply~path_sigma_hprop;~cbn).] 0.002 secs (0.001u,0.s)
Chars 17444 - 17481 [transparent~assert~(~x_a~:~(x....] 0. secs (0.u,0.s)
Chars 17492 - 17530 [exact~((equiv_resize_hprop~_)^...] 0. secs (0.u,0.s)
Chars 17545 - 17565 [(apply~(injective~f)).] 0. secs (0.u,0.s)
Chars 17572 - 17576 [(cbn).] 0. secs (0.u,0.s)
Chars 17577 - 17609 [(unfold~initial_segment_proper...] 0. secs (0.u,0.s)
Chars 17610 - 17614 [(cbn).] 0. secs (0.u,0.s)
Chars 17621 - 17637 [(rewrite~eissect).] 0. secs (0.u,0.s)
Chars 17644 - 17710 [exact~(snd~(simulation_is_mini...] 0. secs (0.u,0.s)
Chars 17715 - 17719 [(cbn).] 0.01 secs (0.009u,0.s)
Chars 17720 - 17748 [(intros~[x~x_a]~[y~y_a];~cbn).] 0.001 secs (0.001u,0.s)
Chars 17749 - 17755 [split.] 0. secs (0.u,0.s)
Chars 17762 - 17790 [(apply~(simulation_is_hom~f)).] 0. secs (0.u,0.s)
Chars 17797 - 17810 [(intros~fx_fy).] 0. secs (0.u,0.s)
Chars 17817 - 17877 [(destruct~(simulation_is_minim...] 0. secs (0.u,0.s)
Chars 17884 - 17918 [(apply~injective~in~p;~try~exa...] 0. secs (0.u,0.s)
Chars 17919 - 17928 [subst~a'.] 0. secs (0.u,0.s)
Chars 17929 - 17940 [exact~a'_y.] 0. secs (0.u,0.s)
Chars 17941 - 17945 [Qed.] 0.058 secs (0.047u,0.01s)
Chars 17948 - 18192 [Lemma~path_initial_segment_sim...] 0.001 secs (0.001u,0.s)
Chars 18193 - 18199 [Proof.] 0. secs (0.u,0.s)
Chars 6407 - 6442 [transitivity~(x~<=~y~/\~apart~...] 40.135 secs (0.024u,0.026s)
Chars 6446 - 6447 [-] 0. secs (0.u,0.s)
Chars 6448 - 6470 [(apply~lt_iff_le_apart).] 0.001 secs (0.001u,0.s)
Chars 6474 - 6475 [-] 0. secs (0.u,0.s)
Chars 6476 - 6539 [(split;~intros~[E1~E2];~split;...] 0.007 secs (0.007u,0.s)
Chars 6407 - 6442 [transitivity~(x~<=~y~/\~apart~...] 0. secs (0.u,0.s)
Chars 6448 - 6470 [(apply~lt_iff_le_apart).] 0. secs (0.u,0.s)
Chars 6476 - 6539 [(split;~intros~[E1~E2];~split;...] 0.002 secs (0.001u,0.001s)
Chars 6542 - 6546 [Qed.] 0.001 secs (0.001u,0.s)
Chars 6550 - 6661 [Lemma~le_equiv_lt~`{!TrivialAp...] 0.001 secs (0.001u,0.s)
Chars 6664 - 6670 [Proof.] 0. secs (0.u,0.s)
Chars 6262 - 6271 [(intros~E).] 40.011 secs (0.u,0.002s)
Chars 6272 - 6299 [(apply~(antisymmetry~(≤))).] 0.003 secs (0.002u,0.s)
Chars 6302 - 6303 [-] 0. secs (0.u,0.s)
Chars 6304 - 6320 [(apply~meet_lb_l).] 0. secs (0.u,0.s)
Chars 6323 - 6324 [-] 0. secs (0.u,0.s)
Chars 6325 - 6349 [(apply~meet_glb;~trivial).] 0. secs (0.u,0.s)
Chars 6350 - 6368 [(apply~reflexivity).] 0.003 secs (0.003u,0.s)
Chars 6262 - 6271 [(intros~E).] 0. secs (0.u,0.s)
Chars 6272 - 6299 [(apply~(antisymmetry~(≤))).] 0. secs (0.u,0.s)
Chars 6304 - 6320 [(apply~meet_lb_l).] 0. secs (0.u,0.s)
Chars 6325 - 6349 [(apply~meet_glb;~trivial).] 0. secs (0.u,0.s)
Chars 6350 - 6368 [(apply~reflexivity).] 0. secs (0.u,0.s)
Chars 6371 - 6375 [Qed.] 0. secs (0.u,0.s)
Chars 6379 - 6421 [Lemma~meet_r~x~y~:~y~≤~x~->~x~...] 0. secs (0.u,0.s)
Chars 6424 - 6430 [Proof.] 0. secs (0.u,0.s)
Chars 16592 - 16646 [(srapply~(Colimit_ind~_~F);~in...] 40.104 secs (0.007u,0.02s)
Chars 16651 - 16712 [exact~((I~(fib_seq_to_type_fam...] 0.011 secs (0.011u,0.s)
Chars 16592 - 16646 [(srapply~(Colimit_ind~_~F);~in...] 0.004 secs (0.004u,0.s)
Chars 16651 - 16712 [exact~((I~(fib_seq_to_type_fam...] 0.001 secs (0.u,0.s)
Chars 16715 - 16723 [Defined.] 0.002 secs (0.002u,0.s)
Chars 16809 - 16951 [Definition~seq_colim_sum_ind_c...] 0.016 secs (0.012u,0.003s)
Chars 16954 - 16960 [Proof.] 0. secs (0.u,0.s)
Chars 6433 - 6442 [(intros~E).] 11.299 secs (0.u,0.003s)
Chars 6443 - 6477 [(rewrite~(commutativity~(f:=me...] 0.001 secs (0.001u,0.s)
Chars 6478 - 6491 [(apply~meet_l).] 0. secs (0.u,0.s)
Chars 6494 - 6502 [trivial.] 0. secs (0.u,0.s)
Chars 6433 - 6442 [(intros~E).] 0. secs (0.u,0.s)
Chars 6443 - 6477 [(rewrite~(commutativity~(f:=me...] 0. secs (0.u,0.s)
Chars 6478 - 6491 [(apply~meet_l).] 0. secs (0.u,0.s)
Chars 6494 - 6502 [trivial.] 0. secs (0.u,0.s)
Chars 6505 - 6509 [Qed.] 0. secs (0.u,0.s)
Chars 6513 - 6565 [Lemma~meet_sl_le_spec~x~y~:~x~...] 0. secs (0.u,0.s)
Chars 6568 - 6574 [Proof.] 0. secs (0.u,0.s)
Chars 6577 - 6593 [(split;~intros~E).] 1.909 secs (0.001u,0.002s)
Chars 6596 - 6597 [-] 0. secs (0.u,0.s)
Chars 6598 - 6619 [(apply~meet_l;~trivial).] 0. secs (0.u,0.s)
Chars 6622 - 6623 [-] 0. secs (0.u,0.s)
Chars 6624 - 6636 [(rewrite~<-~E).] 0. secs (0.u,0.s)
Chars 6637 - 6653 [(apply~meet_lb_r).] 0. secs (0.u,0.s)
Chars 6577 - 6593 [(split;~intros~E).] 0. secs (0.u,0.s)
Chars 6598 - 6619 [(apply~meet_l;~trivial).] 0. secs (0.u,0.s)
Chars 6624 - 6636 [(rewrite~<-~E).] 0. secs (0.u,0.s)
Chars 6637 - 6653 [(apply~meet_lb_r).] 0. secs (0.u,0.s)
Chars 6656 - 6660 [Qed.] 0. secs (0.u,0.s)
Chars 6664 - 6715 [#[global]Instance:~(forall~z,~...] 0. secs (0.u,0.s)
Chars 6718 - 6724 [Proof.] 0. secs (0.u,0.s)
Chars 19943 - 19976 [snrapply~Build_GroupHomomorphism.] 40.014 secs (0.001u,0.003s)
Chars 19981 - 20030 [1:~srapply~(AmalgamatedFreePro...] 0. secs (0.u,0.s)
Chars 20035 - 20043 [exact~_.] 0.005 secs (0.005u,0.s)
Chars 19943 - 19976 [snrapply~Build_GroupHomomorphism.] 0. secs (0.u,0.s)
Chars 19981 - 20030 [1:~srapply~(AmalgamatedFreePro...] 0. secs (0.u,0.s)
Chars 20035 - 20043 [exact~_.] 0. secs (0.u,0.s)
Chars 20046 - 20054 [Defined.] 0.005 secs (0.005u,0.s)
Chars 20058 - 20123 [Definition~amal_inl~:~GroupHom...] 0. secs (0.u,0.s)
Chars 20126 - 20132 [Proof.] 0. secs (0.u,0.s)
Chars 18202 - 18227 [(apply~equiv_path_Ordinal).] 40.089 secs (0.001u,0.018s)
Chars 18228 - 18271 [(apply~(equiv_initial_segment_...] 0.001 secs (0.001u,0.s)
Chars 18202 - 18227 [(apply~equiv_path_Ordinal).] 0. secs (0.u,0.s)
Chars 18228 - 18271 [(apply~(equiv_initial_segment_...] 0. secs (0.u,0.s)
Chars 18272 - 18276 [Qed.] 0.001 secs (0.001u,0.s)
Chars 18316 - 18453 [#[global]~Instance~lt_Ordinal@...] 0.001 secs (0.001u,0.s)
Chars 18456 - 18573 [#[global]~Instance~is_mere_rel...] 0. secs (0.u,0.s)
Chars 18574 - 18580 [Proof.] 0. secs (0.u,0.s)
Chars 6673 - 6680 [(intros).] 40.164 secs (0.u,0.018s)
Chars 6683 - 6716 [(destruct~(dec~(x~=~y));~try~a...] 0.005 secs (0.004u,0.s)
Chars 6719 - 6725 [right.] 0. secs (0.u,0.s)
Chars 6728 - 6753 [(apply~lt_iff_le_ne;~auto).] 0.002 secs (0.002u,0.s)
Chars 6673 - 6680 [(intros).] 0. secs (0.u,0.s)
Chars 6683 - 6716 [(destruct~(dec~(x~=~y));~try~a...] 0. secs (0.u,0.s)
Chars 6719 - 6725 [right.] 0. secs (0.u,0.s)
Chars 6728 - 6753 [(apply~lt_iff_le_ne;~auto).] 0. secs (0.u,0.s)
Chars 6756 - 6760 [Qed.] 0. secs (0.u,0.s)
Chars 6764 - 6866 [Instance~dec_from_lt_dec~~`{!T...] 0.001 secs (0.001u,0.s)
Chars 6869 - 6875 [Proof.] 0. secs (0.u,0.s)
Chars 16965 - 17018 [(apply~moveR_equiv_M;~srapply~...] 40.122 secs (0.011u,0.027s)
Chars 16965 - 17018 [(apply~moveR_equiv_M;~srapply~...] 0.004 secs (0.004u,0.s)
Chars 17021 - 17029 [Defined.] 0.037 secs (0.033u,0.003s)
Chars 17107 - 17152 [Definition~seq_colim_sum_ind~:...] 0. secs (0.u,0.s)
Chars 17155 - 17161 [Proof.] 0. secs (0.u,0.s)
Chars 6727 - 6738 [(red;~intros).] 40.013 secs (0.001u,0.003s)
Chars 6741 - 6756 [(apply~meet_glb).] 0. secs (0.u,0.s)
Chars 6759 - 6760 [-] 0. secs (0.u,0.s)
Chars 6761 - 6777 [(apply~meet_lb_l).] 0. secs (0.u,0.s)
Chars 6780 - 6781 [-] 0. secs (0.u,0.s)
Chars 6782 - 6806 [(apply~meet_le_compat_l).] 0. secs (0.u,0.s)
Chars 6807 - 6815 [trivial.] 0. secs (0.u,0.s)
Chars 6727 - 6738 [(red;~intros).] 0. secs (0.u,0.s)
Chars 6741 - 6756 [(apply~meet_glb).] 0. secs (0.u,0.s)
Chars 6761 - 6777 [(apply~meet_lb_l).] 0. secs (0.u,0.s)
Chars 6782 - 6806 [(apply~meet_le_compat_l).] 0. secs (0.u,0.s)
Chars 6807 - 6815 [trivial.] 0. secs (0.u,0.s)
Chars 6818 - 6822 [Qed.] 0. secs (0.u,0.s)
Chars 6826 - 6877 [#[global]Instance:~(forall~z,~...] 0. secs (0.u,0.s)
Chars 6880 - 6886 [Proof.] 0. secs (0.u,0.s)
Chars 20137 - 20170 [snrapply~Build_GroupHomomorphism.] 40.014 secs (0.001u,0.003s)
Chars 20175 - 20176 [{] 0. secs (0.u,0.s)
Chars 20177 - 20185 [intro~x.] 0. secs (0.u,0.s)
Chars 20192 - 20217 [exact~(amal_eta~[inl~x]).] 0. secs (0.u,0.s)
Chars 20218 - 20219 [}] 0. secs (0.u,0.s)
Chars 20224 - 20235 [(intros~x~y).] 0. secs (0.u,0.s)
Chars 20240 - 20285 [(rewrite~<-~(word_concat_w_nil...] 0.006 secs (0.006u,0.s)
Chars 20290 - 20325 [(rewrite~<-~(amal_mu_H~nil~nil...] 0.001 secs (0.001u,0.s)
Chars 20330 - 20356 [(rewrite~word_concat_w_nil).] 0.001 secs (0.001u,0.s)
Chars 20361 - 20373 [reflexivity.] 0.006 secs (0.006u,0.s)
Chars 20137 - 20170 [snrapply~Build_GroupHomomorphism.] 0. secs (0.u,0.s)
Chars 20177 - 20185 [intro~x.] 0. secs (0.u,0.s)
Chars 20192 - 20217 [exact~(amal_eta~[inl~x]).] 0. secs (0.u,0.s)
Chars 20224 - 20235 [(intros~x~y).] 0. secs (0.u,0.s)
Chars 20240 - 20285 [(rewrite~<-~(word_concat_w_nil...] 0. secs (0.u,0.s)
Chars 20290 - 20325 [(rewrite~<-~(amal_mu_H~nil~nil...] 0. secs (0.u,0.s)
Chars 20330 - 20356 [(rewrite~word_concat_w_nil).] 0. secs (0.u,0.s)
Chars 20361 - 20373 [reflexivity.] 0. secs (0.u,0.s)
Chars 20376 - 20384 [Defined.] 0.006 secs (0.006u,0.s)
Chars 20388 - 20453 [Definition~amal_inr~:~GroupHom...] 0. secs (0.u,0.s)
Chars 20456 - 20462 [Proof.] 0. secs (0.u,0.s)
     = ("decr",
       (["p"], [], bedrock_func_body:(
         $"ttl" = load($"p" + $8 * $1);
         $"ttl" = $"ttl" + $18446744073709551615;
         store($"p" + $8 * $1, $"ttl"))))
     : bedrock_func
     = ("mask_bytes",
       (["bs"; "len"; "mask"], [], bedrock_func_body:(
         $"_gs_from0" = $0;
         $"_gs_to0" = $"len";
         while $"_gs_from0" < $"_gs_to0" {
           {$"_gs_tmp0" = load1($"bs" + $1 * $"_gs_from0");
            $"_gs_tmp0" = $"mask" & $"_gs_tmp0";
            store1($"bs" + $1 * $"_gs_from0", $"_gs_tmp0");
            $(cmd.unset "_gs_tmp0")};
           $"_gs_from0" = $"_gs_from0" + $1
         })))
     : bedrock_func
     = ("xor_bytes",
       (["bs"; "len"], ["r"], bedrock_func_body:(
         $"r" = $0;
         $"_gs_from0" = $0;
         $"_gs_to0" = $"len";
         while $"_gs_from0" < $"_gs_to0" {
           {$"_gs_tmp0" = load1($"bs" + $1 * $"_gs_from0");
            $"r" = $"r" ^ $"_gs_tmp0";
            $(cmd.unset "_gs_tmp0")};
           $"_gs_from0" = $"_gs_from0" + $1
         })))
     : bedrock_func
     = ("incr_words",
       (["ws"; "len"], [], bedrock_func_body:(
         $"_gs_from0" = $0;
         $"_gs_to0" = $"len";
         while $"_gs_from0" < $"_gs_to0" {
           {$"_gs_tmp0" = load($"ws" + $8 * $"_gs_from0");
            $"_gs_tmp0" = $1 + $"_gs_tmp0";
            store($"ws" + $8 * $"_gs_from0", $"_gs_tmp0");
            $(cmd.unset "_gs_tmp0")};
           $"_gs_from0" = $"_gs_from0" + $1
         })))
     : bedrock_func
     = ("sum_words",
       (["ws"; "len"], ["r"], bedrock_func_body:(
         $"r" = $0;
         $"_gs_from0" = $0;
         $"_gs_to0" = $"len";
         while $"_gs_from0" < $"_gs_to0" {
           {$"_gs_tmp0" = load($"ws" + $8 * $"_gs_from0");
            $"r" = $"r" + $"_gs_tmp0";
            $(cmd.unset "_gs_tmp0")};
           $"_gs_from0" = $"_gs_from0" + $1
         })))
     : bedrock_func
     = ("count_ws",
       (["data"; "len"; "needle"], ["r"], bedrock_func_body:(
         $"r" = $0;
         $"_gs_from0" = $0;
         $"_gs_to0" = $(expr.op bopname.divu "len" 8);
         while $"_gs_from0" < $"_gs_to0" {
           {$"_gs_tmp0" = load($"data" + $8 * $"_gs_from0");
            $"hit" = $"_gs_tmp0" == $"needle";
            $"r" = $"r" + $"hit";
            /*skip*/;
            $(cmd.unset "_gs_tmp0");
            $(cmd.unset "hit")};
           $"_gs_from0" = $"_gs_from0" + $1
         })))
     : bedrock_func
Chars 18583 - 18594 [(intros~A~B).] 40.152 secs (0.u,0.021s)
Chars 18597 - 18626 [(apply~ishprop_sigma_disjoint).] 0.009 secs (0.007u,0.001s)
Chars 18629 - 18646 [(intros~b~b'~->~p).] 0. secs (0.u,0.s)
Chars 18647 - 18681 [(apply~(injective~initial_segm...] 0.002 secs (0.002u,0.s)
Chars 18682 - 18690 [exact~p.] 0. secs (0.u,0.s)
Chars 18583 - 18594 [(intros~A~B).] 0. secs (0.u,0.s)
Chars 18597 - 18626 [(apply~ishprop_sigma_disjoint).] 0. secs (0.u,0.s)
Chars 18629 - 18646 [(intros~b~b'~->~p).] 0. secs (0.u,0.s)
Chars 18647 - 18681 [(apply~(injective~initial_segm...] 0. secs (0.u,0.s)
Chars 18682 - 18690 [exact~p.] 0. secs (0.u,0.s)
Chars 18691 - 18695 [Qed.] 0.001 secs (0.001u,0.s)
Chars 18698 - 18796 [Definition~bound~`{PropResizin...] 0.001 secs (0.001u,0.s)
Chars 18886 - 18948 [Notation~"A~◁~B"~:=~(@bound~A~...] 0. secs (0.u,0.s)
Chars 18951 - 19073 [Definition~bound_property~`{Pr...] 0.002 secs (0.001u,0.001s)
Chars 19076 - 19202 [Lemma~isembedding_initial_segm...] 0.002 secs (0.001u,0.s)
Chars 19203 - 19209 [Proof.] 0. secs (0.u,0.s)
Chars 6878 - 6889 [(intros~x~y).] 40.091 secs (0.001u,0.019s)
Chars 6892 - 6982 [(destruct~(decide_rel~(<=)~x~y...] 0.005 secs (0.002u,0.003s)
Chars 6985 - 6986 [-] 0. secs (0.u,0.s)
Chars 6987 - 6992 [left.] 0. secs (0.u,0.s)
Chars 6993 - 7030 [(apply~(antisymmetry~(<=));~as...] 0.005 secs (0.004u,0.s)
Chars 7033 - 7034 [-] 0. secs (0.u,0.s)
Chars 7035 - 7041 [right.] 0. secs (0.u,0.s)
Chars 7042 - 7061 [(intros~E3;~apply~E2).] 0. secs (0.u,0.s)
Chars 7066 - 7076 [(pattern~y).] 0. secs (0.u,0.s)
Chars 7077 - 7100 [(apply~(transport~_~E3)).] 0. secs (0.u,0.s)
Chars 7105 - 7123 [(apply~reflexivity).] 0.005 secs (0.004u,0.s)
Chars 7126 - 7127 [-] 0. secs (0.u,0.s)
Chars 7128 - 7134 [right.] 0. secs (0.u,0.s)
Chars 7135 - 7154 [(intros~E3;~apply~E1).] 0. secs (0.u,0.s)
Chars 7159 - 7193 [(pattern~y;~apply~(transport~_...] 0.001 secs (0.001u,0.s)
Chars 7198 - 7216 [(apply~reflexivity).] 0.005 secs (0.004u,0.s)
Chars 6878 - 6889 [(intros~x~y).] 0. secs (0.u,0.s)
Chars 6892 - 6982 [(destruct~(decide_rel~(<=)~x~y...] 0. secs (0.u,0.s)
Chars 6987 - 6992 [left.] 0. secs (0.u,0.s)
Chars 6993 - 7030 [(apply~(antisymmetry~(<=));~as...] 0. secs (0.u,0.s)
Chars 7035 - 7041 [right.] 0. secs (0.u,0.s)
Chars 7042 - 7061 [(intros~E3;~apply~E2).] 0. secs (0.u,0.s)
Chars 7066 - 7076 [(pattern~y).] 0. secs (0.u,0.s)
Chars 7077 - 7100 [(apply~(transport~_~E3)).] 0. secs (0.u,0.s)
Chars 7105 - 7123 [(apply~reflexivity).] 0. secs (0.u,0.s)
Chars 7128 - 7134 [right.] 0. secs (0.u,0.s)
Chars 7135 - 7154 [(intros~E3;~apply~E1).] 0. secs (0.u,0.s)
Chars 7159 - 7193 [(pattern~y;~apply~(transport~_...] 0. secs (0.u,0.s)
Chars 7198 - 7216 [(apply~reflexivity).] 0. secs (0.u,0.s)
Chars 7219 - 7227 [Defined.] 0.001 secs (0.001u,0.s)
Chars 7231 - 7344 [Definition~lt_dec_slow~`{!Triv...] 0.001 secs (0.001u,0.s)
Chars 7347 - 7353 [Proof.] 0. secs (0.u,0.s)
Chars 6889 - 6896 [(intros).] 30.147 secs (0.u,0.003s)
Chars 6897 - 6930 [(apply~maps.order_preserving_f...] 0.001 secs (0.001u,0.s)
Chars 6889 - 6896 [(intros).] 0. secs (0.u,0.s)
Chars 6897 - 6930 [(apply~maps.order_preserving_f...] 0. secs (0.u,0.s)
Chars 6933 - 6937 [Qed.] 0. secs (0.u,0.s)
Chars 6941 - 7050 [Lemma~meet_le_compat~x₁~x₂~y₁~...] 0.001 secs (0.001u,0.s)
Chars 7053 - 7059 [Proof.] 0. secs (0.u,0.s)
Chars 17166 - 17208 [(intros~[x~y];~apply~seq_colim...] 40.1 secs (0.003u,0.021s)
Chars 17166 - 17208 [(intros~[x~y];~apply~seq_colim...] 0.002 secs (0.002u,0.s)
Chars 17211 - 17219 [Defined.] 0. secs (0.u,0.s)
Chars 17223 - 17478 [#[local]~Definition~Xi~{X}~{Y}...] 0.01 secs (0.007u,0.002s)
Chars 17481 - 17487 [Proof.] 0. secs (0.u,0.s)
Chars 20467 - 20500 [snrapply~Build_GroupHomomorphism.] 40.013 secs (0.001u,0.004s)
Chars 20505 - 20506 [{] 0. secs (0.u,0.s)
Chars 20507 - 20515 [intro~x.] 0. secs (0.u,0.s)
Chars 20522 - 20547 [exact~(amal_eta~[inr~x]).] 0. secs (0.u,0.s)
Chars 20548 - 20549 [}] 0. secs (0.u,0.s)
Chars 20554 - 20565 [(intros~x~y).] 0. secs (0.u,0.s)
Chars 20570 - 20615 [(rewrite~<-~(word_concat_w_nil...] 0.002 secs (0.002u,0.s)
Chars 20620 - 20655 [(rewrite~<-~(amal_mu_K~nil~nil...] 0.001 secs (0.001u,0.s)
Chars 20660 - 20686 [(rewrite~word_concat_w_nil).] 0.001 secs (0.001u,0.s)
Chars 20691 - 20703 [reflexivity.] 0.006 secs (0.006u,0.s)
Chars 20467 - 20500 [snrapply~Build_GroupHomomorphism.] 0. secs (0.u,0.s)
Chars 20507 - 20515 [intro~x.] 0. secs (0.u,0.s)
Chars 20522 - 20547 [exact~(amal_eta~[inr~x]).] 0. secs (0.u,0.s)
Chars 20554 - 20565 [(intros~x~y).] 0. secs (0.u,0.s)
Chars 20570 - 20615 [(rewrite~<-~(word_concat_w_nil...] 0. secs (0.u,0.s)
Chars 20620 - 20655 [(rewrite~<-~(amal_mu_K~nil~nil...] 0. secs (0.u,0.s)
Chars 20660 - 20686 [(rewrite~word_concat_w_nil).] 0. secs (0.u,0.s)
Chars 20691 - 20703 [reflexivity.] 0. secs (0.u,0.s)
Chars 20706 - 20714 [Defined.] 0.007 secs (0.007u,0.s)
Chars 20718 - 20916 [Theorem~equiv_amalgamatedfreep...] 0.001 secs (0.001u,0.s)
Chars 20919 - 20925 [Proof.] 0. secs (0.u,0.s)
Chars 7356 - 7367 [(intros~x~y).] 32.478 secs (25.963u,-0.344s)
Chars 19212 - 19218 [split.] 40.088 secs (0.001u,0.019s)
Chars 19221 - 19222 [-] 0. secs (0.u,0.s)
Chars 19223 - 19234 [(intros~a_b).] 0. secs (0.u,0.s)
Chars 19235 - 19254 [exists~(in_~a~a_b).] 0.001 secs (0.001u,0.s)
Chars 19259 - 19315 [exact~(path_initial_segment_si...] 0.003 secs (0.003u,0.s)
Chars 19318 - 19319 [-] 0. secs (0.u,0.s)
Chars 19320 - 19331 [(intros~a_b).] 0. secs (0.u,0.s)
Chars 19336 - 19382 [(assert~(a~=~out~(bound~a_b))~...] 0.002 secs (0.001u,0.s)
Chars 19383 - 19384 [{] 0. secs (0.u,0.s)
Chars 19391 - 19425 [(apply~(injective~initial_segm...] 0.003 secs (0.003u,0.s)
Chars 19432 - 19478 [(rewrite~(path_initial_segment...] 0.005 secs (0.004u,0.s)
Chars 19485 - 19506 [(apply~bound_property).] 0.001 secs (0.001u,0.s)
Chars 19511 - 19512 [}] 0. secs (0.u,0.s)
Chars 19517 - 19548 [(apply~initial_segment_property).] 0.001 secs (0.001u,0.s)
Chars 19212 - 19218 [split.] 0. secs (0.u,0.s)
Chars 19223 - 19234 [(intros~a_b).] 0. secs (0.u,0.s)
Chars 19235 - 19254 [exists~(in_~a~a_b).] 0. secs (0.u,0.s)
Chars 19259 - 19315 [exact~(path_initial_segment_si...] 0. secs (0.u,0.s)
Chars 19320 - 19331 [(intros~a_b).] 0. secs (0.u,0.s)
Chars 19336 - 19382 [(assert~(a~=~out~(bound~a_b))~...] 0. secs (0.u,0.s)
Chars 19391 - 19425 [(apply~(injective~initial_segm...] 0. secs (0.u,0.s)
Chars 19432 - 19478 [(rewrite~(path_initial_segment...] 0. secs (0.u,0.s)
Chars 19485 - 19506 [(apply~bound_property).] 0. secs (0.u,0.s)
Chars 19517 - 19548 [(apply~initial_segment_property).] 0. secs (0.u,0.s)
Chars 19549 - 19553 [Qed.] 0.004 secs (0.003u,0.s)
Chars 19556 - 19656 [#[global]~Instance~Ordinal_is_...] 0. secs (0.u,0.s)
Chars 19657 - 19663 [Proof.] 0. secs (0.u,0.s)
Chars 7356 - 7367 [(intros~x~y).] 40.026 secs (0.u,0.018s)
Chars 7370 - 7424 [(destruct~(dec~(x~≤~y));~[~des...] 0.027 secs (0.024u,0.002s)
Chars 7427 - 7428 [-] 0. secs (0.u,0.s)
Chars 7429 - 7435 [right.] 0. secs (0.u,0.s)
Chars 7436 - 7452 [(apply~eq_not_lt).] 0.001 secs (0.001u,0.s)
Chars 7453 - 7464 [assumption.] 0. secs (0.u,0.s)
Chars 7467 - 7468 [-] 0. secs (0.u,0.s)
Chars 7469 - 7474 [left.] 0. secs (0.u,0.s)
Chars 7475 - 7494 [(apply~lt_iff_le_ne).] 0.001 secs (0.001u,0.s)
Chars 7495 - 7500 [auto.] 0. secs (0.u,0.s)
Chars 7503 - 7504 [-] 0. secs (0.u,0.s)
Chars 7505 - 7511 [right.] 0. secs (0.u,0.s)
Chars 7512 - 7532 [(apply~not_le_not_lt).] 0. secs (0.u,0.s)
Chars 7533 - 7544 [assumption.] 0. secs (0.u,0.s)
Chars 7356 - 7367 [(intros~x~y).] 0. secs (0.u,0.s)
Chars 7370 - 7424 [(destruct~(dec~(x~≤~y));~[~des...] 0. secs (0.u,0.s)
Chars 7429 - 7435 [right.] 0. secs (0.u,0.s)
Chars 7436 - 7452 [(apply~eq_not_lt).] 0. secs (0.u,0.s)
Chars 7453 - 7464 [assumption.] 0. secs (0.u,0.s)
Chars 7469 - 7474 [left.] 0. secs (0.u,0.s)
Chars 7475 - 7494 [(apply~lt_iff_le_ne).] 0. secs (0.u,0.s)
Chars 7495 - 7500 [auto.] 0. secs (0.u,0.s)
Chars 7505 - 7511 [right.] 0. secs (0.u,0.s)
Chars 7512 - 7532 [(apply~not_le_not_lt).] 0. secs (0.u,0.s)
Chars 7533 - 7544 [assumption.] 0. secs (0.u,0.s)
Chars 7547 - 7555 [Defined.] 0. secs (0.u,0.s)
Chars 7556 - 7579 [End~full_partial_order.] 0.029 secs (0.025u,0.003s)
Chars 7604 - 7704 [#[export]~Hint~Extern~5~(PropH...] 0. secs (0.u,0.s)
Chars 7705 - 7793 [#[export]~Hint~Extern~10~(Prop...] 0. secs (0.u,0.s)
Chars 7794 - 7886 [#[export]~Hint~Extern~20~(Deci...] 0. secs (0.u,0.s)
Chars 7888 - 7914 [Section~full_pseudo_order.] 0. secs (0.u,0.s)
Chars 7917 - 7946 [Context~`{FullPseudoOrder~A}.] 0. secs (0.u,0.s)
Chars 7950 - 7993 [#[local]Existing~Instance~pseu...] 0. secs (0.u,0.s)
Chars 7997 - 8044 [Lemma~not_lt_le_flip~x~y~:~~~(...] 0. secs (0.u,0.s)
Chars 8047 - 8053 [Proof.] 0. secs (0.u,0.s)
Chars 7062 - 7075 [(intros~E1~E2).] 40.012 secs (0.u,0.003s)
Chars 7076 - 7105 [transitivity~(x₁~⊓~y₂).] 0.009 secs (0.009u,0.s)
Chars 7108 - 7109 [-] 0. secs (0.u,0.s)
Chars 7110 - 7146 [(apply~(order_preserving~(x₁⊓))).] 0. secs (0.u,0.s)
Chars 7147 - 7155 [trivial.] 0. secs (0.u,0.s)
Chars 7158 - 7159 [-] 0. secs (0.u,0.s)
Chars 7160 - 7196 [(apply~(order_preserving~(⊓y₂))).] 0.001 secs (0.001u,0.s)
Chars 7197 - 7205 [trivial.] 0. secs (0.u,0.s)
Chars 7062 - 7075 [(intros~E1~E2).] 0. secs (0.u,0.s)
Chars 7076 - 7105 [transitivity~(x₁~⊓~y₂).] 0. secs (0.u,0.s)
Chars 7110 - 7146 [(apply~(order_preserving~(x₁⊓))).] 0. secs (0.u,0.s)
Chars 7147 - 7155 [trivial.] 0. secs (0.u,0.s)
Chars 7160 - 7196 [(apply~(order_preserving~(⊓y₂))).] 0. secs (0.u,0.s)
Chars 7197 - 7205 [trivial.] 0. secs (0.u,0.s)
Chars 7208 - 7212 [Qed.] 0. secs (0.u,0.s)
Chars 7216 - 7274 [Lemma~meet_le~x~y~z~:~z~≤~x~->...] 0. secs (0.u,0.s)
Chars 7277 - 7283 [Proof.] 0. secs (0.u,0.s)
Chars 7288 - 7303 [(apply~meet_glb).] 0.534 secs (0.001u,0.002s)
Chars 7288 - 7303 [(apply~meet_glb).] 0. secs (0.u,0.s)
Chars 7306 - 7310 [Qed.] 0. secs (0.u,0.s)
Chars 7314 - 7333 [Section~total_meet.] 0. secs (0.u,0.s)
Chars 7336 - 7365 [Context~`{!TotalRelation~le}.] 0. secs (0.u,0.s)
Chars 7369 - 7429 [Lemma~total_meet_either~x~y~:~...] 0. secs (0.u,0.s)
Chars 7432 - 7438 [Proof.] 0. secs (0.u,0.s)
Chars 17492 - 17551 [(revert~theta;~srapply~(equiv_...] 40.127 secs (0.015u,0.022s)
Chars 17552 - 17572 [(intro~s;~destruct~s).] 0.01 secs (0.009u,0.s)
Chars 17577 - 17654 [(revert~q1;~srapply~(equiv_ind...] 0.026 secs (0.021u,0.004s)
Chars 17659 - 17683 [(destruct~p;~reflexivity).] 0.014 secs (0.013u,0.s)
Chars 17492 - 17551 [(revert~theta;~srapply~(equiv_...] 0.005 secs (0.004u,0.001s)
Chars 17552 - 17572 [(intro~s;~destruct~s).] 0.005 secs (0.005u,0.s)
Chars 17577 - 17654 [(revert~q1;~srapply~(equiv_ind...] 0.01 secs (0.007u,0.002s)
Chars 17659 - 17683 [(destruct~p;~reflexivity).] 0.006 secs (0.004u,0.001s)
Chars 17686 - 17694 [Defined.] 0.023 secs (0.017u,0.006s)
Chars 17698 - 17897 [#[local]~Definition~Mu~{X}~{Y}...] 0.008 secs (0.007u,0.s)
Chars 17900 - 17906 [Proof.] 0. secs (0.u,0.s)
Chars 17911 - 17965 [(destruct~p;~destruct~psi;~des...] 0.963 secs (0.023u,0.022s)
Chars 17911 - 17965 [(destruct~p;~destruct~psi;~des...] 0.01 secs (0.01u,0.s)
Chars 17968 - 17976 [Defined.] 0.011 secs (0.007u,0.003s)
Chars 18046 - 18204 [Definition~seq_colim_sum_ind_b...] 0.007 secs (0.007u,0.s)
Chars 18207 - 18213 [Proof.] 0. secs (0.u,0.s)
Chars 20930 - 20956 [snrapply~equiv_adjointify.] 40.014 secs (0.001u,0.004s)
Chars 20961 - 21025 [1:~(intros~[h~[k~p]];~exact~(A...] 0.001 secs (0.001u,0.s)
Chars 21030 - 21031 [{] 0. secs (0.u,0.s)
Chars 21032 - 21041 [(intros~r).] 0. secs (0.u,0.s)
Chars 21048 - 21085 [exists~(grp_homo_compose~r~ama...] 0. secs (0.u,0.s)
Chars 21092 - 21129 [exists~(grp_homo_compose~r~ama...] 0. secs (0.u,0.s)
Chars 21136 - 21144 [intro~x.] 0. secs (0.u,0.s)
Chars 21151 - 21164 [(apply~(ap~r)).] 0.002 secs (0.002u,0.s)
Chars 21171 - 21177 [(simpl).] 0. secs (0.u,0.s)
Chars 21184 - 21227 [(rewrite~<-~(word_concat_w_nil...] 0.001 secs (0.001u,0.s)
Chars 21234 - 21277 [(rewrite~<-~(word_concat_w_nil...] 0.001 secs (0.001u,0.s)
Chars 21284 - 21311 [(apply~(amal_tau~nil~nil~x)).] 0. secs (0.u,0.s)
Chars 21312 - 21313 [}] 0. secs (0.u,0.s)
Chars 21318 - 21319 [{] 0. secs (0.u,0.s)
Chars 21320 - 21329 [(intros~r).] 0.002 secs (0.002u,0.s)
Chars 21336 - 21371 [(apply~equiv_path_grouphomomor...] 0.001 secs (0.001u,0.s)
Chars 21378 - 21406 [srapply~amal_type_ind_hprop.] 0.042 secs (0.042u,0.s)
Chars 21413 - 21421 [intro~x.] 0. secs (0.u,0.s)
Chars 21428 - 21450 [(induction~x~as~[|~a~x]).] 0.003 secs (0.003u,0.s)
Chars 21457 - 21494 [1:~(symmetry;~apply~(grp_homo_...] 0.006 secs (0.006u,0.s)
Chars 21501 - 21512 [(simpl~in~*).] 0.01 secs (0.01u,0.s)
Chars 21519 - 21531 [(rewrite~IHx).] 0.002 secs (0.002u,0.s)
Chars 19666 - 19678 [constructor.] 33.27 secs (0.u,0.019s)
Chars 19681 - 19682 [-] 0. secs (0.u,0.s)
Chars 19683 - 19691 [exact~_.] 0. secs (0.u,0.s)
Chars 19694 - 19695 [-] 0. secs (0.u,0.s)
Chars 19696 - 19733 [exact~is_mere_relation_lt_on_O...] 0. secs (0.u,0.s)
Chars 19736 - 19737 [-] 0. secs (0.u,0.s)
Chars 19738 - 19752 [(intros~A~B~H1).] 0. secs (0.u,0.s)
Chars 19757 - 19778 [srapply~path_Ordinal.] 0.001 secs (0.001u,0.s)
Chars 19783 - 19784 [+] 0. secs (0.u,0.s)
Chars 19785 - 19810 [srapply~equiv_adjointify.] 0.001 secs (0.001u,0.s)
Chars 19817 - 19818 [*] 0. secs (0.u,0.s)
Chars 19819 - 19858 [(assert~(lt_B~:~forall~a~:~A,~...] 0.002 secs (0.002u,0.s)
Chars 19859 - 19860 [{] 0. secs (0.u,0.s)
Chars 19871 - 19880 [(intros~a).] 0. secs (0.u,0.s)
Chars 19881 - 19890 [(apply~H1).] 0.001 secs (0.001u,0.s)
Chars 19891 - 19900 [exists~a.] 0. secs (0.u,0.s)
Chars 19901 - 19913 [reflexivity.] 0. secs (0.u,0.s)
Chars 19922 - 19923 [}] 0. secs (0.u,0.s)
Chars 19932 - 19964 [exact~(fun~a~=>~bound~(lt_B~a)).] 0.001 secs (0.001u,0.s)
Chars 19971 - 19972 [*] 0. secs (0.u,0.s)
Chars 19973 - 20012 [(assert~(lt_A~:~forall~b~:~B,~...] 0.002 secs (0.002u,0.s)
Chars 20013 - 20014 [{] 0. secs (0.u,0.s)
Chars 20025 - 20034 [(intros~b).] 0. secs (0.u,0.s)
Chars 20035 - 20044 [(apply~H1).] 0.002 secs (0.002u,0.s)
Chars 20045 - 20054 [exists~b.] 0. secs (0.u,0.s)
Chars 20055 - 20067 [reflexivity.] 0. secs (0.u,0.s)
Chars 20076 - 20077 [}] 0. secs (0.u,0.s)
Chars 20086 - 20118 [exact~(fun~b~=>~bound~(lt_A~b)).] 0.001 secs (0.001u,0.s)
Chars 20125 - 20126 [*] 0. secs (0.u,0.s)
Chars 20127 - 20131 [(cbn).] 0.007 secs (0.006u,0.s)
Chars 20132 - 20141 [(intros~b).] 0.001 secs (0.u,0.001s)
Chars 20142 - 20176 [(apply~(injective~initial_segm...] 0.004 secs (0.003u,0.s)
Chars 21538 - 21617 [(destruct~a;~symmetry;~rapply~...] 0.085 secs (0.085u,0.s)
Chars 21618 - 21619 [}] 0. secs (0.u,0.s)
Chars 21624 - 21634 [intro~hkp.] 0.002 secs (0.002u,0.s)
Chars 20185 - 20218 [(repeat~rewrite~<-~bound_prope...] 0.035 secs (0.028u,0.006s)
Chars 20219 - 20231 [reflexivity.] 0. secs (0.u,0.s)
Chars 20238 - 20239 [*] 0. secs (0.u,0.s)
Chars 21639 - 21645 [(simpl).] 0.011 secs (0.011u,0.s)
Chars 21650 - 21800 [rapply~~((equiv_ap'~~~~~~(equi...] 0.006 secs (0.006u,0.s)
Chars 20240 - 20244 [(cbn).] 0.025 secs (0.018u,0.007s)
Chars 20245 - 20254 [(intros~a).] 0.001 secs (0.001u,0.s)
Chars 20255 - 20289 [(apply~(injective~initial_segm...] 0.004 secs (0.002u,0.001s)
Chars 20298 - 20331 [(repeat~rewrite~<-~bound_prope...] 0.035 secs (0.026u,0.008s)
Chars 20332 - 20344 [reflexivity.] 0. secs (0.u,0.s)
Chars 20349 - 20350 [+] 0. secs (0.u,0.s)
Chars 20351 - 20355 [(cbn).] 0.019 secs (0.017u,0.001s)
Chars 20356 - 20368 [(intros~a~a').] 0. secs (0.u,0.s)
Chars 20369 - 20375 [split.] 0.001 secs (0.001u,0.s)
Chars 20382 - 20383 [*] 0. secs (0.u,0.s)
Chars 20384 - 20396 [(intros~a_a').] 0. secs (0.u,0.s)
Chars 21805 - 21829 [rapply~path_sigma_hprop.] 0.084 secs (0.082u,0.001s)
Chars 20405 - 20439 [(apply~isembedding_initial_seg...] 0.006 secs (0.002u,0.003s)
Chars 21834 - 21860 [(destruct~hkp~as~[h~[k~p]]).] 0.01 secs (0.01u,0.s)
Chars 20448 - 20481 [(repeat~rewrite~<-~bound_prope...] 0.013 secs (0.011u,0.001s)
Chars 20490 - 20524 [(apply~isembedding_initial_seg...] 0.002 secs (0.001u,0.001s)
Chars 20533 - 20544 [assumption.] 0. secs (0.u,0.s)
Chars 20551 - 20552 [*] 0. secs (0.u,0.s)
Chars 20553 - 20565 [(intros~a_a').] 0. secs (0.u,0.s)
Chars 20574 - 20616 [(apply~isembedding_initial_seg...] 0.002 secs (0.001u,0.s)
Chars 21865 - 21967 [(apply~path_prod;~cbn;~apply~e...] 0.024 secs (0.024u,0.s)
Chars 20930 - 20956 [snrapply~equiv_adjointify.] 0. secs (0.u,0.s)
Chars 20961 - 21025 [1:~(intros~[h~[k~p]];~exact~(A...] 0. secs (0.u,0.s)
Chars 21032 - 21041 [(intros~r).] 0. secs (0.u,0.s)
Chars 21048 - 21085 [exists~(grp_homo_compose~r~ama...] 0. secs (0.u,0.s)
Chars 21092 - 21129 [exists~(grp_homo_compose~r~ama...] 0. secs (0.u,0.s)
Chars 21136 - 21144 [intro~x.] 0. secs (0.u,0.s)
Chars 21151 - 21164 [(apply~(ap~r)).] 0. secs (0.u,0.s)
Chars 21171 - 21177 [(simpl).] 0. secs (0.u,0.s)
Chars 20625 - 20666 [(repeat~rewrite~<-~bound_prope...] 0.013 secs (0.011u,0.001s)
Chars 21184 - 21227 [(rewrite~<-~(word_concat_w_nil...] 0. secs (0.u,0.s)
Chars 21234 - 21277 [(rewrite~<-~(word_concat_w_nil...] 0. secs (0.u,0.s)
Chars 21284 - 21311 [(apply~(amal_tau~nil~nil~x)).] 0. secs (0.u,0.s)
Chars 21320 - 21329 [(intros~r).] 0.001 secs (0.001u,0.s)
Chars 21336 - 21371 [(apply~equiv_path_grouphomomor...] 0. secs (0.u,0.s)
Chars 21378 - 21406 [srapply~amal_type_ind_hprop.] 0. secs (0.u,0.s)
Chars 20675 - 20717 [(apply~isembedding_initial_seg...] 0.004 secs (0.004u,0.s)
Chars 21413 - 21421 [intro~x.] 0. secs (0.u,0.s)
Chars 20726 - 20737 [assumption.] 0. secs (0.u,0.s)
Chars 20740 - 20741 [-] 0. secs (0.u,0.s)
Chars 21428 - 21450 [(induction~x~as~[|~a~x]).] 0. secs (0.u,0.s)
Chars 20742 - 20751 [(intros~A).] 0. secs (0.u,0.s)
Chars 20756 - 20768 [constructor.] 0. secs (0.u,0.s)
Chars 21457 - 21494 [1:~(symmetry;~apply~(grp_homo_...] 0.001 secs (0.001u,0.s)
Chars 20769 - 20785 [(intros~?~[a~->]).] 0.001 secs (0.u,0.001s)
Chars 21501 - 21512 [(simpl~in~*).] 0.001 secs (0.001u,0.s)
Chars 21519 - 21531 [(rewrite~IHx).] 0. secs (0.u,0.s)
Chars 20790 - 20833 [(induction~(well_foundedness~a...] 0.002 secs (0.002u,0.s)
Chars 20838 - 20850 [constructor.] 0. secs (0.u,0.s)
Chars 21538 - 21617 [(destruct~a;~symmetry;~rapply~...] 0.002 secs (0.002u,0.s)
Chars 21624 - 21634 [intro~hkp.] 0.002 secs (0.002u,0.s)
Chars 20851 - 20867 [(intros~?~[x~->]).] 0.002 secs (0.002u,0.s)
Chars 21639 - 21645 [(simpl).] 0.001 secs (0.001u,0.s)
Chars 21650 - 21800 [rapply~~((equiv_ap'~~~~~~(equi...] 0. secs (0.u,0.s)
Chars 21805 - 21829 [rapply~path_sigma_hprop.] 0.001 secs (0.001u,0.s)
Chars 21834 - 21860 [(destruct~hkp~as~[h~[k~p]]).] 0. secs (0.u,0.s)
Chars 20872 - 20921 [(rewrite~<-~(path_initial_segm...] 0.005 secs (0.003u,0.001s)
Chars 20926 - 20935 [(apply~IH).] 0. secs (0.u,0.s)
Chars 20936 - 20967 [(apply~initial_segment_property).] 0.001 secs (0.001u,0.s)
Chars 20970 - 20971 [-] 0. secs (0.u,0.s)
Chars 21865 - 21967 [(apply~path_prod;~cbn;~apply~e...] 0.005 secs (0.005u,0.s)
Chars 20972 - 20999 [(intros~?~?~A~[x~->]~[a~->]).] 0.003 secs (0.002u,0.s)
Chars 21000 - 21015 [exists~(out~x).] 0.001 secs (0.001u,0.s)
Chars 21020 - 21066 [(rewrite~(path_initial_segment...] 0.02 secs (0.016u,0.003s)
Chars 21071 - 21083 [reflexivity.] 0. secs (0.u,0.s)
Chars 19666 - 19678 [constructor.] 0. secs (0.u,0.s)
Chars 19683 - 19691 [exact~_.] 0. secs (0.u,0.s)
Chars 19696 - 19733 [exact~is_mere_relation_lt_on_O...] 0. secs (0.u,0.s)
Chars 19738 - 19752 [(intros~A~B~H1).] 0. secs (0.u,0.s)
Chars 19757 - 19778 [srapply~path_Ordinal.] 0. secs (0.u,0.s)
Chars 19785 - 19810 [srapply~equiv_adjointify.] 0. secs (0.u,0.s)
Chars 19819 - 19858 [(assert~(lt_B~:~forall~a~:~A,~...] 0. secs (0.u,0.s)
Chars 19871 - 19880 [(intros~a).] 0. secs (0.u,0.s)
Chars 19881 - 19890 [(apply~H1).] 0. secs (0.u,0.s)
Chars 19891 - 19900 [exists~a.] 0. secs (0.u,0.s)
Chars 19901 - 19913 [reflexivity.] 0. secs (0.u,0.s)
Chars 19932 - 19964 [exact~(fun~a~=>~bound~(lt_B~a)).] 0. secs (0.u,0.s)
Chars 19973 - 20012 [(assert~(lt_A~:~forall~b~:~B,~...] 0. secs (0.u,0.s)
Chars 20025 - 20034 [(intros~b).] 0. secs (0.u,0.s)
Chars 20035 - 20044 [(apply~H1).] 0. secs (0.u,0.s)
Chars 20045 - 20054 [exists~b.] 0. secs (0.u,0.s)
Chars 20055 - 20067 [reflexivity.] 0. secs (0.u,0.s)
Chars 20086 - 20118 [exact~(fun~b~=>~bound~(lt_A~b)).] 0. secs (0.u,0.s)
Chars 20127 - 20131 [(cbn).] 0. secs (0.u,0.s)
Chars 20132 - 20141 [(intros~b).] 0. secs (0.u,0.s)
Chars 20142 - 20176 [(apply~(injective~initial_segm...] 0. secs (0.u,0.s)
Chars 20185 - 20218 [(repeat~rewrite~<-~bound_prope...] 0. secs (0.u,0.s)
Chars 20219 - 20231 [reflexivity.] 0. secs (0.u,0.s)
Chars 20240 - 20244 [(cbn).] 0. secs (0.u,0.s)
Chars 20245 - 20254 [(intros~a).] 0. secs (0.u,0.s)
Chars 20255 - 20289 [(apply~(injective~initial_segm...] 0. secs (0.u,0.s)
Chars 20298 - 20331 [(repeat~rewrite~<-~bound_prope...] 0.001 secs (0.001u,0.s)
Chars 20332 - 20344 [reflexivity.] 0. secs (0.u,0.s)
Chars 21970 - 21978 [Defined.] 0.054 secs (0.054u,0.s)
Chars 20351 - 20355 [(cbn).] 0.011 secs (0.008u,0.002s)
Chars 20356 - 20368 [(intros~a~a').] 0. secs (0.u,0.s)
Chars 20369 - 20375 [split.] 0. secs (0.u,0.s)
Chars 20384 - 20396 [(intros~a_a').] 0. secs (0.u,0.s)
Chars 20405 - 20439 [(apply~isembedding_initial_seg...] 0. secs (0.u,0.s)
Chars 20448 - 20481 [(repeat~rewrite~<-~bound_prope...] 0. secs (0.u,0.s)
Chars 20490 - 20524 [(apply~isembedding_initial_seg...] 0. secs (0.u,0.s)
Chars 20533 - 20544 [assumption.] 0. secs (0.u,0.s)
Chars 20553 - 20565 [(intros~a_a').] 0. secs (0.u,0.s)
Chars 20574 - 20616 [(apply~isembedding_initial_seg...] 0. secs (0.u,0.s)
Chars 20625 - 20666 [(repeat~rewrite~<-~bound_prope...] 0. secs (0.u,0.s)
Chars 20675 - 20717 [(apply~isembedding_initial_seg...] 0. secs (0.u,0.s)
Chars 20726 - 20737 [assumption.] 0. secs (0.u,0.s)
Chars 20742 - 20751 [(intros~A).] 0. secs (0.u,0.s)
Chars 20756 - 20768 [constructor.] 0. secs (0.u,0.s)
Chars 20769 - 20785 [(intros~?~[a~->]).] 0. secs (0.u,0.s)
Chars 20790 - 20833 [(induction~(well_foundedness~a...] 0. secs (0.u,0.s)
Chars 20838 - 20850 [constructor.] 0. secs (0.u,0.s)
Chars 20851 - 20867 [(intros~?~[x~->]).] 0. secs (0.u,0.s)
Chars 20872 - 20921 [(rewrite~<-~(path_initial_segm...] 0. secs (0.u,0.s)
Chars 20926 - 20935 [(apply~IH).] 0. secs (0.u,0.s)
Chars 20936 - 20967 [(apply~initial_segment_property).] 0. secs (0.u,0.s)
Chars 20972 - 20999 [(intros~?~?~A~[x~->]~[a~->]).] 0. secs (0.u,0.s)
Chars 21000 - 21015 [exists~(out~x).] 0. secs (0.u,0.s)
Chars 21020 - 21066 [(rewrite~(path_initial_segment...] 0. secs (0.u,0.s)
Chars 21071 - 21083 [reflexivity.] 0. secs (0.u,0.s)
Chars 21084 - 21088 [Qed.] 0.075 secs (0.071u,0.003s)
Chars 21198 - 21314 [Lemma~isomorphism_to_initial_s...] 0.001 secs (0.001u,0.s)
Chars 21315 - 21321 [Proof.] 0. secs (0.u,0.s)
Chars 21980 - 21996 [End~FreeProduct.] 0.838 secs (0.828u,0.009s)
Chars 21998 - 22127 [Definition~FreeProduct~(G~H~:~...] 0. secs (0.u,0.s)
Chars 22129 - 22234 [Definition~freeproduct_inl~{G~...] 0. secs (0.u,0.s)
Chars 22236 - 22341 [Definition~freeproduct_inr~{G~...] 0. secs (0.u,0.s)
Chars 22343 - 22486 [Definition~FreeProduct_rec~(G~...] 0. secs (0.u,0.s)
Chars 22487 - 22493 [Proof.] 0. secs (0.u,0.s)
Chars 18218 - 18262 [(intros~n~a~b;~pose~(h~:=~F_be...] 18.396 secs (0.006u,0.019s)
Chars 18267 - 18354 [(rewrite~~~(Xi~seq_colim_sum_i...] 0.04 secs (0.033u,0.007s)
Chars 18359 - 18446 [(rewrite~~~(Mu~(glue~_~n~a)~se...] 0.176 secs (0.144u,0.031s)
Chars 18451 - 18499 [(rewrite~concat_1p~in~h;~exact...] 0.066 secs (0.066u,0.s)
Chars 18218 - 18262 [(intros~n~a~b;~pose~(h~:=~F_be...] 0.003 secs (0.003u,0.s)
Chars 18267 - 18354 [(rewrite~~~(Xi~seq_colim_sum_i...] 0.003 secs (0.003u,0.s)
Chars 18359 - 18446 [(rewrite~~~(Mu~(glue~_~n~a)~se...] 0.005 secs (0.005u,0.s)
Chars 18451 - 18499 [(rewrite~concat_1p~in~h;~exact...] 0.012 secs (0.012u,0.s)
Chars 18502 - 18510 [Defined.] 0.384 secs (0.38u,0.003s)
Chars 8056 - 8063 [(intros).] 40.097 secs (0.001u,0.018s)
Chars 8066 - 8091 [(apply~le_iff_not_lt_flip).] 0.001 secs (0.001u,0.s)
Chars 8094 - 8105 [assumption.] 0. secs (0.u,0.s)
Chars 8056 - 8063 [(intros).] 0. secs (0.u,0.s)
Chars 8066 - 8091 [(apply~le_iff_not_lt_flip).] 0. secs (0.u,0.s)
Chars 8094 - 8105 [assumption.] 0. secs (0.u,0.s)
Chars 8108 - 8112 [Qed.] 0. secs (0.u,0.s)
Chars 8116 - 8170 [Instance~fullpseudo_partial~:~...] 0. secs (0.u,0.s)
Chars 8173 - 8179 [Proof.] 0. secs (0.u,0.s)
Chars 18512 - 18533 [End~SeqColimitSumInd.] 0.33 secs (0.319u,0.01s)
Chars 18613 - 18638 [Section~SeqColimitSumRec.] 0. secs (0.u,0.s)
Chars 18642 - 18688 [Context~`{Univalence}~{A}~(B~:...] 0. secs (0.u,0.s)
Chars 18691 - 18732 [Context~E~(e~:~forall~n~a,~B~(...] 0. secs (0.u,0.s)
Chars 18735 - 18805 [Context~(t~:~forall~n~a~(b~:~B...] 0.001 secs (0.001u,0.s)
Chars 18809 - 18872 [Definition~seq_colim_sum_rec~:...] 0. secs (0.u,0.s)
Chars 18875 - 18881 [Proof.] 0. secs (0.u,0.s)
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building ident_interp...
Building base_eq_dec...
Building base_beq_and_reflect...
Building base_beq...
Building reflect_base_beq...
Building baseHasNatAndCorrect...
Building baseHasNat...
Building baseHasNatCorrect...
Building base_interp_beq...
Building reflect_base_interp_beq...
Building try_make_base_transport_cps...
Building try_make_base_transport_cps_correct...
Building all_idents...
Building all_ident_and_interp...
Building buildEagerIdentAndInterpCorrect...
Building buildEagerIdent...
Building buildInterpEagerIdentCorrect...
Building toRestrictedIdentAndCorrect...
Building toRestrictedIdent...
Building toFromRestrictedIdent...
Building buildIdentAndInterpCorrect...
Building buildIdent...
Building buildInterpIdentCorrect...
Building ident_is_var_like...
Building eqv_Reflexive_Proper...
Building ident_interp_Proper...
Building invertIdent...
Building buildInvertIdentCorrect...
Building base_default...
Building package...
Building all_base...
Building all_idents...
Building ident_index...
Building eta_ident_cps_gen...
Building eta_ident_cps_gen_expand_literal...
Building eta_ident_cps...
Building simple_idents...
Building all_raw_idents...
Building raw_ident_index...
Building raw_ident_index_idempotent...
Building eta_raw_ident_cps_gen...
Building raw_ident_to_ident...
Building raw_ident_infos_of...
Building split_raw_ident_gen...
Building invert_bind_args...
Building invert_bind_args_unknown...
Building all_pattern_idents...
Building eta_pattern_ident_cps_gen...
Building eta_pattern_ident_cps_gen_expand_literal...
Building split_types...
Building add_types_from_raw_sig...
Building to_type_split_types_subst_default_eq...
Building projT1_add_types_from_raw_sig_eq...
Building arg_types_unfolded...
Building type_of_list_arg_types_beq_unfolded...
Building to_typed_unfolded...
Building of_typed_ident_unfolded...
Building arg_types_of_typed_ident_unfolded...
Building unify...
Building unify_unknown...
Building final ident package...
Proving is_simple_correct0...
Tactic call ran for 0.384 secs (0.375u,0.008s) (success)
Proving invert_bind_args_raw_to_typed...
Tactic call ran for 0.234 secs (0.23u,0.004s) (success)
Proving fold_invert_bind_args...
Tactic call ran for 0.018 secs (0.018u,0.s) (success)
Proving split_ident_to_ident...
Tactic call ran for 0.021 secs (0.019u,0.001s) (success)
Proving eq_indep_types_of_eq_types...
Tactic call ran for 0.804 secs (0.796u,0.007s) (success)
Proving fold_eta_ident_cps...
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving fold_unify...
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving to_typed_of_typed_ident...
Chars 7441 - 7474 [(destruct~(total~le~x~y)~as~[E...] 40.015 secs (0.002u,0.003s)
Chars 7477 - 7478 [-] 0. secs (0.u,0.s)
Chars 7479 - 7484 [left.] 0. secs (0.u,0.s)
Chars 7485 - 7500 [(apply~meet_l,~E).] 0. secs (0.u,0.s)
Chars 7503 - 7504 [-] 0. secs (0.u,0.s)
Chars 7505 - 7511 [right.] 0. secs (0.u,0.s)
Chars 7512 - 7527 [(apply~meet_r,~E).] 0. secs (0.u,0.s)
Chars 7441 - 7474 [(destruct~(total~le~x~y)~as~[E...] 0. secs (0.u,0.s)
Chars 7479 - 7484 [left.] 0. secs (0.u,0.s)
Chars 7485 - 7500 [(apply~meet_l,~E).] 0. secs (0.u,0.s)
Chars 7505 - 7511 [right.] 0. secs (0.u,0.s)
Chars 7512 - 7527 [(apply~meet_r,~E).] 0. secs (0.u,0.s)
Chars 7530 - 7534 [Qed.] 0. secs (0.u,0.s)
Chars 7538 - 7630 [Definition~min~x~y~:=~match~to...] 0.001 secs (0.001u,0.s)
Chars 7634 - 7680 [Lemma~total_meet_min~x~y~:~mee...] 0. secs (0.u,0.s)
Chars 7683 - 7689 [Proof.] 0. secs (0.u,0.s)
Tactic call ran for 1.501 secs (1.484u,0.016s) (success)
Proving eq_invert_bind_args_unknown...
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving eq_unify_unknown...
Tactic call ran for 0. secs (0.u,0.s) (success)
Reifying...
Compiling decision tree...
Splitting rewrite rules...
Assembling rewrite_head...
Reducing rewrite_head...
Tactic call ran for 0.077 secs (0.076u,0.s) (success)
Tactic call ran for 0.049 secs (0.047u,0.001s) (success)
Tactic call ran for 0.062 secs (0.062u,0.s) (success)
Assembling rewrite_head_no_dtree...
Reducing rewrite_head_no_dtree...
Proving Rewriter_Wf...
Tactic call ran for 0.033 secs (0.031u,0.002s) (success)
Tactic call ran for 0.44 secs (0.437u,0.002s) (success)
Proving Rewriter_Interp...
Tactic call ran for 0.419 secs (0.417u,0.001s) (success)
Tactic call ran for 0.194 secs (0.193u,0.001s) (success)
Assembling verified rewriter...
Refining with verified rewriter...
Finished transaction in 16.393 secs (16.19u,0.201s) (successful)
Finished transaction in 1.519 secs (1.504u,0.015s) (successful)
Finished transaction in 1.532 secs (1.5u,0.032s) (successful)
Chars 21324 - 21338 [srapply~exist.] 40.159 secs (0.u,0.02s)
Chars 21341 - 21342 [-] 0. secs (0.u,0.s)
Chars 21343 - 21368 [srapply~equiv_adjointify.] 0.001 secs (0.001u,0.s)
Chars 21373 - 21374 [+] 0. secs (0.u,0.s)
Chars 21375 - 21384 [(intros~b).] 0. secs (0.u,0.s)
Chars 21385 - 21397 [exists~↓b.] 0.001 secs (0.001u,0.s)
Chars 21404 - 21429 [(apply~equiv_resize_hprop).] 0. secs (0.u,0.s)
Chars 21436 - 21445 [exists~b.] 0. secs (0.u,0.s)
Chars 21446 - 21458 [reflexivity.] 0. secs (0.u,0.s)
Chars 21463 - 21464 [+] 0. secs (0.u,0.s)
Chars 21465 - 21479 [(intros~[C~HC]).] 0.001 secs (0.001u,0.s)
Chars 21480 - 21519 [(eapply~(equiv_resize_hprop~_)...] 0.002 secs (0.002u,0.s)
Chars 21526 - 21543 [exact~(bound~HC).] 0. secs (0.u,0.s)
Chars 21548 - 21549 [+] 0. secs (0.u,0.s)
Chars 21550 - 21554 [(cbn).] 0.004 secs (0.003u,0.001s)
Chars 21555 - 21569 [(intros~[C~HC]).] 0.004 secs (0.004u,0.s)
Chars 21570 - 21598 [(apply~path_sigma_hprop;~cbn).] 0.007 secs (0.007u,0.s)
Chars 21605 - 21614 [symmetry.] 0.001 secs (0.001u,0.s)
Chars 21615 - 21636 [(apply~bound_property).] 0.001 secs (0.001u,0.s)
Chars 21641 - 21642 [+] 0. secs (0.u,0.s)
Chars 21643 - 21647 [(cbn).] 0.003 secs (0.003u,0.s)
Chars 21648 - 21657 [(intros~x).] 0. secs (0.u,0.s)
Chars 21658 - 21674 [(rewrite~eissect).] 0.003 secs (0.002u,0.s)
Chars 21675 - 21687 [reflexivity.] 0. secs (0.u,0.s)
Chars 21690 - 21691 [-] 0. secs (0.u,0.s)
Chars 21692 - 21696 [(cbn).] 0.007 secs (0.007u,0.s)
Chars 21697 - 21709 [(intros~b~b').] 0. secs (0.u,0.s)
Chars 21710 - 21744 [(apply~isembedding_initial_seg...] 0.001 secs (0.001u,0.s)
Chars 21324 - 21338 [srapply~exist.] 0. secs (0.u,0.s)
Chars 21343 - 21368 [srapply~equiv_adjointify.] 0. secs (0.u,0.s)
Chars 21375 - 21384 [(intros~b).] 0. secs (0.u,0.s)
Chars 21385 - 21397 [exists~↓b.] 0. secs (0.u,0.s)
Chars 21404 - 21429 [(apply~equiv_resize_hprop).] 0. secs (0.u,0.s)
Chars 21436 - 21445 [exists~b.] 0. secs (0.u,0.s)
Chars 21446 - 21458 [reflexivity.] 0. secs (0.u,0.s)
Chars 21465 - 21479 [(intros~[C~HC]).] 0. secs (0.u,0.s)
Chars 21480 - 21519 [(eapply~(equiv_resize_hprop~_)...] 0. secs (0.u,0.s)
Chars 21526 - 21543 [exact~(bound~HC).] 0. secs (0.u,0.s)
Chars 21550 - 21554 [(cbn).] 0.001 secs (0.001u,0.s)
Chars 21555 - 21569 [(intros~[C~HC]).] 0.001 secs (0.001u,0.s)
Chars 21570 - 21598 [(apply~path_sigma_hprop;~cbn).] 0.002 secs (0.002u,0.s)
Chars 21605 - 21614 [symmetry.] 0. secs (0.u,0.s)
Chars 21615 - 21636 [(apply~bound_property).] 0. secs (0.u,0.s)
Chars 21643 - 21647 [(cbn).] 0.001 secs (0.001u,0.s)
Chars 21648 - 21657 [(intros~x).] 0. secs (0.u,0.s)
Chars 21658 - 21674 [(rewrite~eissect).] 0. secs (0.u,0.s)
Chars 21675 - 21687 [reflexivity.] 0. secs (0.u,0.s)
Chars 21692 - 21696 [(cbn).] 0.005 secs (0.005u,0.s)
Chars 21697 - 21709 [(intros~b~b').] 0. secs (0.u,0.s)
Chars 21710 - 21744 [(apply~isembedding_initial_seg...] 0. secs (0.u,0.s)
Chars 21745 - 21749 [Qed.] 0.023 secs (0.021u,0.001s)
Chars 21783 - 21828 [Definition~successor~(A~:~Ordi...] 0. secs (0.u,0.s)
Chars 21829 - 21835 [Proof.] 0. secs (0.u,0.s)
Chars 22496 - 22550 [snrapply~(AmalgamatedFreeProdu...] 40.013 secs (0.u,0.004s)
Chars 22553 - 22563 [(intros~[]).] 0. secs (0.u,0.s)
Chars 22566 - 22612 [refine~(grp_homo_unit~_~@~(grp...] 0.001 secs (0.001u,0.s)
Chars 22496 - 22550 [snrapply~(AmalgamatedFreeProdu...] 0. secs (0.u,0.s)
Chars 22553 - 22563 [(intros~[]).] 0. secs (0.u,0.s)
Chars 22566 - 22612 [refine~(grp_homo_unit~_~@~(grp...] 0. secs (0.u,0.s)
Chars 22613 - 22621 [Defined.] 0. secs (0.u,0.s)
Chars 22623 - 22789 [Definition~equiv_freeproduct_r...] 0. secs (0.u,0.s)
Chars 22790 - 22796 [Proof.] 0. secs (0.u,0.s)
Chars 8182 - 8195 [(repeat~split).] 40.116 secs (0.u,0.019s)
Chars 8198 - 8199 [-] 0. secs (0.u,0.s)
Chars 8200 - 8208 [(apply~_).] 0.016 secs (0.014u,0.002s)
Chars 8211 - 8212 [-] 0. secs (0.u,0.s)
Chars 8213 - 8221 [(apply~_).] 0.034 secs (0.025u,0.008s)
Chars 8224 - 8225 [-] 0. secs (0.u,0.s)
Chars 8226 - 8235 [(intros~x).] 0. secs (0.u,0.s)
Chars 8236 - 8278 [(apply~not_lt_le_flip,~(irrefl...] 0.001 secs (0.001u,0.s)
Chars 8281 - 8282 [-] 0. secs (0.u,0.s)
Chars 8283 - 8302 [(intros~x~y~z~E1~E2).] 0. secs (0.u,0.s)
Chars 8307 - 8404 [(apply~le_iff_not_lt_flip;~app...] 0.003 secs (0.003u,0.s)
Chars 8409 - 8437 [(change~(complement~(<)~z~x)).] 0. secs (0.u,0.s)
Chars 8442 - 8468 [(transitivity~y;~assumption).] 0.008 secs (0.008u,0.s)
Chars 8471 - 8472 [-] 0. secs (0.u,0.s)
Chars 8473 - 8490 [(intros~x~y~E1~E2).] 0. secs (0.u,0.s)
Chars 8495 - 8562 [(apply~le_iff_not_lt_flip~in~E...] 0.002 secs (0.002u,0.s)
Chars 8567 - 8616 [(apply~(antisymmetry~(compleme...] 0.005 secs (0.005u,0.s)
Chars 8182 - 8195 [(repeat~split).] 0. secs (0.u,0.s)
Chars 8200 - 8208 [(apply~_).] 0. secs (0.u,0.s)
Chars 8213 - 8221 [(apply~_).] 0. secs (0.u,0.s)
Chars 8226 - 8235 [(intros~x).] 0. secs (0.u,0.s)
Chars 8236 - 8278 [(apply~not_lt_le_flip,~(irrefl...] 0. secs (0.u,0.s)
Chars 8283 - 8302 [(intros~x~y~z~E1~E2).] 0. secs (0.u,0.s)
Chars 8307 - 8404 [(apply~le_iff_not_lt_flip;~app...] 0. secs (0.u,0.s)
Chars 8409 - 8437 [(change~(complement~(<)~z~x)).] 0. secs (0.u,0.s)
Chars 8442 - 8468 [(transitivity~y;~assumption).] 0. secs (0.u,0.s)
Chars 8473 - 8490 [(intros~x~y~E1~E2).] 0. secs (0.u,0.s)
Chars 8495 - 8562 [(apply~le_iff_not_lt_flip~in~E...] 0. secs (0.u,0.s)
Chars 8567 - 8616 [(apply~(antisymmetry~(compleme...] 0. secs (0.u,0.s)
Chars 8619 - 8623 [Qed.] 0.001 secs (0.001u,0.s)
Chars 8627 - 8684 [Lemma~fullpseudo_fullpartial'~...] 0. secs (0.u,0.s)
Chars 8687 - 8693 [Proof.] 0. secs (0.u,0.s)
Chars 18886 - 18963 [exact~(seq_colim_sum_ind~B~_~e...] 40.109 secs (0.004u,0.023s)
Chars 18886 - 18963 [exact~(seq_colim_sum_ind~B~_~e...] 0. secs (0.u,0.s)
Chars 18966 - 18974 [Defined.] 0.003 secs (0.002u,0.s)
Chars 18978 - 19139 [Definition~seq_colim_sum_rec_b...] 0.005 secs (0.004u,0.001s)
Chars 19142 - 19148 [Proof.] 0. secs (0.u,0.s)
Chars 7692 - 7703 [(unfold~min).] 40.013 secs (0.u,0.003s)
Chars 7704 - 7737 [(destruct~(total~le~x~y)~as~[E...] 0.002 secs (0.001u,0.s)
Chars 7740 - 7741 [-] 0. secs (0.u,0.s)
Chars 7742 - 7757 [(apply~meet_l,~E).] 0. secs (0.u,0.s)
Chars 7760 - 7761 [-] 0. secs (0.u,0.s)
Chars 7762 - 7777 [(apply~meet_r,~E).] 0. secs (0.u,0.s)
Chars 7692 - 7703 [(unfold~min).] 0. secs (0.u,0.s)
Chars 7704 - 7737 [(destruct~(total~le~x~y)~as~[E...] 0. secs (0.u,0.s)
Chars 7742 - 7757 [(apply~meet_l,~E).] 0. secs (0.u,0.s)
Chars 7762 - 7777 [(apply~meet_r,~E).] 0. secs (0.u,0.s)
Chars 7780 - 7784 [Qed.] 0. secs (0.u,0.s)
Chars 7787 - 7802 [End~total_meet.] 0.001 secs (0.001u,0.s)
Chars 7806 - 7844 [Lemma~meet_idempotent~x~:~x~⊓~...] 0. secs (0.u,0.s)
Chars 7847 - 7853 [Proof.] 0. secs (0.u,0.s)
Chars 7858 - 7887 [(assert~(le1~:~x~⊓~x~≤~x)).] 0.316 secs (0.001u,0.002s)
Chars 7892 - 7893 [{] 0. secs (0.u,0.s)
Chars 7900 - 7923 [refine~(meet_lb_l~_~_).] 0. secs (0.u,0.s)
Chars 7928 - 7929 [}] 0. secs (0.u,0.s)
Chars 7934 - 7963 [(assert~(le2~:~x~≤~x~⊓~x)).] 0. secs (0.u,0.s)
Chars 7968 - 7969 [{] 0. secs (0.u,0.s)
Chars 7976 - 8023 [(refine~(meet_glb~_~_~_~_~_);~...] 0.006 secs (0.006u,0.s)
Chars 8028 - 8029 [}] 0. secs (0.u,0.s)
Chars 8034 - 8070 [refine~(antisymmetry~_~_~_~le1...] 0.002 secs (0.002u,0.s)
Chars 7858 - 7887 [(assert~(le1~:~x~⊓~x~≤~x)).] 0. secs (0.u,0.s)
Chars 7900 - 7923 [refine~(meet_lb_l~_~_).] 0. secs (0.u,0.s)
Chars 7934 - 7963 [(assert~(le2~:~x~≤~x~⊓~x)).] 0. secs (0.u,0.s)
Chars 7976 - 8023 [(refine~(meet_glb~_~_~_~_~_);~...] 0. secs (0.u,0.s)
Chars 8034 - 8070 [refine~(antisymmetry~_~_~_~le1...] 0. secs (0.u,0.s)
Chars 8073 - 8077 [Qed.] 0. secs (0.u,0.s)
Chars 8079 - 8106 [End~meet_semilattice_order.] 0.016 secs (0.016u,0.s)
Chars 8108 - 8130 [Section~lattice_order.] 0. secs (0.u,0.s)
Chars 8133 - 8159 [Context~`{LatticeOrder~L}.] 0. secs (0.u,0.s)
Chars 8163 - 8218 [Instance:~(IsJoinSemiLattice~L...] 0. secs (0.u,0.s)
Chars 8221 - 8276 [Instance:~(IsMeetSemiLattice~L...] 0. secs (0.u,0.s)
Chars 8280 - 8313 [Instance:~(Absorption~(⊓)~(⊔)).] 0. secs (0.u,0.s)
Chars 8316 - 8322 [Proof.] 0. secs (0.u,0.s)
Chars 8325 - 8336 [(intros~x~y).] 8.871 secs (0.u,0.002s)
Chars 8337 - 8364 [(apply~(antisymmetry~(≤))).] 0.002 secs (0.002u,0.s)
Chars 8367 - 8368 [-] 0. secs (0.u,0.s)
Chars 8369 - 8385 [(apply~meet_lb_l).] 0. secs (0.u,0.s)
Chars 8388 - 8389 [-] 0. secs (0.u,0.s)
Chars 8390 - 8404 [(apply~meet_le).] 0. secs (0.u,0.s)
Chars 8408 - 8409 [+] 0. secs (0.u,0.s)
Chars 8410 - 8428 [(apply~reflexivity).] 0.002 secs (0.002u,0.s)
Chars 8432 - 8433 [+] 0. secs (0.u,0.s)
Chars 8434 - 8450 [(apply~join_ub_l).] 0. secs (0.u,0.s)
Chars 8325 - 8336 [(intros~x~y).] 0. secs (0.u,0.s)
Chars 8337 - 8364 [(apply~(antisymmetry~(≤))).] 0. secs (0.u,0.s)
Chars 8369 - 8385 [(apply~meet_lb_l).] 0. secs (0.u,0.s)
Chars 8390 - 8404 [(apply~meet_le).] 0. secs (0.u,0.s)
Chars 8410 - 8428 [(apply~reflexivity).] 0. secs (0.u,0.s)
Chars 8434 - 8450 [(apply~join_ub_l).] 0. secs (0.u,0.s)
Chars 8453 - 8457 [Qed.] 0. secs (0.u,0.s)
Chars 8461 - 8494 [Instance:~(Absorption~(⊔)~(⊓)).] 0. secs (0.u,0.s)
Chars 8497 - 8503 [Proof.] 0. secs (0.u,0.s)
Chars 21838 - 21871 [(set~(carrier~:=~(A~+~Unit)%ty...] 40.097 secs (0.001u,0.02s)
Chars 21874 - 22077 [(set~~~(relation~:=~~~~fun~x~y...] 0.002 secs (0.002u,0.s)
Chars 22080 - 22104 [exists~carrier~relation.] 0. secs (0.u,0.s)
Chars 22105 - 22117 [constructor.] 0. secs (0.u,0.s)
Chars 22120 - 22121 [-] 0. secs (0.u,0.s)
Chars 22122 - 22130 [exact~_.] 0.024 secs (0.015u,0.008s)
Chars 22133 - 22134 [-] 0. secs (0.u,0.s)
Chars 22135 - 22172 [(intros~[x|~?]~[y|~?];~cbn;~ex...] 0.01 secs (0.009u,0.001s)
Chars 22175 - 22176 [-] 0. secs (0.u,0.s)
Chars 22177 - 22204 [(intros~[x|~[]]~[y|~[]]~H).] 0.003 secs (0.003u,0.s)
Chars 22209 - 22210 [+] 0. secs (0.u,0.s)
Chars 22211 - 22216 [f_ap.] 0.001 secs (0.001u,0.s)
Chars 22217 - 22238 [(apply~extensionality).] 0.001 secs (0.001u,0.s)
Chars 22239 - 22248 [(intros~z).] 0. secs (0.u,0.s)
Chars 22249 - 22267 [exact~(H~(inl~z)).] 0.016 secs (0.009u,0.007s)
Chars 22272 - 22273 [+] 0. secs (0.u,0.s)
Chars 22274 - 22313 [(enough~(H0~:~relation~(inl~x)...] 0.001 secs (0.001u,0.s)
Chars 22314 - 22315 [{] 0. secs (0.u,0.s)
Chars 22324 - 22334 [(cbn~in~H0).] 0. secs (0.u,0.s)
Chars 22335 - 22367 [(destruct~(irreflexivity~_~_~H...] 0.002 secs (0.002u,0.s)
Chars 22374 - 22375 [}] 0. secs (0.u,0.s)
Chars 22382 - 22390 [(apply~H).] 0.001 secs (0.001u,0.s)
Chars 22391 - 22395 [(cbn).] 0. secs (0.u,0.s)
Chars 22396 - 22405 [exact~tt.] 0. secs (0.u,0.s)
Chars 22410 - 22411 [+] 0. secs (0.u,0.s)
Chars 22412 - 22451 [(enough~(H0~:~relation~(inl~y)...] 0. secs (0.u,0.s)
Chars 22452 - 22453 [{] 0. secs (0.u,0.s)
Chars 22462 - 22472 [(cbn~in~H0).] 0. secs (0.u,0.s)
Chars 22473 - 22505 [(destruct~(irreflexivity~_~_~H...] 0.002 secs (0.002u,0.s)
Chars 22512 - 22513 [}] 0. secs (0.u,0.s)
Chars 22520 - 22528 [(apply~H).] 0. secs (0.u,0.s)
Chars 22529 - 22533 [(cbn).] 0. secs (0.u,0.s)
Chars 22534 - 22543 [exact~tt.] 0. secs (0.u,0.s)
Chars 22548 - 22549 [+] 0. secs (0.u,0.s)
Chars 22550 - 22562 [reflexivity.] 0. secs (0.u,0.s)
Chars 22565 - 22566 [-] 0. secs (0.u,0.s)
Chars 22567 - 22618 [(assert~(H~:~forall~a,~Accessi...] 0. secs (0.u,0.s)
Chars 22619 - 22620 [{] 0. secs (0.u,0.s)
Chars 22627 - 22636 [(intros~a).] 0. secs (0.u,0.s)
Chars 22637 - 22680 [(induction~(well_foundedness~a...] 0.002 secs (0.002u,0.s)
Chars 22687 - 22731 [(constructor;~intros~[b|~[]];~...] 0.003 secs (0.003u,0.s)
Chars 22738 - 22739 [+] 0. secs (0.u,0.s)
Chars 22740 - 22749 [(apply~IH).] 0. secs (0.u,0.s)
Chars 22750 - 22758 [exact~H.] 0. secs (0.u,0.s)
Chars 22765 - 22766 [+] 0. secs (0.u,0.s)
Chars 22767 - 22778 [(destruct~H).] 0. secs (0.u,0.s)
Chars 22783 - 22784 [}] 0. secs (0.u,0.s)
Chars 22789 - 22805 [(intros~[x|~[]]).] 0.001 secs (0.001u,0.s)
Chars 22810 - 22811 [+] 0. secs (0.u,0.s)
Chars 22812 - 22820 [(apply~H).] 0. secs (0.u,0.s)
Chars 22825 - 22826 [+] 0. secs (0.u,0.s)
Chars 22827 - 22872 [(constructor;~intros~[b|~[]];~...] 0.004 secs (0.004u,0.s)
Chars 22879 - 22880 [*] 0. secs (0.u,0.s)
Chars 22881 - 22889 [(apply~H).] 0. secs (0.u,0.s)
Chars 22896 - 22897 [*] 0. secs (0.u,0.s)
Chars 22898 - 22910 [(destruct~H0).] 0. secs (0.u,0.s)
Chars 22913 - 22914 [-] 0. secs (0.u,0.s)
Chars 22915 - 22960 [(intros~[x|~[]]~[y|~[]]~[z|~[]...] 0.016 secs (0.013u,0.002s)
Chars 22965 - 22977 [(intros~_~[]).] 0. secs (0.u,0.s)
Chars 21838 - 21871 [(set~(carrier~:=~(A~+~Unit)%ty...] 0. secs (0.u,0.s)
Chars 21874 - 22077 [(set~~~(relation~:=~~~~fun~x~y...] 0. secs (0.u,0.s)
Chars 22080 - 22104 [exists~carrier~relation.] 0. secs (0.u,0.s)
Chars 22105 - 22117 [constructor.] 0. secs (0.u,0.s)
Chars 22122 - 22130 [exact~_.] 0. secs (0.u,0.s)
Chars 22135 - 22172 [(intros~[x|~?]~[y|~?];~cbn;~ex...] 0.002 secs (0.002u,0.s)
Chars 22177 - 22204 [(intros~[x|~[]]~[y|~[]]~H).] 0. secs (0.u,0.s)
Chars 22211 - 22216 [f_ap.] 0. secs (0.u,0.s)
Chars 22217 - 22238 [(apply~extensionality).] 0. secs (0.u,0.s)
Chars 22239 - 22248 [(intros~z).] 0. secs (0.u,0.s)
Chars 22249 - 22267 [exact~(H~(inl~z)).] 0. secs (0.u,0.s)
Chars 22274 - 22313 [(enough~(H0~:~relation~(inl~x)...] 0. secs (0.u,0.s)
Chars 22324 - 22334 [(cbn~in~H0).] 0. secs (0.u,0.s)
Chars 22335 - 22367 [(destruct~(irreflexivity~_~_~H...] 0. secs (0.u,0.s)
Chars 22382 - 22390 [(apply~H).] 0. secs (0.u,0.s)
Chars 22391 - 22395 [(cbn).] 0. secs (0.u,0.s)
Chars 22396 - 22405 [exact~tt.] 0. secs (0.u,0.s)
Chars 22412 - 22451 [(enough~(H0~:~relation~(inl~y)...] 0. secs (0.u,0.s)
Chars 22462 - 22472 [(cbn~in~H0).] 0. secs (0.u,0.s)
Chars 22473 - 22505 [(destruct~(irreflexivity~_~_~H...] 0. secs (0.u,0.s)
Chars 22520 - 22528 [(apply~H).] 0. secs (0.u,0.s)
Chars 22529 - 22533 [(cbn).] 0. secs (0.u,0.s)
Chars 22534 - 22543 [exact~tt.] 0. secs (0.u,0.s)
Chars 22550 - 22562 [reflexivity.] 0. secs (0.u,0.s)
Chars 22567 - 22618 [(assert~(H~:~forall~a,~Accessi...] 0. secs (0.u,0.s)
Chars 22627 - 22636 [(intros~a).] 0. secs (0.u,0.s)
Chars 22637 - 22680 [(induction~(well_foundedness~a...] 0. secs (0.u,0.s)
Chars 22687 - 22731 [(constructor;~intros~[b|~[]];~...] 0.002 secs (0.001u,0.s)
Chars 22740 - 22749 [(apply~IH).] 0. secs (0.u,0.s)
Chars 22750 - 22758 [exact~H.] 0. secs (0.u,0.s)
Chars 22767 - 22778 [(destruct~H).] 0. secs (0.u,0.s)
Chars 22789 - 22805 [(intros~[x|~[]]).] 0. secs (0.u,0.s)
Chars 22812 - 22820 [(apply~H).] 0. secs (0.u,0.s)
Chars 22827 - 22872 [(constructor;~intros~[b|~[]];~...] 0.002 secs (0.002u,0.s)
Chars 22881 - 22889 [(apply~H).] 0. secs (0.u,0.s)
Chars 22898 - 22910 [(destruct~H0).] 0. secs (0.u,0.s)
Chars 22915 - 22960 [(intros~[x|~[]]~[y|~[]]~[z|~[]...] 0.005 secs (0.005u,0.s)
Chars 22965 - 22977 [(intros~_~[]).] 0. secs (0.u,0.s)
Chars 22978 - 22986 [Defined.] 0.011 secs (0.008u,0.002s)
Chars 22989 - 23078 [Lemma~lt_successor~`{Univalenc...] 0. secs (0.u,0.s)
Chars 23079 - 23085 [Proof.] 0. secs (0.u,0.s)
Chars 22799 - 22862 [refine~(equiv_amalgamatedfreep...] 40.013 secs (0.001u,0.003s)
Chars 22865 - 22953 [refine~~(equiv_sigma_prod0~_~_...] 0.045 secs (0.045u,0.s)
Chars 22956 - 22965 [(intros~f).] 0. secs (0.u,0.s)
Chars 22968 - 22988 [rapply~contr_forall.] 0.022 secs (0.022u,0.s)
Chars 22991 - 23025 [(intros~[];~apply~contr_inhab_...] 0.015 secs (0.015u,0.s)
Chars 23028 - 23037 [(apply~tr).] 0. secs (0.u,0.s)
Chars 23040 - 23086 [refine~(grp_homo_unit~_~@~(grp...] 0.001 secs (0.001u,0.s)
Chars 22799 - 22862 [refine~(equiv_amalgamatedfreep...] 0. secs (0.u,0.s)
Chars 22865 - 22953 [refine~~(equiv_sigma_prod0~_~_...] 0. secs (0.u,0.s)
Chars 22956 - 22965 [(intros~f).] 0. secs (0.u,0.s)
Chars 22968 - 22988 [rapply~contr_forall.] 0. secs (0.u,0.s)
Chars 22991 - 23025 [(intros~[];~apply~contr_inhab_...] 0. secs (0.u,0.s)
Chars 23028 - 23037 [(apply~tr).] 0. secs (0.u,0.s)
Chars 23040 - 23086 [refine~(grp_homo_unit~_~@~(grp...] 0. secs (0.u,0.s)
Chars 23087 - 23095 [Defined.] 0.002 secs (0.002u,0.s)
Chars 8506 - 8517 [(intros~x~y).] 10.199 secs (0.u,0.002s)
Chars 8518 - 8545 [(apply~(antisymmetry~(≤))).] 0.002 secs (0.002u,0.s)
Chars 8548 - 8549 [-] 0. secs (0.u,0.s)
Chars 8550 - 8564 [(apply~join_le).] 0. secs (0.u,0.s)
Chars 8569 - 8570 [+] 0. secs (0.u,0.s)
Chars 8571 - 8589 [(apply~reflexivity).] 0.002 secs (0.002u,0.s)
Chars 8594 - 8595 [+] 0. secs (0.u,0.s)
Chars 8596 - 8612 [(apply~meet_lb_l).] 0. secs (0.u,0.s)
Chars 8615 - 8616 [-] 0. secs (0.u,0.s)
Chars 8617 - 8633 [(apply~join_ub_l).] 0. secs (0.u,0.s)
Chars 8506 - 8517 [(intros~x~y).] 0. secs (0.u,0.s)
Chars 8518 - 8545 [(apply~(antisymmetry~(≤))).] 0. secs (0.u,0.s)
Chars 8550 - 8564 [(apply~join_le).] 0. secs (0.u,0.s)
Chars 8571 - 8589 [(apply~reflexivity).] 0. secs (0.u,0.s)
Chars 8596 - 8612 [(apply~meet_lb_l).] 0. secs (0.u,0.s)
Chars 8617 - 8633 [(apply~join_ub_l).] 0. secs (0.u,0.s)
Chars 8636 - 8640 [Qed.] 0. secs (0.u,0.s)
Chars 8644 - 8694 [Instance~lattice_order_lattice...] 0. secs (0.u,0.s)
Chars 8698 - 8777 [Lemma~meet_join_distr_l_le~x~y...] 0.001 secs (0.001u,0.s)
Chars 8780 - 8786 [Proof.] 0. secs (0.u,0.s)
Chars 19153 - 19214 [(intros~n~a~b;~srapply~(cancel...] 35.248 secs (0.005u,0.021s)
Chars 19219 - 19255 [srapply~seq_colim_sum_ind_beta...] 0.023 secs (0.016u,0.006s)
Chars 19153 - 19214 [(intros~n~a~b;~srapply~(cancel...] 0.002 secs (0.002u,0.s)
Chars 19219 - 19255 [srapply~seq_colim_sum_ind_beta...] 0.002 secs (0.002u,0.s)
Chars 19258 - 19266 [Defined.] 0.029 secs (0.023u,0.005s)
Chars 19268 - 19289 [End~SeqColimitSumRec.] 0.016 secs (0.013u,0.002s)
Chars 19309 - 19523 [Definition~seq_colimit_sum_uni...] 0.007 secs (0.006u,0.s)
Chars 19524 - 19530 [Proof.] 0. secs (0.u,0.s)
Chars 23088 - 23104 [exists~(inr~tt).] 8.686 secs (0.002u,0.02s)
Chars 23107 - 23128 [srapply~path_Ordinal.] 0.002 secs (0.002u,0.s)
Chars 23131 - 23132 [-] 0. secs (0.u,0.s)
Chars 23133 - 23158 [srapply~equiv_adjointify.] 0.001 secs (0.001u,0.s)
Chars 23163 - 23164 [+] 0. secs (0.u,0.s)
Chars 23165 - 23174 [(intros~a).] 0. secs (0.u,0.s)
Chars 23175 - 23187 [srapply~in_.] 0.005 secs (0.004u,0.s)
Chars 23194 - 23195 [*] 0. secs (0.u,0.s)
Chars 23196 - 23210 [exact~(inl~a).] 0.001 secs (0.001u,0.s)
Chars 23217 - 23218 [*] 0. secs (0.u,0.s)
Chars 23219 - 23228 [exact~tt.] 0. secs (0.u,0.s)
Chars 23233 - 23234 [+] 0. secs (0.u,0.s)
Chars 23235 - 23266 [(intros~[[a|~[]]~Ha];~cbn~in~*).] 0.011 secs (0.008u,0.002s)
Chars 23273 - 23274 [*] 0. secs (0.u,0.s)
Chars 23275 - 23283 [exact~a.] 0. secs (0.u,0.s)
Chars 23290 - 23291 [*] 0. secs (0.u,0.s)
Chars 23292 - 23323 [(apply~equiv_resize_hprop~in~Ha).] 0. secs (0.u,0.s)
Chars 23324 - 23336 [(destruct~Ha).] 0. secs (0.u,0.s)
Chars 23341 - 23342 [+] 0. secs (0.u,0.s)
Chars 23343 - 23364 [(intros~[[a|~[]]~Ha]).] 0.033 secs (0.026u,0.007s)
Chars 23371 - 23372 [*] 0. secs (0.u,0.s)
Chars 23373 - 23384 [(unfold~in_).] 0. secs (0.u,0.s)
Chars 23385 - 23389 [(cbn).] 0.026 secs (0.017u,0.008s)
Chars 23390 - 23395 [f_ap.] 0.004 secs (0.004u,0.s)
Chars 23404 - 23452 [(assert~(IsHProp~(resize_hprop...] 0.003 secs (0.003u,0.s)
Chars 23461 - 23480 [(apply~path_ishprop).] 0.001 secs (0.001u,0.s)
Chars 23487 - 23488 [*] 0. secs (0.u,0.s)
Chars 23489 - 23529 [(destruct~((equiv_resize_hprop...] 0.014 secs (0.014u,0.s)
Chars 23534 - 23535 [+] 0. secs (0.u,0.s)
Chars 23536 - 23545 [(intros~a).] 0.001 secs (0.001u,0.s)
Chars 23546 - 23558 [reflexivity.] 0.002 secs (0.002u,0.s)
Chars 23561 - 23562 [-] 0. secs (0.u,0.s)
Chars 23563 - 23567 [(cbn).] 0.014 secs (0.014u,0.s)
Chars 23568 - 23580 [(intros~a~a').] 0. secs (0.u,0.s)
Chars 23581 - 23593 [reflexivity.] 0.001 secs (0.001u,0.s)
Chars 23088 - 23104 [exists~(inr~tt).] 0. secs (0.u,0.s)
Chars 23107 - 23128 [srapply~path_Ordinal.] 0. secs (0.u,0.s)
Chars 23133 - 23158 [srapply~equiv_adjointify.] 0. secs (0.u,0.s)
Chars 23165 - 23174 [(intros~a).] 0. secs (0.u,0.s)
Chars 23175 - 23187 [srapply~in_.] 0. secs (0.u,0.s)
Chars 23196 - 23210 [exact~(inl~a).] 0. secs (0.u,0.s)
Chars 23219 - 23228 [exact~tt.] 0. secs (0.u,0.s)
Chars 23235 - 23266 [(intros~[[a|~[]]~Ha];~cbn~in~*).] 0. secs (0.u,0.s)
Chars 23275 - 23283 [exact~a.] 0. secs (0.u,0.s)
Chars 23292 - 23323 [(apply~equiv_resize_hprop~in~Ha).] 0. secs (0.u,0.s)
Chars 23324 - 23336 [(destruct~Ha).] 0. secs (0.u,0.s)
Chars 23343 - 23364 [(intros~[[a|~[]]~Ha]).] 0.001 secs (0.001u,0.s)
Chars 23373 - 23384 [(unfold~in_).] 0. secs (0.u,0.s)
Chars 23385 - 23389 [(cbn).] 0. secs (0.u,0.s)
Chars 23390 - 23395 [f_ap.] 0.001 secs (0.001u,0.s)
Chars 23404 - 23452 [(assert~(IsHProp~(resize_hprop...] 0. secs (0.u,0.s)
Chars 23461 - 23480 [(apply~path_ishprop).] 0. secs (0.u,0.s)
Chars 23489 - 23529 [(destruct~((equiv_resize_hprop...] 0. secs (0.u,0.s)
Chars 23536 - 23545 [(intros~a).] 0.001 secs (0.u,0.s)
Chars 23546 - 23558 [reflexivity.] 0. secs (0.u,0.s)
Chars 23563 - 23567 [(cbn).] 0.011 secs (0.01u,0.001s)
Chars 23568 - 23580 [(intros~a~a').] 0. secs (0.u,0.s)
Chars 23581 - 23593 [reflexivity.] 0. secs (0.u,0.s)
Chars 23594 - 23598 [Qed.] 0.201 secs (0.177u,0.023s)
Chars 23627 - 23747 [Definition~image@{i~j}~{A~:~Ty...] 0.011 secs (0.011u,0.s)
Chars 23749 - 23838 [Definition~factor1~{A}~{B~:~HS...] 0. secs (0.u,0.s)
Chars 23840 - 24007 [Lemma~image_ind_prop~{A}~{B~:~...] 0. secs (0.u,0.s)
Chars 24008 - 24014 [Proof.] 0. secs (0.u,0.s)
Chars 8696 - 8715 [(split;~try~apply~_).] 40.105 secs (0.011u,0.018s)
Chars 8718 - 8729 [(intros~x~y).] 0. secs (0.u,0.s)
Chars 8732 - 8738 [split.] 0. secs (0.u,0.s)
Chars 8741 - 8742 [-] 0. secs (0.u,0.s)
Chars 8743 - 8752 [(intros~E).] 0. secs (0.u,0.s)
Chars 8753 - 8759 [split.] 0. secs (0.u,0.s)
Chars 8764 - 8765 [+] 0. secs (0.u,0.s)
Chars 8766 - 8787 [(apply~not_lt_le_flip).] 0. secs (0.u,0.s)
Chars 8788 - 8813 [(apply~lt_flip;~assumption).] 0.001 secs (0.001u,0.s)
Chars 8818 - 8819 [+] 0. secs (0.u,0.s)
Chars 8820 - 8848 [(apply~pseudo_order_lt_apart).] 0.001 secs (0.001u,0.s)
Chars 8849 - 8860 [assumption.] 0. secs (0.u,0.s)
Chars 8863 - 8864 [-] 0. secs (0.u,0.s)
Chars 8865 - 8878 [(intros~[?~E]).] 0. secs (0.u,0.s)
Chars 8879 - 8926 [(apply~not_lt_apart_lt_flip;~[...] 0.003 secs (0.003u,0.s)
Chars 8931 - 8956 [(apply~le_iff_not_lt_flip).] 0.001 secs (0.001u,0.s)
Chars 8957 - 8965 [trivial.] 0. secs (0.u,0.s)
Chars 8696 - 8715 [(split;~try~apply~_).] 0. secs (0.u,0.s)
Chars 8718 - 8729 [(intros~x~y).] 0. secs (0.u,0.s)
Chars 8732 - 8738 [split.] 0. secs (0.u,0.s)
Chars 8743 - 8752 [(intros~E).] 0. secs (0.u,0.s)
Chars 8753 - 8759 [split.] 0. secs (0.u,0.s)
Chars 8766 - 8787 [(apply~not_lt_le_flip).] 0. secs (0.u,0.s)
Chars 8788 - 8813 [(apply~lt_flip;~assumption).] 0. secs (0.u,0.s)
Chars 8820 - 8848 [(apply~pseudo_order_lt_apart).] 0. secs (0.u,0.s)
Chars 8849 - 8860 [assumption.] 0. secs (0.u,0.s)
Chars 8865 - 8878 [(intros~[?~E]).] 0. secs (0.u,0.s)
Chars 8879 - 8926 [(apply~not_lt_apart_lt_flip;~[...] 0. secs (0.u,0.s)
Chars 8931 - 8956 [(apply~le_iff_not_lt_flip).] 0. secs (0.u,0.s)
Chars 8957 - 8965 [trivial.] 0. secs (0.u,0.s)
Chars 8968 - 8972 [Qed.] 0. secs (0.u,0.s)
Chars 8976 - 9173 [#[global]~Instance~fullpseudo_...] 0. secs (0.u,0.s)
Chars 9177 - 9234 [#[global]Instance~le_stable~:~...] 0. secs (0.u,0.s)
Chars 9237 - 9243 [Proof.] 0. secs (0.u,0.s)
"~~~~~~~~~~~~~~~~~~"
"Translating Coq.Init.Logic.eq"
"Coq.Init.Logic.eq has been translated."
"Translating MetaCoq.Translations.MiniHoTT.paths"
"paths has been translated as pathsᵗ"
"Translating Coq.Init.Logic.False"
"Coq.Init.Logic.False has been translated."
"Translating MetaCoq.Translations.times_bool_fun.NotFunext"
"NotFunext has been translated as NotFunextᵗ"
Chars 8789 - 8803 [(apply~meet_le).] 40.013 secs (0.001u,0.002s)
Chars 8806 - 8807 [-] 0. secs (0.u,0.s)
Chars 8808 - 8839 [(apply~join_le;~apply~meet_lb_l).] 0.013 secs (0.013u,0.s)
Chars 8842 - 8843 [-] 0. secs (0.u,0.s)
Chars 8844 - 8858 [(apply~join_le).] 0. secs (0.u,0.s)
Chars 8863 - 8864 [+] 0. secs (0.u,0.s)
Chars 8865 - 8880 [transitivity~y.] 0.007 secs (0.007u,0.s)
Chars 8887 - 8888 [*] 0. secs (0.u,0.s)
Chars 8889 - 8905 [(apply~meet_lb_r).] 0. secs (0.u,0.s)
Chars 8912 - 8913 [*] 0. secs (0.u,0.s)
Chars 8914 - 8930 [(apply~join_ub_l).] 0. secs (0.u,0.s)
Chars 8935 - 8936 [+] 0. secs (0.u,0.s)
Chars 8937 - 8952 [transitivity~z.] 0.007 secs (0.007u,0.s)
Chars 8959 - 8960 [*] 0. secs (0.u,0.s)
Chars 8961 - 8977 [(apply~meet_lb_r).] 0. secs (0.u,0.s)
Chars 8984 - 8985 [*] 0. secs (0.u,0.s)
Chars 8986 - 9002 [(apply~join_ub_r).] 0. secs (0.u,0.s)
Chars 8789 - 8803 [(apply~meet_le).] 0. secs (0.u,0.s)
Chars 8808 - 8839 [(apply~join_le;~apply~meet_lb_l).] 0. secs (0.u,0.s)
Chars 8844 - 8858 [(apply~join_le).] 0. secs (0.u,0.s)
Chars 8865 - 8880 [transitivity~y.] 0. secs (0.u,0.s)
Chars 8889 - 8905 [(apply~meet_lb_r).] 0. secs (0.u,0.s)
Chars 8914 - 8930 [(apply~join_ub_l).] 0. secs (0.u,0.s)
Chars 8937 - 8952 [transitivity~z.] 0. secs (0.u,0.s)
Chars 8961 - 8977 [(apply~meet_lb_r).] 0. secs (0.u,0.s)
Chars 8986 - 9002 [(apply~join_ub_r).] 0. secs (0.u,0.s)
Chars 9005 - 9009 [Qed.] 0. secs (0.u,0.s)
Chars 9013 - 9092 [Lemma~join_meet_distr_l_le~x~y...] 0.001 secs (0.001u,0.s)
Chars 9095 - 9101 [Proof.] 0. secs (0.u,0.s)
Chars 9104 - 9118 [(apply~meet_le).] 1.081 secs (0.001u,0.002s)
Chars 9121 - 9122 [-] 0. secs (0.u,0.s)
Chars 9123 - 9137 [(apply~join_le).] 0. secs (0.u,0.s)
Chars 9142 - 9143 [+] 0. secs (0.u,0.s)
Chars 9144 - 9160 [(apply~join_ub_l).] 0. secs (0.u,0.s)
Chars 9165 - 9166 [+] 0. secs (0.u,0.s)
Chars 9167 - 9182 [transitivity~y.] 0.007 secs (0.007u,0.s)
Chars 9189 - 9190 [*] 0. secs (0.u,0.s)
Chars 9191 - 9207 [(apply~meet_lb_l).] 0. secs (0.u,0.s)
Chars 9214 - 9215 [*] 0. secs (0.u,0.s)
Chars 9216 - 9232 [(apply~join_ub_r).] 0. secs (0.u,0.s)
Chars 9235 - 9236 [-] 0. secs (0.u,0.s)
Chars 9237 - 9251 [(apply~join_le).] 0. secs (0.u,0.s)
Chars 9256 - 9257 [+] 0. secs (0.u,0.s)
Chars 9258 - 9274 [(apply~join_ub_l).] 0. secs (0.u,0.s)
Chars 9279 - 9280 [+] 0. secs (0.u,0.s)
Chars 9281 - 9296 [transitivity~z.] 0.007 secs (0.007u,0.s)
Chars 9303 - 9304 [*] 0. secs (0.u,0.s)
Chars 9305 - 9321 [(apply~meet_lb_r).] 0. secs (0.u,0.s)
Chars 9328 - 9329 [*] 0. secs (0.u,0.s)
Chars 9330 - 9346 [(apply~join_ub_r).] 0. secs (0.u,0.s)
Chars 9104 - 9118 [(apply~meet_le).] 0. secs (0.u,0.s)
Chars 9123 - 9137 [(apply~join_le).] 0. secs (0.u,0.s)
Chars 9144 - 9160 [(apply~join_ub_l).] 0. secs (0.u,0.s)
Chars 9167 - 9182 [transitivity~y.] 0. secs (0.u,0.s)
Chars 9191 - 9207 [(apply~meet_lb_l).] 0. secs (0.u,0.s)
Chars 9216 - 9232 [(apply~join_ub_r).] 0. secs (0.u,0.s)
Chars 9237 - 9251 [(apply~join_le).] 0. secs (0.u,0.s)
Chars 9258 - 9274 [(apply~join_ub_l).] 0. secs (0.u,0.s)
Chars 9281 - 9296 [transitivity~z.] 0. secs (0.u,0.s)
Chars 9305 - 9321 [(apply~meet_lb_r).] 0. secs (0.u,0.s)
Chars 9330 - 9346 [(apply~join_ub_r).] 0. secs (0.u,0.s)
Chars 9349 - 9353 [Qed.] 0. secs (0.u,0.s)
Chars 9354 - 9372 [End~lattice_order.] 0.005 secs (0.005u,0.s)
Chars 9374 - 9461 [Definition~default_join_sl_le~...] 0. secs (0.u,0.s)
Chars 9463 - 9489 [Section~join_sl_order_alt.] 0. secs (0.u,0.s)
Chars 9492 - 9611 [Context~`{IsJoinSemiLattice~L}...] 0.001 secs (0.001u,0.s)
Chars 9615 - 9681 [Lemma~alt_Build_JoinSemiLattic...] 0. secs (0.u,0.s)
Chars 9684 - 9690 [Proof.] 0. secs (0.u,0.s)
Chars 24017 - 24029 [(intros~step).] 38.239 secs (0.u,0.019s)
Chars 24032 - 24081 [(srefine~(quotient_ind_prop~_~...] 0.002 secs (0.002u,0.s)
Chars 24084 - 24095 [(apply~step).] 0. secs (0.u,0.s)
Chars 24017 - 24029 [(intros~step).] 0. secs (0.u,0.s)
Chars 24032 - 24081 [(srefine~(quotient_ind_prop~_~...] 0. secs (0.u,0.s)
Chars 24084 - 24095 [(apply~step).] 0. secs (0.u,0.s)
Chars 24096 - 24100 [Qed.] 0. secs (0.u,0.s)
Chars 24102 - 24279 [Definition~image_rec~{A}~{B~:~...] 0.015 secs (0.011u,0.003s)
Chars 24283 - 24397 [Definition~factor2~{A}~{B~:~HS...] 0.001 secs (0.001u,0.s)
Chars 24399 - 24501 [#[global]~Instance~isinjective...] 0. secs (0.u,0.s)
Chars 24502 - 24508 [Proof.] 0. secs (0.u,0.s)
Chars 19533 - 19607 [(intro~h;~srapply~(seq_colim_s...] 40.106 secs (0.007u,0.021s)
Chars 19610 - 19695 [(srapply~((transport_compose~_...] 0.008 secs (0.008u,0.s)
Chars 19533 - 19607 [(intro~h;~srapply~(seq_colim_s...] 0.002 secs (0.002u,0.s)
Chars 19610 - 19695 [(srapply~((transport_compose~_...] 0.003 secs (0.003u,0.s)
Chars 19696 - 19704 [Defined.] 0.012 secs (0.011u,0.s)
Chars 19837 - 19977 [#[global]~Instance~isequiv_seq...] 0.001 secs (0.001u,0.s)
Chars 19978 - 19984 [Proof.] 0. secs (0.u,0.s)
Chars 9246 - 9257 [(intros~x~y).] 40.094 secs (0.u,0.018s)
Chars 9258 - 9272 [(unfold~Stable).] 0. secs (0.u,0.s)
Chars 9275 - 9285 [(intros~dn).] 0. secs (0.u,0.s)
Chars 9286 - 9311 [(apply~le_iff_not_lt_flip).] 0.001 secs (0.001u,0.s)
Chars 9314 - 9323 [(intros~E).] 0. secs (0.u,0.s)
Chars 9324 - 9333 [(apply~dn).] 0. secs (0.u,0.s)
Chars 9336 - 9382 [(intros~E';~apply~le_iff_not_l...] 0.002 secs (0.002u,0.s)
Chars 9246 - 9257 [(intros~x~y).] 0. secs (0.u,0.s)
Chars 9258 - 9272 [(unfold~Stable).] 0. secs (0.u,0.s)
Chars 9275 - 9285 [(intros~dn).] 0. secs (0.u,0.s)
Chars 9286 - 9311 [(apply~le_iff_not_lt_flip).] 0. secs (0.u,0.s)
Chars 9314 - 9323 [(intros~E).] 0. secs (0.u,0.s)
Chars 9324 - 9333 [(apply~dn).] 0. secs (0.u,0.s)
Chars 9336 - 9382 [(intros~E';~apply~le_iff_not_l...] 0. secs (0.u,0.s)
Chars 9385 - 9389 [Qed.] 0. secs (0.u,0.s)
Chars 9393 - 9471 [Lemma~le_or_lt~`{!TrivialApart...] 0. secs (0.u,0.s)
Chars 9474 - 9480 [Proof.] 0. secs (0.u,0.s)
"notFunext has been translated as notFunextᵗ"
Chars 24511 - 24537 [(unfold~IsInjective,~image).] 20.618 secs (0.u,0.02s)
Chars 24540 - 24588 [(refine~(quotient_ind_prop~_~_...] 0.024 secs (0.023u,0.001s)
Chars 24591 - 24639 [(refine~(quotient_ind_prop~_~_...] 0.019 secs (0.016u,0.002s)
Chars 24642 - 24668 [rapply~related_classes_eq.] 0.017 secs (0.012u,0.004s)
Chars 24511 - 24537 [(unfold~IsInjective,~image).] 0. secs (0.u,0.s)
Chars 24540 - 24588 [(refine~(quotient_ind_prop~_~_...] 0.001 secs (0.001u,0.s)
Chars 24591 - 24639 [(refine~(quotient_ind_prop~_~_...] 0.001 secs (0.001u,0.s)
Chars 24642 - 24668 [rapply~related_classes_eq.] 0. secs (0.u,0.s)
Chars 24669 - 24673 [Qed.] 0.004 secs (0.003u,0.s)
Chars 24676 - 24774 [Definition~limit~`{Univalence}...] 0. secs (0.u,0.s)
Chars 24775 - 24781 [Proof.] 0. secs (0.u,0.s)
Chars 9693 - 9706 [(repeat~split).] 40.014 secs (0.001u,0.003s)
Chars 9709 - 9710 [-] 0. secs (0.u,0.s)
Chars 9711 - 9719 [(apply~_).] 0.01 secs (0.01u,0.s)
Chars 9722 - 9723 [-] 0. secs (0.u,0.s)
Chars 9724 - 9732 [(apply~_).] 0. secs (0.u,0.s)
Chars 9735 - 9736 [-] 0. secs (0.u,0.s)
Chars 9737 - 9746 [(intros~x).] 0. secs (0.u,0.s)
Chars 9751 - 9768 [(apply~le_correct).] 0. secs (0.u,0.s)
Chars 9769 - 9793 [(apply~binary_idempotent).] 0.002 secs (0.002u,0.s)
Chars 9796 - 9797 [-] 0. secs (0.u,0.s)
Chars 9798 - 9817 [(intros~x~y~z~E1~E2).] 0. secs (0.u,0.s)
Chars 9822 - 9885 [(apply~le_correct~in~E1;~apply...] 0.001 secs (0.001u,0.s)
Chars 9890 - 9929 [(rewrite~<-~E2,~simple_associa...] 0.007 secs (0.007u,0.s)
Chars 9930 - 9942 [reflexivity.] 0. secs (0.u,0.s)
Chars 9945 - 9946 [-] 0. secs (0.u,0.s)
Chars 9947 - 9964 [(intros~x~y~E1~E2).] 0. secs (0.u,0.s)
Chars 9969 - 10015 [(apply~le_correct~in~E1;~apply...] 0.001 secs (0.001u,0.s)
Chars 10020 - 10060 [(rewrite~<-~E1,~(commutativity...] 0.003 secs (0.003u,0.s)
Chars 10065 - 10088 [(apply~symmetry;~trivial).] 0.001 secs (0.001u,0.s)
Chars 10091 - 10092 [-] 0. secs (0.u,0.s)
Chars 10093 - 10100 [(intros).] 0. secs (0.u,0.s)
Chars 10101 - 10118 [(apply~le_correct).] 0. secs (0.u,0.s)
Chars 10123 - 10170 [(rewrite~simple_associativity,...] 0.009 secs (0.009u,0.s)
Chars 10175 - 10187 [reflexivity.] 0. secs (0.u,0.s)
Chars 10190 - 10191 [-] 0. secs (0.u,0.s)
Chars 10192 - 10216 [(intros;~apply~le_correct).] 0.001 secs (0.001u,0.s)
Chars 10221 - 10255 [(rewrite~(commutativity~(f:=jo...] 0.015 secs (0.012u,0.002s)
Chars 10260 - 10291 [(rewrite~<-~simple_associativi...] 0.005 secs (0.005u,0.s)
Chars 10296 - 10322 [(rewrite~(idempotency~_~_)).] 0.003 secs (0.003u,0.s)
Chars 10327 - 10339 [reflexivity.] 0. secs (0.u,0.s)
Chars 10342 - 10343 [-] 0. secs (0.u,0.s)
Chars 10344 - 10363 [(intros~x~y~z~E1~E2).] 0. secs (0.u,0.s)
Chars 10368 - 10431 [(apply~le_correct~in~E1;~apply...] 0.002 secs (0.002u,0.s)
Chars 10436 - 10471 [(rewrite~<-~simple_associativi...] 0.006 secs (0.006u,0.s)
Chars 10472 - 10480 [trivial.] 0. secs (0.u,0.s)
Chars 9693 - 9706 [(repeat~split).] 0. secs (0.u,0.s)
Chars 9711 - 9719 [(apply~_).] 0. secs (0.u,0.s)
Chars 9724 - 9732 [(apply~_).] 0. secs (0.u,0.s)
Chars 9737 - 9746 [(intros~x).] 0. secs (0.u,0.s)
Chars 9751 - 9768 [(apply~le_correct).] 0. secs (0.u,0.s)
Chars 9769 - 9793 [(apply~binary_idempotent).] 0. secs (0.u,0.s)
Chars 9798 - 9817 [(intros~x~y~z~E1~E2).] 0. secs (0.u,0.s)
Chars 9822 - 9885 [(apply~le_correct~in~E1;~apply...] 0. secs (0.u,0.s)
Chars 9890 - 9929 [(rewrite~<-~E2,~simple_associa...] 0. secs (0.u,0.s)
Chars 9930 - 9942 [reflexivity.] 0. secs (0.u,0.s)
Chars 9947 - 9964 [(intros~x~y~E1~E2).] 0. secs (0.u,0.s)
Chars 9969 - 10015 [(apply~le_correct~in~E1;~apply...] 0. secs (0.u,0.s)
Chars 10020 - 10060 [(rewrite~<-~E1,~(commutativity...] 0. secs (0.u,0.s)
Chars 10065 - 10088 [(apply~symmetry;~trivial).] 0. secs (0.u,0.s)
Chars 10093 - 10100 [(intros).] 0. secs (0.u,0.s)
Chars 10101 - 10118 [(apply~le_correct).] 0. secs (0.u,0.s)
Chars 10123 - 10170 [(rewrite~simple_associativity,...] 0. secs (0.u,0.s)
Chars 10175 - 10187 [reflexivity.] 0. secs (0.u,0.s)
Chars 10192 - 10216 [(intros;~apply~le_correct).] 0. secs (0.u,0.s)
Chars 10221 - 10255 [(rewrite~(commutativity~(f:=jo...] 0. secs (0.u,0.s)
Chars 10260 - 10291 [(rewrite~<-~simple_associativi...] 0. secs (0.u,0.s)
Chars 10296 - 10322 [(rewrite~(idempotency~_~_)).] 0. secs (0.u,0.s)
Chars 10327 - 10339 [reflexivity.] 0. secs (0.u,0.s)
Chars 10344 - 10363 [(intros~x~y~z~E1~E2).] 0. secs (0.u,0.s)
Chars 10368 - 10431 [(apply~le_correct~in~E1;~apply...] 0. secs (0.u,0.s)
Chars 10436 - 10471 [(rewrite~<-~simple_associativi...] 0. secs (0.u,0.s)
Chars 10472 - 10480 [trivial.] 0. secs (0.u,0.s)
Chars 10483 - 10487 [Qed.] 0.002 secs (0.002u,0.s)
Chars 10488 - 10510 [End~join_sl_order_alt.] 0.008 secs (0.008u,0.s)
Chars 10512 - 10599 [Definition~default_meet_sl_le~...] 0. secs (0.u,0.s)
Chars 10601 - 10627 [Section~meet_sl_order_alt.] 0. secs (0.u,0.s)
Chars 10630 - 10749 [Context~`{IsMeetSemiLattice~L}...] 0.001 secs (0.001u,0.s)
Chars 10753 - 10819 [Lemma~alt_Build_MeetSemiLattic...] 0. secs (0.u,0.s)
Chars 10822 - 10828 [Proof.] 0. secs (0.u,0.s)
Chars 19987 - 20056 [(assert~(L~:~{G~:~_~&~G~o~seq_...] 40.103 secs (0.003u,0.02s)
Chars 20059 - 20060 [-] 0. secs (0.u,0.s)
Chars 20061 - 20075 [srapply~(_;~_).] 0.002 secs (0.u,0.001s)
Chars 20080 - 20081 [+] 0. secs (0.u,0.s)
Chars 20082 - 20108 [srapply~seq_colim_sum_rec.] 0.004 secs (0.002u,0.001s)
Chars 20115 - 20116 [*] 0. secs (0.u,0.s)
Chars 20117 - 20162 [exact~(fun~n~a~b~=>~inj~(sig_s...] 0.002 secs (0.002u,0.s)
Chars 20169 - 20170 [*] 0. secs (0.u,0.s)
Chars 20171 - 20217 [exact~(fun~n~a~b~=>~glue~(sig_...] 0.003 secs (0.003u,0.s)
Chars 20222 - 20223 [+] 0. secs (0.u,0.s)
Chars 20224 - 20249 [srapply~seq_colimit_uniq.] 0.007 secs (0.006u,0.s)
Chars 20256 - 20257 [*] 0. secs (0.u,0.s)
Chars 20258 - 20284 [exact~(fun~n~a~=>~idpath).] 0.006 secs (0.005u,0.s)
Chars 20291 - 20292 [*] 0. secs (0.u,0.s)
Chars 20293 - 20356 [(intros~n~a;~rewrite~concat_1p...] 0.101 secs (0.082u,0.018s)
Chars 20365 - 20414 [(rewrite~seq_colim_sum_rec_bet...] 0.077 secs (0.068u,0.008s)
Chars 20417 - 20418 [-] 0. secs (0.u,0.s)
Chars 20419 - 20490 [(srapply~(isequiv_adjointify~_...] 0.017 secs (0.017u,0.s)
Chars 20495 - 20529 [(intro~x;~rewrite~L.2;~reflexi...] 0.013 secs (0.009u,0.003s)
Chars 19987 - 20056 [(assert~(L~:~{G~:~_~&~G~o~seq_...] 0. secs (0.u,0.s)
Chars 20061 - 20075 [srapply~(_;~_).] 0.001 secs (0.001u,0.s)
Chars 20082 - 20108 [srapply~seq_colim_sum_rec.] 0. secs (0.u,0.s)
Chars 20117 - 20162 [exact~(fun~n~a~b~=>~inj~(sig_s...] 0. secs (0.u,0.s)
Chars 20171 - 20217 [exact~(fun~n~a~b~=>~glue~(sig_...] 0. secs (0.u,0.s)
Chars 20224 - 20249 [srapply~seq_colimit_uniq.] 0.001 secs (0.u,0.s)
Chars 20258 - 20284 [exact~(fun~n~a~=>~idpath).] 0.001 secs (0.001u,0.s)
Chars 20293 - 20356 [(intros~n~a;~rewrite~concat_1p...] 0.008 secs (0.007u,0.s)
Chars 20365 - 20414 [(rewrite~seq_colim_sum_rec_bet...] 0.003 secs (0.003u,0.s)
Chars 20419 - 20490 [(srapply~(isequiv_adjointify~_...] 0.005 secs (0.004u,0.s)
Chars 20495 - 20529 [(intro~x;~rewrite~L.2;~reflexi...] 0.006 secs (0.005u,0.s)
Chars 20530 - 20538 [Defined.] 0.1 secs (0.098u,0.002s)
Chars 20540 - 20748 [Definition~equiv_seq_colim_sum...] 0.002 secs (0.002u,0.s)
Chars 20900 - 21065 [Definition~seq_colim_sum_to_su...] 0.001 secs (0.001u,0.s)
Chars 21066 - 21072 [Proof.] 0. secs (0.u,0.s)
Chars 9483 - 9533 [(destruct~(trichotomy~(<)~x~y)...] 40.102 secs (0.013u,0.019s)
Chars 9536 - 9537 [-] 0. secs (0.u,0.s)
Chars 9538 - 9543 [left.] 0. secs (0.u,0.s)
Chars 9544 - 9564 [(apply~lt_le;~trivial).] 0.001 secs (0.001u,0.s)
Chars 9567 - 9568 [-] 0. secs (0.u,0.s)
Chars 9569 - 9574 [left.] 0. secs (0.u,0.s)
Chars 9575 - 9595 [(apply~eq_le;~trivial).] 0.003 secs (0.003u,0.s)
Chars 9483 - 9533 [(destruct~(trichotomy~(<)~x~y)...] 0. secs (0.u,0.s)
Chars 9538 - 9543 [left.] 0. secs (0.u,0.s)
Chars 9544 - 9564 [(apply~lt_le;~trivial).] 0. secs (0.u,0.s)
Chars 9569 - 9574 [left.] 0. secs (0.u,0.s)
Chars 9575 - 9595 [(apply~eq_le;~trivial).] 0. secs (0.u,0.s)
Chars 9598 - 9602 [Qed.] 0.001 secs (0.u,0.s)
Chars 9606 - 9693 [#[global]~Instance~le_total~~`...] 0. secs (0.u,0.s)
Chars 9696 - 9702 [Proof.] 0. secs (0.u,0.s)
Chars 21075 - 21100 [srapply~seq_colimit_uniq.] 11.799 secs (0.004u,0.021s)
Chars 21103 - 21104 [-] 0. secs (0.u,0.s)
Chars 21105 - 21131 [exact~(fun~n~a~=>~idpath).] 0.001 secs (0.001u,0.s)
Chars 21134 - 21135 [-] 0. secs (0.u,0.s)
Chars 21136 - 21219 [(intros~n~[a~b];~~~rewrite~con...] 0.107 secs (0.094u,0.012s)
Chars 21224 - 21292 [(rewrite~ap_pp,~(Delta_proj~_~...] 0.04 secs (0.033u,0.006s)
Chars 21297 - 21370 [(srapply~(whiskerL~_~_~@~conca...] 0.019 secs (0.017u,0.001s)
Chars 21375 - 21405 [(rewrite~ap_const;~reflexivity).] 0.003 secs (0.002u,0.001s)
Chars 21075 - 21100 [srapply~seq_colimit_uniq.] 0. secs (0.u,0.s)
Chars 21105 - 21131 [exact~(fun~n~a~=>~idpath).] 0. secs (0.u,0.s)
Chars 21136 - 21219 [(intros~n~[a~b];~~~rewrite~con...] 0.002 secs (0.001u,0.s)
Chars 21224 - 21292 [(rewrite~ap_pp,~(Delta_proj~_~...] 0.003 secs (0.002u,0.001s)
Chars 21297 - 21370 [(srapply~(whiskerL~_~_~@~conca...] 0.004 secs (0.004u,0.s)
Chars 21375 - 21405 [(rewrite~ap_const;~reflexivity).] 0. secs (0.u,0.s)
Chars 21406 - 21414 [Defined.] 0.165 secs (0.148u,0.016s)
Chars 21508 - 21635 [Definition~path_seq~(A~:~Seque...] 0.001 secs (0.001u,0.s)
Chars 21637 - 21774 [Definition~equiv_path_colim_ze...] 0.001 secs (0.001u,0.s)
Chars 21776 - 21782 [Proof.] 0. secs (0.u,0.s)
"notη has been translated as notηᵗ"
"~~~~~~~~~~~~~~~~~~"
"Translating Coq.Init.Logic.eq"
"Coq.Init.Logic.eq was already translated"
"Translating MetaCoq.Translations.MiniHoTT.paths"
"MetaCoq.Translations.MiniHoTT.paths was already translated"
"Translating MetaCoq.Translations.times_bool_fun.UIP"
"UIP has been translated as UIPᵗ"
Chars 24784 - 24827 [(set~(f~:=~fun~x~:~{i~:~X~&~F~...] 40.082 secs (0.001u,0.021s)
Chars 24830 - 24866 [(set~(carrier~:=~image~f~:~Typ...] 0.001 secs (0.u,0.001s)
Chars 24869 - 25002 [(set~~~(relation~:=~~~~fun~A~B...] 0.006 secs (0.006u,0.s)
Chars 25005 - 25029 [exists~carrier~relation.] 0.001 secs (0.001u,0.s)
Chars 25032 - 25075 [srapply~(isordinal_simulation~...] 0.014 secs (0.01u,0.003s)
Chars 25078 - 25079 [-] 0. secs (0.u,0.s)
Chars 25080 - 25088 [exact~_.] 0.001 secs (0.u,0.s)
Chars 25091 - 25092 [-] 0. secs (0.u,0.s)
Chars 25093 - 25101 [exact~_.] 0.001 secs (0.001u,0.s)
Chars 25104 - 25105 [-] 0. secs (0.u,0.s)
Chars 25106 - 25123 [(constructor;~cbn).] 0.005 secs (0.005u,0.s)
Chars 25128 - 25129 [+] 0. secs (0.u,0.s)
Chars 25130 - 25147 [(intros~x~x'~x_x').] 0.001 secs (0.001u,0.s)
Chars 25154 - 25174 [(unfold~lt,~relation).] 0.001 secs (0.001u,0.s)
Chars 25175 - 25208 [(apply~equiv_resize_hprop~in~x...] 0.002 secs (0.002u,0.s)
Chars 25209 - 25220 [exact~x_x'.] 0.001 secs (0.u,0.s)
Chars 25225 - 25226 [+] 0. secs (0.u,0.s)
Chars 25227 - 25259 [(rapply~image_ind_prop;~intros...] 0.059 secs (0.051u,0.007s)
Chars 25260 - 25264 [(cbn).] 0.001 secs (0.001u,0.s)
Chars 25271 - 25285 [(intros~B~B_fa).] 0.001 secs (0.001u,0.s)
Chars 25286 - 25295 [(apply~tr).] 0.001 secs (0.001u,0.s)
Chars 25302 - 25345 [exists~(factor1~f~(a.1;~out~(b...] 0.005 secs (0.005u,0.s)
Chars 25346 - 25350 [(cbn).] 0.002 secs (0.002u,0.s)
Chars 25357 - 25385 [(unfold~lt,~relation,~f;~cbn).] 0.006 secs (0.006u,0.s)
Chars 25392 - 25433 [(assert~(↓(out~(bound~B_fa))~=...] 0.006 secs (0.005u,0.s)
Chars 25434 - 25435 [{] 0. secs (0.u,0.s)
Chars 25444 - 25490 [(rewrite~(path_initial_segment...] 0.005 secs (0.004u,0.s)
Chars 25499 - 25508 [symmetry.] 0.002 secs (0.002u,0.s)
Chars 25509 - 25530 [(apply~bound_property).] 0.002 secs (0.002u,0.s)
Chars 25537 - 25538 [}] 0. secs (0.u,0.s)
Chars 25545 - 25551 [split.] 0.001 secs (0.u,0.s)
Chars 25558 - 25559 [*] 0. secs (0.u,0.s)
Chars 25560 - 25585 [(apply~equiv_resize_hprop).] 0.001 secs (0.001u,0.s)
Chars 25586 - 25597 [exact~B_fa.] 0.001 secs (0.001u,0.s)
Chars 25604 - 25605 [*] 0. secs (0.u,0.s)
Chars 25606 - 25618 [reflexivity.] 0. secs (0.u,0.s)
Chars 24784 - 24827 [(set~(f~:=~fun~x~:~{i~:~X~&~F~...] 0. secs (0.u,0.s)
Chars 24830 - 24866 [(set~(carrier~:=~image~f~:~Typ...] 0. secs (0.u,0.s)
Chars 24869 - 25002 [(set~~~(relation~:=~~~~fun~A~B...] 0. secs (0.u,0.s)
Chars 25005 - 25029 [exists~carrier~relation.] 0. secs (0.u,0.s)
Chars 25032 - 25075 [srapply~(isordinal_simulation~...] 0. secs (0.u,0.s)
Chars 25080 - 25088 [exact~_.] 0. secs (0.u,0.s)
Chars 25093 - 25101 [exact~_.] 0. secs (0.u,0.s)
Chars 25106 - 25123 [(constructor;~cbn).] 0.003 secs (0.001u,0.001s)
Chars 25130 - 25147 [(intros~x~x'~x_x').] 0.001 secs (0.001u,0.s)
Chars 25154 - 25174 [(unfold~lt,~relation).] 0.001 secs (0.001u,0.s)
Chars 25175 - 25208 [(apply~equiv_resize_hprop~in~x...] 0. secs (0.u,0.s)
Chars 25209 - 25220 [exact~x_x'.] 0.001 secs (0.001u,0.s)
Chars 25227 - 25259 [(rapply~image_ind_prop;~intros...] 0.002 secs (0.002u,0.s)
Chars 25260 - 25264 [(cbn).] 0.001 secs (0.001u,0.s)
Chars 25271 - 25285 [(intros~B~B_fa).] 0.001 secs (0.001u,0.s)
Chars 25286 - 25295 [(apply~tr).] 0.001 secs (0.001u,0.s)
Chars 25302 - 25345 [exists~(factor1~f~(a.1;~out~(b...] 0.001 secs (0.001u,0.s)
Chars 25346 - 25350 [(cbn).] 0.001 secs (0.001u,0.s)
Chars 25357 - 25385 [(unfold~lt,~relation,~f;~cbn).] 0.003 secs (0.003u,0.s)
Chars 25392 - 25433 [(assert~(↓(out~(bound~B_fa))~=...] 0.001 secs (0.001u,0.s)
Chars 25444 - 25490 [(rewrite~(path_initial_segment...] 0. secs (0.u,0.s)
Chars 25499 - 25508 [symmetry.] 0. secs (0.u,0.s)
Chars 25509 - 25530 [(apply~bound_property).] 0. secs (0.u,0.s)
Chars 25545 - 25551 [split.] 0. secs (0.u,0.s)
Chars 25560 - 25585 [(apply~equiv_resize_hprop).] 0. secs (0.u,0.s)
Chars 25586 - 25597 [exact~B_fa.] 0. secs (0.u,0.s)
Chars 25606 - 25618 [reflexivity.] 0. secs (0.u,0.s)
Chars 25619 - 25627 [Defined.] 0.019 secs (0.018u,0.s)
Chars 25632 - 25725 [#[global]~Instance~le_on_Ordin...] 0.001 secs (0.001u,0.s)
Chars 25728 - 25860 [Definition~limit_is_upper_boun...] 0.001 secs (0.001u,0.s)
Chars 25861 - 25867 [Proof.] 0. secs (0.u,0.s)
Chars 10831 - 10844 [(repeat~split).] 40.014 secs (0.001u,0.003s)
Chars 10847 - 10848 [-] 0. secs (0.u,0.s)
Chars 10849 - 10857 [(apply~_).] 0.009 secs (0.009u,0.s)
Chars 10860 - 10861 [-] 0. secs (0.u,0.s)
Chars 10862 - 10870 [(apply~_).] 0. secs (0.u,0.s)
Chars 10873 - 10874 [-] 0. secs (0.u,0.s)
Chars 10875 - 10884 [(intros~?).] 0. secs (0.u,0.s)
Chars 10885 - 10902 [(apply~le_correct).] 0. secs (0.u,0.s)
Chars 10903 - 10927 [(apply~(idempotency~_~_)).] 0.001 secs (0.001u,0.s)
Chars 10930 - 10931 [-] 0. secs (0.u,0.s)
Chars 10932 - 10951 [(intros~?~?~?~E1~E2).] 0. secs (0.u,0.s)
Chars 10956 - 11019 [(apply~le_correct~in~E1;~apply...] 0.001 secs (0.001u,0.s)
Chars 11024 - 11065 [(rewrite~<-~E1,~<-~simple_asso...] 0.003 secs (0.003u,0.s)
Chars 11070 - 11082 [reflexivity.] 0. secs (0.u,0.s)
Chars 11085 - 11086 [-] 0. secs (0.u,0.s)
Chars 11087 - 11104 [(intros~?~?~E1~E2).] 0. secs (0.u,0.s)
Chars 11109 - 11155 [(apply~le_correct~in~E1;~apply...] 0.001 secs (0.001u,0.s)
Chars 11160 - 11200 [(rewrite~<-~E2,~(commutativity...] 0.002 secs (0.002u,0.s)
Chars 11205 - 11223 [(apply~symmetry,~E1).] 0. secs (0.u,0.s)
Chars 11226 - 11227 [-] 0. secs (0.u,0.s)
Chars 11228 - 11239 [(intros~?~?).] 0. secs (0.u,0.s)
Chars 11240 - 11257 [(apply~le_correct).] 0. secs (0.u,0.s)
Chars 11262 - 11337 [(rewrite~(commutativity~(f:=me...] 0.006 secs (0.006u,0.s)
Chars 11342 - 11354 [reflexivity.] 0. secs (0.u,0.s)
Chars 11357 - 11358 [-] 0. secs (0.u,0.s)
Chars 11359 - 11370 [(intros~?~?).] 0. secs (0.u,0.s)
Chars 11371 - 11388 [(apply~le_correct).] 0. secs (0.u,0.s)
Chars 11393 - 11443 [(rewrite~<-~simple_associativi...] 0.004 secs (0.004u,0.s)
Chars 11448 - 11460 [reflexivity.] 0. secs (0.u,0.s)
Chars 11463 - 11464 [-] 0. secs (0.u,0.s)
Chars 11465 - 11484 [(intros~?~?~?~E1~E2).] 0. secs (0.u,0.s)
Chars 11489 - 11552 [(apply~le_correct~in~E1;~apply...] 0.002 secs (0.002u,0.s)
Chars 11557 - 11583 [(rewrite~associativity,~E1).] 0.003 secs (0.002u,0.s)
Chars 11588 - 11596 [trivial.] 0. secs (0.u,0.s)
Chars 10831 - 10844 [(repeat~split).] 0. secs (0.u,0.s)
Chars 10849 - 10857 [(apply~_).] 0. secs (0.u,0.s)
Chars 10862 - 10870 [(apply~_).] 0. secs (0.u,0.s)
Chars 10875 - 10884 [(intros~?).] 0. secs (0.u,0.s)
Chars 10885 - 10902 [(apply~le_correct).] 0. secs (0.u,0.s)
Chars 10903 - 10927 [(apply~(idempotency~_~_)).] 0. secs (0.u,0.s)
Chars 10932 - 10951 [(intros~?~?~?~E1~E2).] 0. secs (0.u,0.s)
Chars 10956 - 11019 [(apply~le_correct~in~E1;~apply...] 0. secs (0.u,0.s)
Chars 11024 - 11065 [(rewrite~<-~E1,~<-~simple_asso...] 0. secs (0.u,0.s)
Chars 11070 - 11082 [reflexivity.] 0. secs (0.u,0.s)
Chars 11087 - 11104 [(intros~?~?~E1~E2).] 0. secs (0.u,0.s)
Chars 11109 - 11155 [(apply~le_correct~in~E1;~apply...] 0. secs (0.u,0.s)
Chars 11160 - 11200 [(rewrite~<-~E2,~(commutativity...] 0. secs (0.u,0.s)
Chars 11205 - 11223 [(apply~symmetry,~E1).] 0. secs (0.u,0.s)
Chars 11228 - 11239 [(intros~?~?).] 0. secs (0.u,0.s)
Chars 11240 - 11257 [(apply~le_correct).] 0. secs (0.u,0.s)
Chars 11262 - 11337 [(rewrite~(commutativity~(f:=me...] 0. secs (0.u,0.s)
Chars 11342 - 11354 [reflexivity.] 0. secs (0.u,0.s)
Chars 11359 - 11370 [(intros~?~?).] 0. secs (0.u,0.s)
Chars 11371 - 11388 [(apply~le_correct).] 0. secs (0.u,0.s)
Chars 11393 - 11443 [(rewrite~<-~simple_associativi...] 0. secs (0.u,0.s)
Chars 11448 - 11460 [reflexivity.] 0. secs (0.u,0.s)
Chars 11465 - 11484 [(intros~?~?~?~E1~E2).] 0. secs (0.u,0.s)
Chars 11489 - 11552 [(apply~le_correct~in~E1;~apply...] 0. secs (0.u,0.s)
Chars 11557 - 11583 [(rewrite~associativity,~E1).] 0. secs (0.u,0.s)
Chars 11588 - 11596 [trivial.] 0. secs (0.u,0.s)
Chars 11599 - 11603 [Qed.] 0.002 secs (0.001u,0.s)
Chars 11604 - 11626 [End~meet_sl_order_alt.] 0.008 secs (0.008u,0.s)
Chars 11628 - 11658 [Section~join_order_preserving.] 0. secs (0.u,0.s)
Chars 11661 - 11761 [Context~`{JoinSemiLatticeOrder...] 0.001 secs (0.001u,0.s)
Chars 11765 - 11813 [Lemma~join_sl_mor_preserving~:...] 0. secs (0.u,0.s)
Chars 11816 - 11822 [Proof.] 0. secs (0.u,0.s)
Chars 9705 - 9724 [(split;~try~apply~_).] 40.096 secs (0.002u,0.019s)
Chars 9727 - 9738 [(intros~x~y).] 0. secs (0.u,0.s)
Chars 9741 - 9771 [(destruct~(le_or_lt~x~y);~auto).] 0.035 secs (0.029u,0.005s)
Chars 9774 - 9780 [right.] 0. secs (0.u,0.s)
Chars 9781 - 9793 [(apply~lt_le).] 0.001 secs (0.001u,0.s)
Chars 9796 - 9804 [trivial.] 0. secs (0.u,0.s)
Chars 9705 - 9724 [(split;~try~apply~_).] 0. secs (0.u,0.s)
Chars 9727 - 9738 [(intros~x~y).] 0. secs (0.u,0.s)
Chars 9741 - 9771 [(destruct~(le_or_lt~x~y);~auto).] 0. secs (0.u,0.s)
Chars 9774 - 9780 [right.] 0. secs (0.u,0.s)
Chars 9781 - 9793 [(apply~lt_le).] 0. secs (0.u,0.s)
Chars 9796 - 9804 [trivial.] 0. secs (0.u,0.s)
Chars 9807 - 9811 [Qed.] 0.001 secs (0.001u,0.s)
Chars 9815 - 9905 [Lemma~not_le_lt_flip~`{!Trivia...] 0.001 secs (0.u,0.s)
Chars 9908 - 9914 [Proof.] 0. secs (0.u,0.s)
Chars 21785 - 21873 [(pose~~~(B~:=~~~~Build_FibSequ...] 40.097 secs (0.002u,0.021s)
Chars 21876 - 21926 [transitivity~(fib_seq_to_type_...] 0.003 secs (0.003u,0.s)
Chars 21929 - 21930 [+] 0. secs (0.u,0.s)
Chars 21931 - 21971 [(symmetry;~srapply~equiv_path_...] 0.017 secs (0.016u,0.s)
Chars 21976 - 21977 [-] 0. secs (0.u,0.s)
Chars 21978 - 22025 [exact~(inj~(fib_seq_to_seq~B~(...] 0.002 secs (0.002u,0.s)
Chars 22030 - 22031 [-] 0. secs (0.u,0.s)
Chars 22032 - 22091 [srefine~(contr_equiv~_~(seq_co...] 0.008 secs (0.006u,0.001s)
Chars 22098 - 22163 [(srapply~contr_colim_contr_seq...] 0.015 secs (0.013u,0.001s)
Chars 22166 - 22167 [+] 0. secs (0.u,0.s)
Chars 22168 - 22256 [(srapply~equiv_functor_colimit...] 0.018 secs (0.014u,0.004s)
Chars 22261 - 22289 [srapply~Build_diagram_equiv.] 0.051 secs (0.041u,0.01s)
Chars 22294 - 22295 [*] 0. secs (0.u,0.s)
Chars 22296 - 22321 [srapply~Build_DiagramMap.] 0.001 secs (0.001u,0.s)
Chars 22328 - 22329 [-] 0. secs (0.u,0.s)
Chars 22330 - 22390 [exact~(fun~n~=>~coe~(ap~B~(seq...] 0.002 secs (0.002u,0.s)
Chars 22397 - 22398 [-] 0. secs (0.u,0.s)
Chars 22399 - 22475 [(intros~n~m~p~b;~destruct~p;~s...] 0.012 secs (0.009u,0.002s)
Chars 22480 - 22481 [*] 0. secs (0.u,0.s)
Chars 22482 - 22512 [(intro~n;~srapply~isequiv_path).] 0.004 secs (0.004u,0.s)
Chars 21785 - 21873 [(pose~~~(B~:=~~~~Build_FibSequ...] 0. secs (0.u,0.s)
Chars 21876 - 21926 [transitivity~(fib_seq_to_type_...] 0. secs (0.u,0.s)
Chars 21931 - 21971 [(symmetry;~srapply~equiv_path_...] 0. secs (0.u,0.s)
Chars 21978 - 22025 [exact~(inj~(fib_seq_to_seq~B~(...] 0. secs (0.u,0.s)
Chars 22032 - 22091 [srefine~(contr_equiv~_~(seq_co...] 0. secs (0.u,0.s)
Chars 22098 - 22163 [(srapply~contr_colim_contr_seq...] 0.001 secs (0.001u,0.s)
Chars 22168 - 22256 [(srapply~equiv_functor_colimit...] 0. secs (0.u,0.s)
Chars 22261 - 22289 [srapply~Build_diagram_equiv.] 0. secs (0.u,0.s)
Chars 22296 - 22321 [srapply~Build_DiagramMap.] 0. secs (0.u,0.s)
Chars 22330 - 22390 [exact~(fun~n~=>~coe~(ap~B~(seq...] 0. secs (0.u,0.s)
Chars 22399 - 22475 [(intros~n~m~p~b;~destruct~p;~s...] 0.002 secs (0.002u,0.s)
Chars 22482 - 22512 [(intro~n;~srapply~isequiv_path).] 0.002 secs (0.002u,0.s)
Chars 22513 - 22521 [Defined.] 0.006 secs (0.005u,0.s)
Chars 22616 - 22764 [Definition~equiv_path_colim~`{...] 0.001 secs (0.001u,0.s)
Chars 22765 - 22771 [Proof.] 0. secs (0.u,0.s)
Chars 25870 - 25891 [(unfold~le_on_Ordinal).] 40.089 secs (0.u,0.019s)
Chars 25894 - 25903 [(intros~x).] 0. secs (0.u,0.s)
Chars 25904 - 25914 [(unfold~le).] 0. secs (0.u,0.s)
Chars 25917 - 25952 [exists~(fun~u~=>~factor1~_~(x;...] 0.003 secs (0.003u,0.s)
Chars 25955 - 25961 [split.] 0.001 secs (0.001u,0.s)
Chars 25964 - 25965 [-] 0. secs (0.u,0.s)
Chars 25966 - 25981 [(intros~u~v~u_v).] 0. secs (0.u,0.s)
Chars 25982 - 25997 [(unfold~lt;~cbn).] 0.004 secs (0.003u,0.s)
Chars 25998 - 26023 [(apply~equiv_resize_hprop).] 0.001 secs (0.001u,0.s)
Chars 26028 - 26062 [(apply~isembedding_initial_seg...] 0.002 secs (0.002u,0.s)
Chars 26063 - 26073 [exact~u_v.] 0. secs (0.u,0.s)
Chars 26076 - 26077 [-] 0. secs (0.u,0.s)
Chars 26078 - 26087 [(intros~u).] 0. secs (0.u,0.s)
Chars 26088 - 26120 [(rapply~image_ind_prop;~intros...] 0.072 secs (0.06u,0.011s)
Chars 26125 - 26136 [(intros~a_u).] 0.001 secs (0.001u,0.s)
Chars 26137 - 26169 [(apply~equiv_resize_hprop~in~a...] 0.005 secs (0.002u,0.002s)
Chars 26170 - 26181 [(cbn~in~a_u).] 0.002 secs (0.002u,0.s)
Chars 26186 - 26195 [(apply~tr).] 0.001 secs (0.001u,0.s)
Chars 26196 - 26221 [exists~(out~(bound~a_u)).] 0.003 secs (0.002u,0.s)
Chars 26222 - 26228 [split.] 0.002 secs (0.002u,0.s)
Chars 26233 - 26234 [+] 0. secs (0.u,0.s)
Chars 26235 - 26266 [(apply~initial_segment_property).] 0.001 secs (0.001u,0.s)
Chars 26271 - 26272 [+] 0. secs (0.u,0.s)
Chars 26273 - 26303 [(apply~(injective~(factor2~_))).] 0.006 secs (0.005u,0.s)
Chars 26304 - 26308 [(cbn).] 0.002 secs (0.002u,0.s)
Chars 26315 - 26361 [(rewrite~(path_initial_segment...] 0.009 secs (0.006u,0.003s)
Chars 26368 - 26377 [symmetry.] 0.002 secs (0.002u,0.s)
Chars 26378 - 26399 [(apply~bound_property).] 0.001 secs (0.001u,0.s)
Chars 25870 - 25891 [(unfold~le_on_Ordinal).] 0. secs (0.u,0.s)
Chars 25894 - 25903 [(intros~x).] 0. secs (0.u,0.s)
Chars 25904 - 25914 [(unfold~le).] 0. secs (0.u,0.s)
Chars 25917 - 25952 [exists~(fun~u~=>~factor1~_~(x;...] 0. secs (0.u,0.s)
Chars 25955 - 25961 [split.] 0. secs (0.u,0.s)
Chars 25966 - 25981 [(intros~u~v~u_v).] 0. secs (0.u,0.s)
Chars 25982 - 25997 [(unfold~lt;~cbn).] 0.001 secs (0.001u,0.s)
Chars 25998 - 26023 [(apply~equiv_resize_hprop).] 0. secs (0.u,0.s)
Chars 26028 - 26062 [(apply~isembedding_initial_seg...] 0. secs (0.u,0.s)
Chars 26063 - 26073 [exact~u_v.] 0. secs (0.u,0.s)
Chars 26078 - 26087 [(intros~u).] 0. secs (0.u,0.s)
Chars 26088 - 26120 [(rapply~image_ind_prop;~intros...] 0.001 secs (0.001u,0.s)
Chars 26125 - 26136 [(intros~a_u).] 0.001 secs (0.001u,0.s)
Chars 26137 - 26169 [(apply~equiv_resize_hprop~in~a...] 0.001 secs (0.001u,0.s)
Chars 26170 - 26181 [(cbn~in~a_u).] 0.001 secs (0.u,0.s)
Chars 26186 - 26195 [(apply~tr).] 0. secs (0.u,0.s)
Chars 26196 - 26221 [exists~(out~(bound~a_u)).] 0. secs (0.u,0.s)
Chars 26222 - 26228 [split.] 0.001 secs (0.001u,0.s)
Chars 26235 - 26266 [(apply~initial_segment_property).] 0. secs (0.u,0.s)
Chars 26273 - 26303 [(apply~(injective~(factor2~_))).] 0. secs (0.u,0.s)
Chars 26304 - 26308 [(cbn).] 0.001 secs (0.u,0.001s)
Chars 26315 - 26361 [(rewrite~(path_initial_segment...] 0. secs (0.u,0.s)
Chars 26368 - 26377 [symmetry.] 0. secs (0.u,0.s)
Chars 26378 - 26399 [(apply~bound_property).] 0. secs (0.u,0.s)
Chars 26400 - 26404 [Qed.] 0.066 secs (0.041u,0.024s)
clear  IHl  :  (False -> list_last_error (ntimes n x nil) = Some a)
Chars 11825 - 11838 [(intros~x~y~E).] 40.013 secs (0.u,0.003s)
Chars 11841 - 11868 [(apply~join_sl_le_spec~in~E).] 0.001 secs (0.001u,0.s)
Chars 11869 - 11891 [(apply~join_sl_le_spec).] 0.001 secs (0.001u,0.s)
Chars 11894 - 11919 [(rewrite~<-~preserves_join).] 0.001 secs (0.001u,0.s)
Chars 11922 - 11934 [(apply~ap,~E).] 0. secs (0.u,0.s)
Chars 11825 - 11838 [(intros~x~y~E).] 0. secs (0.u,0.s)
Chars 11841 - 11868 [(apply~join_sl_le_spec~in~E).] 0. secs (0.u,0.s)
Chars 11869 - 11891 [(apply~join_sl_le_spec).] 0. secs (0.u,0.s)
Chars 11894 - 11919 [(rewrite~<-~preserves_join).] 0. secs (0.u,0.s)
Chars 11922 - 11934 [(apply~ap,~E).] 0. secs (0.u,0.s)
Chars 11937 - 11941 [Qed.] 0. secs (0.u,0.s)
Chars 11945 - 12011 [Lemma~join_sl_mor_reflecting~`...] 0. secs (0.u,0.s)
Chars 12014 - 12020 [Proof.] 0. secs (0.u,0.s)
Chars 9917 - 9924 [(intros).] 40.104 secs (0.u,0.019s)
Chars 9927 - 9957 [(destruct~(le_or_lt~y~x);~auto).] 0.003 secs (0.003u,0.s)
Chars 9960 - 9974 [contradiction.] 0. secs (0.u,0.s)
Chars 9917 - 9924 [(intros).] 0. secs (0.u,0.s)
Chars 9927 - 9957 [(destruct~(le_or_lt~y~x);~auto).] 0. secs (0.u,0.s)
Chars 9960 - 9974 [contradiction.] 0. secs (0.u,0.s)
Chars 9977 - 9981 [Qed.] 0. secs (0.u,0.s)
Chars 9985 - 10019 [Existing~Instance~dec_from_lt_...] 0. secs (0.u,0.s)
Chars 10023 - 10131 [Definition~lt_dec~`{!TrivialAp...] 0.001 secs (0.001u,0.s)
Chars 10134 - 10140 [Proof.] 0. secs (0.u,0.s)
Chars 10143 - 10150 [(intros).] 3.647 secs (0.001u,0.019s)
Chars 10153 - 10184 [(destruct~(decide_rel~(<=)~y~x)).] 0.002 secs (0.002u,0.s)
Chars 10187 - 10188 [-] 0. secs (0.u,0.s)
Chars 10189 - 10227 [(right;~apply~le_not_lt_flip;~...] 0.002 secs (0.001u,0.001s)
Chars 10230 - 10231 [-] 0. secs (0.u,0.s)
Chars 10232 - 10270 [(left;~apply~not_le_lt_flip;~a...] 0.011 secs (0.009u,0.001s)
Chars 10143 - 10150 [(intros).] 0. secs (0.u,0.s)
Chars 10153 - 10184 [(destruct~(decide_rel~(<=)~y~x)).] 0. secs (0.u,0.s)
Chars 10189 - 10227 [(right;~apply~le_not_lt_flip;~...] 0. secs (0.u,0.s)
Chars 10232 - 10270 [(left;~apply~not_le_lt_flip;~a...] 0. secs (0.u,0.s)
Chars 10273 - 10281 [Defined.] 0. secs (0.u,0.s)
Chars 10282 - 10304 [End~full_pseudo_order.] 0.017 secs (0.012u,0.004s)
Chars 10306 - 10390 [#[export]~Hint~Extern~8~(Decid...] 0. secs (0.u,0.s)
Chars 10714 - 10746 [Section~dec_strict_setoid_order.] 0. secs (0.u,0.s)
Chars 10749 - 10824 [Context~`{StrictOrder~A}~`{Apa...] 0. secs (0.u,0.s)
Chars 10828 - 10869 [Instance:~(IsApart~A)~:=~dec_s...] 0. secs (0.u,0.s)
Chars 10873 - 10900 [Context~`{!Trichotomy~(<)}.] 0. secs (0.u,0.s)
Chars 10904 - 10954 [Instance~dec_strict_pseudo_ord...] 0. secs (0.u,0.s)
Chars 10957 - 10963 [Proof.] 0. secs (0.u,0.s)
Chars 22774 - 22837 [(srefine~(transitivity~_~(equi...] 40.099 secs (0.003u,0.021s)
Chars 22840 - 22899 [srapply~(@equiv_ap~_~_~(colim_...] 0.044 secs (0.036u,0.007s)
Chars 22774 - 22837 [(srefine~(transitivity~_~(equi...] 0. secs (0.u,0.s)
Chars 22840 - 22899 [srapply~(@equiv_ap~_~_~(colim_...] 0. secs (0.u,0.s)
Chars 22900 - 22908 [Defined.] 0.002 secs (0.u,0.002s)
Chars 22910 - 22933 [Open~Scope~trunc_scope.] 0. secs (0.u,0.s)
Chars 22972 - 23098 [#[global]~Instance~trunc_seq_c...] 0. secs (0.u,0.s)
Chars 23099 - 23105 [Proof.] 0. secs (0.u,0.s)
"~~~~~~~~~~~~~~~~~~"
"Translating Coq.Init.Logic.eq"
"Coq.Init.Logic.eq was already translated"
"Translating MetaCoq.Translations.MiniHoTT.paths"
"MetaCoq.Translations.MiniHoTT.paths was already translated"
"Translating MetaCoq.Translations.times_bool_fun.wFunext"
"wFunext has been translated as wFunextᵗ"
"Translating Coq.Init.Logic.False"
"Coq.Init.Logic.False was already translated"
Chars 12023 - 12036 [(intros~x~y~E).] 40.013 secs (0.u,0.003s)
Chars 12039 - 12066 [(apply~join_sl_le_spec~in~E).] 0.001 secs (0.001u,0.s)
Chars 12067 - 12089 [(apply~join_sl_le_spec).] 0.001 secs (0.001u,0.s)
Chars 12092 - 12122 [(rewrite~<-~preserves_join~in~E).] 0.001 secs (0.001u,0.s)
Chars 12125 - 12145 [(apply~(injective~f)).] 0. secs (0.u,0.s)
Chars 12146 - 12157 [assumption.] 0. secs (0.u,0.s)
Chars 12023 - 12036 [(intros~x~y~E).] 0. secs (0.u,0.s)
Chars 12039 - 12066 [(apply~join_sl_le_spec~in~E).] 0. secs (0.u,0.s)
Chars 12067 - 12089 [(apply~join_sl_le_spec).] 0. secs (0.u,0.s)
Chars 12092 - 12122 [(rewrite~<-~preserves_join~in~E).] 0. secs (0.u,0.s)
Chars 12125 - 12145 [(apply~(injective~f)).] 0. secs (0.u,0.s)
Chars 12146 - 12157 [assumption.] 0. secs (0.u,0.s)
Chars 12160 - 12164 [Qed.] 0.008 secs (0.007u,0.s)
Chars 12165 - 12191 [End~join_order_preserving.] 0.002 secs (0.002u,0.s)
Chars 12193 - 12223 [Section~meet_order_preserving.] 0. secs (0.u,0.s)
Chars 12226 - 12326 [Context~`{MeetSemiLatticeOrder...] 0.001 secs (0.001u,0.s)
Chars 12330 - 12378 [Lemma~meet_sl_mor_preserving~:...] 0. secs (0.u,0.s)
Chars 12381 - 12387 [Proof.] 0. secs (0.u,0.s)
Chars 10966 - 10985 [(split;~try~apply~_).] 40.109 secs (0.01u,0.019s)
Chars 10988 - 10989 [-] 0. secs (0.u,0.s)
Chars 10990 - 11006 [(intros~x~y~[?~?]).] 0. secs (0.u,0.s)
Chars 11011 - 11043 [(destruct~(lt_antisym~x~y);~au...] 0.002 secs (0.001u,0.001s)
Chars 11046 - 11047 [-] 0. secs (0.u,0.s)
Chars 11048 - 11065 [(intros~x~y~Exy~z).] 0. secs (0.u,0.s)
Chars 11070 - 11140 [(destruct~(trichotomy~(<)~x~z)...] 0.009 secs (0.008u,0.s)
Chars 11145 - 11151 [right.] 0. secs (0.u,0.s)
Chars 11152 - 11166 [(rewrite~<-~Exz).] 0. secs (0.u,0.s)
Chars 11167 - 11178 [assumption.] 0. secs (0.u,0.s)
Chars 11181 - 11182 [-] 0. secs (0.u,0.s)
Chars 11183 - 11194 [(intros~x~y).] 0. secs (0.u,0.s)
Chars 11195 - 11246 [(transitivity~(x~<>~y);~[~spli...] 0.009 secs (0.008u,0.s)
Chars 11251 - 11257 [split.] 0. secs (0.u,0.s)
Chars 11262 - 11263 [+] 0. secs (0.u,0.s)
Chars 11264 - 11313 [(destruct~(trichotomy~(<)~x~y)...] 0.007 secs (0.005u,0.001s)
Chars 11320 - 11345 [(intros~E;~contradiction~~E).] 0.001 secs (0.u,0.s)
Chars 11350 - 11351 [+] 0. secs (0.u,0.s)
Chars 11352 - 11404 [(intros~[?|~?];~[~apply~lt_ne~...] 0.003 secs (0.003u,0.s)
Chars 10966 - 10985 [(split;~try~apply~_).] 0. secs (0.u,0.s)
Chars 10990 - 11006 [(intros~x~y~[?~?]).] 0. secs (0.u,0.s)
Chars 11011 - 11043 [(destruct~(lt_antisym~x~y);~au...] 0. secs (0.u,0.s)
Chars 11048 - 11065 [(intros~x~y~Exy~z).] 0. secs (0.u,0.s)
Chars 11070 - 11140 [(destruct~(trichotomy~(<)~x~z)...] 0.001 secs (0.u,0.001s)
Chars 11145 - 11151 [right.] 0. secs (0.u,0.s)
Chars 11152 - 11166 [(rewrite~<-~Exz).] 0. secs (0.u,0.s)
Chars 11167 - 11178 [assumption.] 0. secs (0.u,0.s)
Chars 11183 - 11194 [(intros~x~y).] 0. secs (0.u,0.s)
Chars 11195 - 11246 [(transitivity~(x~<>~y);~[~spli...] 0. secs (0.u,0.s)
Chars 11251 - 11257 [split.] 0. secs (0.u,0.s)
Chars 11264 - 11313 [(destruct~(trichotomy~(<)~x~y)...] 0.001 secs (0.001u,0.s)
Chars 11320 - 11345 [(intros~E;~contradiction~~E).] 0. secs (0.u,0.s)
Chars 11352 - 11404 [(intros~[?|~?];~[~apply~lt_ne~...] 0. secs (0.u,0.s)
Chars 11407 - 11411 [Qed.] 0.003 secs (0.003u,0.s)
Chars 11412 - 11440 [End~dec_strict_setoid_order.] 0.008 secs (0.008u,0.s)
Chars 11442 - 11468 [Section~dec_partial_order.] 0. secs (0.u,0.s)
Chars 11471 - 11517 [Context~`{PartialOrder~A}~`{De...] 0. secs (0.u,0.s)
Chars 11521 - 11577 [Definition~dec_lt~:~Lt~A~:=~fu...] 0. secs (0.u,0.s)
Chars 11581 - 11687 [Context~`{Alt~:~Lt~A}~`{is_mer...] 0.001 secs (0.001u,0.s)
Chars 11691 - 11727 [Instance~dec_order~:~(StrictOr...] 0. secs (0.u,0.s)
Chars 11730 - 11736 [Proof.] 0. secs (0.u,0.s)
Chars 23108 - 23144 [(revert~A;~induction~k~as~[|~k...] 40.113 secs (0.001u,0.021s)
Chars 23147 - 23148 [-] 0. secs (0.u,0.s)
Chars 23149 - 23179 [srapply~contr_colim_contr_seq.] 0.001 secs (0.001u,0.s)
Chars 23182 - 23183 [-] 0. secs (0.u,0.s)
Chars 23184 - 23218 [(intros~A~trH;~srapply~Colimit...] 0.003 secs (0.002u,0.s)
Chars 23223 - 23224 [+] 0. secs (0.u,0.s)
Chars 23225 - 23282 [(intro~n;~revert~trH;~revert~A...] 0.003 secs (0.001u,0.001s)
Chars 23289 - 23290 [*] 0. secs (0.u,0.s)
Chars 23291 - 23327 [(intros~A~trH~a;~srapply~Colim...] 0.003 secs (0.002u,0.s)
Chars 23336 - 23337 [{] 0. secs (0.u,0.s)
Chars 23338 - 23418 [(intros~m~b;~revert~b;~revert~...] 0.004 secs (0.004u,0.s)
Chars 23429 - 23430 [{] 0. secs (0.u,0.s)
Chars 23431 - 23448 [(intros~A~trH~a~b).] 0. secs (0.u,0.s)
Chars 23461 - 23536 [srefine~(istrunc_equiv_istrunc...] 0.004 secs (0.003u,0.s)
Chars 23537 - 23538 [}] 0. secs (0.u,0.s)
Chars 23549 - 23550 [{] 0. secs (0.u,0.s)
Chars 23551 - 23568 [(intros~A~trH~a~b).] 0. secs (0.u,0.s)
Chars 23581 - 23663 [srefine~~(istrunc_equiv_istrun...] 0.042 secs (0.038u,0.003s)
Chars 23676 - 23768 [srapply~~(@istrunc_equiv_istru...] 0.004 secs (0.004u,0.s)
Chars 23781 - 23832 [srapply~(equiv_ap~(colim_succ_...] 0.01 secs (0.007u,0.002s)
Chars 23833 - 23834 [}] 0. secs (0.u,0.s)
Chars 23834 - 23835 [}] 0. secs (0.u,0.s)
Chars 23844 - 23845 [{] 0. secs (0.u,0.s)
Chars 23846 - 23919 [(intros~n~m~p~b;~snrapply~path...] 0.016 secs (0.016u,0.s)
Chars 23920 - 23921 [}] 0. secs (0.u,0.s)
Chars 23928 - 23929 [*] 0. secs (0.u,0.s)
Chars 23930 - 24012 [(intros~A~trH~a;~srapply~~~(fu...] 0.006 secs (0.005u,0.001s)
Chars 24021 - 24114 [(intro~x;~srapply~(@istrunc_eq...] 0.076 secs (0.064u,0.011s)
Chars 24119 - 24120 [+] 0. secs (0.u,0.s)
Chars 24121 - 24184 [(intros~n~m~p~a;~snrapply~path...] 0.052 secs (0.047u,0.004s)
Chars 24191 - 24224 [(intro~x;~srapply~ishprop_istr...] 0.004 secs (0.002u,0.002s)
Chars 23108 - 23144 [(revert~A;~induction~k~as~[|~k...] 0. secs (0.u,0.s)
Chars 23149 - 23179 [srapply~contr_colim_contr_seq.] 0. secs (0.u,0.s)
Chars 23184 - 23218 [(intros~A~trH;~srapply~Colimit...] 0. secs (0.u,0.s)
Chars 23225 - 23282 [(intro~n;~revert~trH;~revert~A...] 0.001 secs (0.001u,0.s)
Chars 23291 - 23327 [(intros~A~trH~a;~srapply~Colim...] 0. secs (0.u,0.s)
Chars 23338 - 23418 [(intros~m~b;~revert~b;~revert~...] 0.002 secs (0.001u,0.s)
Chars 23431 - 23448 [(intros~A~trH~a~b).] 0. secs (0.u,0.s)
Chars 23461 - 23536 [srefine~(istrunc_equiv_istrunc...] 0. secs (0.u,0.s)
Chars 23551 - 23568 [(intros~A~trH~a~b).] 0. secs (0.u,0.s)
Chars 23581 - 23663 [srefine~~(istrunc_equiv_istrun...] 0. secs (0.u,0.s)
Chars 23676 - 23768 [srapply~~(@istrunc_equiv_istru...] 0. secs (0.u,0.s)
Chars 23781 - 23832 [srapply~(equiv_ap~(colim_succ_...] 0. secs (0.u,0.s)
Chars 23846 - 23919 [(intros~n~m~p~b;~snrapply~path...] 0.007 secs (0.007u,0.s)
Chars 23930 - 24012 [(intros~A~trH~a;~srapply~~~(fu...] 0.001 secs (0.001u,0.s)
Chars 24021 - 24114 [(intro~x;~srapply~(@istrunc_eq...] 0.001 secs (0.001u,0.s)
Chars 24121 - 24184 [(intros~n~m~p~a;~snrapply~path...] 0.019 secs (0.014u,0.004s)
Chars 24191 - 24224 [(intro~x;~srapply~ishprop_istr...] 0. secs (0.u,0.s)
Chars 24225 - 24233 [Defined.] 0.038 secs (0.038u,0.s)
"notwFunext has been translated as notwFunextᵗ"
"idpath has been translated as idpathᵗ"
"paths_ind has been translated as paths_indᵗ"
"~~~~~~~~~~~~~~~~~~"
"Translating Coq.Init.Logic.eq"
"Coq.Init.Logic.eq was already translated"
"Translating MetaCoq.Translations.MiniHoTT.paths"
"MetaCoq.Translations.MiniHoTT.paths was already translated"
"Translating MetaCoq.Translations.MiniHoTT.Sect"
"Sect has been translated as Sectᵗ"
"Translating MetaCoq.Translations.MiniHoTT.idpath"
"MetaCoq.Translations.MiniHoTT.idpath was already translated"
"Translating MetaCoq.Translations.MiniHoTT.paths_ind"
"MetaCoq.Translations.MiniHoTT.paths_ind was already translated"
"Translating MetaCoq.Translations.MiniHoTT.transport"
"transport has been translated as transportᵗ"
"Translating MetaCoq.Translations.MiniHoTT.ap"
"ap has been translated as apᵗ"
"Translating MetaCoq.Translations.MiniHoTT.IsEquiv"
"MetaCoq.Translations.MiniHoTT.IsEquiv has been translated."
"Translating MetaCoq.Translations.MiniHoTT.Equiv"
"MetaCoq.Translations.MiniHoTT.Equiv has been translated."
"Translating MetaCoq.Translations.times_bool_fun.wUnivalence"
"wUnivalence has been translated as wUnivalenceᵗ"
simplified dependent [if true]
e : (x <? n1)  = true
if (x <? n1)
then (fun E0 : (x <? n1) = true => AA (ltN_of_nat x n1 E0))
else
(fun E0 : (x <? n1) = false =>
 BB (ltN_of_nat (x - n1) n2 (ltN_split_lemma1 (ltN_plus_lemma1 e) E0)))
Finished transaction in 26.98 secs (26.778u,0.198s) (successful)
Finished transaction in 0.012 secs (0.012u,0.s) (successful)
Chars 12390 - 12403 [(intros~x~y~E).] 40.012 secs (0.u,0.002s)
Chars 12406 - 12433 [(apply~meet_sl_le_spec~in~E).] 0.001 secs (0.001u,0.s)
Chars 12434 - 12456 [(apply~meet_sl_le_spec).] 0.001 secs (0.001u,0.s)
Chars 12459 - 12484 [(rewrite~<-~preserves_meet).] 0.001 secs (0.001u,0.s)
Chars 12487 - 12499 [(apply~ap,~E).] 0. secs (0.u,0.s)
Chars 12390 - 12403 [(intros~x~y~E).] 0. secs (0.u,0.s)
Chars 12406 - 12433 [(apply~meet_sl_le_spec~in~E).] 0. secs (0.u,0.s)
Chars 12434 - 12456 [(apply~meet_sl_le_spec).] 0. secs (0.u,0.s)
Chars 12459 - 12484 [(rewrite~<-~preserves_meet).] 0. secs (0.u,0.s)
Chars 12487 - 12499 [(apply~ap,~E).] 0. secs (0.u,0.s)
Chars 12502 - 12506 [Qed.] 0. secs (0.u,0.s)
Chars 12510 - 12576 [Lemma~meet_sl_mor_reflecting~`...] 0. secs (0.u,0.s)
Chars 12579 - 12585 [Proof.] 0. secs (0.u,0.s)
(UnderLets.wf
   (fun G' : list {t : type & (var1 t * var2 t)%type} => expr.wf G') G
   (rew [fun t : type => UnderLets var1 (expr t)]
        match
          Hwf in (@Compile.wf_rawexpr _ _ _ _ l t r e r0 e0)
          return (type_of_rawexpr r = t)
        with
        | @Wf_rApp _ _ _ _ _ d _ _ _ _ _ _ _ _ _ _ _ => eq_refl
        | @Wf_rIdent _ _ _ _ t _ _ _ | @Wf_rExpr _ _ _ _ t _ _ _ _ |
          @Wf_rValue _ _ _ _ t _ _ _ _ => eq_refl
        end in eval_rewrite_rules1 do_again1 d rew1 re1)
   (rew [fun t : type => UnderLets var2 (expr t)]
        match
          Hwf in (@Compile.wf_rawexpr _ _ _ _ l t r e r0 e0)
          return (type_of_rawexpr r0 = t)
        with
        | @Wf_rApp _ _ _ _ _ d _ _ _ _ _ _ _ _ _ _ _ => eq_refl
        | @Wf_rIdent _ _ _ _ t _ _ _ | @Wf_rExpr _ _ _ _ t _ _ _ _ |
          @Wf_rValue _ _ _ _ t _ _ _ _ => eq_refl
        end in eval_rewrite_rules2 do_again2 d rew2 re2))
(UnderLets.wf
   (fun G' : list {t : type & (var1 t * var2 t)%type} => expr.wf G') G
   (rew [fun t : type => UnderLets var1 (expr t)]
        let (a, _) := eq_type_of_rawexpr_of_wf Hwf in a in
    eval_rewrite_rules1 do_again1 d rew1 re1)
   (rew [fun t : type => UnderLets var2 (expr t)]
        let (_, b) := eq_type_of_rawexpr_of_wf Hwf in b in
    eval_rewrite_rules2 do_again2 d rew2 re2))
(UnderLets.wf
   (fun G' : list {t : type & (var1 t * var2 t)%type} => expr.wf G') G
   (rew [fun t : type => UnderLets var1 (expr t)]
        match
          Hwf in (@Compile.wf_rawexpr _ _ _ _ l t r e r0 e0)
          return (type_of_rawexpr r = t)
        with
        | @Wf_rApp _ _ _ _ _ d _ _ _ _ _ _ _ _ _ _ _ => eq_refl
        | @Wf_rIdent _ _ _ _ t _ _ _ | @Wf_rExpr _ _ _ _ t _ _ _ _ |
          @Wf_rValue _ _ _ _ t _ _ _ _ => eq_refl
        end in eval_rewrite_rules1 do_again1 d rew1 re1)
   (rew [fun t : type => UnderLets var2 (expr t)]
        match
          Hwf in (@Compile.wf_rawexpr _ _ _ _ l t r e r0 e0)
          return (type_of_rawexpr r0 = t)
        with
        | @Wf_rApp _ _ _ _ _ d _ _ _ _ _ _ _ _ _ _ _ => eq_refl
        | @Wf_rIdent _ _ _ _ t _ _ _ | @Wf_rExpr _ _ _ _ t _ _ _ _ |
          @Wf_rValue _ _ _ _ t _ _ _ _ => eq_refl
        end in eval_rewrite_rules2 do_again2 d rew2 re2))
(UnderLets.wf
   (fun G' : list {t : type & (var1 t * var2 t)%type} => expr.wf G') G
   (rew [fun t : type => UnderLets var1 (expr t)]
        match
          Hwf in (@Compile.wf_rawexpr _ _ _ _ l t r e r0 e0)
          return (type_of_rawexpr r = t)
        with
        | @Wf_rApp _ _ _ _ _ d _ _ _ _ _ _ _ _ _ _ _ => eq_refl
        | @Wf_rIdent _ _ _ _ t _ _ _ | @Wf_rExpr _ _ _ _ t _ _ _ _ |
          @Wf_rValue _ _ _ _ t _ _ _ _ => eq_refl
        end in eval_rewrite_rules1 do_again1 d rew1 re1)
   (rew [fun t : type => UnderLets var2 (expr t)]
        match
          Hwf in (@Compile.wf_rawexpr _ _ _ _ l t r e r0 e0)
          return (type_of_rawexpr r0 = t)
        with
        | @Wf_rApp _ _ _ _ _ d _ _ _ _ _ _ _ _ _ _ _ => eq_refl
        | @Wf_rIdent _ _ _ _ t _ _ _ | @Wf_rExpr _ _ _ _ t _ _ _ _ |
          @Wf_rValue _ _ _ _ t _ _ _ _ => eq_refl
        end in eval_rewrite_rules2 do_again2 d rew2 re2))
(UnderLets.wf
   (fun G' : list {t : type & (var1 t * var2 t)%type} => expr.wf G') G
   (rew [fun t : type => UnderLets var1 (expr t)]
        let (a, _) := eq_type_of_rawexpr_of_wf Hwf in a in
    eval_rewrite_rules1 do_again1 d rew1 re1)
   (rew [fun t : type => UnderLets var2 (expr t)]
        let (_, b) := eq_type_of_rawexpr_of_wf Hwf in b in
    eval_rewrite_rules2 do_again2 d rew2 re2))
(UnderLets.wf
   (fun G' : list {t : type & (var1 t * var2 t)%type} => expr.wf G') G
   (rew [fun t : type => UnderLets var1 (expr t)]
        match
          Hwf in (@Compile.wf_rawexpr _ _ _ _ l t r e r0 e0)
          return (type_of_rawexpr r = t)
        with
        | @Wf_rApp _ _ _ _ _ d _ _ _ _ _ _ _ _ _ _ _ => eq_refl
        | @Wf_rIdent _ _ _ _ t _ _ _ | @Wf_rExpr _ _ _ _ t _ _ _ _ |
          @Wf_rValue _ _ _ _ t _ _ _ _ => eq_refl
        end in eval_rewrite_rules1 do_again1 d rew1 re1)
   (rew [fun t : type => UnderLets var2 (expr t)]
        match
          Hwf in (@Compile.wf_rawexpr _ _ _ _ l t r e r0 e0)
          return (type_of_rawexpr r0 = t)
        with
        | @Wf_rApp _ _ _ _ _ d _ _ _ _ _ _ _ _ _ _ _ => eq_refl
        | @Wf_rIdent _ _ _ _ t _ _ _ | @Wf_rExpr _ _ _ _ t _ _ _ _ |
          @Wf_rValue _ _ _ _ t _ _ _ _ => eq_refl
        end in eval_rewrite_rules2 do_again2 d rew2 re2))
Chars 11739 - 11745 [split.] 40.09 secs (0.u,0.019s)
Chars 11748 - 11749 [-] 0. secs (0.u,0.s)
Chars 11750 - 11758 [(apply~_).] 0. secs (0.u,0.s)
Chars 11761 - 11762 [-] 0. secs (0.u,0.s)
Chars 11763 - 11774 [(intros~x~E).] 0. secs (0.u,0.s)
Chars 11775 - 11797 [(apply~lt_correct~in~E).] 0. secs (0.u,0.s)
Chars 11798 - 11827 [(destruct~E~as~[_~[]];~trivial).] 0.001 secs (0.001u,0.s)
Chars 11830 - 11831 [-] 0. secs (0.u,0.s)
Chars 11832 - 11851 [(intros~x~y~z~E1~E2).] 0. secs (0.u,0.s)
Chars 11856 - 11929 [(apply~lt_correct;~apply~lt_co...] 0.003 secs (0.003u,0.s)
Chars 11934 - 11975 [(destruct~E1~as~[E1a~E1b],~E2~...] 0.001 secs (0.001u,0.s)
Chars 11980 - 11986 [split.] 0. secs (0.u,0.s)
Chars 11991 - 11992 [+] 0. secs (0.u,0.s)
Chars 11993 - 12016 [(transitivity~y;~trivial).] 0.008 secs (0.007u,0.001s)
Chars 12021 - 12022 [+] 0. secs (0.u,0.s)
Chars 12023 - 12033 [(intros~E3).] 0. secs (0.u,0.s)
Chars 12034 - 12047 [(destruct~E2b).] 0.001 secs (0.001u,0.s)
Chars 12054 - 12090 [(apply~(antisymmetry~(≤));~tri...] 0.003 secs (0.003u,0.s)
Chars 12097 - 12110 [(rewrite~<-~E3).] 0. secs (0.u,0.s)
Chars 12111 - 12122 [assumption.] 0. secs (0.u,0.s)
Chars 11739 - 11745 [split.] 0. secs (0.u,0.s)
Chars 11750 - 11758 [(apply~_).] 0. secs (0.u,0.s)
Chars 11763 - 11774 [(intros~x~E).] 0. secs (0.u,0.s)
Chars 11775 - 11797 [(apply~lt_correct~in~E).] 0. secs (0.u,0.s)
Chars 11798 - 11827 [(destruct~E~as~[_~[]];~trivial).] 0. secs (0.u,0.s)
Chars 11832 - 11851 [(intros~x~y~z~E1~E2).] 0. secs (0.u,0.s)
Chars 11856 - 11929 [(apply~lt_correct;~apply~lt_co...] 0.001 secs (0.001u,0.s)
Chars 11934 - 11975 [(destruct~E1~as~[E1a~E1b],~E2~...] 0. secs (0.u,0.s)
Chars 11980 - 11986 [split.] 0. secs (0.u,0.s)
Chars 11993 - 12016 [(transitivity~y;~trivial).] 0. secs (0.u,0.s)
Chars 12023 - 12033 [(intros~E3).] 0. secs (0.u,0.s)
Chars 12034 - 12047 [(destruct~E2b).] 0. secs (0.u,0.s)
Chars 12054 - 12090 [(apply~(antisymmetry~(≤));~tri...] 0. secs (0.u,0.s)
Chars 12097 - 12110 [(rewrite~<-~E3).] 0. secs (0.u,0.s)
Chars 12111 - 12122 [assumption.] 0. secs (0.u,0.s)
Chars 12125 - 12129 [Qed.] 0.001 secs (0.u,0.001s)
Chars 12133 - 12171 [Context~`{Apart~A}~`{!TrivialA...] 0. secs (0.u,0.s)
Chars 12175 - 12216 [Instance:~(IsApart~A)~:=~dec_s...] 0. secs (0.u,0.s)
Chars 12220 - 12280 [Instance~dec_full_partial_orde...] 0. secs (0.u,0.s)
Chars 12283 - 12289 [Proof.] 0. secs (0.u,0.s)
(UnderLets.wf
   (fun G' : list {t : type & (var1 t * var2 t)%type} => expr.wf G') G
   (rew [fun t : type => UnderLets var1 (expr t)]
        match
          Hwf in (@Compile.wf_rawexpr _ _ _ _ l t r e r0 e0)
          return (type_of_rawexpr r = t)
        with
        | @Wf_rApp _ _ _ _ _ d _ _ _ _ _ _ _ _ _ _ _ => eq_refl
        | @Wf_rIdent _ _ _ _ t _ _ _ | @Wf_rExpr _ _ _ _ t _ _ _ _ |
          @Wf_rValue _ _ _ _ t _ _ _ _ => eq_refl
        end in eval_rewrite_rules1 do_again1 d rew1 re1)
   (rew [fun t : type => UnderLets var2 (expr t)]
        match
          Hwf in (@Compile.wf_rawexpr _ _ _ _ l t r e r0 e0)
          return (type_of_rawexpr r0 = t)
        with
        | @Wf_rApp _ _ _ _ _ d _ _ _ _ _ _ _ _ _ _ _ => eq_refl
        | @Wf_rIdent _ _ _ _ t _ _ _ | @Wf_rExpr _ _ _ _ t _ _ _ _ |
          @Wf_rValue _ _ _ _ t _ _ _ _ => eq_refl
        end in eval_rewrite_rules2 do_again2 d rew2 re2))
(UnderLets.wf
   (fun G' : list {t : type & (var1 t * var2 t)%type} => expr.wf G') G
   (rew [fun t : type => UnderLets var1 (expr t)]
        match
          Hwf in (@Compile.wf_rawexpr _ _ _ _ l t r e r0 e0)
          return (type_of_rawexpr r = t)
        with
        | @Wf_rApp _ _ _ _ _ d _ _ _ _ _ _ _ _ _ _ _ => eq_refl
        | @Wf_rIdent _ _ _ _ t _ _ _ | @Wf_rExpr _ _ _ _ t _ _ _ _ |
          @Wf_rValue _ _ _ _ t _ _ _ _ => eq_refl
        end in eval_rewrite_rules1 do_again1 d rew1 re1)
   (rew [fun t : type => UnderLets var2 (expr t)]
        match
          Hwf in (@Compile.wf_rawexpr _ _ _ _ l t r e r0 e0)
          return (type_of_rawexpr r0 = t)
        with
        | @Wf_rApp _ _ _ _ _ d _ _ _ _ _ _ _ _ _ _ _ => eq_refl
        | @Wf_rIdent _ _ _ _ t _ _ _ | @Wf_rExpr _ _ _ _ t _ _ _ _ |
          @Wf_rValue _ _ _ _ t _ _ _ _ => eq_refl
        end in eval_rewrite_rules2 do_again2 d rew2 re2))
(UnderLets.wf
   (fun G' : list {t : type & (var1 t * var2 t)%type} => expr.wf G') G
   (rew [fun t : type => UnderLets var1 (expr t)]
        let (a, _) := eq_type_of_rawexpr_of_wf Hwf in a in
    eval_rewrite_rules1 do_again1 d rew1 re1)
   (rew [fun t : type => UnderLets var2 (expr t)]
        let (_, b) := eq_type_of_rawexpr_of_wf Hwf in b in
    eval_rewrite_rules2 do_again2 d rew2 re2))
(UnderLets.wf
   (fun G' : list {t : type & (var1 t * var2 t)%type} => expr.wf G') G
   (rew [fun t : type => UnderLets var1 (expr t)]
        match
          Hwf in (@Compile.wf_rawexpr _ _ _ _ l t r e r0 e0)
          return (type_of_rawexpr r = t)
        with
        | @Wf_rApp _ _ _ _ _ d _ _ _ _ _ _ _ _ _ _ _ => eq_refl
        | @Wf_rIdent _ _ _ _ t _ _ _ | @Wf_rExpr _ _ _ _ t _ _ _ _ |
          @Wf_rValue _ _ _ _ t _ _ _ _ => eq_refl
        end in eval_rewrite_rules1 do_again1 d rew1 re1)
   (rew [fun t : type => UnderLets var2 (expr t)]
        match
          Hwf in (@Compile.wf_rawexpr _ _ _ _ l t r e r0 e0)
          return (type_of_rawexpr r0 = t)
        with
        | @Wf_rApp _ _ _ _ _ d _ _ _ _ _ _ _ _ _ _ _ => eq_refl
        | @Wf_rIdent _ _ _ _ t _ _ _ | @Wf_rExpr _ _ _ _ t _ _ _ _ |
          @Wf_rValue _ _ _ _ t _ _ _ _ => eq_refl
        end in eval_rewrite_rules2 do_again2 d rew2 re2))
(UnderLets.wf
   (fun G' : list {t : type & (var1 t * var2 t)%type} => expr.wf G') G
   (rew [fun t : type => UnderLets var1 (expr t)]
        match
          Hwf in (@Compile.wf_rawexpr _ _ _ _ l t r e r0 e0)
          return (type_of_rawexpr r = t)
        with
        | @Wf_rApp _ _ _ _ _ d _ _ _ _ _ _ _ _ _ _ _ => eq_refl
        | @Wf_rIdent _ _ _ _ t _ _ _ | @Wf_rExpr _ _ _ _ t _ _ _ _ |
          @Wf_rValue _ _ _ _ t _ _ _ _ => eq_refl
        end in eval_rewrite_rules1 do_again1 d rew1 re1)
   (rew [fun t : type => UnderLets var2 (expr t)]
        match
          Hwf in (@Compile.wf_rawexpr _ _ _ _ l t r e r0 e0)
          return (type_of_rawexpr r0 = t)
        with
        | @Wf_rApp _ _ _ _ _ d _ _ _ _ _ _ _ _ _ _ _ => eq_refl
        | @Wf_rIdent _ _ _ _ t _ _ _ | @Wf_rExpr _ _ _ _ t _ _ _ _ |
          @Wf_rValue _ _ _ _ t _ _ _ _ => eq_refl
        end in eval_rewrite_rules2 do_again2 d rew2 re2))
(UnderLets.wf
   (fun G' : list {t : type & (var1 t * var2 t)%type} => expr.wf G') G
   (rew [fun t : type => UnderLets var1 (expr t)]
        match
          Hwf in (@Compile.wf_rawexpr _ _ _ _ l t r e r0 e0)
          return (type_of_rawexpr r = t)
        with
        | @Wf_rApp _ _ _ _ _ d _ _ _ _ _ _ _ _ _ _ _ => eq_refl
        | @Wf_rIdent _ _ _ _ t _ _ _ | @Wf_rExpr _ _ _ _ t _ _ _ _ |
          @Wf_rValue _ _ _ _ t _ _ _ _ => eq_refl
        end in eval_rewrite_rules1 do_again1 d rew1 re1)
   (rew [fun t : type => UnderLets var2 (expr t)]
        match
          Hwf in (@Compile.wf_rawexpr _ _ _ _ l t r e r0 e0)
          return (type_of_rawexpr r0 = t)
        with
        | @Wf_rApp _ _ _ _ _ d _ _ _ _ _ _ _ _ _ _ _ => eq_refl
        | @Wf_rIdent _ _ _ _ t _ _ _ | @Wf_rExpr _ _ _ _ t _ _ _ _ |
          @Wf_rValue _ _ _ _ t _ _ _ _ => eq_refl
        end in eval_rewrite_rules2 do_again2 d rew2 re2))
"isequiv_idmap has been translated as isequiv_idmapᵗ"
"equiv_idmap has been translated as equiv_idmapᵗ"
(UnderLets.wf
   (fun G' : list {t : type & (var1 t * var2 t)%type} => expr.wf G') G
   (rew [fun t : type => UnderLets var1 (expr t)]
        let (a, _) := eq_type_of_rawexpr_of_wf Hwf in a in
    eval_rewrite_rules1 do_again1 d rew1 re1)
   (rew [fun t : type => UnderLets var2 (expr t)]
        let (_, b) := eq_type_of_rawexpr_of_wf Hwf in b in
    eval_rewrite_rules2 do_again2 d rew2 re2))
"UA has been translated as UAᵗ"
(UnderLets.wf
   (fun G' : list {t : type & (var1 t * var2 t)%type} => expr.wf G') G
   (rew [fun t : type => UnderLets var1 (expr t)]
        match
          Hwf in (@Compile.wf_rawexpr _ _ _ _ l t r e r0 e0)
          return (type_of_rawexpr r = t)
        with
        | @Wf_rApp _ _ _ _ _ d _ _ _ _ _ _ _ _ _ _ _ => eq_refl
        | @Wf_rIdent _ _ _ _ t _ _ _ | @Wf_rExpr _ _ _ _ t _ _ _ _ |
          @Wf_rValue _ _ _ _ t _ _ _ _ => eq_refl
        end in eval_rewrite_rules1 do_again1 d rew1 re1)
   (rew [fun t : type => UnderLets var2 (expr t)]
        match
          Hwf in (@Compile.wf_rawexpr _ _ _ _ l t r e r0 e0)
          return (type_of_rawexpr r0 = t)
        with
        | @Wf_rApp _ _ _ _ _ d _ _ _ _ _ _ _ _ _ _ _ => eq_refl
        | @Wf_rIdent _ _ _ _ t _ _ _ | @Wf_rExpr _ _ _ _ t _ _ _ _ |
          @Wf_rValue _ _ _ _ t _ _ _ _ => eq_refl
        end in eval_rewrite_rules2 do_again2 d rew2 re2))
rewrite if_dtt
if (n1 + x <? n1)
then (fun E0 : (n1 + x <? n1) = true => AA (ltN_of_nat (n1 + x) n1 E0))
else
(fun E0 : (n1 + x <? n1) = false =>
 BB (ltN_of_nat (n1 + x - n1) n2 (ltN_split_lemma1 (plus_ltN_lemma1 e) E0)))
(UnderLets.wf
   (fun G' : list {t : type & (var1 t * var2 t)%type} => expr.wf G') G
   (rew [fun t : type => UnderLets var1 (expr t)]
        match
          Hwf in (@Compile.wf_rawexpr _ _ _ _ l t r e r0 e0)
          return (type_of_rawexpr r = t)
        with
        | @Wf_rApp _ _ _ _ _ d _ _ _ _ _ _ _ _ _ _ _ => eq_refl
        | @Wf_rIdent _ _ _ _ t _ _ _ | @Wf_rExpr _ _ _ _ t _ _ _ _ |
          @Wf_rValue _ _ _ _ t _ _ _ _ => eq_refl
        end in eval_rewrite_rules1 do_again1 d rew1 re1)
   (rew [fun t : type => UnderLets var2 (expr t)]
        match
          Hwf in (@Compile.wf_rawexpr _ _ _ _ l t r e r0 e0)
          return (type_of_rawexpr r0 = t)
        with
        | @Wf_rApp _ _ _ _ _ d _ _ _ _ _ _ _ _ _ _ _ => eq_refl
        | @Wf_rIdent _ _ _ _ t _ _ _ | @Wf_rExpr _ _ _ _ t _ _ _ _ |
          @Wf_rValue _ _ _ _ t _ _ _ _ => eq_refl
        end in eval_rewrite_rules2 do_again2 d rew2 re2))
Chars 12588 - 12601 [(intros~x~y~E).] 40.013 secs (0.u,0.003s)
Chars 12604 - 12631 [(apply~meet_sl_le_spec~in~E).] 0.001 secs (0.001u,0.s)
Chars 12632 - 12654 [(apply~meet_sl_le_spec).] 0.001 secs (0.001u,0.s)
Chars 12657 - 12687 [(rewrite~<-~preserves_meet~in~E).] 0.001 secs (0.001u,0.s)
Chars 12690 - 12710 [(apply~(injective~f)).] 0. secs (0.u,0.s)
Chars 12711 - 12722 [assumption.] 0. secs (0.u,0.s)
Chars 12588 - 12601 [(intros~x~y~E).] 0. secs (0.u,0.s)
Chars 12604 - 12631 [(apply~meet_sl_le_spec~in~E).] 0. secs (0.u,0.s)
Chars 12632 - 12654 [(apply~meet_sl_le_spec).] 0. secs (0.u,0.s)
Chars 12657 - 12687 [(rewrite~<-~preserves_meet~in~E).] 0. secs (0.u,0.s)
Chars 12690 - 12710 [(apply~(injective~f)).] 0. secs (0.u,0.s)
Chars 12711 - 12722 [assumption.] 0. secs (0.u,0.s)
Chars 12725 - 12729 [Qed.] 0. secs (0.u,0.s)
Chars 12730 - 12756 [End~meet_order_preserving.] 0.002 secs (0.002u,0.s)
Chars 12758 - 12795 [Section~order_preserving_join_...] 0. secs (0.u,0.s)
Chars 12798 - 12951 [Context~`{JoinSemiLatticeOrder...] 0.001 secs (0.001u,0.s)
Chars 12955 - 13010 [Lemma~order_preserving_join_sl...] 0. secs (0.u,0.s)
Chars 13013 - 13019 [Proof.] 0. secs (0.u,0.s)
Chars 12292 - 12310 [(split;~try~apply~_).] 40.121 secs (0.016u,0.025s)
Chars 12313 - 12320 [(intros).] 0. secs (0.u,0.s)
Chars 12321 - 12420 [(transitivity~(x~<=~y~/\~x~<>~...] 0.014 secs (0.014u,0.s)
Chars 12423 - 12440 [(apply~lt_correct).] 0. secs (0.u,0.s)
Chars 12292 - 12310 [(split;~try~apply~_).] 0.001 secs (0.001u,0.s)
Chars 12313 - 12320 [(intros).] 0. secs (0.u,0.s)
Chars 12321 - 12420 [(transitivity~(x~<=~y~/\~x~<>~...] 0.004 secs (0.004u,0.s)
Chars 12423 - 12440 [(apply~lt_correct).] 0. secs (0.u,0.s)
Chars 12443 - 12447 [Qed.] 0.001 secs (0.u,0.s)
Chars 12451 - 12483 [Context~`{!TotalRelation~(≤)}.] 0. secs (0.u,0.s)
Chars 12487 - 12512 [Instance:~(Trichotomy~(<)).] 0. secs (0.u,0.s)
Chars 12515 - 12521 [Proof.] 0. secs (0.u,0.s)
rewrite if_dtt
if (x <? n1)
then
(fun E0 : (x <? n1) = true =>
 AA (exist (fun k : nat => (k <? n1) = true) x E0))
else
(fun E0 : (x <? n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true) (x - n1) (ltN_split_lemma1 e E0)))
     = omega
     : t
     = (1, 3)
     : t
rewrite if_dtt
if (proj1_sig x <? n)
then
(fun E0 : (proj1_sig x <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x) E0))
else
(fun E0 : (proj1_sig x <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x - n)
      (ltN_split_lemma1 (proj2_sig x) E0)))
rewrite if_dtt
if (proj1_sig x <? n)
then
(fun E0 : (proj1_sig x <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x) E0))
else
(fun E0 : (proj1_sig x <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x - n)
      (ltN_split_lemma1 (proj2_sig x) E0)))
rewrite if_dtt
if (proj1_sig x0 <? n)
then
(fun E0 : (proj1_sig x0 <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x0) E0))
else
(fun E0 : (proj1_sig x0 <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x0 - n)
      (ltN_split_lemma1 (proj2_sig x0) E0)))
rewrite if_dtt
if (proj1_sig x <? n)
then
(fun E0 : (proj1_sig x <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x) E0))
else
(fun E0 : (proj1_sig x <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x - n)
      (ltN_split_lemma1 (proj2_sig x) E0)))
Chars 13022 - 13033 [(intros~x~y).] 40.012 secs (0.u,0.002s)
Chars 13034 - 13067 [(case~(total~(≤)~x~y);~intros~E).] 0.002 secs (0.002u,0.s)
Chars 13070 - 13071 [-] 0. secs (0.u,0.s)
Chars 13072 - 13113 [(change~(f~(join~x~y)~=~join~(...] 0.001 secs (0.001u,0.s)
Chars 13118 - 13156 [(rewrite~(join_r~_~_~E),~join_...] 0.002 secs (0.002u,0.s)
Chars 13161 - 13188 [(apply~(order_preserving~_)).] 0. secs (0.u,0.s)
Chars 13189 - 13197 [trivial.] 0. secs (0.u,0.s)
Chars 13200 - 13201 [-] 0. secs (0.u,0.s)
Chars 13202 - 13243 [(change~(f~(join~x~y)~=~join~(...] 0.001 secs (0.001u,0.s)
Chars 13248 - 13274 [(rewrite~2!join_l;~trivial).] 0.003 secs (0.003u,0.s)
Chars 13275 - 13302 [(apply~(order_preserving~_)).] 0. secs (0.u,0.s)
Chars 13303 - 13311 [trivial.] 0. secs (0.u,0.s)
Chars 13022 - 13033 [(intros~x~y).] 0. secs (0.u,0.s)
Chars 13034 - 13067 [(case~(total~(≤)~x~y);~intros~E).] 0. secs (0.u,0.s)
Chars 13072 - 13113 [(change~(f~(join~x~y)~=~join~(...] 0. secs (0.u,0.s)
Chars 13118 - 13156 [(rewrite~(join_r~_~_~E),~join_...] 0. secs (0.u,0.s)
Chars 13161 - 13188 [(apply~(order_preserving~_)).] 0. secs (0.u,0.s)
Chars 13189 - 13197 [trivial.] 0. secs (0.u,0.s)
Chars 13202 - 13243 [(change~(f~(join~x~y)~=~join~(...] 0. secs (0.u,0.s)
Chars 13248 - 13274 [(rewrite~2!join_l;~trivial).] 0. secs (0.u,0.s)
Chars 13275 - 13302 [(apply~(order_preserving~_)).] 0. secs (0.u,0.s)
Chars 13303 - 13311 [trivial.] 0. secs (0.u,0.s)
Chars 13314 - 13318 [Qed.] 0. secs (0.u,0.s)
Chars 13319 - 13352 [End~order_preserving_join_sl_mor.] 0.004 secs (0.004u,0.s)
Chars 13354 - 13391 [Section~order_preserving_meet_...] 0. secs (0.u,0.s)
Chars 13394 - 13547 [Context~`{MeetSemiLatticeOrder...] 0.001 secs (0.001u,0.s)
Chars 13551 - 13611 [Lemma~order_preserving_meet_sl...] 0.001 secs (0.001u,0.s)
Chars 13614 - 13620 [Proof.] 0. secs (0.u,0.s)
rewrite if_dtt
if (proj1_sig x0 <? n)
then
(fun E0 : (proj1_sig x0 <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x0) E0))
else
(fun E0 : (proj1_sig x0 <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x0 - n)
      (ltN_split_lemma1 (proj2_sig x0) E0)))
rewrite if_dtt
if (proj1_sig x0 <? n)
then
(fun E0 : (proj1_sig x0 <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x0) E0))
else
(fun E0 : (proj1_sig x0 <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x0 - n)
      (ltN_split_lemma1 (proj2_sig x0) E0)))
rewrite if_dtt
if (proj1_sig x0 <? n)
then
(fun E0 : (proj1_sig x0 <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x0) E0))
else
(fun E0 : (proj1_sig x0 <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x0 - n)
      (ltN_split_lemma1 (proj2_sig x0) E0)))
rewrite if_dtt
if (proj1_sig x0 <? n)
then
(fun E0 : (proj1_sig x0 <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x0) E0))
else
(fun E0 : (proj1_sig x0 <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x0 - n)
      (ltN_split_lemma1 (proj2_sig x0) E0)))
rewrite if_dtt
if (proj1_sig x0 <? n)
then
(fun E0 : (proj1_sig x0 <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x0) E0))
else
(fun E0 : (proj1_sig x0 <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x0 - n)
      (ltN_split_lemma1 (proj2_sig x0) E0)))
rewrite if_dtt
if (proj1_sig x <? n)
then
(fun E0 : (proj1_sig x <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x) E0))
else
(fun E0 : (proj1_sig x <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x - n)
      (ltN_split_lemma1 (proj2_sig x) E0)))
rewrite if_dtt
if (proj1_sig x0 <? n)
then
(fun E0 : (proj1_sig x0 <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x0) E0))
else
(fun E0 : (proj1_sig x0 <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x0 - n)
      (ltN_split_lemma1 (proj2_sig x0) E0)))
rewrite if_dtt
if (proj1_sig x0 <? n)
then
(fun E0 : (proj1_sig x0 <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x0) E0))
else
(fun E0 : (proj1_sig x0 <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x0 - n)
      (ltN_split_lemma1 (proj2_sig x0) E0)))
rewrite if_dtt
if (proj1_sig x0 <? n)
then
(fun E0 : (proj1_sig x0 <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x0) E0))
else
(fun E0 : (proj1_sig x0 <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x0 - n)
      (ltN_split_lemma1 (proj2_sig x0) E0)))
rewrite if_dtt
if (proj1_sig x0 <? n)
then
(fun E0 : (proj1_sig x0 <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x0) E0))
else
(fun E0 : (proj1_sig x0 <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x0 - n)
      (ltN_split_lemma1 (proj2_sig x0) E0)))
rewrite if_dtt
if (proj1_sig x0 <? n)
then
(fun E0 : (proj1_sig x0 <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x0) E0))
else
(fun E0 : (proj1_sig x0 <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x0 - n)
      (ltN_split_lemma1 (proj2_sig x0) E0)))
Chars 12524 - 12535 [(intros~x~y).] 40.095 secs (0.u,0.02s)
Chars 12538 - 12571 [(destruct~(dec~(x~=~y));~try~a...] 0.016 secs (0.016u,0.s)
Chars 12574 - 12645 [(destruct~(total~(≤)~x~y);~[~l...] 0.008 secs (0.008u,0.s)
Chars 12648 - 12659 [(split;~auto).] 0.002 secs (0.002u,0.s)
Chars 12662 - 12695 [(intro~E;~apply~symmetry~in~E;...] 0.002 secs (0.002u,0.s)
Chars 12524 - 12535 [(intros~x~y).] 0. secs (0.u,0.s)
Chars 12538 - 12571 [(destruct~(dec~(x~=~y));~try~a...] 0.001 secs (0.001u,0.s)
Chars 12574 - 12645 [(destruct~(total~(≤)~x~y);~[~l...] 0.002 secs (0.002u,0.s)
Chars 12648 - 12659 [(split;~auto).] 0. secs (0.u,0.s)
Chars 12662 - 12695 [(intro~E;~apply~symmetry~in~E;...] 0. secs (0.u,0.s)
Chars 12698 - 12702 [Qed.] 0.001 secs (0.001u,0.s)
Chars 12706 - 12776 [Instance~dec_pseudo_order~:~(P...] 0.001 secs (0.001u,0.s)
Chars 12780 - 12838 [Instance~dec_full_pseudo_order...] 0. secs (0.u,0.s)
Chars 12841 - 12847 [Proof.] 0. secs (0.u,0.s)
rewrite if_dtt
if (proj1_sig x0 <? n)
then
(fun E0 : (proj1_sig x0 <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x0) E0))
else
(fun E0 : (proj1_sig x0 <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x0 - n)
      (ltN_split_lemma1 (proj2_sig x0) E0)))
rewrite if_dtt
if (proj1_sig x0 <? n)
then
(fun E0 : (proj1_sig x0 <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x0) E0))
else
(fun E0 : (proj1_sig x0 <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x0 - n)
      (ltN_split_lemma1 (proj2_sig x0) E0)))
rewrite if_dtt
if (proj1_sig x0 <? n)
then
(fun E0 : (proj1_sig x0 <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x0) E0))
else
(fun E0 : (proj1_sig x0 <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x0 - n)
      (ltN_split_lemma1 (proj2_sig x0) E0)))
rewrite if_dtt
if (proj1_sig x0 <? n)
then
(fun E0 : (proj1_sig x0 <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x0) E0))
else
(fun E0 : (proj1_sig x0 <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x0 - n)
      (ltN_split_lemma1 (proj2_sig x0) E0)))
rewrite if_dtt
if (proj1_sig x0 <? n)
then
(fun E0 : (proj1_sig x0 <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x0) E0))
else
(fun E0 : (proj1_sig x0 <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x0 - n)
      (ltN_split_lemma1 (proj2_sig x0) E0)))
rewrite if_dtt
if (proj1_sig x0 <? n)
then
(fun E0 : (proj1_sig x0 <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x0) E0))
else
(fun E0 : (proj1_sig x0 <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x0 - n)
      (ltN_split_lemma1 (proj2_sig x0) E0)))
rewrite if_dtt
if (proj1_sig x0 <? n)
then
(fun E0 : (proj1_sig x0 <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x0) E0))
else
(fun E0 : (proj1_sig x0 <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x0 - n)
      (ltN_split_lemma1 (proj2_sig x0) E0)))
rewrite if_dtt
if (proj1_sig x0 <? n)
then
(fun E0 : (proj1_sig x0 <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x0) E0))
else
(fun E0 : (proj1_sig x0 <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x0 - n)
      (ltN_split_lemma1 (proj2_sig x0) E0)))
rewrite if_dtt
if (proj1_sig x <? n)
then
(fun E0 : (proj1_sig x <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x) E0))
else
(fun E0 : (proj1_sig x <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x - n)
      (ltN_split_lemma1 (proj2_sig x) E0)))
rewrite if_dtt
if (proj1_sig x0 <? n)
then
(fun E0 : (proj1_sig x0 <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x0) E0))
else
(fun E0 : (proj1_sig x0 <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x0 - n)
      (ltN_split_lemma1 (proj2_sig x0) E0)))
rewrite if_dtt
if (proj1_sig x0 <? n)
then
(fun E0 : (proj1_sig x0 <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x0) E0))
else
(fun E0 : (proj1_sig x0 <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x0 - n)
      (ltN_split_lemma1 (proj2_sig x0) E0)))
rewrite if_dtt
if (proj1_sig x0 <? n)
then
(fun E0 : (proj1_sig x0 <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x0) E0))
else
(fun E0 : (proj1_sig x0 <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x0 - n)
      (ltN_split_lemma1 (proj2_sig x0) E0)))
rewrite if_dtt
if (proj1_sig x0 <? n)
then
(fun E0 : (proj1_sig x0 <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x0) E0))
else
(fun E0 : (proj1_sig x0 <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x0 - n)
      (ltN_split_lemma1 (proj2_sig x0) E0)))
rewrite if_dtt
if (proj1_sig x0 <? n)
then
(fun E0 : (proj1_sig x0 <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x0) E0))
else
(fun E0 : (proj1_sig x0 <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x0 - n)
      (ltN_split_lemma1 (proj2_sig x0) E0)))
rewrite if_dtt
if (proj1_sig x0 <? n)
then
(fun E0 : (proj1_sig x0 <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x0) E0))
else
(fun E0 : (proj1_sig x0 <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x0 - n)
      (ltN_split_lemma1 (proj2_sig x0) E0)))
rewrite if_dtt
if (proj1_sig x0 <? n)
then
(fun E0 : (proj1_sig x0 <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x0) E0))
else
(fun E0 : (proj1_sig x0 <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x0 - n)
      (ltN_split_lemma1 (proj2_sig x0) E0)))
rewrite if_dtt
if (proj1_sig x0 <? n)
then
(fun E0 : (proj1_sig x0 <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x0) E0))
else
(fun E0 : (proj1_sig x0 <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x0 - n)
      (ltN_split_lemma1 (proj2_sig x0) E0)))
rewrite if_dtt
if (proj1_sig x0 <? n)
then
(fun E0 : (proj1_sig x0 <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x0) E0))
else
(fun E0 : (proj1_sig x0 <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x0 - n)
      (ltN_split_lemma1 (proj2_sig x0) E0)))
rewrite if_dtt
if (proj1_sig x0 <? n)
then
(fun E0 : (proj1_sig x0 <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x0) E0))
else
(fun E0 : (proj1_sig x0 <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x0 - n)
      (ltN_split_lemma1 (proj2_sig x0) E0)))
rewrite if_dtt
if (proj1_sig x0 <? n)
then
(fun E0 : (proj1_sig x0 <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x0) E0))
else
(fun E0 : (proj1_sig x0 <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x0 - n)
      (ltN_split_lemma1 (proj2_sig x0) E0)))
"notUA has been translated as notUAᵗ"
rewrite if_dtt
if (proj1_sig x0 <? n)
then
(fun E0 : (proj1_sig x0 <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x0) E0))
else
(fun E0 : (proj1_sig x0 <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x0 - n)
      (ltN_split_lemma1 (proj2_sig x0) E0)))
rewrite if_dtt
if (proj1_sig x0 <? n)
then
(fun E0 : (proj1_sig x0 <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x0) E0))
else
(fun E0 : (proj1_sig x0 <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x0 - n)
      (ltN_split_lemma1 (proj2_sig x0) E0)))
rewrite if_dtt
if (proj1_sig x0 <? n)
then
(fun E0 : (proj1_sig x0 <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x0) E0))
else
(fun E0 : (proj1_sig x0 <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x0 - n)
      (ltN_split_lemma1 (proj2_sig x0) E0)))
rewrite if_dtt
if (proj1_sig x0 <? n)
then
(fun E0 : (proj1_sig x0 <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x0) E0))
else
(fun E0 : (proj1_sig x0 <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x0 - n)
      (ltN_split_lemma1 (proj2_sig x0) E0)))
rewrite if_dtt
if (proj1_sig x0 <? n)
then
(fun E0 : (proj1_sig x0 <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x0) E0))
else
(fun E0 : (proj1_sig x0 <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x0 - n)
      (ltN_split_lemma1 (proj2_sig x0) E0)))
rewrite if_dtt
if (proj1_sig x0 <? n)
then
(fun E0 : (proj1_sig x0 <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x0) E0))
else
(fun E0 : (proj1_sig x0 <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x0 - n)
      (ltN_split_lemma1 (proj2_sig x0) E0)))
rewrite if_dtt
if (proj1_sig x0 <? n)
then
(fun E0 : (proj1_sig x0 <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) (proj1_sig x0) E0))
else
(fun E0 : (proj1_sig x0 <? n) = false =>
 BB
   (exist (fun k : nat => (k <? 0) = true) (proj1_sig x0 - n)
      (ltN_split_lemma1 (proj2_sig x0) E0)))
Chars 13623 - 13634 [(intros~x~y).] 40.013 secs (0.u,0.002s)
Chars 13635 - 13668 [(case~(total~(≤)~x~y);~intros~E).] 0.002 secs (0.002u,0.s)
Chars 13671 - 13672 [-] 0. secs (0.u,0.s)
Chars 13673 - 13714 [(change~(f~(meet~x~y)~=~meet~(...] 0.001 secs (0.001u,0.s)
Chars 13719 - 13744 [(rewrite~2!meet_l;~trivial).] 0.003 secs (0.003u,0.s)
Chars 13749 - 13776 [(apply~(order_preserving~_)).] 0.001 secs (0.001u,0.s)
Chars 13777 - 13785 [trivial.] 0. secs (0.u,0.s)
Chars 13788 - 13789 [-] 0. secs (0.u,0.s)
Chars 13790 - 13831 [(change~(f~(meet~x~y)~=~meet~(...] 0.001 secs (0.001u,0.s)
Chars 13836 - 13862 [(rewrite~2!meet_r;~trivial).] 0.003 secs (0.003u,0.s)
Chars 13867 - 13894 [(apply~(order_preserving~_)).] 0.001 secs (0.001u,0.s)
Chars 13895 - 13903 [trivial.] 0. secs (0.u,0.s)
Chars 13623 - 13634 [(intros~x~y).] 0. secs (0.u,0.s)
Chars 13635 - 13668 [(case~(total~(≤)~x~y);~intros~E).] 0. secs (0.u,0.s)
Chars 13673 - 13714 [(change~(f~(meet~x~y)~=~meet~(...] 0. secs (0.u,0.s)
Chars 13719 - 13744 [(rewrite~2!meet_l;~trivial).] 0. secs (0.u,0.s)
Chars 13749 - 13776 [(apply~(order_preserving~_)).] 0. secs (0.u,0.s)
Chars 13777 - 13785 [trivial.] 0. secs (0.u,0.s)
Chars 13790 - 13831 [(change~(f~(meet~x~y)~=~meet~(...] 0. secs (0.u,0.s)
Chars 13836 - 13862 [(rewrite~2!meet_r;~trivial).] 0. secs (0.u,0.s)
Chars 13867 - 13894 [(apply~(order_preserving~_)).] 0. secs (0.u,0.s)
Chars 13895 - 13903 [trivial.] 0. secs (0.u,0.s)
Chars 13906 - 13910 [Qed.] 0. secs (0.u,0.s)
Chars 13911 - 13944 [End~order_preserving_meet_sl_mor.] 0.004 secs (0.004u,0.s)
Chars 13946 - 13975 [Section~strict_ordered_field.] 0. secs (0.u,0.s)
Chars 13979 - 14030 [Generalizable~Variables~Lle~Ll...] 0. secs (0.u,0.s)
Chars 14033 - 14076 [Context~`{@LatticeOrder~L~Lle~...] 0. secs (0.u,0.s)
Chars 14079 - 14124 [Context~`{@FullPseudoOrder~L~L...] 0. secs (0.u,0.s)
Chars 14128 - 14175 [Lemma~join_lt_l_l~x~y~z~:~z~<~...] 0. secs (0.u,0.s)
Chars 14178 - 14184 [Proof.] 0. secs (0.u,0.s)
rewrite if_dtt
if (x0 <? n)
then
(fun E0 : (x0 <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) x0 E0))
else
(fun E0 : (x0 <? n) = false =>
 BB (exist (fun k : nat => (k <? 0) = true) (x0 - n) (ltN_split_lemma1 e E0)))
destruct  (Nat.add_0_r n)  in  x
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (exist (fun k : nat => (k <? S n1) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1)
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
rewrite if_dtt
if (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e) <? n1)
then
(fun
   E0 : (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e) <? n1) =
        true =>
 AA
   (exist (fun k : nat => (k <? n1) = true)
      (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e)) E0))
else
(fun
   E0 : (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e) <? n1) =
        false =>
 BB
   (exist (fun k : nat => (k <? n2) = true)
      (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e) - n1)
      (ltN_split_lemma1
         (proj2_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e)) E0)))
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (exist (fun k : nat => (k <? S n1) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1)
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      (S n1) E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1) n2
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
rewrite if_dtt
if (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e) <? n1)
then
(fun
   E0 : (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e) <? n1) =
        true =>
 AA
   (exist (fun k : nat => (k <? n1) = true)
      (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e)) E0))
else
(fun
   E0 : (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e) <? n1) =
        false =>
 BB
   (exist (fun k : nat => (k <? n2) = true)
      (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e) - n1)
      (ltN_split_lemma1
         (proj2_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e)) E0)))
rewrite if_dtt
if (S x <? S n1)
then
(fun E0 : (S x <? S n1) = true =>
 AA (exist (fun k : nat => (k <? S n1) = true) (S x) E0))
else
(fun E0 : (S x <? S n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true) (x - n1) (ltN_split_lemma1 e E0)))
rewrite if_dtt
if (S x <? S n1)
then
(fun E0 : (S x <? S n1) = true =>
 AA (exist (fun k : nat => (k <? S n1) = true) (S x) E0))
else
(fun E0 : (S x <? S n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true) (x - n1) (ltN_split_lemma1 e E0)))
rewrite if_dtt
if (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e) <? n1)
then
(fun
   E0 : (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e) <? n1) =
        true =>
 AA
   (ltN_of_nat (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e))
      n1 E0))
else
(fun
   E0 : (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e) <? n1) =
        false =>
 BB
   (ltN_of_nat
      (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e) - n1) n2
      (ltN_split_lemma1
         (proj2_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e)) E0)))
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (exist (fun k : nat => (k <? S n1) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1)
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      (S n1) E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1) n2
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
rewrite if_dtt
if (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e) <? n1)
then
(fun
   E0 : (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e) <? n1) =
        true =>
 AA
   (exist (fun k : nat => (k <? n1) = true)
      (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e)) E0))
else
(fun
   E0 : (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e) <? n1) =
        false =>
 BB
   (exist (fun k : nat => (k <? n2) = true)
      (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e) - n1)
      (ltN_split_lemma1
         (proj2_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e)) E0)))
rewrite if_dtt
if (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e) <? n1)
then
(fun
   E0 : (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e) <? n1) =
        true =>
 AA
   (ltN_of_nat (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e))
      n1 E0))
else
(fun
   E0 : (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e) <? n1) =
        false =>
 BB
   (ltN_of_nat
      (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e) - n1) n2
      (ltN_split_lemma1
         (proj2_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e)) E0)))
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (exist (fun k : nat => (k <? S n1) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1)
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
rewrite if_dtt
if (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e) <? n1)
then
(fun
   E0 : (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e) <? n1) =
        true =>
 AA
   (exist (fun k : nat => (k <? n1) = true)
      (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e)) E0))
else
(fun
   E0 : (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e) <? n1) =
        false =>
 BB
   (exist (fun k : nat => (k <? n2) = true)
      (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e) - n1)
      (ltN_split_lemma1
         (proj2_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e)) E0)))
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (exist (fun k : nat => (k <? S n1) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1)
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
Chars 12850 - 12869 [(split;~try~apply~_).] 40.108 secs (0.011u,0.018s)
Chars 12872 - 12883 [(intros~x~y).] 0. secs (0.u,0.s)
Chars 12886 - 12892 [split.] 0. secs (0.u,0.s)
Chars 12895 - 12896 [-] 0. secs (0.u,0.s)
Chars 12897 - 12908 [(intros~?~E).] 0. secs (0.u,0.s)
Chars 12909 - 12952 [(apply~lt_correct~in~E;~destru...] 0.001 secs (0.001u,0.s)
Chars 12957 - 12995 [(apply~(antisymmetry~(≤));~ass...] 0.002 secs (0.002u,0.s)
Chars 12998 - 12999 [-] 0. secs (0.u,0.s)
Chars 13000 - 13010 [(intros~E1).] 0. secs (0.u,0.s)
Chars 13015 - 13051 [(destruct~(total~(≤)~x~y);~tri...] 0.003 secs (0.003u,0.s)
Chars 13056 - 13090 [(destruct~(dec~(x~=~y))~as~[E2...] 0.015 secs (0.015u,0.s)
Chars 13095 - 13096 [+] 0. secs (0.u,0.s)
Chars 13097 - 13108 [(rewrite~E2).] 0. secs (0.u,0.s)
Chars 13109 - 13127 [(apply~reflexivity).] 0.002 secs (0.002u,0.s)
Chars 13132 - 13133 [+] 0. secs (0.u,0.s)
Chars 13134 - 13146 [(destruct~E1).] 0.001 secs (0.001u,0.s)
Chars 13147 - 13175 [(apply~lt_correct;~split;~auto).] 0.003 secs (0.003u,0.s)
Chars 13182 - 13213 [(apply~symmetric_neq;~assumpti...] 0.001 secs (0.u,0.s)
Chars 12850 - 12869 [(split;~try~apply~_).] 0.001 secs (0.001u,0.s)
Chars 12872 - 12883 [(intros~x~y).] 0. secs (0.u,0.s)
Chars 12886 - 12892 [split.] 0. secs (0.u,0.s)
Chars 12897 - 12908 [(intros~?~E).] 0. secs (0.u,0.s)
Chars 12909 - 12952 [(apply~lt_correct~in~E;~destru...] 0. secs (0.u,0.s)
Chars 12957 - 12995 [(apply~(antisymmetry~(≤));~ass...] 0.001 secs (0.001u,0.s)
Chars 13000 - 13010 [(intros~E1).] 0. secs (0.u,0.s)
Chars 13015 - 13051 [(destruct~(total~(≤)~x~y);~tri...] 0.001 secs (0.001u,0.s)
Chars 13056 - 13090 [(destruct~(dec~(x~=~y))~as~[E2...] 0. secs (0.u,0.s)
Chars 13097 - 13108 [(rewrite~E2).] 0. secs (0.u,0.s)
Chars 13109 - 13127 [(apply~reflexivity).] 0. secs (0.u,0.s)
Chars 13134 - 13146 [(destruct~E1).] 0. secs (0.u,0.s)
Chars 13147 - 13175 [(apply~lt_correct;~split;~auto).] 0.001 secs (0.001u,0.s)
Chars 13182 - 13213 [(apply~symmetric_neq;~assumpti...] 0. secs (0.u,0.s)
Chars 13216 - 13220 [Qed.] 0.001 secs (0.001u,0.s)
Chars 13221 - 13243 [End~dec_partial_order.] 0.041 secs (0.035u,0.005s)
Chars 13245 - 13311 [Lemma~lt_eq_trans~`{Lt~A}~:~fo...] 0.001 secs (0.001u,0.s)
Chars 13312 - 13318 [Proof.] 0. secs (0.u,0.s)
rewrite if_dtt
if match n1 with
   | 0 => false
   | S _ => true
   end
then
(fun E0 : match n1 with
          | 0 => false
          | S _ => true
          end = true =>
 AA
   (exist
      (fun k : nat =>
       (fix leb (n m : nat) {struct n} : bool :=
          match n with
          | 0 => true
          | S n' => match m with
                    | 0 => false
                    | S m' => leb n' m'
                    end
          end) k n1 = true) 1 E0))
else
(fun E0 : match n1 with
          | 0 => false
          | S _ => true
          end = false =>
 BB
   (exist
      (fun k : nat =>
       match n2 with
       | 0 => false
       | S m' =>
           (fix leb (n m : nat) {struct n} : bool :=
              match n with
              | 0 => true
              | S n' => match m with
                        | 0 => false
                        | S m'0 => leb n' m'0
                        end
              end) k m'
       end = true) 0 (ltN_split_lemma1 e E0)))
Chars 13319 - 13342 [(intros~?~?~?~?~[];~trivial).] 0.996 secs (0.u,0.02s)
Chars 13319 - 13342 [(intros~?~?~?~?~[];~trivial).] 0. secs (0.u,0.s)
Chars 13343 - 13347 [Qed.] 0. secs (0.u,0.s)
Chars 13349 - 13364 [Section~pseudo.] 0. secs (0.u,0.s)
Chars 13367 - 13386 [Context~{A~:~Type}.] 0. secs (0.u,0.s)
Chars 13389 - 13414 [Context~`{PseudoOrder~A}.] 0. secs (0.u,0.s)
Chars 13418 - 13479 [Lemma~nlt_lt_trans~{x~y~z~:~A}...] 0. secs (0.u,0.s)
Chars 13482 - 13488 [Proof.] 0. secs (0.u,0.s)
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      (S n1) E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1) n2
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      (S n1) E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1) n2
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
rewrite if_dtt
if (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e) <? n1)
then
(fun
   E0 : (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e) <? n1) =
        true =>
 AA
   (exist (fun k : nat => (k <? n1) = true)
      (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e)) E0))
else
(fun
   E0 : (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e) <? n1) =
        false =>
 BB
   (exist (fun k : nat => (k <? n2) = true)
      (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e) - n1)
      (ltN_split_lemma1
         (proj2_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e)) E0)))
rewrite if_dtt
if (S x <? S n1)
then
(fun E0 : (S x <? S n1) = true =>
 AA (exist (fun k : nat => (k <? S n1) = true) (S x) E0))
else
(fun E0 : (S x <? S n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true) (x - n1) (ltN_split_lemma1 e E0)))
rewrite if_dtt
if (S x <? S n1)
then
(fun E0 : (S x <? S n1) = true =>
 AA (exist (fun k : nat => (k <? S n1) = true) (S x) E0))
else
(fun E0 : (S x <? S n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true) (x - n1) (ltN_split_lemma1 e E0)))
rewrite if_dtt
if (S x <? S n1)
then
(fun E0 : (S x <? S n1) = true =>
 AA (exist (fun k : nat => (k <? S n1) = true) (S x) E0))
else
(fun E0 : (S x <? S n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true) (x - n1) (ltN_split_lemma1 e E0)))
Chars 13493 - 13511 [(intros~nltyx~ltyz).] 4.869 secs (0.u,0.019s)
Chars 13516 - 13553 [(pose~proof~(cotransitive~ltyz...] 0.001 secs (0.001u,0.s)
Chars 13558 - 13576 [strip_truncations.] 0.049 secs (0.036u,0.012s)
Chars 13581 - 13610 [(destruct~disj~as~[ltyx|~ltxz]).] 0.001 secs (0.001u,0.s)
Chars 13615 - 13616 [-] 0. secs (0.u,0.s)
Chars 13617 - 13639 [(destruct~(nltyx~ltyx)).] 0.001 secs (0.001u,0.s)
Chars 13644 - 13645 [-] 0. secs (0.u,0.s)
Chars 13646 - 13657 [exact~ltxz.] 0. secs (0.u,0.s)
Chars 13493 - 13511 [(intros~nltyx~ltyz).] 0. secs (0.u,0.s)
Chars 13516 - 13553 [(pose~proof~(cotransitive~ltyz...] 0. secs (0.u,0.s)
Chars 13558 - 13576 [strip_truncations.] 0. secs (0.u,0.s)
Chars 13581 - 13610 [(destruct~disj~as~[ltyx|~ltxz]).] 0. secs (0.u,0.s)
Chars 13617 - 13639 [(destruct~(nltyx~ltyx)).] 0. secs (0.u,0.s)
Chars 13646 - 13657 [exact~ltxz.] 0. secs (0.u,0.s)
Chars 13660 - 13664 [Qed.] 0.001 secs (0.001u,0.s)
Chars 13668 - 13729 [Lemma~lt_nlt_trans~{x~y~z~:~A}...] 0. secs (0.u,0.s)
Chars 13732 - 13738 [Proof.] 0. secs (0.u,0.s)
rewrite if_dtt
if match n1 with
   | 0 => false
   | S _ => true
   end
then
(fun E0 : match n1 with
          | 0 => false
          | S _ => true
          end = true =>
 AA
   (exist
      (fun k : nat =>
       match n1 with
       | 0 => false
       | S m' =>
           (fix leb (n m : nat) {struct n} : bool :=
              match n with
              | 0 => true
              | S n' => match m with
                        | 0 => false
                        | S m'0 => leb n' m'0
                        end
              end) k m'
       end = true) 0 E0))
else
(fun E0 : match n1 with
          | 0 => false
          | S _ => true
          end = false =>
 BB
   (exist
      (fun k : nat =>
       match n2 with
       | 0 => false
       | S m' =>
           (fix leb (n m : nat) {struct n} : bool :=
              match n with
              | 0 => true
              | S n' => match m with
                        | 0 => false
                        | S m'0 => leb n' m'0
                        end
              end) k m'
       end = true) 0 (ltN_split_lemma1 e E0)))
rewrite if_dtt
if (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e) <? n1)
then
(fun
   E0 : (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e) <? n1) =
        true =>
 AA
   (ltN_of_nat (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e))
      n1 E0))
else
(fun
   E0 : (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e) <? n1) =
        false =>
 BB
   (ltN_of_nat
      (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e) - n1) n2
      (ltN_split_lemma1
         (proj2_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e)) E0)))
rewrite if_dtt
if (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e) <? n1)
then
(fun
   E0 : (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e) <? n1) =
        true =>
 AA
   (ltN_of_nat (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e))
      n1 E0))
else
(fun
   E0 : (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e) <? n1) =
        false =>
 BB
   (ltN_of_nat
      (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e) - n1) n2
      (ltN_split_lemma1
         (proj2_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e)) E0)))
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (exist (fun k : nat => (k <? S n1) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1)
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
rewrite if_dtt
if match n1 with
   | 0 => false
   | S _ => true
   end
then
(fun E0 : match n1 with
          | 0 => false
          | S _ => true
          end = true =>
 AA
   (exist
      (fun k : nat =>
       (fix leb (n m : nat) {struct n} : bool :=
          match n with
          | 0 => true
          | S n' => match m with
                    | 0 => false
                    | S m' => leb n' m'
                    end
          end) k n1 = true) 1 E0))
else
(fun E0 : match n1 with
          | 0 => false
          | S _ => true
          end = false =>
 BB
   (exist
      (fun k : nat =>
       match n2 with
       | 0 => false
       | S m' =>
           (fix leb (n m : nat) {struct n} : bool :=
              match n with
              | 0 => true
              | S n' => match m with
                        | 0 => false
                        | S m'0 => leb n' m'0
                        end
              end) k m'
       end = true) 0 (ltN_split_lemma1 e E0)))
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      (S n1) E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1) n2
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      (S n1) E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1) n2
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
rewrite if_dtt
if (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e) <? n1)
then
(fun
   E0 : (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e) <? n1) =
        true =>
 AA
   (exist (fun k : nat => (k <? n1) = true)
      (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e)) E0))
else
(fun
   E0 : (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e) <? n1) =
        false =>
 BB
   (exist (fun k : nat => (k <? n2) = true)
      (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e) - n1)
      (ltN_split_lemma1
         (proj2_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e)) E0)))
rewrite if_dtt
if (S x <? S n1)
then
(fun E0 : (S x <? S n1) = true =>
 AA (exist (fun k : nat => (k <? S n1) = true) (S x) E0))
else
(fun E0 : (S x <? S n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true) (x - n1) (ltN_split_lemma1 e E0)))
rewrite if_dtt
if (S x <? S n1)
then
(fun E0 : (S x <? S n1) = true =>
 AA (exist (fun k : nat => (k <? S n1) = true) (S x) E0))
else
(fun E0 : (S x <? S n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true) (x - n1) (ltN_split_lemma1 e E0)))
rewrite if_dtt
if match n1 with
   | 0 => false
   | S _ => true
   end
then
(fun E0 : match n1 with
          | 0 => false
          | S _ => true
          end = true =>
 AA
   (exist
      (fun k : nat =>
       match n1 with
       | 0 => false
       | S m' =>
           (fix leb (n m : nat) {struct n} : bool :=
              match n with
              | 0 => true
              | S n' => match m with
                        | 0 => false
                        | S m'0 => leb n' m'0
                        end
              end) k m'
       end = true) 0 E0))
else
(fun E0 : match n1 with
          | 0 => false
          | S _ => true
          end = false =>
 BB
   (exist
      (fun k : nat =>
       match n2 with
       | 0 => false
       | S m' =>
           (fix leb (n m : nat) {struct n} : bool :=
              match n with
              | 0 => true
              | S n' => match m with
                        | 0 => false
                        | S m'0 => leb n' m'0
                        end
              end) k m'
       end = true) 0 (ltN_split_lemma1 e E0)))
rewrite if_dtt
if (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e) <? n1)
then
(fun
   E0 : (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e) <? n1) =
        true =>
 AA
   (ltN_of_nat (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e))
      n1 E0))
else
(fun
   E0 : (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e) <? n1) =
        false =>
 BB
   (ltN_of_nat
      (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e) - n1) n2
      (ltN_split_lemma1
         (proj2_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e)) E0)))
rewrite if_dtt
if (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e) <? n1)
then
(fun
   E0 : (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e) <? n1) =
        true =>
 AA
   (ltN_of_nat (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e))
      n1 E0))
else
(fun
   E0 : (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e) <? n1) =
        false =>
 BB
   (ltN_of_nat
      (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e) - n1) n2
      (ltN_split_lemma1
         (proj2_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e)) E0)))
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (exist (fun k : nat => (k <? S n1) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1)
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
rewrite if_dtt
if match n1 with
   | 0 => false
   | S _ => true
   end
then
(fun E0 : match n1 with
          | 0 => false
          | S _ => true
          end = true =>
 AA
   (exist
      (fun k : nat =>
       (fix leb (n m : nat) {struct n} : bool :=
          match n with
          | 0 => true
          | S n' => match m with
                    | 0 => false
                    | S m' => leb n' m'
                    end
          end) k n1 = true) 1 E0))
else
(fun E0 : match n1 with
          | 0 => false
          | S _ => true
          end = false =>
 BB
   (exist
      (fun k : nat =>
       match n2 with
       | 0 => false
       | S m' =>
           (fix leb (n m : nat) {struct n} : bool :=
              match n with
              | 0 => true
              | S n' => match m with
                        | 0 => false
                        | S m'0 => leb n' m'0
                        end
              end) k m'
       end = true) 0 (ltN_split_lemma1 e E0)))
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      (S n1) E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1) n2
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      (S n1) E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1) n2
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
rewrite if_dtt
if (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e) <? n1)
then
(fun
   E0 : (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e) <? n1) =
        true =>
 AA
   (exist (fun k : nat => (k <? n1) = true)
      (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e)) E0))
else
(fun
   E0 : (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e) <? n1) =
        false =>
 BB
   (exist (fun k : nat => (k <? n2) = true)
      (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e) - n1)
      (ltN_split_lemma1
         (proj2_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e)) E0)))
rewrite if_dtt
if (S x <? S n1)
then
(fun E0 : (S x <? S n1) = true =>
 AA (exist (fun k : nat => (k <? S n1) = true) (S x) E0))
else
(fun E0 : (S x <? S n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true) (x - n1) (ltN_split_lemma1 e E0)))
rewrite if_dtt
if (S x <? S n1)
then
(fun E0 : (S x <? S n1) = true =>
 AA (exist (fun k : nat => (k <? S n1) = true) (S x) E0))
else
(fun E0 : (S x <? S n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true) (x - n1) (ltN_split_lemma1 e E0)))
rewrite if_dtt
if match n1 with
   | 0 => false
   | S _ => true
   end
then
(fun E0 : match n1 with
          | 0 => false
          | S _ => true
          end = true =>
 AA
   (exist
      (fun k : nat =>
       match n1 with
       | 0 => false
       | S m' =>
           (fix leb (n m : nat) {struct n} : bool :=
              match n with
              | 0 => true
              | S n' => match m with
                        | 0 => false
                        | S m'0 => leb n' m'0
                        end
              end) k m'
       end = true) 0 E0))
else
(fun E0 : match n1 with
          | 0 => false
          | S _ => true
          end = false =>
 BB
   (exist
      (fun k : nat =>
       match n2 with
       | 0 => false
       | S m' =>
           (fix leb (n m : nat) {struct n} : bool :=
              match n with
              | 0 => true
              | S n' => match m with
                        | 0 => false
                        | S m'0 => leb n' m'0
                        end
              end) k m'
       end = true) 0 (ltN_split_lemma1 e E0)))
rewrite if_dtt
if (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e) <? n1)
then
(fun
   E0 : (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e) <? n1) =
        true =>
 AA
   (ltN_of_nat (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e))
      n1 E0))
else
(fun
   E0 : (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e) <? n1) =
        false =>
 BB
   (ltN_of_nat
      (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e) - n1) n2
      (ltN_split_lemma1
         (proj2_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e)) E0)))
rewrite if_dtt
if (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e) <? n1)
then
(fun
   E0 : (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e) <? n1) =
        true =>
 AA
   (ltN_of_nat (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e))
      n1 E0))
else
(fun
   E0 : (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e) <? n1) =
        false =>
 BB
   (ltN_of_nat
      (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e) - n1) n2
      (ltN_split_lemma1
         (proj2_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e)) E0)))
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (exist (fun k : nat => (k <? S n1) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1)
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      (S n1) E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1) n2
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      (S n1) E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1) n2
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
rewrite if_dtt
if (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e) <? n1)
then
(fun
   E0 : (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e) <? n1) =
        true =>
 AA
   (exist (fun k : nat => (k <? n1) = true)
      (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e)) E0))
else
(fun
   E0 : (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e) <? n1) =
        false =>
 BB
   (exist (fun k : nat => (k <? n2) = true)
      (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e) - n1)
      (ltN_split_lemma1
         (proj2_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e)) E0)))
rewrite if_dtt
if (S x <? S n1)
then
(fun E0 : (S x <? S n1) = true =>
 AA (exist (fun k : nat => (k <? S n1) = true) (S x) E0))
else
(fun E0 : (S x <? S n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true) (x - n1) (ltN_split_lemma1 e E0)))
rewrite if_dtt
if (S x <? S n1)
then
(fun E0 : (S x <? S n1) = true =>
 AA (exist (fun k : nat => (k <? S n1) = true) (S x) E0))
else
(fun E0 : (S x <? S n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true) (x - n1) (ltN_split_lemma1 e E0)))
rewrite if_dtt
if (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e) <? n1)
then
(fun
   E0 : (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e) <? n1) =
        true =>
 AA
   (ltN_of_nat (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e))
      n1 E0))
else
(fun
   E0 : (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e) <? n1) =
        false =>
 BB
   (ltN_of_nat
      (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e) - n1) n2
      (ltN_split_lemma1
         (proj2_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e)) E0)))
rewrite if_dtt
if (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e) <? n1)
then
(fun
   E0 : (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e) <? n1) =
        true =>
 AA
   (ltN_of_nat (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e))
      n1 E0))
else
(fun
   E0 : (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e) <? n1) =
        false =>
 BB
   (ltN_of_nat
      (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e) - n1) n2
      (ltN_split_lemma1
         (proj2_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e)) E0)))
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (exist (fun k : nat => (k <? S n1) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1)
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      (S n1) E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1) n2
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
rewrite if_dtt
if (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e) <? n1)
then
(fun
   E0 : (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e) <? n1) =
        true =>
 AA
   (exist (fun k : nat => (k <? n1) = true)
      (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e)) E0))
else
(fun
   E0 : (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e) <? n1) =
        false =>
 BB
   (exist (fun k : nat => (k <? n2) = true)
      (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e) - n1)
      (ltN_split_lemma1
         (proj2_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e)) E0)))
rewrite if_dtt
if (S x <? S n1)
then
(fun E0 : (S x <? S n1) = true =>
 AA (exist (fun k : nat => (k <? S n1) = true) (S x) E0))
else
(fun E0 : (S x <? S n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true) (x - n1) (ltN_split_lemma1 e E0)))
rewrite if_dtt
if (S x <? S n1)
then
(fun E0 : (S x <? S n1) = true =>
 AA (exist (fun k : nat => (k <? S n1) = true) (S x) E0))
else
(fun E0 : (S x <? S n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true) (x - n1) (ltN_split_lemma1 e E0)))
rewrite if_dtt
if (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e) <? n1)
then
(fun
   E0 : (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e) <? n1) =
        true =>
 AA
   (ltN_of_nat (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e))
      n1 E0))
else
(fun
   E0 : (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e) <? n1) =
        false =>
 BB
   (ltN_of_nat
      (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e) - n1) n2
      (ltN_split_lemma1
         (proj2_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e)) E0)))
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (exist (fun k : nat => (k <? S n1) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true)
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1)
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
rewrite if_dtt
if
(proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <? S n1)
then
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = true =>
 AA
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)))
      (S n1) E0))
else
(fun
   E0 : (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) <?
         S n1) = false =>
 BB
   (ltN_of_nat
      (proj1_sig (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e)) -
       S n1) n2
      (ltN_split_lemma1
         (proj2_sig
            (ltN_S (exist (fun k : nat => (k <? n1 + n2) = true) x e))) E0)))
Chars 14189 - 14201 [(intros~ltzx).] 40.014 secs (0.u,0.002s)
Chars 14206 - 14253 [(refine~(lt_le_trans~z~x~_~_~_...] 0.001 secs (0.001u,0.s)
Chars 14258 - 14274 [(apply~join_ub_l).] 0.001 secs (0.001u,0.s)
Chars 14189 - 14201 [(intros~ltzx).] 0. secs (0.u,0.s)
Chars 14206 - 14253 [(refine~(lt_le_trans~z~x~_~_~_...] 0. secs (0.u,0.s)
Chars 14258 - 14274 [(apply~join_ub_l).] 0. secs (0.u,0.s)
Chars 14277 - 14281 [Qed.] 0. secs (0.u,0.s)
Chars 14285 - 14332 [Lemma~join_lt_l_r~x~y~z~:~z~<~...] 0. secs (0.u,0.s)
Chars 14335 - 14341 [Proof.] 0. secs (0.u,0.s)
rewrite if_dtt
if (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e) <? n1)
then
(fun
   E0 : (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e) <? n1) =
        true =>
 AA
   (exist (fun k : nat => (k <? n1) = true)
      (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e)) E0))
else
(fun
   E0 : (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e) <? n1) =
        false =>
 BB
   (exist (fun k : nat => (k <? n2) = true)
      (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e) - n1)
      (ltN_split_lemma1
         (proj2_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e)) E0)))
rewrite if_dtt
if (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e) <? n1)
then
(fun
   E0 : (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e) <? n1) =
        true =>
 AA
   (ltN_of_nat (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e))
      n1 E0))
else
(fun
   E0 : (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e) <? n1) =
        false =>
 BB
   (ltN_of_nat
      (proj1_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e) - n1) n2
      (ltN_split_lemma1
         (proj2_sig (exist (fun k : nat => (k <? n1 + n2) = true) x e)) E0)))
rewrite if_dtt
if (S x <? S n1)
then
(fun E0 : (S x <? S n1) = true =>
 AA (exist (fun k : nat => (k <? S n1) = true) (S x) E0))
else
(fun E0 : (S x <? S n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true) (x - n1) (ltN_split_lemma1 e E0)))
simplified dependent [if true]
p : (S x <? S n1)  = true
if (S x <? S n1)
then
(fun E0 : (x <? n1) = true =>
 AA (exist (fun k : nat => (k <? n1) = true) x E0))
else
(fun E0 : (x <? n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true) (x - n1) (ltN_split_lemma1 e E0)))
simplified dependent [if false]
p : (S x <? S n1)  = true
if (S x <? S n1)
then
(fun E0 : (x <? n1) = true =>
 AA (exist (fun k : nat => (k <? n1) = true) x E0))
else
(fun E0 : (x <? n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true) (x - n1) (ltN_split_lemma1 e E0)))
Chars 13743 - 13761 [(intros~ltxy~nltzy).] 40.095 secs (0.001u,0.018s)
Chars 13766 - 13803 [(pose~proof~(cotransitive~ltxy...] 0.001 secs (0.001u,0.s)
Chars 13808 - 13826 [strip_truncations.] 0.05 secs (0.045u,0.004s)
Chars 13831 - 13860 [(destruct~disj~as~[ltxz|~ltzy]).] 0.001 secs (0.001u,0.s)
Chars 13865 - 13866 [-] 0. secs (0.u,0.s)
Chars 13867 - 13878 [exact~ltxz.] 0. secs (0.u,0.s)
Chars 13883 - 13884 [-] 0. secs (0.u,0.s)
Chars 13885 - 13907 [(destruct~(nltzy~ltzy)).] 0. secs (0.u,0.s)
Chars 13743 - 13761 [(intros~ltxy~nltzy).] 0. secs (0.u,0.s)
Chars 13766 - 13803 [(pose~proof~(cotransitive~ltxy...] 0. secs (0.u,0.s)
Chars 13808 - 13826 [strip_truncations.] 0. secs (0.u,0.s)
Chars 13831 - 13860 [(destruct~disj~as~[ltxz|~ltzy]).] 0. secs (0.u,0.s)
Chars 13867 - 13878 [exact~ltxz.] 0. secs (0.u,0.s)
Chars 13885 - 13907 [(destruct~(nltzy~ltzy)).] 0. secs (0.u,0.s)
Chars 13910 - 13914 [Qed.] 0. secs (0.u,0.s)
Chars 13918 - 13962 [Lemma~lt_transitive~:~Transiti...] 0.01 secs (0.006u,0.003s)
Chars 13965 - 13971 [Proof.] 0. secs (0.u,0.s)
Finished transaction in 45.334 secs (44.33u,1.001s) (successful)
Crunching: (list2D_to_matrix [[e]] = ⟨ 0 ∣ × ∣ 0 ⟩)
Crunching: (list2D_to_matrix [[C1]] = I 1)
Chars 14346 - 14358 [(intros~ltzy).] 40.012 secs (0.u,0.003s)
Chars 14363 - 14410 [(refine~(lt_le_trans~z~y~_~_~_...] 0.001 secs (0.001u,0.s)
Chars 14415 - 14431 [(apply~join_ub_r).] 0. secs (0.u,0.s)
Chars 14346 - 14358 [(intros~ltzy).] 0. secs (0.u,0.s)
Chars 14363 - 14410 [(refine~(lt_le_trans~z~y~_~_~_...] 0. secs (0.u,0.s)
Chars 14415 - 14431 [(apply~join_ub_r).] 0. secs (0.u,0.s)
Chars 14434 - 14438 [Qed.] 0. secs (0.u,0.s)
Chars 14442 - 14496 [Lemma~join_lt_r~x~y~z~:~x~<~z~...] 0.001 secs (0.001u,0.s)
Chars 14499 - 14505 [Proof.] 0. secs (0.u,0.s)
Crunching: (list2D_to_matrix [[e]; [e0]] = / √ 2 .* ∣ 0 ⟩ .+ / √ 2 .* ∣ 1 ⟩)
Crunching:
(list2D_to_matrix [[e]; [e0]] =
 hadamard × list2D_to_matrix [[/ √ 2]; [/ √ 2]])
Crunching:
(list2D_to_matrix
   [[C1 / √ 2 * / √ 2 + C1 / √ 2 * / √ 2];
   [C1 / √ 2 * / √ 2 + - (C1 / √ 2) * / √ 2]] = ∣ 0 ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = / √ 2 .* ∣ 0 ⟩ .+ / √ 2 .* ∣ 1 ⟩)
Crunching:
(list2D_to_matrix [[e]; [e0]] =
 hadamard × list2D_to_matrix [[/ √ 2]; [/ √ 2]])
Crunching:
(list2D_to_matrix
   [[C1 / √ 2 * / √ 2 + C1 / √ 2 * / √ 2];
   [C1 / √ 2 * / √ 2 + - (C1 / √ 2) * / √ 2]] = ∣ 0 ⟩)
Crunching:
(forall ψ : Vector Hxlex0,
 probability_of_outcome Hyley0 ψ = probability_of_outcome ψ Hyley0)
Crunching:
(probability_of_outcome Hyley0 q = probability_of_outcome q Hyley0)
Finished transaction in 8.55 secs (8.41u,0.138s) (successful)
Chars 13976 - 13999 [(intros~x~y~z~ltxy~ltyz).] 26.316 secs (0.u,0.018s)
Chars 14004 - 14042 [(pose~proof~(cotransitive~ltxy...] 0.001 secs (0.001u,0.s)
Chars 14047 - 14065 [strip_truncations.] 0.034 secs (0.034u,0.s)
Chars 14070 - 14100 [(destruct~ltxyz~as~[ltxz|~ltzy]).] 0. secs (0.u,0.s)
Chars 14105 - 14106 [-] 0. secs (0.u,0.s)
Chars 14107 - 14118 [assumption.] 0. secs (0.u,0.s)
Chars 14123 - 14124 [-] 0. secs (0.u,0.s)
Chars 14125 - 14175 [(destruct~(pseudo_order_antisy...] 0.001 secs (0.001u,0.s)
Chars 13976 - 13999 [(intros~x~y~z~ltxy~ltyz).] 0. secs (0.u,0.s)
Chars 14004 - 14042 [(pose~proof~(cotransitive~ltxy...] 0. secs (0.u,0.s)
Chars 14047 - 14065 [strip_truncations.] 0. secs (0.u,0.s)
Chars 14070 - 14100 [(destruct~ltxyz~as~[ltxz|~ltzy]).] 0. secs (0.u,0.s)
Chars 14107 - 14118 [assumption.] 0. secs (0.u,0.s)
Chars 14125 - 14175 [(destruct~(pseudo_order_antisy...] 0. secs (0.u,0.s)
Chars 14178 - 14182 [Qed.] 0. secs (0.u,0.s)
Chars 14186 - 14225 [#[global]Existing~Instance~lt_...] 0. secs (0.u,0.s)
Chars 14227 - 14238 [End~pseudo.] 0.003 secs (0.003u,0.s)
Crunching: (forall z : C, m - z = n' -> m - n' - z = 0)
Crunching: (env - e - a = 0)
Crunching:
(forall ψ : Vector Hxlex0,
 probability_of_outcome Hyley0 ψ = probability_of_outcome ψ Hyley0)
Crunching:
(probability_of_outcome Hyley0 q = probability_of_outcome q Hyley0)
Crunching:
((((let (x, _) := a in x) + - (let (x, _) := b in x))%R,
 ((let (_, y) := a in y) + - (let (_, y) := b in y))%R) = a' ->
 (((let (x, _) := a in x) + - (let (x, _) := a' in x) +
   - (let (x, _) := b in x))%R,
 ((let (_, y) := a in y) + - (let (_, y) := a' in y) +
  - (let (_, y) := b in y))%R) = (R0, R0))
Finished transaction in 12.256 secs (12.228u,0.027s) (successful)
Finished transaction in 4.241 secs (4.206u,0.034s) (successful)
Crunching:
(forall ψ : Vector Hxlex0,
 probability_of_outcome Hyley0 ψ = probability_of_outcome ψ Hyley0)
Crunching:
(probability_of_outcome Hyley0 q = probability_of_outcome q Hyley0)
Crunching:
(forall A0 B : Square (2 ^ F), pad A f A0 × pad A f B = pad A f (A0 × B))
specialized IHeP using (eq_refl e )
rewrite if_dtt
if
match (let (x, _) := k in x) with
| 0 => false
| S x0 =>
    (fix Ffix (x x1 : nat) {struct x} : bool :=
       match x with
       | 0 => true
       | S x2 => match x1 with
                 | 0 => false
                 | S x3 => Ffix x2 x3
                 end
       end) x x0
end
then
(fun
   x0 : match (let (x, _) := k in x) with
        | 0 => false
        | S x0 =>
            (fix Ffix (x x1 : nat) {struct x} : bool :=
               match x with
               | 0 => true
               | S x2 => match x1 with
                         | 0 => false
                         | S x3 => Ffix x2 x3
                         end
               end) x x0
        end = true =>
 exist
   (fun x : nat =>
    (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
       match x1 with
       | 0 => true
       | S x3 => match x2 with
                 | 0 => false
                 | S x4 => Ffix x3 x4
                 end
       end) x n = true) x
   (ltN_intro_lemma1 n k (exist (fun k : nat => (k <? n) = true) x e) x0))
else
(fun
   x0 : match (let (x, _) := k in x) with
        | 0 => false
        | S x0 =>
            (fix Ffix (x x1 : nat) {struct x} : bool :=
               match x with
               | 0 => true
               | S x2 => match x1 with
                         | 0 => false
                         | S x3 => Ffix x2 x3
                         end
               end) x x0
        end = false =>
 exist
   (fun x : nat =>
    (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
       match x1 with
       | 0 => true
       | S x3 => match x2 with
                 | 0 => false
                 | S x4 => Ffix x3 x4
                 end
       end) x n = true) (S x)
   (ltN_intro_lemma2 n k (exist (fun k : nat => (k <? n) = true) x e) x0))
Crunching: (0 < b)
specialized IHeP2 using (eq_refl e0 )
specialized IHeP1 using (eq_refl e )
Crunching:
(forall r : R,
 (((let (H, _) := x in H) + - (fst x + - fst z) + - H9)%R,
 ((let (_, H) := x in H) + - (snd x + - snd z) + - r)%R) = 
 (R0, R0))
Finished transaction in 12.868 secs (12.805u,0.062s) (successful)
Crunching:
(forall A0 B : Square (2 ^ F), pad A f A0 × pad A f B = pad A f (A0 × B))
Chars 14510 - 14527 [(intros~ltxz~ltyz).] 40.015 secs (0.u,0.003s)
Chars 14532 - 14574 [(set~(disj~:=~cotransitive~ltx...] 0.002 secs (0.002u,0.s)
Chars 14579 - 14627 [(refine~(Trunc_rec~_~disj);~in...] 0.007 secs (0.007u,0.s)
Chars 14632 - 14633 [-] 0. secs (0.u,0.s)
Chars 14634 - 14677 [(set~(disj'~:=~cotransitive~lt...] 0.002 secs (0.002u,0.s)
Chars 14684 - 14733 [(refine~(Trunc_rec~_~disj');~i...] 0.008 secs (0.008u,0.s)
Chars 14740 - 14741 [+] 0. secs (0.u,0.s)
Chars 14742 - 14772 [(assert~(ineqx~:~x~⊔~y~<>~x)).] 0.001 secs (0.001u,0.s)
Chars 14781 - 14782 [{] 0. secs (0.u,0.s)
Chars 14793 - 14822 [(apply~lt_ne_flip;~assumption).] 0.002 secs (0.002u,0.s)
Chars 14831 - 14832 [}] 0. secs (0.u,0.s)
Chars 14841 - 14929 [(assert~(nleyx~:~~~(y~≤~x))~by...] 0.002 secs (0.002u,0.s)
Chars 14938 - 14962 [(assert~(lexy~:~x~≤~y)).] 0.001 secs (0.001u,0.s)
Chars 14971 - 14972 [{] 0. secs (0.u,0.s)
Chars 14983 - 15008 [(apply~le_iff_not_lt_flip).] 0.001 secs (0.001u,0.s)
Chars 15019 - 15031 [(intros~ltyx).] 0. secs (0.u,0.s)
Chars 15042 - 15071 [refine~(nleyx~(lt_le~_~_~_)).] 0.002 secs (0.002u,0.s)
Chars 15080 - 15081 [}] 0. secs (0.u,0.s)
Chars 15090 - 15120 [(assert~(ineqy~:~x~⊔~y~<>~y)).] 0.001 secs (0.001u,0.s)
Chars 15129 - 15130 [{] 0. secs (0.u,0.s)
Chars 15141 - 15170 [(apply~lt_ne_flip;~assumption).] 0.004 secs (0.004u,0.s)
Chars 15179 - 15180 [}] 0. secs (0.u,0.s)
Chars 15189 - 15277 [(assert~(nlexy~:~~~(x~≤~y))~by...] 0.003 secs (0.003u,0.s)
Chars 15286 - 15310 [(assert~(leyx~:~y~≤~x)).] 0.017 secs (0.014u,0.002s)
Chars 15319 - 15320 [{] 0. secs (0.u,0.s)
Chars 15331 - 15356 [(apply~le_iff_not_lt_flip).] 0.002 secs (0.002u,0.s)
Chars 15367 - 15379 [(intros~ltxy).] 0. secs (0.u,0.s)
Chars 15390 - 15419 [refine~(nlexy~(lt_le~_~_~_)).] 0.002 secs (0.002u,0.s)
Chars 15428 - 15429 [}] 0. secs (0.u,0.s)
Chars 15438 - 15511 [(assert~(eqxy~:~x~=~y)~by~refi...] 0.006 secs (0.006u,0.s)
Chars 15520 - 15545 [(rewrite~<-~eqxy~in~ineqx).] 0. secs (0.u,0.s)
Chars 15554 - 15591 [(destruct~(ineqx~(join_idempot...] 0.004 secs (0.004u,0.s)
Chars 15598 - 15599 [+] 0. secs (0.u,0.s)
Chars 15600 - 15611 [assumption.] 0. secs (0.u,0.s)
Chars 15616 - 15617 [-] 0. secs (0.u,0.s)
Chars 15618 - 15629 [assumption.] 0. secs (0.u,0.s)
Chars 14510 - 14527 [(intros~ltxz~ltyz).] 0. secs (0.u,0.s)
Chars 14532 - 14574 [(set~(disj~:=~cotransitive~ltx...] 0. secs (0.u,0.s)
Chars 14579 - 14627 [(refine~(Trunc_rec~_~disj);~in...] 0. secs (0.u,0.s)
Chars 14634 - 14677 [(set~(disj'~:=~cotransitive~lt...] 0. secs (0.u,0.s)
Chars 14684 - 14733 [(refine~(Trunc_rec~_~disj');~i...] 0. secs (0.u,0.s)
Chars 14742 - 14772 [(assert~(ineqx~:~x~⊔~y~<>~x)).] 0. secs (0.u,0.s)
Chars 14793 - 14822 [(apply~lt_ne_flip;~assumption).] 0. secs (0.u,0.s)
Chars 14841 - 14929 [(assert~(nleyx~:~~~(y~≤~x))~by...] 0. secs (0.u,0.s)
Chars 14938 - 14962 [(assert~(lexy~:~x~≤~y)).] 0. secs (0.u,0.s)
Chars 14983 - 15008 [(apply~le_iff_not_lt_flip).] 0. secs (0.u,0.s)
Chars 15019 - 15031 [(intros~ltyx).] 0. secs (0.u,0.s)
Chars 15042 - 15071 [refine~(nleyx~(lt_le~_~_~_)).] 0. secs (0.u,0.s)
Chars 15090 - 15120 [(assert~(ineqy~:~x~⊔~y~<>~y)).] 0. secs (0.u,0.s)
Chars 15141 - 15170 [(apply~lt_ne_flip;~assumption).] 0. secs (0.u,0.s)
Chars 15189 - 15277 [(assert~(nlexy~:~~~(x~≤~y))~by...] 0. secs (0.u,0.s)
Chars 15286 - 15310 [(assert~(leyx~:~y~≤~x)).] 0. secs (0.u,0.s)
Chars 15331 - 15356 [(apply~le_iff_not_lt_flip).] 0. secs (0.u,0.s)
Chars 15367 - 15379 [(intros~ltxy).] 0. secs (0.u,0.s)
Chars 15390 - 15419 [refine~(nlexy~(lt_le~_~_~_)).] 0. secs (0.u,0.s)
Chars 15438 - 15511 [(assert~(eqxy~:~x~=~y)~by~refi...] 0. secs (0.u,0.s)
Chars 15520 - 15545 [(rewrite~<-~eqxy~in~ineqx).] 0. secs (0.u,0.s)
Chars 15554 - 15591 [(destruct~(ineqx~(join_idempot...] 0. secs (0.u,0.s)
Chars 15600 - 15611 [assumption.] 0. secs (0.u,0.s)
Chars 15618 - 15629 [assumption.] 0. secs (0.u,0.s)
Chars 15632 - 15636 [Qed.] 0.001 secs (0.001u,0.s)
Chars 15640 - 15688 [Lemma~meet_lt_r_l~x~y~z~:~x~<~...] 0. secs (0.u,0.s)
Chars 15691 - 15697 [Proof.] 0. secs (0.u,0.s)
Crunching:
(list2D_to_matrix [[e]; [e0]] = / √ 2 .* ∣ 0 ⟩ .+ - / √ 2 .* ∣ 1 ⟩)
Crunching:
(list2D_to_matrix [[e]; [e0]] =
 hadamard × list2D_to_matrix [[/ √ 2]; [- / √ 2]])
Crunching:
(list2D_to_matrix
   [[C1 / √ 2 * / √ 2 + C1 / √ 2 * - / √ 2];
   [C1 / √ 2 * / √ 2 + - (C1 / √ 2) * - / √ 2]] = 
 ∣ 1 ⟩)
Crunching: ((?Goal2 < ?Goal1)%Z -> n ⨂ hadamard × env = n ⨂ f)
Crunching: (Cmod2 c = (Cmod c ^ 2)%R)
Crunching: (Cmod2 c = (Cmod c ^ 2)%R)
Crunching: (0 <= Cmod2 H)
Crunching:
(Z.abs_N (Z.rem (Z.pos x0) (Z.pos H7)) = (N.pos x0 mod N.pos H7)%N)
Crunching: (pad start dim A × pad start dim B = pad start dim (A × B))
Crunching: (0 < PI2 < 2)
Crunching: (pad 0 dim (I 2) = I (2 ^ dim))
Crunching: (0 < PI2 < 2)
Crunching: (0 < PI2 < 2)
Crunching: (pad 0 dim (I 2) = I (2 ^ dim))
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching: (Cmod2 c = (Cmod c ^ 2)%R)
Crunching: (Cmod2 c = (Cmod c ^ 2)%R)
Crunching: (0 <= Cmod2 H)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching: (0 <= Cmod2 H)
Crunching: (0 <= Cmod2 H)
Crunching:
(I a = big_sum (fun i : nat => basis_vector n i × (basis_vector n i) †) a)
Crunching: (0 <= Cmod2 H)
Crunching: (pad 0 dim (I 2) = I (2 ^ dim))
Crunching: (0 <= Cmod2 H)
Chars 15702 - 15714 [(intros~ltxz).] 40.014 secs (0.u,0.003s)
Chars 15719 - 15766 [(refine~(le_lt_trans~_~x~_~_~_...] 0.001 secs (0.001u,0.s)
Chars 15771 - 15787 [(apply~meet_lb_l).] 0. secs (0.u,0.s)
Chars 15702 - 15714 [(intros~ltxz).] 0. secs (0.u,0.s)
Chars 15719 - 15766 [(refine~(le_lt_trans~_~x~_~_~_...] 0. secs (0.u,0.s)
Chars 15771 - 15787 [(apply~meet_lb_l).] 0. secs (0.u,0.s)
Chars 15790 - 15794 [Qed.] 0. secs (0.u,0.s)
Chars 15798 - 15846 [Lemma~meet_lt_r_r~x~y~z~:~y~<~...] 0. secs (0.u,0.s)
Chars 15849 - 15855 [Proof.] 0. secs (0.u,0.s)
Crunching: (0 <= Cmod2 H)
Crunching: (pad 0 dim (I 2) = I (2 ^ dim))
Crunching: (0 <= Cmod2 H)
Crunching: (0 <= Cmod2 H)
Crunching:
(I N1 = big_sum (fun i : nat => basis_vector H2 i × (basis_vector H2 i) †) N1)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching: (pad 0 dim (I 2) = I (2 ^ dim))
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching: (0 <= Cmod2 H)
Crunching: (0 <= Cmod2 H)
Crunching: (0 <= Cmod2 H)
Crunching: (0 <= Cmod2 H)
Crunching: (sum_over_list (n :: Hn) = (n + sum_over_list Hn)%R)
Crunching:
(I a x x0 =
 big_sum (fun i : nat => basis_vector n i × (basis_vector n i) †) a x x0)
Crunching: (sum_over_list (n :: Hn) = (n + sum_over_list Hn)%R)
Crunching:
(I a x x0 =
 big_sum (fun i : nat => basis_vector n i × (basis_vector n i) †) a x x0)
Crunching: (sum_over_list (n :: Hn) = (n + sum_over_list Hn)%R)
Crunching:
(I a x x0 =
 big_sum (fun i : nat => basis_vector n i × (basis_vector n i) †) a x x0)
Crunching:
((/ √ 2 + 0)%R <> 0 -> sum_over_list (N :: H5) = (N + sum_over_list H5)%R)
Crunching:
(I a x x0 =
 big_sum (fun i : nat => basis_vector n i × (basis_vector n i) †) a x x0)
Crunching: ((x < 1)%nat -> (σx × ∣ 0 ⟩) H x = ∣ 1 ⟩ H x)
Crunching: (WF_Matrix (pad h hn0 (I 2)))
Crunching: ((σx × ∣ 0 ⟩) H 0%nat = ∣ 1 ⟩ H 0%nat)
Crunching: ((σx × ∣ 0 ⟩) H 0%nat = ∣ 1 ⟩ H 0%nat)
Crunching:
(I a x x0 =
 big_sum (fun i : nat => basis_vector n i × (basis_vector n i) †) a x x0)
Crunching:
(I a x x0 =
 big_sum (fun i : nat => basis_vector n i × (basis_vector n i) †) a x x0)
Crunching: (sum_over_list (n :: Hn) = (n + sum_over_list Hn)%R)
Crunching:
(I a x x0 =
 big_sum (fun i : nat => basis_vector n i × (basis_vector n i) †) a x x0)
Crunching: ((fun r : R => exp r <> 0) 1)
Crunching:
(forall (dim n : nat) (u : Square 2),
 WF_Matrix u -> WF_Matrix (pad_u dim n u))
Crunching: (∣ 1 ⟩ H x = (σx × ∣ 0 ⟩) H x)
Crunching:
(I a x x0 =
 big_sum (fun i : nat => basis_vector n i × (basis_vector n i) †) a x x0)
Crunching: (sum_over_list (He :: esp) = (He + sum_over_list esp)%R)
Crunching: ((σx × ∣ 0 ⟩) H l = ∣ 1 ⟩ H l)
Crunching:
((forall r1 r2 : R, r1 > 0 -> r2 > 0 -> r1 * r2 > 0) ->
 (l < 1)%nat -> (σx × ∣ 0 ⟩) H l = ∣ 1 ⟩ H l)
Crunching: (pad_u x y H m Hm = 0)
Crunching:
(I a x x0 =
 big_sum (fun i : nat => basis_vector n i × (basis_vector n i) †) a x x0)
Crunching:
(I a x x0 =
 big_sum (fun i : nat => basis_vector n i × (basis_vector n i) †) a x x0)
Crunching: ((σx × ∣ 0 ⟩) H l = ∣ 1 ⟩ H l)
Crunching: ((σx × ∣ 0 ⟩) H l = ∣ 1 ⟩ H l)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Crunching:
(I a x x0 =
 big_sum (fun i : nat => basis_vector n i × (basis_vector n i) †) a x x0)
Crunching:
(forall (dim n : nat) (u : Square 2),
 WF_Matrix u -> WF_Matrix (pad_u dim n u))
Crunching:
(I a x x0 =
 big_sum (fun i : nat => basis_vector n i × (basis_vector n i) †) a x x0)
Crunching:
(I a x x0 =
 big_sum (fun i : nat => basis_vector n i × (basis_vector n i) †) a x x0)
Crunching:
(I a x x0 =
 big_sum (fun i : nat => basis_vector n i × (basis_vector n i) †) a x x0)
Crunching:
(forall j : nat,
 (Hb < 2)%nat -> (j < 1)%nat -> (σx × ∣ 0 ⟩) Hb j = ∣ 1 ⟩ Hb j)
Crunching: ((σx × ∣0⟩) x = ∣1⟩ x)
Crunching:
(I a x x0 =
 big_sum (fun i : nat => basis_vector n i × (basis_vector n i) †) a x x0)
Crunching:
(I a =
 big_sum
   (fun i x z : nat =>
    Σ (fun y : nat => basis_vector n i x y * (basis_vector n i) † y z) 1) a)
Crunching:
(I (S m) =
 I m
 .+ (fun i j : nat => if (i =? m) && (j =? 0) then C1 else 0)
    × (fun i j : nat => if (i =? m) && (j =? 0) then C1 else 0) †)
Crunching: (0 < 1 -> σx × ∣ 0 ⟩ = ∣ 1 ⟩)
Crunching:
(prob_partial_meas Hypmn ψ = (norm ((Hypmn ⊗ I (2 ^ 0)) † × ψ) ^ 2)%R)
Crunching:
(forall ψ : Vector (2 ^ (m + n)),
 prob_partial_meas Hypmn ψ = (norm ((Hypmn ⊗ I (2 ^ n)) † × ψ) ^ 2)%R)
Crunching:
(forall (n : nat) (P : nat -> Type),
 (forall k : nat, (0 < k)%nat -> P k) ->
 ((forall k : nat, (0 < k)%nat -> P k) -> P 0%nat) -> P n)
Crunching: (pad_u a b u n m = 0)
Crunching: (pad_u n v le H11 y = 0)
Crunching: ((σx × ∣ 0 ⟩) H 0%nat = ∣ 1 ⟩ H 0%nat)
Crunching: (0 < cos (7 / 8))
Crunching:
(forall (ϕ : Vector (2 ^ alp_1)) (ψ : Vector (2 ^ (alp_1 + H3))),
 prob_partial_meas ϕ ψ =
 (norm
    (fun x z : nat =>
     Σ
       (fun y : nat =>
        (((ϕ
           ⊗ (fun x0 y0 : nat =>
              if (x0 =? y0) && (x0 <? 2 ^ H3) then C1 else 0)) y x) ^* *
         ψ y z)%C) (2 ^ alp_1 * 2 ^ H3)) ^ 2)%R)
Chars 15860 - 15872 [(intros~ltyz).] 40.015 secs (0.u,0.003s)
Chars 15877 - 15924 [(refine~(le_lt_trans~_~y~_~_~_...] 0.001 secs (0.001u,0.s)
Chars 15929 - 15945 [(apply~meet_lb_r).] 0. secs (0.u,0.s)
Chars 15860 - 15872 [(intros~ltyz).] 0. secs (0.u,0.s)
Chars 15877 - 15924 [(refine~(le_lt_trans~_~y~_~_~_...] 0. secs (0.u,0.s)
Chars 15929 - 15945 [(apply~meet_lb_r).] 0. secs (0.u,0.s)
Chars 15948 - 15952 [Qed.] 0. secs (0.u,0.s)
Chars 15956 - 16010 [Lemma~meet_lt_l~x~y~z~:~x~<~y~...] 0.001 secs (0.001u,0.s)
Chars 16013 - 16019 [Proof.] 0. secs (0.u,0.s)
Crunching: (pad_u x y H m Hm = 0)
Finished transaction in 83.736 secs (81.64u,2.087s) (successful)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (∣1⟩ = basis_vector 2 1)
clear  H0  :  (False -> cB (map (rec a1)) a1 = Lt)
Crunching: positive
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching:
(forall ψ : Vector (2 ^ (m + n)),
 prob_partial_meas H3 ψ = (norm ((H3 ⊗ I (2 ^ n)) † × ψ) ^ 2)%R)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching:
(prob_partial_meas Hypmn ψ = (norm ((Hypmn ⊗ I (2 ^ n)) † × ψ) ^ 2)%R)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching:
(prob_partial_meas Hypmn ψ = (norm ((Hypmn ⊗ I (2 ^ 0)) † × ψ) ^ 2)%R)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching:
(exists alp : R,
   alp > 0 /\
   (forall x0 : R,
    D_x no_cond 1 x0 /\ R_dist x0 1 < alp -> R_dist (atan x0) (atan 1) < x))
Crunching:
(exists alp : R,
   alp > 0 /\
   (forall x0 : R,
    D_x no_cond 1 x0 /\ R_dist x0 1 < alp -> R_dist (atan x0) (atan 1) < x))
Crunching:
(exists alp : R,
   alp > 0 /\
   (forall x0 : R,
    D_x no_cond 1 x0 /\ R_dist x0 1 < alp -> R_dist (atan x0) (atan 1) < x))
Crunching:
(exists alp : R,
   alp > 0 /\
   (forall x : Base R_met,
    D_x no_cond 1 x /\ dist R_met x 1 < alp ->
    dist R_met (atan x) (atan 1) < v))
Crunching: (0 <= 1)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching:
(nat ->
 (Cmod ⟨ Hypmn ⊗ basis_vector 1 0, ψ ⟩ *
  (Cmod ⟨ Hypmn ⊗ basis_vector 1 0, ψ ⟩ * 1))%R =
 (norm ((Hypmn) † × ψ) * (norm ((Hypmn) † × ψ) * 1))%R)
Crunching:
(forall u : Square 2, WF_Matrix u -> WF_Matrix (pad_ctrl H2 m 0 u))
Crunching:
(exists alp : R,
   alp > 0 /\
   (forall x0 : R,
    D_x no_cond 1 x0 /\ R_dist x0 1 < alp -> R_dist (atan x0) (atan 1) < x))
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching: (2 * dist R_met (atan x) (atan 1) < 2 * n)
Crunching: (2 * dist R_met (atan x) (atan 1) < 2 * n)
     = (3, 0)
     : t
     = (18, 0)
     : t
     = (18, 1)
     : t
     = omega
     : t
     = (5, 10)
     : t
     = (5, 10)
     : t
     = (0, 12)
     : t
     = (1, 10)
     : t
Finished transaction in 0.013 secs (0.013u,0.s) (successful)
Chars 16024 - 16041 [(intros~ltxy~ltxz).] 40.013 secs (0.u,0.002s)
Chars 16046 - 16088 [(set~(disj~:=~cotransitive~ltx...] 0.002 secs (0.002u,0.s)
Chars 16093 - 16141 [(refine~(Trunc_rec~_~disj);~in...] 0.007 secs (0.007u,0.s)
Chars 16146 - 16147 [-] 0. secs (0.u,0.s)
Chars 16148 - 16159 [assumption.] 0. secs (0.u,0.s)
Chars 16164 - 16165 [-] 0. secs (0.u,0.s)
Chars 16166 - 16209 [(set~(disj'~:=~cotransitive~lt...] 0.002 secs (0.002u,0.s)
Chars 16216 - 16265 [(refine~(Trunc_rec~_~disj');~i...] 0.008 secs (0.008u,0.s)
Chars 16272 - 16273 [+] 0. secs (0.u,0.s)
Chars 16274 - 16285 [assumption.] 0. secs (0.u,0.s)
Chars 16292 - 16293 [+] 0. secs (0.u,0.s)
Chars 16294 - 16324 [(assert~(ineqy~:~y~⊓~z~<>~y)).] 0.001 secs (0.001u,0.s)
Chars 16333 - 16334 [{] 0. secs (0.u,0.s)
Chars 16345 - 16369 [(apply~lt_ne;~assumption).] 0.002 secs (0.002u,0.s)
Chars 16378 - 16379 [}] 0. secs (0.u,0.s)
Chars 16388 - 16476 [(assert~(nleyz~:~~~(y~≤~z))~by...] 0.002 secs (0.002u,0.s)
Chars 16485 - 16509 [(assert~(lezy~:~z~≤~y)).] 0.001 secs (0.001u,0.s)
Chars 16518 - 16519 [{] 0. secs (0.u,0.s)
Chars 16530 - 16555 [(apply~le_iff_not_lt_flip).] 0.001 secs (0.001u,0.s)
Chars 16566 - 16578 [(intros~ltzy).] 0. secs (0.u,0.s)
Chars 16589 - 16618 [refine~(nleyz~(lt_le~_~_~_)).] 0.002 secs (0.002u,0.s)
Chars 16627 - 16628 [}] 0. secs (0.u,0.s)
Chars 16637 - 16667 [(assert~(ineqz~:~y~⊓~z~<>~z)).] 0.001 secs (0.001u,0.s)
Chars 16676 - 16677 [{] 0. secs (0.u,0.s)
Chars 16688 - 16712 [(apply~lt_ne;~assumption).] 0.003 secs (0.003u,0.s)
Chars 16721 - 16722 [}] 0. secs (0.u,0.s)
Chars 16731 - 16819 [(assert~(nlezy~:~~~(z~≤~y))~by...] 0.002 secs (0.002u,0.s)
Chars 16828 - 16852 [(assert~(leyz~:~y~≤~z)).] 0.001 secs (0.001u,0.s)
Chars 16861 - 16862 [{] 0. secs (0.u,0.s)
Chars 16873 - 16898 [(apply~le_iff_not_lt_flip).] 0.001 secs (0.001u,0.s)
Chars 16909 - 16921 [(intros~ltzy).] 0. secs (0.u,0.s)
Chars 16932 - 16961 [refine~(nlezy~(lt_le~_~_~_)).] 0.002 secs (0.002u,0.s)
Chars 16970 - 16971 [}] 0. secs (0.u,0.s)
Chars 16980 - 17053 [(assert~(eqyz~:~y~=~z)~by~refi...] 0.006 secs (0.006u,0.s)
Chars 17062 - 17087 [(rewrite~<-~eqyz~in~ineqy).] 0. secs (0.u,0.s)
Chars 17096 - 17133 [(destruct~(ineqy~(meet_idempot...] 0.004 secs (0.004u,0.s)
Chars 16024 - 16041 [(intros~ltxy~ltxz).] 0. secs (0.u,0.s)
Chars 16046 - 16088 [(set~(disj~:=~cotransitive~ltx...] 0. secs (0.u,0.s)
Chars 16093 - 16141 [(refine~(Trunc_rec~_~disj);~in...] 0. secs (0.u,0.s)
Chars 16148 - 16159 [assumption.] 0. secs (0.u,0.s)
Chars 16166 - 16209 [(set~(disj'~:=~cotransitive~lt...] 0. secs (0.u,0.s)
Chars 16216 - 16265 [(refine~(Trunc_rec~_~disj');~i...] 0. secs (0.u,0.s)
Chars 16274 - 16285 [assumption.] 0. secs (0.u,0.s)
Chars 16294 - 16324 [(assert~(ineqy~:~y~⊓~z~<>~y)).] 0. secs (0.u,0.s)
Chars 16345 - 16369 [(apply~lt_ne;~assumption).] 0. secs (0.u,0.s)
Chars 16388 - 16476 [(assert~(nleyz~:~~~(y~≤~z))~by...] 0. secs (0.u,0.s)
Chars 16485 - 16509 [(assert~(lezy~:~z~≤~y)).] 0. secs (0.u,0.s)
Chars 16530 - 16555 [(apply~le_iff_not_lt_flip).] 0. secs (0.u,0.s)
Chars 16566 - 16578 [(intros~ltzy).] 0. secs (0.u,0.s)
Chars 16589 - 16618 [refine~(nleyz~(lt_le~_~_~_)).] 0. secs (0.u,0.s)
Chars 16637 - 16667 [(assert~(ineqz~:~y~⊓~z~<>~z)).] 0. secs (0.u,0.s)
Chars 16688 - 16712 [(apply~lt_ne;~assumption).] 0. secs (0.u,0.s)
Chars 16731 - 16819 [(assert~(nlezy~:~~~(z~≤~y))~by...] 0. secs (0.u,0.s)
Chars 16828 - 16852 [(assert~(leyz~:~y~≤~z)).] 0. secs (0.u,0.s)
Chars 16873 - 16898 [(apply~le_iff_not_lt_flip).] 0. secs (0.u,0.s)
Chars 16909 - 16921 [(intros~ltzy).] 0. secs (0.u,0.s)
Chars 16932 - 16961 [refine~(nlezy~(lt_le~_~_~_)).] 0. secs (0.u,0.s)
Chars 16980 - 17053 [(assert~(eqyz~:~y~=~z)~by~refi...] 0. secs (0.u,0.s)
Chars 17062 - 17087 [(rewrite~<-~eqyz~in~ineqy).] 0. secs (0.u,0.s)
Chars 17096 - 17133 [(destruct~(ineqy~(meet_idempot...] 0. secs (0.u,0.s)
Chars 17136 - 17140 [Qed.] 0.001 secs (0.001u,0.s)
Chars 17143 - 17168 [End~strict_ordered_field.] 0.035 secs (0.031u,0.003s)
Crunching:
(forall x : Base R_met,
 D_x no_cond 1 x /\ dist R_met x 1 < 1 -> dist R_met (atan x) (atan 1) < n)
Crunching: (2 * dist R_met (atan x) (atan 1) < 2 * n)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (2 * dist R_met (atan x) (atan 1) < 2 * n)
Crunching: False
Crunching: ((σz × ∣ 0 ⟩) n m = ∣ 0 ⟩ n m)
Crunching: ((σz × ∣ 0 ⟩) n m = ∣ 0 ⟩ n m)
Crunching: ((σz × ∣ 0 ⟩) n m = ∣ 0 ⟩ n m)
Crunching: False
Crunching:
(forall j : nat,
 (H1 < 2)%nat -> (j < 1)%nat -> (σz × ∣ 0 ⟩) H1 j = ∣ 0 ⟩ H1 j)
Crunching:
(forall j : nat,
 (s2 < 2)%nat -> (j < 1)%nat -> (σz × ∣ 0 ⟩) s2 j = ∣ 0 ⟩ s2 j)
Crunching: ((σz × ∣ 0 ⟩) s2 j = ∣ 0 ⟩ s2 j)
Crunching: False
Crunching: False
Crunching: ((σz × ∣ 0 ⟩) n m = ∣ 0 ⟩ n m)
Crunching: ((σz × ∣ 0 ⟩) n m = ∣ 0 ⟩ n m)
Crunching: ((σz × ∣ 0 ⟩) n m = ∣ 0 ⟩ n m)
Crunching: ((σz × ∣ 0 ⟩) n m = ∣ 0 ⟩ n m)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching:
(Pure_State_Vector H2 ->
 prob_partial_meas n (H1 ⊗ H2) = (Cmod ⟨ n, H1 ⟩ ^ 2)%R)
Crunching: ((m < 1)%nat -> (σz × ∣ 0 ⟩) n m = ∣ 0 ⟩ n m)
rewrite if_dtt
if (proj1_sig x =? proj1_sig k)
then (fun _ : (proj1_sig x =? proj1_sig k) = true => AA tt)
else
(fun E0 : (proj1_sig x =? proj1_sig k) = false =>
 BB
   ((if proj1_sig x <? proj1_sig k as b1
      return ((proj1_sig x <? proj1_sig k) = b1 -> ltN n)
     then
      fun E1 : (proj1_sig x <? proj1_sig k) = true =>
      ltN_of_nat (proj1_sig x) n (ltN_pop_lemma1 n k x E1)
     else
      fun E1 : (proj1_sig x <? proj1_sig k) = false =>
      ltN_of_nat (Init.Nat.pred (proj1_sig x)) n (ltN_pop_lemma2 n k x E1 E0))
      eq_refl))
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching:
(Pure_State_Vector H2 ->
 prob_partial_meas n (H1 ⊗ H2) = (Cmod ⟨ n, H1 ⟩ ^ 2)%R)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching: ((x < 2)%nat -> (Ex < 1)%nat -> (σz × ∣ 0 ⟩) x Ex = ∣ 0 ⟩ x Ex)
Crunching: (probability_of_outcome n H1 = prob_partial_meas n (H1 ⊗ H2))
Crunching: (prob_partial_meas n (H1 ⊗ H2) = probability_of_outcome n H1)
Crunching:
(Pure_State_Vector H2 ->
 prob_partial_meas n (H1 ⊗ H2) = probability_of_outcome n H1)
Crunching: (permutation n (fswap f x n))
Crunching:
(forall j : nat,
 (H1 < 2)%nat -> (j < 1)%nat -> (σz × ∣ 0 ⟩) H1 j = ∣ 0 ⟩ H1 j)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching:
(permutation (S y_encad1) y_encad2 ->
 H8 < S y_encad1 ->
 y_encad2 H8 = y_encad1 -> permutation y_encad1 (fswap y_encad2 H8 y_encad1))
Crunching: (permutation a (fswap n Ha a))
Crunching: (permutation a (fswap n Ha a))
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching: (permutation a (fswap n Ha a))
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching: (permutation a (fswap n Ha a))
Crunching: (permutation a (fswap n Ha a))
Crunching: (permutation a (fswap n Ha a))
out of reach
Tactic call ran for 0.002 secs (0.001u,0.s) (failure)
Crunching: (permutation (f x) (fswap f x (f x)))
Crunching: (Σ (fun y : nat => σz H1 y * ∣ 0 ⟩ y p) 2 = ∣ 0 ⟩ H1 p)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching:
(forall j : nat,
 (s2 < 2)%nat -> (j < 1)%nat -> (σz × ∣ 0 ⟩) s2 j = ∣ 0 ⟩ s2 j)
Finished transaction in 23.601 secs (23.518u,0.08s) (successful)
Crunching:
(exists x0 : nat -> nat,
   forall x1 : nat,
   S x1 <= n ->
   S
     (if
       (fix Ffix (x x3 : nat) {struct x} : bool :=
          match x with
          | 0 => match x3 with
                 | 0 => true
                 | S _ => false
                 end
          | S x4 => match x3 with
                    | 0 => false
                    | S x5 => Ffix x4 x5
                    end
          end) x1 x
      then f n
      else
       if
        (fix Ffix (x x3 : nat) {struct x} : bool :=
           match x with
           | 0 => match x3 with
                  | 0 => true
                  | S _ => false
                  end
           | S x4 => match x3 with
                     | 0 => false
                     | S x5 => Ffix x4 x5
                     end
           end) x1 n
       then f x
       else f x1) <= n /\
   S (x0 x1) <= n /\
   x0
     (if
       (fix Ffix (x x3 : nat) {struct x} : bool :=
          match x with
          | 0 => match x3 with
                 | 0 => true
                 | S _ => false
                 end
          | S x4 => match x3 with
                    | 0 => false
                    | S x5 => Ffix x4 x5
                    end
          end) x1 x
      then f n
      else
       if
        (fix Ffix (x x3 : nat) {struct x} : bool :=
           match x with
           | 0 => match x3 with
                  | 0 => true
                  | S _ => false
                  end
           | S x4 => match x3 with
                     | 0 => false
                     | S x5 => Ffix x4 x5
                     end
           end) x1 n
       then f x
       else f x1) = x1 /\
   (if
     (fix Ffix (x x3 : nat) {struct x} : bool :=
        match x with
        | 0 => match x3 with
               | 0 => true
               | S _ => false
               end
        | S x4 => match x3 with
                  | 0 => false
                  | S x5 => Ffix x4 x5
                  end
        end) (x0 x1) x
    then f n
    else
     if
      (fix Ffix (x x3 : nat) {struct x} : bool :=
         match x with
         | 0 => match x3 with
                | 0 => true
                | S _ => false
                end
         | S x4 => match x3 with
                   | 0 => false
                   | S x5 => Ffix x4 x5
                   end
         end) (x0 x1) n
     then f x
     else f (x0 x1)) = x1)
Crunching: ((σz × ∣ 0 ⟩) s2 j = ∣ 0 ⟩ s2 j)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
Crunching: (sample (r :: r0) r1 <= length (r :: r0))%nat
Crunching: (sample (r :: r0) r1 <= length (r :: r0))%nat
Crunching: (sample (r :: r0) r1 <= length (r :: r0))%nat
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching: (sample (r :: r0) r1 <= length (r :: r0))%nat
Crunching: (sample (r :: r0) r1 <= length (r :: r0))%nat
Crunching: (permutation n (fswap f x n))
Crunching: (sample (r :: r0) r1 <= length (r :: r0))%nat
Crunching:
((forall (l1 lf1 : list R) (a b c : R) (f : R -> R),
  adapted_couple f a b l1 lf1 ->
  a <= c <= b -> {l : list R & {l0 : list R & adapted_couple f c b l l0}}) ->
 (sample (r :: r0) c <= length (r :: r0))%nat)
Crunching: (w < S HE -> v w = HE -> permutation HE (fswap v w HE))
Crunching: (sample abs HF <= length abs)%nat
Crunching:
(0 <> 2 ->
 forall (n : nat) (f : nat -> nat) (x : nat),
 permutation (S n) f -> x < S n -> f x = n -> permutation n (fswap f x n))
rewrite match_option_dtt
match (List.nth_error (list_of_array a) (proj1_sig x)) with
| None =>
(fun E : List.nth_error (list_of_array a) (proj1_sig x) = None =>
 match slist_nth_lemma1 (slist_of_array a) x E return A with
 end)
| Some m =>
(fun (a0 : A) (_ : List.nth_error (list_of_array a) (proj1_sig x) = Some a0)
 => a0)
rewrite match_option_dtt
match (List.nth_error (list_of_array a) (proj1_sig x)) with
| None =>
(fun E : List.nth_error (list_of_array a) (proj1_sig x) = None =>
 match slist_nth_lemma1 (slist_of_array a) x E return A with
 end)
| Some m =>
(fun (a0 : A) (_ : List.nth_error (list_of_array a) (proj1_sig x) = Some a0)
 => a0)
Crunching:
(forall y : nat,
 (HE >= 2 ^ l)%nat \/ (y >= 2 ^ l)%nat -> pad_swap l m' P' HE y = 0)
Crunching:
(permutation (S m) Hm -> H < S m -> Hm H = m -> permutation m (fswap Hm H m))
Crunching: (WF_Matrix (pad_swap l 0 n))
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift θ × ∣ b ⟩)
Crunching:
(list2D_to_matrix
   [[(if (b =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 0%nat 0%nat];
   [Cexp θ *
    (if (b =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat]] = Cexp (b * θ) .* ∣ b ⟩)
Crunching:
(0 =
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat 1%nat)
Crunching:
(0 =
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat (S (S y)))
Crunching:
(0 =
 Cexp θ *
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat 1%nat)
Crunching:
(0 =
 Cexp θ *
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat (S (S y)))
Crunching:
((phase_shift n × ∣ i ⟩) 0%nat 0%nat = (Cexp (i * n) .* ∣ i ⟩) 0%nat 0%nat)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift n × ∣ i ⟩)
Crunching:
(list2D_to_matrix
   [[(if (i =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 0%nat 0%nat];
   [Cexp n *
    (if (i =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat]] = Cexp (i * n) .* ∣ i ⟩)
Crunching:
(0 =
 (if (i =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat 1%nat)
Crunching:
(0 =
 (if (i =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat (S (S y)))
Crunching:
(0 =
 Cexp n *
 (if (i =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat 1%nat)
Crunching:
(0 =
 Cexp n *
 (if (i =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat (S (S y)))
Crunching:
(list2D_to_matrix [[e]; [e0]] =
 (fun x y : nat =>
  match x with
  | 0%nat => match y with
             | 0%nat => C1
             | S _ => 0
             end
  | 1%nat => match y with
             | 1%nat => Cexp θ
             | _ => 0
             end
  | S (S _) => 0
  end) × ∣ b ⟩)
Crunching:
(list2D_to_matrix
   [[(if (b =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 0%nat 0%nat];
   [Cexp θ *
    (if (b =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat]] = (fun x y : nat => Cexp (b * θ) * ∣ b ⟩ x y))
Crunching:
(0 =
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat 1%nat)
Crunching:
(0 =
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat (S (S y)))
Crunching:
(0 =
 Cexp θ *
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat 1%nat)
Crunching:
(0 =
 Cexp θ *
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat (S (S y)))
out of reach
Tactic call ran for 0.001 secs (0.u,0.s) (failure)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift θ × ∣ b ⟩)
Crunching:
(list2D_to_matrix
   [[(if (b =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 0%nat 0%nat];
   [Cexp θ *
    (if (b =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat]] = Cexp (b * θ) .* ∣ b ⟩)
Crunching:
(0 =
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat 1%nat)
Crunching:
(0 =
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat (S (S y)))
Crunching:
(0 =
 Cexp θ *
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat 1%nat)
Crunching:
(0 =
 Cexp θ *
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat (S (S y)))
Crunching: (Rabs 2 = 2 -> phase_shift θ × ∣ b ⟩ = Cexp (b * θ) .* ∣ b ⟩)
Crunching: (sample (r :: r0) r1 <= length (r :: r0))%nat
Crunching: (sample (r :: r0) r1 <= length (r :: r0))%nat
Crunching: (sample (r :: r0) r1 <= length (r :: r0))%nat
Crunching: (sample (r :: r0) r1 <= length (r :: r0))%nat
Crunching: (sample (r :: r0) r1 <= length (r :: r0))%nat
Crunching: (sample (r :: r0) r1 <= length (r :: r0))%nat
Crunching:
((phase_shift n × ∣ i ⟩) 0%nat 0%nat = (Cexp (i * n) .* ∣ i ⟩) 0%nat 0%nat)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift n × ∣ i ⟩)
Crunching:
(list2D_to_matrix
   [[(if (i =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 0%nat 0%nat];
   [Cexp n *
    (if (i =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat]] = Cexp (i * n) .* ∣ i ⟩)
Crunching:
(0 =
 (if (i =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat 1%nat)
Crunching:
(0 =
 (if (i =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat (S (S y)))
Crunching:
(0 =
 Cexp n *
 (if (i =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat 1%nat)
Crunching:
(0 =
 Cexp n *
 (if (i =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat (S (S y)))
Crunching: (sample (r :: r0) r1 <= length (r :: r0))%nat
Crunching: (sample (r :: r0) r1 <= length (r :: r0))%nat
Crunching: (sample (r :: r0) r1 <= length (r :: r0))%nat
Crunching: (sample (r :: r0) r1 <= length (r :: r0))%nat
Crunching: (sample (r :: r0) r1 <= length (r :: r0))%nat
Crunching:
(list2D_to_matrix [[e]; [e0]] =
 (fun x y : nat =>
  match x with
  | 0%nat => match y with
             | 0%nat => C1
             | S _ => 0
             end
  | 1%nat => match y with
             | 1%nat => Cexp θ
             | _ => 0
             end
  | S (S _) => 0
  end) × ∣ b ⟩)
Crunching:
(list2D_to_matrix
   [[(if (b =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 0%nat 0%nat];
   [Cexp θ *
    (if (b =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat]] = (fun x y : nat => Cexp (b * θ) * ∣ b ⟩ x y))
Crunching: (sample (r :: r0) r1 <= length (r :: r0))%nat
Crunching:
(0 =
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat 1%nat)
Crunching:
(0 =
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat (S (S y)))
Crunching:
(0 =
 Cexp θ *
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat 1%nat)
Crunching:
(0 =
 Cexp θ *
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat (S (S y)))
Crunching: (sample (r :: r0) r1 <= length (r :: r0))%nat
Crunching: (sample (r :: r0) r1 <= length (r :: r0))%nat
Crunching: (sample (r :: r0) r1 <= length (r :: r0))%nat
Crunching: (sample (r :: r0) r1 <= length (r :: r0))%nat
Crunching: (S ?x@{n:=0} <= 0)
Crunching: (sample (r :: r0) r1 <= length (r :: r0))%nat
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift θ × ∣ b ⟩)
Crunching: (sample (r :: r0) r1 <= length (r :: r0))%nat
Crunching:
(list2D_to_matrix
   [[(if (b =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 0%nat 0%nat];
   [Cexp θ *
    (if (b =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat]] = Cexp (b * θ) .* ∣ b ⟩)
Crunching: (sample (r :: r0) r1 <= length (r :: r0))%nat
Crunching:
(0 =
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat 1%nat)
Crunching:
(0 =
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat (S (S y)))
Crunching:
(0 =
 Cexp θ *
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat 1%nat)
Crunching:
(0 =
 Cexp θ *
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat (S (S y)))
Crunching: (sample (r :: r0) r1 <= length (r :: r0))%nat
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift θ × ∣ b ⟩)
Crunching: (sample (r :: r0) r1 <= length (r :: r0))%nat
Crunching:
(list2D_to_matrix
   [[(if (b =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 0%nat 0%nat];
   [Cexp θ *
    (if (b =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat]] = Cexp (b * θ) .* ∣ b ⟩)
Crunching: (sample (r :: r0) r1 <= length (r :: r0))%nat
Crunching:
(0 =
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat 1%nat)
Crunching:
(0 =
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat (S (S y)))
Crunching:
(0 =
 Cexp θ *
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat 1%nat)
Crunching:
(0 =
 Cexp θ *
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat (S (S y)))
Crunching: (sample (r :: r0) r1 <= length (r :: r0))%nat
Crunching: (Rabs 2 = 2 -> phase_shift θ × ∣ b ⟩ = Cexp (b * θ) .* ∣ b ⟩)
Crunching: (sample (r :: r0) r1 <= length (r :: r0))%nat
Crunching: (sample (r :: r0) r1 <= length (r :: r0))%nat
Crunching: (sample (r :: r0) r1 <= length (r :: r0))%nat
Crunching: (sample (r :: r0) r1 <= length (r :: r0))%nat
Crunching: (sample (r :: r0) r1 <= length (r :: r0))%nat
Crunching: (S ?x@{n:=0} <= 0)
Crunching: (sample (r :: r0) r1 <= length (r :: r0))%nat
Crunching:
((phase_shift n × ∣ i ⟩) 0%nat 0%nat = (Cexp (i * n) .* ∣ i ⟩) 0%nat 0%nat)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift n × ∣ i ⟩)
Crunching: (sample (r :: r0) r1 <= length (r :: r0))%nat
Crunching:
(list2D_to_matrix
   [[(if (i =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 0%nat 0%nat];
   [Cexp n *
    (if (i =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat]] = Cexp (i * n) .* ∣ i ⟩)
Crunching: (sample (r :: r0) r1 <= length (r :: r0))%nat
Crunching:
(0 =
 (if (i =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat 1%nat)
Crunching:
(0 =
 (if (i =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat (S (S y)))
Crunching:
(0 =
 Cexp n *
 (if (i =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat 1%nat)
Crunching:
(0 =
 Cexp n *
 (if (i =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat (S (S y)))
Crunching: (sample (r :: r0) r1 <= length (r :: r0))%nat
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift H8 × ∣ b ⟩)
Crunching:
(list2D_to_matrix
   [[(if (b =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 0%nat 0%nat];
   [Cexp H8 *
    (if (b =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat]] = Cexp (b * H8) .* ∣ b ⟩)
Crunching:
(0 =
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat 1%nat)
Crunching:
(0 =
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat (S (S y)))
Crunching:
(0 =
 Cexp H8 *
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat 1%nat)
Crunching:
(0 =
 Cexp H8 *
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat (S (S y)))
Crunching: (sample (r :: r0) r1 <= length (r :: r0))%nat
Crunching: (sample (r :: r0) r1 <= length (r :: r0))%nat
Crunching: (sample (r :: r0) r1 <= length (r :: r0))%nat
Crunching:
(list2D_to_matrix [[e]; [e0]] =
 (fun x y : nat =>
  match x with
  | 0%nat => match y with
             | 0%nat => C1
             | S _ => 0
             end
  | 1%nat => match y with
             | 1%nat => Cexp θ
             | _ => 0
             end
  | S (S _) => 0
  end) × ∣ b ⟩)
Crunching:
(list2D_to_matrix
   [[(if (b =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 0%nat 0%nat];
   [Cexp θ *
    (if (b =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat]] = (fun x y : nat => Cexp (b * θ) * ∣ b ⟩ x y))
Crunching:
(0 =
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat 1%nat)
Crunching:
(0 =
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat (S (S y)))
Crunching:
(0 =
 Cexp θ *
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat 1%nat)
Crunching:
(0 =
 Cexp θ *
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat (S (S y)))
Crunching: False
Crunching: (sample (r :: r0) r1 <= length (r :: r0))%nat
Crunching: (sample (r :: r0) r1 <= length (r :: r0))%nat
rewrite if_dtt
if
((fix Ffix (x x0 : nat) {struct x} : bool :=
    match x with
    | 0 => match x0 with
           | 0 => true
           | S _ => false
           end
    | S x1 => match x0 with
              | 0 => false
              | S x2 => Ffix x1 x2
              end
    end) (let (x, _) := k1 in x) (let (x, _) := k2 in x))
then
(fun
   _ : (fix Ffix (x x0 : nat) {struct x} : bool :=
          match x with
          | 0 => match x0 with
                 | 0 => true
                 | S _ => false
                 end
          | S x1 => match x0 with
                    | 0 => false
                    | S x2 => Ffix x1 x2
                    end
          end) (let (x, _) := k1 in x) (let (x, _) := k2 in x) = true =>
 AA tt)
else
(fun
   x : (fix Ffix (x x0 : nat) {struct x} : bool :=
          match x with
          | 0 => match x0 with
                 | 0 => true
                 | S _ => false
                 end
          | S x1 => match x0 with
                    | 0 => false
                    | S x2 => Ffix x1 x2
                    end
          end) (let (x, _) := k1 in x) (let (x, _) := k2 in x) = false =>
 BB
   ((if
      match (let (x0, _) := k2 in x0) with
      | 0 => false
      | S x0 =>
          (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
             match x1 with
             | 0 => true
             | S x3 => match x2 with
                       | 0 => false
                       | S x4 => Ffix x3 x4
                       end
             end) (let (x1, _) := k1 in x1) x0
      end as c
      return
        (match (let (x0, _) := k2 in x0) with
         | 0 => false
         | S x0 =>
             (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                match x1 with
                | 0 => true
                | S x3 => match x2 with
                          | 0 => false
                          | S x4 => Ffix x3 x4
                          end
                end) (let (x1, _) := k1 in x1) x0
         end = c ->
         {x1 : nat
         | match n with
           | 0 => false
           | S x2 =>
               (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                  match x3 with
                  | 0 => true
                  | S x5 =>
                      match x4 with
                      | 0 => false
                      | S x6 => Ffix x5 x6
                      end
                  end) x1 x2
           end = true})
     then
      fun
        x0 : match (let (x0, _) := k2 in x0) with
             | 0 => false
             | S x0 =>
                 (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                    match x1 with
                    | 0 => true
                    | S x3 =>
                        match x2 with
                        | 0 => false
                        | S x4 => Ffix x3 x4
                        end
                    end) (let (x1, _) := k1 in x1) x0
             end = true =>
      exist
        (fun x1 : nat =>
         match n with
         | 0 => false
         | S x2 =>
             (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                match x3 with
                | 0 => true
                | S x5 => match x4 with
                          | 0 => false
                          | S x6 => Ffix x5 x6
                          end
                end) x1 x2
         end = true) (let (x1, _) := k1 in x1) (ltN_pop_lemma1 n k2 k1 x0)
     else
      fun
        x0 : match (let (x0, _) := k2 in x0) with
             | 0 => false
             | S x0 =>
                 (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                    match x1 with
                    | 0 => true
                    | S x3 =>
                        match x2 with
                        | 0 => false
                        | S x4 => Ffix x3 x4
                        end
                    end) (let (x1, _) := k1 in x1) x0
             end = false =>
      exist
        (fun x1 : nat =>
         match n with
         | 0 => false
         | S x2 =>
             (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                match x3 with
                | 0 => true
                | S x5 => match x4 with
                          | 0 => false
                          | S x6 => Ffix x5 x6
                          end
                end) x1 x2
         end = true)
        match (let (x1, _) := k1 in x1) with
        | 0 => let (x1, _) := k1 in x1
        | S x1 => x1
        end (ltN_pop_lemma2 n k2 k1 x0 x)) eq_refl))
'A_R' is now a registered translation.
rewrite if_dtt
if
((fix Ffix (x x0 : nat) {struct x} : bool :=
    match x with
    | 0 => match x0 with
           | 0 => true
           | S _ => false
           end
    | S x1 => match x0 with
              | 0 => false
              | S x2 => Ffix x1 x2
              end
    end) (let (x, _) := k1 in x) (let (x, _) := k2 in x))
then
(fun
   _ : (fix Ffix (x x0 : nat) {struct x} : bool :=
          match x with
          | 0 => match x0 with
                 | 0 => true
                 | S _ => false
                 end
          | S x1 => match x0 with
                    | 0 => false
                    | S x2 => Ffix x1 x2
                    end
          end) (let (x, _) := k1 in x) (let (x, _) := k2 in x) = true =>
 AA tt)
else
(fun
   x : (fix Ffix (x x0 : nat) {struct x} : bool :=
          match x with
          | 0 => match x0 with
                 | 0 => true
                 | S _ => false
                 end
          | S x1 => match x0 with
                    | 0 => false
                    | S x2 => Ffix x1 x2
                    end
          end) (let (x, _) := k1 in x) (let (x, _) := k2 in x) = false =>
 BB
   ((if
      match (let (x0, _) := k2 in x0) with
      | 0 => false
      | S x0 =>
          (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
             match x1 with
             | 0 => true
             | S x3 => match x2 with
                       | 0 => false
                       | S x4 => Ffix x3 x4
                       end
             end) (let (x1, _) := k1 in x1) x0
      end as c
      return
        (match (let (x0, _) := k2 in x0) with
         | 0 => false
         | S x0 =>
             (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                match x1 with
                | 0 => true
                | S x3 => match x2 with
                          | 0 => false
                          | S x4 => Ffix x3 x4
                          end
                end) (let (x1, _) := k1 in x1) x0
         end = c ->
         {x1 : nat
         | match n with
           | 0 => false
           | S x2 =>
               (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                  match x3 with
                  | 0 => true
                  | S x5 =>
                      match x4 with
                      | 0 => false
                      | S x6 => Ffix x5 x6
                      end
                  end) x1 x2
           end = true})
     then
      fun
        x0 : match (let (x0, _) := k2 in x0) with
             | 0 => false
             | S x0 =>
                 (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                    match x1 with
                    | 0 => true
                    | S x3 =>
                        match x2 with
                        | 0 => false
                        | S x4 => Ffix x3 x4
                        end
                    end) (let (x1, _) := k1 in x1) x0
             end = true =>
      exist
        (fun x1 : nat =>
         match n with
         | 0 => false
         | S x2 =>
             (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                match x3 with
                | 0 => true
                | S x5 => match x4 with
                          | 0 => false
                          | S x6 => Ffix x5 x6
                          end
                end) x1 x2
         end = true) (let (x1, _) := k1 in x1) (ltN_pop_lemma1 n k2 k1 x0)
     else
      fun
        x0 : match (let (x0, _) := k2 in x0) with
             | 0 => false
             | S x0 =>
                 (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                    match x1 with
                    | 0 => true
                    | S x3 =>
                        match x2 with
                        | 0 => false
                        | S x4 => Ffix x3 x4
                        end
                    end) (let (x1, _) := k1 in x1) x0
             end = false =>
      exist
        (fun x1 : nat =>
         match n with
         | 0 => false
         | S x2 =>
             (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                match x3 with
                | 0 => true
                | S x5 => match x4 with
                          | 0 => false
                          | S x6 => Ffix x5 x6
                          end
                end) x1 x2
         end = true)
        match (let (x1, _) := k1 in x1) with
        | 0 => let (x1, _) := k1 in x1
        | S x1 => x1
        end (ltN_pop_lemma2 n k2 k1 x0 x)) eq_refl))
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift θ × ∣ b ⟩)
Crunching:
(list2D_to_matrix
   [[(if (b =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 0%nat 0%nat];
   [Cexp θ *
    (if (b =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat]] = Cexp (b * θ) .* ∣ b ⟩)
Crunching:
(0 =
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat 1%nat)
Crunching:
(0 =
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat (S (S y)))
Crunching:
(0 =
 Cexp θ *
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat 1%nat)
Crunching:
(0 =
 Cexp θ *
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat (S (S y)))
rewrite if_dtt
if
((fix Ffix (x x0 : nat) {struct x} : bool :=
    match x with
    | 0 => match x0 with
           | 0 => true
           | S _ => false
           end
    | S x1 => match x0 with
              | 0 => false
              | S x2 => Ffix x1 x2
              end
    end) (let (x, _) := k1 in x) (let (x, _) := k2 in x))
then
(fun
   _ : (fix Ffix (x x0 : nat) {struct x} : bool :=
          match x with
          | 0 => match x0 with
                 | 0 => true
                 | S _ => false
                 end
          | S x1 => match x0 with
                    | 0 => false
                    | S x2 => Ffix x1 x2
                    end
          end) (let (x, _) := k1 in x) (let (x, _) := k2 in x) = true =>
 AA tt)
else
(fun
   x : (fix Ffix (x x0 : nat) {struct x} : bool :=
          match x with
          | 0 => match x0 with
                 | 0 => true
                 | S _ => false
                 end
          | S x1 => match x0 with
                    | 0 => false
                    | S x2 => Ffix x1 x2
                    end
          end) (let (x, _) := k1 in x) (let (x, _) := k2 in x) = false =>
 BB
   ((if
      match (let (x0, _) := k2 in x0) with
      | 0 => false
      | S x0 =>
          (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
             match x1 with
             | 0 => true
             | S x3 => match x2 with
                       | 0 => false
                       | S x4 => Ffix x3 x4
                       end
             end) (let (x1, _) := k1 in x1) x0
      end as c
      return
        (match (let (x0, _) := k2 in x0) with
         | 0 => false
         | S x0 =>
             (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                match x1 with
                | 0 => true
                | S x3 => match x2 with
                          | 0 => false
                          | S x4 => Ffix x3 x4
                          end
                end) (let (x1, _) := k1 in x1) x0
         end = c ->
         {x1 : nat
         | match n with
           | 0 => false
           | S x2 =>
               (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                  match x3 with
                  | 0 => true
                  | S x5 =>
                      match x4 with
                      | 0 => false
                      | S x6 => Ffix x5 x6
                      end
                  end) x1 x2
           end = true})
     then
      fun
        x0 : match (let (x0, _) := k2 in x0) with
             | 0 => false
             | S x0 =>
                 (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                    match x1 with
                    | 0 => true
                    | S x3 =>
                        match x2 with
                        | 0 => false
                        | S x4 => Ffix x3 x4
                        end
                    end) (let (x1, _) := k1 in x1) x0
             end = true =>
      exist
        (fun x1 : nat =>
         match n with
         | 0 => false
         | S x2 =>
             (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                match x3 with
                | 0 => true
                | S x5 => match x4 with
                          | 0 => false
                          | S x6 => Ffix x5 x6
                          end
                end) x1 x2
         end = true) (let (x1, _) := k1 in x1) (ltN_pop_lemma1 n k2 k1 x0)
     else
      fun
        x0 : match (let (x0, _) := k2 in x0) with
             | 0 => false
             | S x0 =>
                 (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                    match x1 with
                    | 0 => true
                    | S x3 =>
                        match x2 with
                        | 0 => false
                        | S x4 => Ffix x3 x4
                        end
                    end) (let (x1, _) := k1 in x1) x0
             end = false =>
      exist
        (fun x1 : nat =>
         match n with
         | 0 => false
         | S x2 =>
             (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                match x3 with
                | 0 => true
                | S x5 => match x4 with
                          | 0 => false
                          | S x6 => Ffix x5 x6
                          end
                end) x1 x2
         end = true)
        match (let (x1, _) := k1 in x1) with
        | 0 => let (x1, _) := k1 in x1
        | S x1 => x1
        end (ltN_pop_lemma2 n k2 k1 x0 x)) eq_refl))
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift θ × ∣ b ⟩)
Crunching:
(list2D_to_matrix
   [[(if (b =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 0%nat 0%nat];
   [Cexp θ *
    (if (b =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat]] = Cexp (b * θ) .* ∣ b ⟩)
Crunching:
(0 =
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat 1%nat)
Crunching:
(0 =
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat (S (S y)))
Crunching:
(0 =
 Cexp θ *
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat 1%nat)
Crunching:
(0 =
 Cexp θ *
 (if (b =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat (S (S y)))
Crunching: (Rabs 2 = 2 -> phase_shift θ × ∣ b ⟩ = Cexp (b * θ) .* ∣ b ⟩)
Crunching:
(0%nat <> 2%nat ->
 0 <= Temp < sum_over_list x' -> (sample x' Temp < length x')%nat)
Crunching: (Rabs 2 = 2 -> phase_shift θ × ∣ b ⟩ = Cexp (b * θ) .* ∣ b ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift θ × ∣ true ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift θ × ∣ false ⟩)
Crunching: (list2D_to_matrix [[0]; [Cexp θ]] = Cexp (true * θ) .* ∣ true ⟩)
Crunching: (list2D_to_matrix [[C1]; [0]] = Cexp (false * θ) .* ∣ false ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = hadamard × ∣ n ⟩)
Crunching:
(0%nat <> 2%nat ->
 0 <= Temp < sum_over_list x' -> (sample x' Temp < length x')%nat)
Crunching:
(list2D_to_matrix
   [[C1 / √ 2 *
     (if (n =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 0%nat 0%nat +
     C1 / √ 2 *
     (if (n =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 1%nat 0%nat];
   [C1 / √ 2 *
    (if (n =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 0%nat 0%nat +
    - (C1 / √ 2) *
    (if (n =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat]] = / √ 2 .* (∣ 0 ⟩ .+ (-1) ^ n .* ∣ 1 ⟩))
Crunching:
(0 =
 / √ 2 *
 (if (n =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat 1%nat +
 / √ 2 *
 (if (n =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat 1%nat)
Crunching:
(0 =
 / √ 2 *
 (if (n =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat (S (S y)) +
 / √ 2 *
 (if (n =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat (S (S y)))
Crunching:
(0 =
 / √ 2 *
 (if (n =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat 1%nat +
 -
 (/ √ 2 *
  (if (n =? 0)%nat
   then
    fun x y : nat =>
    match x with
    | 0%nat => match y with
               | 0%nat => C1
               | S _ => RtoC 0
               end
    | 1%nat => match y with
               | 0%nat | _ => RtoC 0
               end
    | S (S _) => RtoC 0
    end
   else
    fun x y : nat =>
    match x with
    | 0%nat => match y with
               | 0%nat | _ => RtoC 0
               end
    | 1%nat => match y with
               | 0%nat => C1
               | S _ => RtoC 0
               end
    | S (S _) => RtoC 0
    end) 1%nat 1%nat))
Crunching:
(0 =
 / √ 2 *
 (if (n =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat (S (S y)) +
 -
 (/ √ 2 *
  (if (n =? 0)%nat
   then
    fun x y : nat =>
    match x with
    | 0%nat => match y with
               | 0%nat => C1
               | S _ => RtoC 0
               end
    | 1%nat => match y with
               | 0%nat | _ => RtoC 0
               end
    | S (S _) => RtoC 0
    end
   else
    fun x y : nat =>
    match x with
    | 0%nat => match y with
               | 0%nat | _ => RtoC 0
               end
    | 1%nat => match y with
               | 0%nat => C1
               | S _ => RtoC 0
               end
    | S (S _) => RtoC 0
    end) 1%nat (S (S y))))
Crunching: (list2D_to_matrix [[e]; [e0]] = hadamard × ∣ n ⟩)
Crunching:
(list2D_to_matrix
   [[C1 / √ 2 *
     (if (n =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 0%nat 0%nat +
     C1 / √ 2 *
     (if (n =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 1%nat 0%nat];
   [C1 / √ 2 *
    (if (n =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 0%nat 0%nat +
    - (C1 / √ 2) *
    (if (n =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat]] = / √ IPR_2 1 .* (∣ 0 ⟩ .+ (- R1)%R ^ n .* ∣ 1 ⟩))
Crunching:
(0%nat <> 2%nat ->
 0 <= Temp < sum_over_list x' -> (sample x' Temp < length x')%nat)
Crunching:
(0 =
 / √ 2 *
 (if (n =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat 1%nat +
 / √ 2 *
 (if (n =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat 1%nat)
Crunching:
(0 =
 / √ 2 *
 (if (n =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat (S (S y)) +
 / √ 2 *
 (if (n =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat (S (S y)))
Crunching:
(0 =
 / √ 2 *
 (if (n =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat 1%nat +
 -
 (/ √ 2 *
  (if (n =? 0)%nat
   then
    fun x y : nat =>
    match x with
    | 0%nat => match y with
               | 0%nat => C1
               | S _ => RtoC 0
               end
    | 1%nat => match y with
               | 0%nat | _ => RtoC 0
               end
    | S (S _) => RtoC 0
    end
   else
    fun x y : nat =>
    match x with
    | 0%nat => match y with
               | 0%nat | _ => RtoC 0
               end
    | 1%nat => match y with
               | 0%nat => C1
               | S _ => RtoC 0
               end
    | S (S _) => RtoC 0
    end) 1%nat 1%nat))
Crunching:
(0 =
 / √ 2 *
 (if (n =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat (S (S y)) +
 -
 (/ √ 2 *
  (if (n =? 0)%nat
   then
    fun x y : nat =>
    match x with
    | 0%nat => match y with
               | 0%nat => C1
               | S _ => RtoC 0
               end
    | 1%nat => match y with
               | 0%nat | _ => RtoC 0
               end
    | S (S _) => RtoC 0
    end
   else
    fun x y : nat =>
    match x with
    | 0%nat => match y with
               | 0%nat | _ => RtoC 0
               end
    | 1%nat => match y with
               | 0%nat => C1
               | S _ => RtoC 0
               end
    | S (S _) => RtoC 0
    end) 1%nat (S (S y))))
Crunching:
(fst
   (/ √ 2 *
    (if (n =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 0%nat 0%nat +
    / √ 2 *
    (if (n =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat) = fst (/ √ (R1 + R1)))
Crunching:
((hadamard × ∣ n ⟩) 0%nat 0%nat =
 (/ √ (R1 + R1) .* (∣ 0 ⟩ .+ (- R1)%R ^ n .* ∣ 1 ⟩)) 0%nat 0%nat)
Crunching:
(0%nat <> 2%nat ->
 0 <= Temp < sum_over_list x' -> (sample x' Temp < length x')%nat)
Crunching: Z
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (list2D_to_matrix [[e]; [e0]] = hadamard × ∣ n ⟩)
Crunching:
(list2D_to_matrix
   [[C1 / √ 2 *
     (if (n =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 0%nat 0%nat +
     C1 / √ 2 *
     (if (n =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 1%nat 0%nat];
   [C1 / √ 2 *
    (if (n =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 0%nat 0%nat +
    - (C1 / √ 2) *
    (if (n =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat]] = / √ 2 .* (∣ 0 ⟩ .+ (-1) ^ n .* ∣ 1 ⟩))
Crunching:
(0 =
 / √ 2 *
 (if (n =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat 1%nat +
 / √ 2 *
 (if (n =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat 1%nat)
Crunching:
(0 =
 / √ 2 *
 (if (n =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat (S (S y)) +
 / √ 2 *
 (if (n =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat (S (S y)))
Crunching:
(0 =
 / √ 2 *
 (if (n =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat 1%nat +
 -
 (/ √ 2 *
  (if (n =? 0)%nat
   then
    fun x y : nat =>
    match x with
    | 0%nat => match y with
               | 0%nat => C1
               | S _ => RtoC 0
               end
    | 1%nat => match y with
               | 0%nat | _ => RtoC 0
               end
    | S (S _) => RtoC 0
    end
   else
    fun x y : nat =>
    match x with
    | 0%nat => match y with
               | 0%nat | _ => RtoC 0
               end
    | 1%nat => match y with
               | 0%nat => C1
               | S _ => RtoC 0
               end
    | S (S _) => RtoC 0
    end) 1%nat 1%nat))
Crunching:
(0 =
 / √ 2 *
 (if (n =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat (S (S y)) +
 -
 (/ √ 2 *
  (if (n =? 0)%nat
   then
    fun x y : nat =>
    match x with
    | 0%nat => match y with
               | 0%nat => C1
               | S _ => RtoC 0
               end
    | 1%nat => match y with
               | 0%nat | _ => RtoC 0
               end
    | S (S _) => RtoC 0
    end
   else
    fun x y : nat =>
    match x with
    | 0%nat => match y with
               | 0%nat | _ => RtoC 0
               end
    | 1%nat => match y with
               | 0%nat => C1
               | S _ => RtoC 0
               end
    | S (S _) => RtoC 0
    end) 1%nat (S (S y))))
Crunching:
(0%nat <> 2%nat ->
 0 <= Temp < sum_over_list x' -> (sample x' Temp < length x')%nat)
Crunching: (list2D_to_matrix [[e]; [e0]] = hadamard × ∣ n ⟩)
Crunching:
(list2D_to_matrix
   [[C1 / √ 2 *
     (if (n =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 0%nat 0%nat +
     C1 / √ 2 *
     (if (n =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 1%nat 0%nat];
   [C1 / √ 2 *
    (if (n =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 0%nat 0%nat +
    - (C1 / √ 2) *
    (if (n =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat]] = / √ IPR_2 1 .* (∣ 0 ⟩ .+ (- R1)%R ^ n .* ∣ 1 ⟩))
Crunching:
(0%nat <> 2%nat ->
 0 <= Temp < sum_over_list x' -> (sample x' Temp < length x')%nat)
Crunching:
(0 =
 / √ 2 *
 (if (n =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat 1%nat +
 / √ 2 *
 (if (n =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat 1%nat)
Crunching:
(0 =
 / √ 2 *
 (if (n =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat (S (S y)) +
 / √ 2 *
 (if (n =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat (S (S y)))
Crunching:
(0 =
 / √ 2 *
 (if (n =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat 1%nat +
 -
 (/ √ 2 *
  (if (n =? 0)%nat
   then
    fun x y : nat =>
    match x with
    | 0%nat => match y with
               | 0%nat => C1
               | S _ => RtoC 0
               end
    | 1%nat => match y with
               | 0%nat | _ => RtoC 0
               end
    | S (S _) => RtoC 0
    end
   else
    fun x y : nat =>
    match x with
    | 0%nat => match y with
               | 0%nat | _ => RtoC 0
               end
    | 1%nat => match y with
               | 0%nat => C1
               | S _ => RtoC 0
               end
    | S (S _) => RtoC 0
    end) 1%nat 1%nat))
Crunching:
(0 =
 / √ 2 *
 (if (n =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat (S (S y)) +
 -
 (/ √ 2 *
  (if (n =? 0)%nat
   then
    fun x y : nat =>
    match x with
    | 0%nat => match y with
               | 0%nat => C1
               | S _ => RtoC 0
               end
    | 1%nat => match y with
               | 0%nat | _ => RtoC 0
               end
    | S (S _) => RtoC 0
    end
   else
    fun x y : nat =>
    match x with
    | 0%nat => match y with
               | 0%nat | _ => RtoC 0
               end
    | 1%nat => match y with
               | 0%nat => C1
               | S _ => RtoC 0
               end
    | S (S _) => RtoC 0
    end) 1%nat (S (S y))))
Crunching:
(fst
   (/ √ 2 *
    (if (n =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 0%nat 0%nat +
    / √ 2 *
    (if (n =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat) = fst (/ √ (R1 + R1)))
Crunching:
(forall y : nat,
 (f >= 2 ^ dim)%nat \/ (y >= 2 ^ dim)%nat ->
 (if start + n <=? dim
  then I (2 ^ start) ⊗ u ⊗ I (2 ^ (dim - (start + n)))
  else Zero) f y = 0)
Crunching:
(forall x y lb ub : nat,
 lb <= x <= ub /\ lb <= y <= ub -> lb <= (x + y) / 2 <= ub)
Crunching:
(0%nat <> 2%nat ->
 0 <= Temp < sum_over_list x' -> (sample x' Temp < length x')%nat)
Crunching:
(0%nat <> 2%nat ->
 0 <= Temp < sum_over_list x' -> (sample x' Temp < length x')%nat)
rewrite match_option_dtt
match (List.nth_error l (proj1_sig x1)) with
| None =>
(fun E : List.nth_error l (proj1_sig x1) = None =>
 match
   slist_nth_lemma1
     (exist (fun l : list A => (length l =? S n) = true) (l0 :: l)%list Hl0)
     (ltN_S x1) E return A
 with
 end)
| Some m => (fun (a : A) (_ : List.nth_error l (proj1_sig x1) = Some a) => a)
rewrite match_option_dtt
match (List.nth_error l (proj1_sig x1)) with
| None =>
(fun E : List.nth_error l (proj1_sig x1) = None =>
 match
   slist_nth_lemma1
     (exist (fun l : list A => (length l =? S n) = true) (l0 :: l)%list Hl0)
     (ltN_S x1) E return A
 with
 end)
| Some m => (fun (a : A) (_ : List.nth_error l (proj1_sig x1) = Some a) => a)
Crunching:
(0%nat <> 2%nat ->
 0 <= Temp < sum_over_list x' -> (sample x' Temp < length x')%nat)
rewrite match_option_dtt
match (List.nth_error l (proj1_sig x1)) with
| None =>
(fun E : List.nth_error l (proj1_sig x1) = None =>
 match
   slist_nth_lemma1
     (exist (fun l : list A => (length l =? S n) = true) (l0 :: l)%list Hl0)
     (ltN_S x1) E return A
 with
 end)
| Some m => (fun (a : A) (_ : List.nth_error l (proj1_sig x1) = Some a) => a)
rewrite match_option_dtt
match (List.nth_error l (proj1_sig x1)) with
| None =>
(fun E : List.nth_error l (proj1_sig x1) = None =>
 match
   slist_nth_lemma1
     (exist (fun l : list A => (length l =? S n) = true) (l0 :: l)%list Hl0)
     (ltN_S x1) E return A
 with
 end)
| Some m => (fun (a : A) (_ : List.nth_error l (proj1_sig x1) = Some a) => a)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
Crunching:
((hadamard × ∣ n ⟩) 0%nat 0%nat =
 (/ √ (R1 + R1) .* (∣ 0 ⟩ .+ (- R1)%R ^ n .* ∣ 1 ⟩)) 0%nat 0%nat)
Crunching:
(forall y : Vector 2,
 ?R4 LE y ->
 Morphisms.respectful eq (Morphisms.respectful eq eq) 
   (hadamard × LE) (/ √ (R1 + R1) .* y))
Crunching:
(0%nat <> 2%nat ->
 0 <= Temp < sum_over_list x' -> (sample x' Temp < length x')%nat)
Crunching:
(Morphisms.respectful eq (Morphisms.respectful eq eq) 
   (hadamard × LE) (/ √ (R1 + R1) .* x))
Crunching:
(forall y : nat,
 H1 = y ->
 Morphisms.respectful eq eq ((hadamard × LE) H1) ((/ √ (R1 + R1) .* x) y))
Crunching:
(Morphisms.respectful eq (Morphisms.respectful eq eq) 
   (hadamard × LE) (/ √ (R1 + R1) .* x))
Crunching:
(forall y : nat,
 H1 = y ->
 Morphisms.respectful eq eq ((hadamard × LE) H1) ((/ √ (R1 + R1) .* x) y))
Crunching: False
rewrite if_dtt
if
((fix Ffix (x x0 : nat) {struct x} : bool :=
    match x with
    | 0 => match x0 with
           | 0 => true
           | S _ => false
           end
    | S x1 => match x0 with
              | 0 => false
              | S x2 => Ffix x1 x2
              end
    end) (let (x, _) := k1 in x) (let (x, _) := k2 in x))
then
(fun
   _ : (fix Ffix (x x0 : nat) {struct x} : bool :=
          match x with
          | 0 => match x0 with
                 | 0 => true
                 | S _ => false
                 end
          | S x1 => match x0 with
                    | 0 => false
                    | S x2 => Ffix x1 x2
                    end
          end) (let (x, _) := k1 in x) (let (x, _) := k2 in x) = true =>
 AA tt)
else
(fun
   x : (fix Ffix (x x0 : nat) {struct x} : bool :=
          match x with
          | 0 => match x0 with
                 | 0 => true
                 | S _ => false
                 end
          | S x1 => match x0 with
                    | 0 => false
                    | S x2 => Ffix x1 x2
                    end
          end) (let (x, _) := k1 in x) (let (x, _) := k2 in x) = false =>
 BB
   ((if
      match (let (x0, _) := k2 in x0) with
      | 0 => false
      | S x0 =>
          (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
             match x1 with
             | 0 => true
             | S x3 => match x2 with
                       | 0 => false
                       | S x4 => Ffix x3 x4
                       end
             end) (let (x1, _) := k1 in x1) x0
      end as c
      return
        (match (let (x0, _) := k2 in x0) with
         | 0 => false
         | S x0 =>
             (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                match x1 with
                | 0 => true
                | S x3 => match x2 with
                          | 0 => false
                          | S x4 => Ffix x3 x4
                          end
                end) (let (x1, _) := k1 in x1) x0
         end = c ->
         {x1 : nat
         | match n with
           | 0 => false
           | S x2 =>
               (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                  match x3 with
                  | 0 => true
                  | S x5 =>
                      match x4 with
                      | 0 => false
                      | S x6 => Ffix x5 x6
                      end
                  end) x1 x2
           end = true})
     then
      fun
        x0 : match (let (x0, _) := k2 in x0) with
             | 0 => false
             | S x0 =>
                 (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                    match x1 with
                    | 0 => true
                    | S x3 =>
                        match x2 with
                        | 0 => false
                        | S x4 => Ffix x3 x4
                        end
                    end) (let (x1, _) := k1 in x1) x0
             end = true =>
      exist
        (fun x1 : nat =>
         match n with
         | 0 => false
         | S x2 =>
             (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                match x3 with
                | 0 => true
                | S x5 => match x4 with
                          | 0 => false
                          | S x6 => Ffix x5 x6
                          end
                end) x1 x2
         end = true) (let (x1, _) := k1 in x1) (ltN_pop_lemma1 n k2 k1 x0)
     else
      fun
        x0 : match (let (x0, _) := k2 in x0) with
             | 0 => false
             | S x0 =>
                 (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
                    match x1 with
                    | 0 => true
                    | S x3 =>
                        match x2 with
                        | 0 => false
                        | S x4 => Ffix x3 x4
                        end
                    end) (let (x1, _) := k1 in x1) x0
             end = false =>
      exist
        (fun x1 : nat =>
         match n with
         | 0 => false
         | S x2 =>
             (fix Ffix (x3 x4 : nat) {struct x3} : bool :=
                match x3 with
                | 0 => true
                | S x5 => match x4 with
                          | 0 => false
                          | S x6 => Ffix x5 x6
                          end
                end) x1 x2
         end = true)
        match (let (x1, _) := k1 in x1) with
        | 0 => let (x1, _) := k1 in x1
        | S x1 => x1
        end (ltN_pop_lemma2 n k2 k1 x0 x)) eq_refl))
Crunching:
(Morphisms.respectful eq (Morphisms.respectful eq eq) 
   (hadamard × LE) (/ √ (R1 + R1) .* x))
Crunching:
(forall y : nat,
 H1 = y ->
 Morphisms.respectful eq eq ((hadamard × LE) H1) ((/ √ (R1 + R1) .* x) y))
Crunching:
(Morphisms.respectful eq (Morphisms.respectful eq eq) 
   (hadamard × LE) (/ √ (R1 + R1) .* x))
Crunching:
(forall y : nat,
 H1 = y ->
 Morphisms.respectful eq eq ((hadamard × LE) H1) ((/ √ (R1 + R1) .* x) y))
Crunching:
(forall y : nat,
 Step = y ->
 Morphisms.respectful eq eq ((hadamard × LE) Step) ((/ √ (R1 + R1) .* z) y))
Crunching: ((hadamard × LE) z1 x = (/ √ (R1 + R1) .* f) z2 y)
Crunching:
(0%nat <> 2%nat ->
 0 <= Temp < sum_over_list x' -> (sample x' Temp < length x')%nat)
Crunching:
(0%nat <> 2%nat ->
 0 <= Temp < sum_over_list x' -> (sample x' Temp < length x')%nat)
Crunching: (list2D_to_matrix [[e]; [e0]] = hadamard × ∣ abs ⟩)
Crunching:
(list2D_to_matrix
   [[C1 / √ 2 *
     (if (abs =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 0%nat 0%nat +
     C1 / √ 2 *
     (if (abs =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 1%nat 0%nat];
   [C1 / √ 2 *
    (if (abs =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 0%nat 0%nat +
    - (C1 / √ 2) *
    (if (abs =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat]] = / √ 2 .* (∣0⟩ .+ (-1) ^ abs .* ∣1⟩))
Crunching:
(0 =
 / √ 2 *
 (if (abs =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat 1%nat +
 / √ 2 *
 (if (abs =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat 1%nat)
Crunching:
(0 =
 / √ 2 *
 (if (abs =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat (S (S y)) +
 / √ 2 *
 (if (abs =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat (S (S y)))
Crunching:
(0 =
 / √ 2 *
 (if (abs =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat 1%nat +
 -
 (/ √ 2 *
  (if (abs =? 0)%nat
   then
    fun x y : nat =>
    match x with
    | 0%nat => match y with
               | 0%nat => C1
               | S _ => RtoC 0
               end
    | 1%nat => match y with
               | 0%nat | _ => RtoC 0
               end
    | S (S _) => RtoC 0
    end
   else
    fun x y : nat =>
    match x with
    | 0%nat => match y with
               | 0%nat | _ => RtoC 0
               end
    | 1%nat => match y with
               | 0%nat => C1
               | S _ => RtoC 0
               end
    | S (S _) => RtoC 0
    end) 1%nat 1%nat))
Crunching:
(0 =
 / √ 2 *
 (if (abs =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat (S (S y)) +
 -
 (/ √ 2 *
  (if (abs =? 0)%nat
   then
    fun x y : nat =>
    match x with
    | 0%nat => match y with
               | 0%nat => C1
               | S _ => RtoC 0
               end
    | 1%nat => match y with
               | 0%nat | _ => RtoC 0
               end
    | S (S _) => RtoC 0
    end
   else
    fun x y : nat =>
    match x with
    | 0%nat => match y with
               | 0%nat | _ => RtoC 0
               end
    | 1%nat => match y with
               | 0%nat => C1
               | S _ => RtoC 0
               end
    | S (S _) => RtoC 0
    end) 1%nat (S (S y))))
Crunching:
(fst ((hadamard × ∣ H1 ⟩) x y) =
 fst ((/ √ 2 .* (∣ 0 ⟩ .+ (-1) ^ H1 .* ∣ 1 ⟩)) x y))
Crunching:
(fst ((hadamard × ∣ true ⟩) x y) =
 fst ((/ √ 2 .* (∣ 0 ⟩ .+ (-1) ^ true .* ∣ 1 ⟩)) x y))
Crunching:
(fst ((hadamard × ∣ true ⟩) x y) =
 fst ((/ √ 2 .* (∣ 0 ⟩ .+ (-1) ^ true .* ∣ 1 ⟩)) x y))
Crunching:
(fst ((/ √ 2 .* (∣ 0 ⟩ .+ (-1) ^ H1 .* ∣ 1 ⟩)) x y) =
 fst ((hadamard × ∣ H1 ⟩) x y))
Crunching:
(fst ((hadamard × ∣ H1 ⟩) x y) =
 fst ((/ √ 2 .* (∣ 0 ⟩ .+ (-1) ^ H1 .* ∣ 1 ⟩)) x y))
Crunching: (WF_Unitary (pad_u a n m))
Crunching:
((hadamard × ∣ b ⟩) 0%nat 0%nat =
 (/ √ 2 .* (∣ 0 ⟩ .+ (-1) ^ b .* ∣ 1 ⟩)) 0%nat 0%nat)
Crunching: (list2D_to_matrix [[e]; [e0]] = hadamard × ∣ n ⟩)
Crunching:
(list2D_to_matrix
   [[C1 / √ 2 *
     (if (n =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 0%nat 0%nat +
     C1 / √ 2 *
     (if (n =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 1%nat 0%nat];
   [C1 / √ 2 *
    (if (n =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 0%nat 0%nat +
    - (C1 / √ 2) *
    (if (n =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat]] = / √ 2 .* (∣ 0 ⟩ .+ (-1) ^ n .* ∣ 1 ⟩))
Crunching:
(0 =
 / √ 2 *
 (if (n =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat 1%nat +
 / √ 2 *
 (if (n =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat 1%nat)
Crunching:
(0 =
 / √ 2 *
 (if (n =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat (S (S y)) +
 / √ 2 *
 (if (n =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat (S (S y)))
Crunching:
(0 =
 / √ 2 *
 (if (n =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat 1%nat +
 -
 (/ √ 2 *
  (if (n =? 0)%nat
   then
    fun x y : nat =>
    match x with
    | 0%nat => match y with
               | 0%nat => C1
               | S _ => RtoC 0
               end
    | 1%nat => match y with
               | 0%nat | _ => RtoC 0
               end
    | S (S _) => RtoC 0
    end
   else
    fun x y : nat =>
    match x with
    | 0%nat => match y with
               | 0%nat | _ => RtoC 0
               end
    | 1%nat => match y with
               | 0%nat => C1
               | S _ => RtoC 0
               end
    | S (S _) => RtoC 0
    end) 1%nat 1%nat))
Crunching:
(0 =
 / √ 2 *
 (if (n =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat (S (S y)) +
 -
 (/ √ 2 *
  (if (n =? 0)%nat
   then
    fun x y : nat =>
    match x with
    | 0%nat => match y with
               | 0%nat => C1
               | S _ => RtoC 0
               end
    | 1%nat => match y with
               | 0%nat | _ => RtoC 0
               end
    | S (S _) => RtoC 0
    end
   else
    fun x y : nat =>
    match x with
    | 0%nat => match y with
               | 0%nat | _ => RtoC 0
               end
    | 1%nat => match y with
               | 0%nat => C1
               | S _ => RtoC 0
               end
    | S (S _) => RtoC 0
    end) 1%nat (S (S y))))
out of reach
Tactic call ran for 0.002 secs (0.001u,0.s) (failure)
Crunching: (list2D_to_matrix [[e]; [e0]] = hadamard × ∣ n ⟩)
Crunching:
(list2D_to_matrix
   [[C1 / √ 2 *
     (if (n =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 0%nat 0%nat +
     C1 / √ 2 *
     (if (n =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 1%nat 0%nat];
   [C1 / √ 2 *
    (if (n =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 0%nat 0%nat +
    - (C1 / √ 2) *
    (if (n =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat]] = / √ IPR_2 1 .* (∣ 0 ⟩ .+ (- R1)%R ^ n .* ∣ 1 ⟩))
Crunching:
(0 =
 / √ 2 *
 (if (n =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat 1%nat +
 / √ 2 *
 (if (n =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat 1%nat)
Crunching:
(0 =
 / √ 2 *
 (if (n =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat (S (S y)) +
 / √ 2 *
 (if (n =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 1%nat (S (S y)))
Crunching:
(0 =
 / √ 2 *
 (if (n =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat 1%nat +
 -
 (/ √ 2 *
  (if (n =? 0)%nat
   then
    fun x y : nat =>
    match x with
    | 0%nat => match y with
               | 0%nat => C1
               | S _ => RtoC 0
               end
    | 1%nat => match y with
               | 0%nat | _ => RtoC 0
               end
    | S (S _) => RtoC 0
    end
   else
    fun x y : nat =>
    match x with
    | 0%nat => match y with
               | 0%nat | _ => RtoC 0
               end
    | 1%nat => match y with
               | 0%nat => C1
               | S _ => RtoC 0
               end
    | S (S _) => RtoC 0
    end) 1%nat 1%nat))
Crunching:
(0 =
 / √ 2 *
 (if (n =? 0)%nat
  then
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end
  else
   fun x y : nat =>
   match x with
   | 0%nat => match y with
              | 0%nat | _ => RtoC 0
              end
   | 1%nat => match y with
              | 0%nat => C1
              | S _ => RtoC 0
              end
   | S (S _) => RtoC 0
   end) 0%nat (S (S y)) +
 -
 (/ √ 2 *
  (if (n =? 0)%nat
   then
    fun x y : nat =>
    match x with
    | 0%nat => match y with
               | 0%nat => C1
               | S _ => RtoC 0
               end
    | 1%nat => match y with
               | 0%nat | _ => RtoC 0
               end
    | S (S _) => RtoC 0
    end
   else
    fun x y : nat =>
    match x with
    | 0%nat => match y with
               | 0%nat | _ => RtoC 0
               end
    | 1%nat => match y with
               | 0%nat => C1
               | S _ => RtoC 0
               end
    | S (S _) => RtoC 0
    end) 1%nat (S (S y))))
Crunching:
(fst
   (/ √ 2 *
    (if (n =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 0%nat 0%nat +
    / √ 2 *
    (if (n =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat) = fst (/ √ (R1 + R1)))
uniform_sigma_lifting (M:=[the monad of idfun]) ?op ?t Identity.naturality
     : imonad_transformer.lifting_monadT (M:=[the monad of idfun]) 
         ?op
         (t:=imonad_transformer.FMT.Exports.imonad_transformer_FMT__to__imonad_transformer_MonadT
               ?t)
         (slifting (M:=[the monad of idfun]) ?op ?t Identity.naturality)
where
?E : [ |- functor]
?op : [ |- ?E .-operation [the monad of idfun]]
?t : [ |- imonad_transformer.FMT.type]
'Z_R' is now a registered translation.
'A_R' is now a registered translation.
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.005 secs (0.003u,0.002s) (failure)
Crunching:
(forall (l : list R) (r : R),
 Forall (fun x : R => 0 <= x) l ->
 sum_over_list l <= r -> sample l r = length l)
Crunching:
(sum_over_list [a] < i \/ sum_over_list [a] = i -> sample [a] i = length [a])
Crunching:
((eps' < Ha)%nat -> WF_Unitary ep' -> WF_Unitary (pad_u Ha eps' ep'))
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching:
(fst
   (/ √ 2 *
    get_vec 0
      (if (n =? 0)%nat
       then
        fun x y : nat =>
        match x with
        | 0%nat => match y with
                   | 0%nat => C1
                   | S _ => IZR (0 * 0)
                   end
        | 1%nat => match y with
                   | 0%nat | _ => IZR (0 * 0)
                   end
        | S (S _) => IZR (0 * 0)
        end
       else
        fun x y : nat =>
        match x with
        | 0%nat => match y with
                   | 0%nat | _ => IZR (0 * 0)
                   end
        | 1%nat => match y with
                   | 0%nat => C1
                   | S _ => IZR (0 * 0)
                   end
        | S (S _) => IZR (0 * 0)
        end) 0%nat 0%nat +
    / √ 2 *
    (if (n =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC (IZR (0 * 0))
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC (IZR (0 * 0))
                 end
      | S (S _) => RtoC (IZR (0 * 0))
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC (IZR (0 * 0))
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC (IZR (0 * 0))
                 end
      | S (S _) => RtoC (IZR (0 * 0))
      end) 1%nat 0%nat) = fst (/ √ (R1 + R1)))
Crunching:
((hadamard × ∣ n ⟩) 0%nat 0%nat =
 (/ √ (R1 + R1) .* (∣ 0 ⟩ .+ (- R1)%R ^ n .* ∣ 1 ⟩)) 0%nat 0%nat)
Crunching: ((hadamard × x) y H15 = (/ √ (R1 + R1) .* x') y' y0)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching:
(forall y : nat,
 f = y ->
 Morphisms.respectful eq eq ((hadamard × H) f) ((/ √ (R1 + R1) .* H1) y))
clear  H1  :  (False -> b1 = false)
Crunching: (list2D_to_matrix [[e]; [e0]] = hadamard × ∣ true ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = hadamard × ∣ false ⟩)
Crunching:
(list2D_to_matrix [[C1 / √ 2]; [- (C1 / √ 2)]] =
 / √ 2 .* (∣ 0 ⟩ .+ (-1) ^ true .* ∣ 1 ⟩))
Crunching:
(list2D_to_matrix [[C1 / √ 2]; [C1 / √ 2]] =
 / √ 2 .* (∣ 0 ⟩ .+ (-1) ^ false .* ∣ 1 ⟩))
Crunching:
(forall r : R,
 0 <= r -> r < sum_over_list A -> sample (A ++ l) r = sample A r)
Crunching:
(forall x : R,
 sin_in 0² x ->
 forall x0 y : nat,
 (x0 < 2)%nat -> (y < 2)%nat -> cnot × ∣ x0, y ⟩ = ∣ x0, (x0 + y) mod 2 ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]; [e1]; [e2]] = cnot × ∣ c, Ha ⟩)
Crunching: (WF_Unitary (pad_u a n m))
Crunching:
(list2D_to_matrix
   [[(if (c =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 0%nat 0%nat *
     (if (Ha =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 0%nat 0%nat];
   [(if (c =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 0%nat 0%nat *
    (if (Ha =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat];
   [(if (c =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat *
    (if (Ha =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat];
   [(if (c =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat *
    (if (Ha =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 0%nat 0%nat]] =
 ∣ c, match snd (Nat.divmod (c + Ha) 1 0 1) with
      | 0 => 1
      | S _ => 0
      end ⟩)
Crunching: (WF_Unitary (pad_u a n m))
Crunching: (WF_Unitary (pad_u a n m))
Crunching: (WF_Unitary (pad_u a n m))
Crunching: (WF_Unitary (pad_u a n m))
Crunching: (WF_Unitary (pad_u a n m))
Crunching: (WF_Unitary (pad_u a n m))
Crunching: (WF_Unitary (pad_u a n m))
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (WF_Unitary (pad_u a n m))
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
Crunching: (WF_Unitary (pad_u a n m))
Crunching: (WF_Unitary (pad_u a n m))
Crunching: (WF_Unitary (pad_u a n m))
Crunching: (WF_Unitary (pad_u a n m))
Crunching: (WF_Unitary (pad_u a n m))
Crunching: (WF_Unitary (pad_u a n m))
Crunching: (WF_Unitary (pad_u a n m))
Crunching: (WF_Unitary (pad_u a n m))
Crunching: (WF_Unitary (pad_u a n m))
Crunching: (WF_Unitary (pad_u a n m))
Crunching: (WF_Unitary (pad_u a n m))
Crunching: (WF_Unitary (pad_u a n m))
Crunching: (WF_Unitary (pad_u a n m))
Crunching: (WF_Unitary (pad_u a n m))
Crunching: (WF_Unitary (pad_u a n m))
Crunching: (- (PI / 2) < 0 -> x > 0)
Crunching: (WF_Unitary (pad_u a n m))
Crunching: (WF_Unitary (pad_u a n m))
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (WF_Unitary (pad_u a n m))
Crunching: (WF_Unitary (pad_u a n m))
Crunching: (WF_Unitary (pad_u a n m))
Crunching: (WF_Unitary (pad_u a n m))
Crunching: (WF_Unitary (pad_u a n m))
Crunching: (WF_Unitary (pad_u a n m))
Crunching:
(forall r : R,
 0 <= r -> r < sum_over_list A -> sample (A ++ l) r = sample A r)
Crunching: (forall b : R, 0 <= k <= b -> b * k + k * b <= k * k + b * b)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching:
((Hyp < 2)%nat ->
 (Hyp2 < 2)%nat -> cnot × ∣ Hyp, Hyp2 ⟩ = ∣ Hyp, (Hyp + Hyp2) mod 2 ⟩)
Crunching: (WF_Unitary (pad_u a n m))
Crunching: (sample (l1 ++ l2) r = sample l1 r)
rewrite if_dtt
if (pA a)
then (fun E : pA a = true => p (exist (fun a0 : A => pA a0 = true) a E))
else (fun _ : pA a = false => false)
Crunching: (∣0⟩ = basis_vector 2 0)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Crunching: (list2D_to_matrix [[e]; [e0]; [e1]; [e2]] = cnot × ∣ env, H ⟩)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
Crunching:
(list2D_to_matrix
   [[(if (env =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 0%nat 0%nat *
     (if (H =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 0%nat 0%nat];
   [(if (env =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 0%nat 0%nat *
    (if (H =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat];
   [(if (env =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat *
    (if (H =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat];
   [(if (env =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat *
    (if (H =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 0%nat 0%nat]] =
 ∣ env, match snd (Nat.divmod (env + H) 1 0 1) with
        | 0 => 1
        | S _ => 0
        end ⟩)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Crunching:
(Hx >= H -> (if (Hx =? N y) && (Hx <? H) && (y <? H) then C1 else 0%R) = 0%R)
fun Z : UU0 =>
uniform_sigma_lifting (M:=[the monad of ExceptMonad.acto Z]) 
  ?op ?t (Exception.naturality Z)
     : forall Z : UU0,
       imonad_transformer.lifting_monadT
         (M:=[the monad of ExceptMonad.acto Z]) ?op
         (t:=imonad_transformer.FMT.Exports.imonad_transformer_FMT__to__imonad_transformer_MonadT
               ?t)
         (slifting (M:=[the monad of ExceptMonad.acto Z]) 
            ?op ?t (Exception.naturality Z))
where
?E : [Z : UU0 |- functor]
?op : [Z : UU0 |- ?E .-operation [the monad of ExceptMonad.acto Z]]
?t : [Z : UU0 |- imonad_transformer.FMT.type]
Crunching:
(H5 >= H \/ H6 >= H ->
 (if (H5 =? N H6) && (H5 <? H) && (H6 <? H) then C1 else 0%R) = 0%R)
Crunching: (WF_Matrix (perm_mat H3 a))
Crunching: (WF_Matrix (perm_mat H3 a))
Crunching: (WF_Matrix (perm_mat H3 a))
Crunching: (WF_Matrix (perm_mat H3 a))
Crunching:
(forall x : R,
 sin_in 0² x ->
 forall x0 y : nat,
 (x0 < 2)%nat -> (y < 2)%nat -> cnot × ∣ x0, y ⟩ = ∣ x0, (x0 + y) mod 2 ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]; [e1]; [e2]] = cnot × ∣ c, Ha ⟩)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Crunching:
(list2D_to_matrix
   [[(if (c =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 0%nat 0%nat *
     (if (Ha =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 0%nat 0%nat];
   [(if (c =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 0%nat 0%nat *
    (if (Ha =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat];
   [(if (c =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat *
    (if (Ha =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat];
   [(if (c =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat *
    (if (Ha =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 0%nat 0%nat]] =
 ∣ c, match snd (Nat.divmod (c + Ha) 1 0 1) with
      | 0 => 1
      | S _ => 0
      end ⟩)
Crunching: (WF_Matrix (perm_mat H3 a))
Crunching: (list2D_to_matrix [[e]; [e0]; [e1]; [e2]] = cnot × ∣ n, Ha ⟩)
Crunching: (WF_Matrix (perm_mat H3 a))
Crunching:
(list2D_to_matrix
   [[(if (n =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 0%nat 0%nat *
     (if (Ha =? 0)%nat
      then
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end
      else
       fun x y : nat =>
       match x with
       | 0%nat => match y with
                  | 0%nat | _ => RtoC 0
                  end
       | 1%nat => match y with
                  | 0%nat => C1
                  | S _ => RtoC 0
                  end
       | S (S _) => RtoC 0
       end) 0%nat 0%nat];
   [(if (n =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 0%nat 0%nat *
    (if (Ha =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat];
   [(if (n =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat *
    (if (Ha =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat];
   [(if (n =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 1%nat 0%nat *
    (if (Ha =? 0)%nat
     then
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end
     else
      fun x y : nat =>
      match x with
      | 0%nat => match y with
                 | 0%nat | _ => RtoC 0
                 end
      | 1%nat => match y with
                 | 0%nat => C1
                 | S _ => RtoC 0
                 end
      | S (S _) => RtoC 0
      end) 0%nat 0%nat]] =
 ∣ n, match snd (Nat.divmod (n + Ha) 1 0 1) with
      | 0 => 1
      | S _ => 0
      end ⟩)
Crunching: (WF_Matrix (perm_mat H3 a))
Crunching: (WF_Matrix (perm_mat H3 a))
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (forall c : C, (Cmod c ^ 2)%R = fst (c ^* * c))
Crunching: (WF_Matrix (perm_mat H3 a))
Crunching: (0 < t)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching: ((perm_mat m n × perm_mat m A) n0 H0 = 0%R)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: ((∣ n ⟩) † = ⟨ n ∣)
Crunching: ((∣ n ⟩) † = ⟨ n ∣)
Crunching:
(((if (n =? 0)%nat
   then
    fun x y : nat =>
    match x with
    | 0%nat => match y with
               | 0%nat => C1
               | S _ => RtoC 0
               end
    | 1%nat => match y with
               | 0%nat | _ => RtoC 0
               end
    | S (S _) => RtoC 0
    end
   else
    fun x y : nat =>
    match x with
    | 0%nat => match y with
               | 0%nat | _ => RtoC 0
               end
    | 1%nat => match y with
               | 0%nat => C1
               | S _ => RtoC 0
               end
    | S (S _) => RtoC 0
    end) y x) ^* =
 (if (n =? 0)%nat
  then
   fun x y : nat =>
   match y with
   | 0%nat => match x with
              | 0%nat => C1
              | S _ => 0
              end
   | 1%nat => match x with
              | 0%nat | _ => 0
              end
   | S (S _) => 0
   end ^*
  else
   fun x y : nat =>
   match y with
   | 0%nat => match x with
              | 0%nat | _ => 0
              end
   | 1%nat => match x with
              | 0%nat => C1
              | S _ => 0
              end
   | S (S _) => 0
   end ^*) x y)
Crunching: ((∣ n ⟩) † = ⟨ n ∣)
Crunching: ((∣ n ⟩) † = ⟨ n ∣)
Crunching: ((∣ 0 ⟩) ⊤ = ⟨ 0 ∣)
Crunching: ((∣ 1 ⟩) ⊤ = ⟨ 1 ∣)
Crunching:
(n0 >= m \/ Eq2 >= m -> (perm_mat m n × perm_mat m A) n0 Eq2 = 0%R)
Crunching: ((⟨ 0 ∣) ⊤ = ∣ 0 ⟩)
Crunching: ((perm_mat m n × perm_mat m A) n0 H0 = 0%R)
Crunching: ((⟨ 0 ∣) ⊤ = ∣ 0 ⟩)
Crunching: ((⟨ 1 ∣) ⊤ = ∣ 1 ⟩)
Crunching: ((⟨ 1 ∣) ⊤ = ∣ 1 ⟩)
Crunching: ((perm_mat m a × perm_mat m A) n0 b = 0%R)
Crunching: ((⟨ 1 ∣) † = ∣ 1 ⟩)
Crunching: ((⟨ 1 ∣) † = ∣ 1 ⟩)
Crunching: ((∣ 1 ⟩) † = ⟨ 1 ∣)
Crunching: ((⟨ 0 ∣) † = ∣ 0 ⟩)
Crunching: ((⟨ 0 ∣) † = ∣ 0 ⟩)
Crunching: ((∣ 0 ⟩) † = ⟨ 0 ∣)
Crunching: (n0 >= m \/ 0 >= m -> (perm_mat m X0 × perm_mat m A) n0 0 = 0%R)
Crunching: (H3 <= sample (repeat 0%R H3 ++ l2) x)%nat
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (a <= sample (repeat 0%R a ++ []) r)%nat
Crunching: (a <= sample (repeat 0%R a ++ []) r)%nat
Crunching: (H3 <= sample (repeat 0%R H3 ++ l2) x)%nat
Crunching: ((-1 + 0)%R = -1 -> (0 + -1)%R = -1 -> ~ 0 <= r)
simplified dependent [if true]
Ha : (pA a)  = true
if (pA a)
then (fun E : pA a = true => p1 (exist (fun a0 : A => pA a0 = true) a E))
else (fun E : pA a = false => p0 (exist (fun a0 : A => pA a0 = false) a E))
Crunching: (∣1⟩ = basis_vector 2 1)
simplified dependent [if false]
Ha : (pA a)  = true
if (pA a)
then (fun E : pA a = true => p1 (exist (fun a0 : A => pA a0 = true) a E))
else (fun E : pA a = false => p0 (exist (fun a0 : A => pA a0 = false) a E))
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
uniform_sigma_lifting (M:=[the monad of option_monad]) 
  ?op ?t Option.naturality
     : imonad_transformer.lifting_monadT (M:=[the monad of option_monad]) 
         ?op
         (t:=imonad_transformer.FMT.Exports.imonad_transformer_FMT__to__imonad_transformer_MonadT
               ?t)
         (slifting (M:=[the monad of option_monad]) ?op ?t Option.naturality)
where
?E : [ |- functor]
?op : [ |- ?E .-operation [the monad of option_monad]]
?t : [ |- imonad_transformer.FMT.type]
'A_R' is now a registered translation.
Crunching: (b * a0 + a0 * b <= a0 * a0 + b * b)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
Crunching: (perm_mat H6 f × perm_mat H6 g = perm_mat H6 (f ∘ g)%prg)
Crunching: (perm_mat l H3 × perm_mat l g = perm_mat l (H3 ∘ g)%prg)
Crunching: (0 < (y - x) / 2)
Crunching:
(0 < a ->
 b * a0 + b * a0 < a0 * a0 + b * b \/
 (b * a0 + b * a0)%R = (a0 * a0 + b * b)%R)
Crunching:
(permutation Hyp' Hm ->
 perm_mat Hyp' m × perm_mat Hyp' Hm = perm_mat Hyp' (m ∘ Hm)%prg)
Crunching:
(0 < a ->
 a0 * b + a0 * b < a0 * a0 + b * b \/
 (a0 * b + a0 * b)%R = (a0 * a0 + b * b)%R)
Crunching:
(permutation Hyp' Hm ->
 perm_mat Hyp' m × perm_mat Hyp' Hm = perm_mat Hyp' (m ∘ Hm)%prg)
Crunching: (0 < a -> a0 * b + a0 * b <= a0 * a0 + b * b)
Crunching:
(forall (a : nat -> a') (b0 : a'),
 b <> H -> (if H =? b then b0 else a H) = a H)
Crunching:
(0 < a ->
 b * a0 + b * a0 < a0 * a0 + b * b \/
 (b * a0 + b * a0)%R = (a0 * a0 + b * b)%R)
Crunching: (0 < a -> b * a0 + b * a0 <= a0 * a0 + b * b)
Crunching:
(0 < a ->
 a0 * b + a0 * b < a0 * a0 + b * b \/
 (a0 * b + a0 * b)%R = (a0 * a0 + b * b)%R)
Crunching: (0 < a -> a0 * b + a0 * b <= a0 * a0 + b * b)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: ((fun j : nat => if j =? 0 then del_c else f j) = f)
Crunching:
(0 < a ->
 b * a0 + b * a0 < a0 * a0 + b * b \/
 (b * a0 + b * a0)%R = (a0 * a0 + b * b)%R)
Crunching: (0 < a -> b * a0 + b * a0 <= a0 * a0 + b * b)
Crunching:
(0 < a ->
 a0 * b + a0 * b < a0 * a0 + b * b \/
 (a0 * b + a0 * b)%R = (a0 * a0 + b * b)%R)
Crunching: (0 < a -> a0 * b + a0 * b <= a0 * a0 + b * b)
Crunching: (∣0⟩ = basis_vector 2 0)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
clear  H0  :  (False -> cmp_sig (fun a : A => pA a = true) cA sa sa = Lt)
Crunching: ((fun j : nat => if j =? 0 then del_c else f j) = f)
Crunching: ((fun j : nat => if j =? 0 then del_c else f j) = f)
Crunching: ((fun j : nat => if j =? 0 then del_c else f j) = f)
Crunching: (0 <> 2 -> perm_mat Dec f = I Dec)
Crunching: (1 <= 0)
Crunching: (C1 = 0%R)
Crunching: (∣0⟩ = basis_vector 2 0)
Tactic call ran for 0.006 secs (0.006u,0.s) (success)
simplified dependent [if true]
Ha : (pA a)  = true
if (pA a)
then (fun E : pA a = true => F (exist (fun a0 : A => pA a0 = true) a E))
else (fun _ : pA a = false => false)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
uniform_sigma_lifting (M:=[the monad of ListMonad.acto]) 
  ?op ?t List.naturality
     : imonad_transformer.lifting_monadT (M:=[the monad of ListMonad.acto])
         ?op
         (t:=imonad_transformer.FMT.Exports.imonad_transformer_FMT__to__imonad_transformer_MonadT
               ?t)
         (slifting (M:=[the monad of ListMonad.acto]) ?op ?t List.naturality)
where
?E : [ |- functor]
?op : [ |- ?E .-operation [the monad of ListMonad.acto]]
?t : [ |- imonad_transformer.FMT.type]
'S_R' is now a registered translation.
'A_R' is now a registered translation.
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (update H2 0 feqt = H2)
Crunching: (update H2 0 feqt = H2)
rewrite if_dtt
if (pA a1)
then (fun E : pA a1 = true => F (exist (fun a0 : A => pA a0 = true) a1 E))
else (fun _ : pA a1 = false => false)
Crunching: (update (update x l H) l Hab = update x l Hab)
simplified dependent [if true] in H0
Ha' : (pA a')  = true
if (pA a')
then (fun E : pA a' = true => F (exist (fun a0 : A => pA a0 = true) a' E))
else (fun _ : pA a' = false => false)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
rewrite if_dtt
if (proj1_sig x <? proj1_sig k)
then
(fun E1 : (proj1_sig x <? proj1_sig k) = true =>
 ltN_of_nat (proj1_sig x) (S n) (ltN_intro_lemma1 n k x E1))
else
(fun E1 : (proj1_sig x <? proj1_sig k) = false =>
 ltN_of_nat (S (proj1_sig x)) (S n) (ltN_intro_lemma2 n k x E1))
rewrite if_dtt
if (proj1_sig x <? proj1_sig k)
then
(fun E1 : (proj1_sig x <? proj1_sig k) = true =>
 ltN_of_nat (proj1_sig x) (S n) (ltN_intro_lemma1 n k x E1))
else
(fun E1 : (proj1_sig x <? proj1_sig k) = false =>
 ltN_of_nat (S (proj1_sig x)) (S n) (ltN_intro_lemma2 n k x E1))
Crunching: (update (update x l H) l Hab = update x l Hab)
rewrite if_dtt
if (proj1_sig x <? proj1_sig k)
then
(fun E1 : (proj1_sig x <? proj1_sig k) = true =>
 ltN_of_nat (proj1_sig x) (S n) (ltN_intro_lemma1 n k x E1))
else
(fun E1 : (proj1_sig x <? proj1_sig k) = false =>
 ltN_of_nat (S (proj1_sig x)) (S n) (ltN_intro_lemma2 n k x E1))
Crunching: (update (update x 0 H) 0 Hxij' = update x 0 Hxij')
Crunching: (update (update x 0 H) 0 Hxij' = update x 0 Hxij')
Crunching: (perm_mat LE f = I LE)
rewrite if_dtt
if (proj1_sig x <? proj1_sig k)
then
(fun E1 : (proj1_sig x <? proj1_sig k) = true =>
 ltN_of_nat (proj1_sig x) (S n) (ltN_intro_lemma1 n k x E1))
else
(fun E1 : (proj1_sig x <? proj1_sig k) = false =>
 ltN_of_nat (S (proj1_sig x)) (S n) (ltN_intro_lemma2 n k x E1))
Crunching:
(-1 < 0 ->
 delta3 = cond3 -> Morphisms.respectful ?R2 Rle (pow delta3) (pow cond3))
rewrite if_dtt
if (proj1_sig H <? n1)
then
(fun E0 : (proj1_sig H <? n1) = true => AA (ltN_of_nat (proj1_sig H) n1 E0))
else
(fun E0 : (proj1_sig H <? n1) = false =>
 BB
   (ltN_of_nat (proj1_sig H - n1) n2
      (ltN_split_lemma1 (ltN_plus_lemma1 (proj2_sig H)) E0)))
rewrite if_dtt
if (proj1_sig x <? proj1_sig k)
then
(fun E1 : (proj1_sig x <? proj1_sig k) = true =>
 ltN_of_nat (proj1_sig x) (S n) (ltN_intro_lemma1 n k x E1))
else
(fun E1 : (proj1_sig x <? proj1_sig k) = false =>
 ltN_of_nat (S (proj1_sig x)) (S n) (ltN_intro_lemma2 n k x E1))
Crunching: (forall b b' : x, update (update k H1 b) H1 b' = update k H1 b')
rewrite if_dtt
if (proj1_sig x <? proj1_sig k)
then
(fun E1 : (proj1_sig x <? proj1_sig k) = true =>
 ltN_of_nat (proj1_sig x) (S n) (ltN_intro_lemma1 n k x E1))
else
(fun E1 : (proj1_sig x <? proj1_sig k) = false =>
 ltN_of_nat (S (proj1_sig x)) (S n) (ltN_intro_lemma2 n k x E1))
Crunching: (update (update x 0 H) 0 EQ = update x 0 EQ)
rewrite if_dtt
if (proj1_sig x <? proj1_sig k)
then
(fun E1 : (proj1_sig x <? proj1_sig k) = true =>
 ltN_of_nat (proj1_sig x) (S n) (ltN_intro_lemma1 n k x E1))
else
(fun E1 : (proj1_sig x <? proj1_sig k) = false =>
 ltN_of_nat (S (proj1_sig x)) (S n) (ltN_intro_lemma2 n k x E1))
rewrite if_dtt
if (proj1_sig x <? proj1_sig k)
then
(fun E1 : (proj1_sig x <? proj1_sig k) = true =>
 ltN_of_nat (proj1_sig x) (S n) (ltN_intro_lemma1 n k x E1))
else
(fun E1 : (proj1_sig x <? proj1_sig k) = false =>
 ltN_of_nat (S (proj1_sig x)) (S n) (ltN_intro_lemma2 n k x E1))
Crunching: (pad_u dim x H × pad_u dim y N1 = pad_u dim y N1 × pad_u dim x H)
Crunching: (pad_u dim x H × pad_u dim y N1 = pad_u dim y N1 × pad_u dim x H)
Crunching:
(forall a : list R,
 pr_outcome_sum (H6 :: a) b =
 (if b 0%nat
  then (H6 + pr_outcome_sum a (fun y : nat => b (S y)))%R
  else pr_outcome_sum a (fun y : nat => b (S y))))
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (update (update x l H) l Hab = update x l Hab)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (update (update x 0 H) 0 Hxij' = update x 0 Hxij')
rewrite if_dtt
if (proj1_sig x <? proj1_sig k)
then
(fun E1 : (proj1_sig x <? proj1_sig k) = true =>
 ltN_of_nat (proj1_sig x) (S n) (ltN_intro_lemma1 n k x E1))
else
(fun E1 : (proj1_sig x <? proj1_sig k) = false =>
 ltN_of_nat (S (proj1_sig x)) (S n) (ltN_intro_lemma2 n k x E1))
Crunching: (update (update x 0 H) 0 Hxij' = update x 0 Hxij')
Crunching:
((forall x0 : nat,
  x0 < x -> H1 x0 < x /\ e x0 < x /\ e (H1 x0) = x0 /\ H1 (e x0) = x0) ->
 permutation (2 ^ x) (qubit_perm_to_nat_perm x H1))
Crunching:
(forall (n : nat) (p : nat -> nat) (f : nat -> bool),
 permutation n p ->
 perm_to_matrix n p × f_to_vec n f = f_to_vec n (fun x : nat => f (p x)))
rewrite if_dtt
if (proj1_sig x <? proj1_sig k)
then
(fun E1 : (proj1_sig x <? proj1_sig k) = true =>
 ltN_of_nat (proj1_sig x) (S n) (ltN_intro_lemma1 n k x E1))
else
(fun E1 : (proj1_sig x <? proj1_sig k) = false =>
 ltN_of_nat (S (proj1_sig x)) (S n) (ltN_intro_lemma2 n k x E1))
rewrite if_dtt
if (proj1_sig x <? proj1_sig k)
then
(fun E1 : (proj1_sig x <? proj1_sig k) = true =>
 ltN_of_nat (proj1_sig x) (S n) (ltN_intro_lemma1 n k x E1))
else
(fun E1 : (proj1_sig x <? proj1_sig k) = false =>
 ltN_of_nat (S (proj1_sig x)) (S n) (ltN_intro_lemma2 n k x E1))
rewrite if_dtt
if (proj1_sig H <? n1)
then
(fun E0 : (proj1_sig H <? n1) = true => AA (ltN_of_nat (proj1_sig H) n1 E0))
else
(fun E0 : (proj1_sig H <? n1) = false =>
 BB
   (ltN_of_nat (proj1_sig H - n1) n2
      (ltN_split_lemma1 (ltN_plus_lemma1 (proj2_sig H)) E0)))
rewrite if_dtt
if (proj1_sig x <? proj1_sig k)
then
(fun E1 : (proj1_sig x <? proj1_sig k) = true =>
 ltN_of_nat (proj1_sig x) (S n) (ltN_intro_lemma1 n k x E1))
else
(fun E1 : (proj1_sig x <? proj1_sig k) = false =>
 ltN_of_nat (S (proj1_sig x)) (S n) (ltN_intro_lemma2 n k x E1))
Crunching: (perm_to_matrix 0 p = I 1)
Crunching:
(forall (n : nat) (p : nat -> nat) (f : nat -> bool),
 permutation n p ->
 perm_to_matrix n p × f_to_vec n f = f_to_vec n (fun x : nat => f (p x)))
Crunching: (forall b b' : x, update (update k H1 b) H1 b' = update k H1 b')
rewrite if_dtt
if (proj1_sig H <? n1)
then
(fun E0 : (proj1_sig H <? n1) = true => AA (ltN_of_nat (proj1_sig H) n1 E0))
else
(fun E0 : (proj1_sig H <? n1) = false =>
 BB
   (ltN_of_nat (proj1_sig H - n1) n2
      (ltN_split_lemma1 (ltN_plus_lemma1 (proj2_sig H)) E0)))
rewrite if_dtt
if (proj1_sig x <? proj1_sig k)
then
(fun E1 : (proj1_sig x <? proj1_sig k) = true =>
 ltN_of_nat (proj1_sig x) (S n) (ltN_intro_lemma1 n k x E1))
else
(fun E1 : (proj1_sig x <? proj1_sig k) = false =>
 ltN_of_nat (S (proj1_sig x)) (S n) (ltN_intro_lemma2 n k x E1))
Crunching: (update x 0 b' = update (update x 0 H) 0 b')
Crunching: (update (update x 0 H) 0 EQ = update x 0 EQ)
simplified dependent [if true]
e : (x <? n1)  = true
if (x <? n1)
then (fun E0 : (x <? n1) = true => AA (ltN_of_nat x n1 E0))
else
(fun E0 : (x <? n1) = false =>
 BB (ltN_of_nat (x - n1) n2 (ltN_split_lemma1 (ltN_plus_lemma1 e) E0)))
Crunching:
(pr_outcome_sum n Hn =
 (pr_outcome_sum [] Hn + pr_outcome_sum n (fun x : nat => Hn x))%R)
Crunching:
(forall (l2 : list R) (f : nat -> bool),
 pr_outcome_sum (r :: r0 ++ l2) f =
 (pr_outcome_sum (r :: r0) f +
  pr_outcome_sum l2 (fun x : nat => f (S (length r0 + x))))%R)
rewrite if_dtt
if (proj1_sig x <? proj1_sig k)
then
(fun E1 : (proj1_sig x <? proj1_sig k) = true =>
 ltN_of_nat (proj1_sig x) (S n) (ltN_intro_lemma1 n k x E1))
else
(fun E1 : (proj1_sig x <? proj1_sig k) = false =>
 ltN_of_nat (S (proj1_sig x)) (S n) (ltN_intro_lemma2 n k x E1))
Crunching:
(forall (l2 : list R) (f : nat -> bool),
 pr_outcome_sum (r :: r0 ++ l2) f =
 (pr_outcome_sum (r :: r0) f +
  pr_outcome_sum l2 (fun x : nat => f (S (length r0 + x))))%R)
rewrite if_dtt
if (proj1_sig x <? proj1_sig k)
then
(fun E1 : (proj1_sig x <? proj1_sig k) = true =>
 ltN_of_nat (proj1_sig x) (S n) (ltN_intro_lemma1 n k x E1))
else
(fun E1 : (proj1_sig x <? proj1_sig k) = false =>
 ltN_of_nat (S (proj1_sig x)) (S n) (ltN_intro_lemma2 n k x E1))
rewrite if_dtt
if (proj1_sig x <? proj1_sig k)
then
(fun E1 : (proj1_sig x <? proj1_sig k) = true =>
 ltN_of_nat (proj1_sig x) (S n) (ltN_intro_lemma1 n k x E1))
else
(fun E1 : (proj1_sig x <? proj1_sig k) = false =>
 ltN_of_nat (S (proj1_sig x)) (S n) (ltN_intro_lemma2 n k x E1))
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
Crunching: (pad_u 0 0 YZ × pad_u 0 XY B = pad_u 0 XY B × pad_u 0 0 YZ)
Crunching: (pad_u 0 H4 q × pad_u 0 p B = pad_u 0 p B × pad_u 0 H4 q)
Crunching: (pad_u 0 p B × pad_u 0 H4 q = pad_u 0 H4 q × pad_u 0 p B)
rewrite if_dtt
if (proj1_sig x <? proj1_sig k)
then
(fun E1 : (proj1_sig x <? proj1_sig k) = true =>
 ltN_of_nat (proj1_sig x) (S n) (ltN_intro_lemma1 n k x E1))
else
(fun E1 : (proj1_sig x <? proj1_sig k) = false =>
 ltN_of_nat (S (proj1_sig x)) (S n) (ltN_intro_lemma2 n k x E1))
rewrite if_dtt
if (proj1_sig x <? proj1_sig k)
then
(fun E1 : (proj1_sig x <? proj1_sig k) = true =>
 ltN_of_nat (proj1_sig x) (S n) (ltN_intro_lemma1 n k x E1))
else
(fun E1 : (proj1_sig x <? proj1_sig k) = false =>
 ltN_of_nat (S (proj1_sig x)) (S n) (ltN_intro_lemma2 n k x E1))
rewrite if_dtt
if (proj1_sig x <? proj1_sig k)
then
(fun E1 : (proj1_sig x <? proj1_sig k) = true =>
 ltN_of_nat (proj1_sig x) (S n) (ltN_intro_lemma1 n k x E1))
else
(fun E1 : (proj1_sig x <? proj1_sig k) = false =>
 ltN_of_nat (S (proj1_sig x)) (S n) (ltN_intro_lemma2 n k x E1))
rewrite if_dtt
if (proj1_sig x <? proj1_sig k)
then
(fun E1 : (proj1_sig x <? proj1_sig k) = true =>
 ltN_of_nat (proj1_sig x) (S n) (ltN_intro_lemma1 n k x E1))
else
(fun E1 : (proj1_sig x <? proj1_sig k) = false =>
 ltN_of_nat (S (proj1_sig x)) (S n) (ltN_intro_lemma2 n k x E1))
rewrite if_dtt
if (proj1_sig x <? proj1_sig k)
then
(fun E1 : (proj1_sig x <? proj1_sig k) = true =>
 ltN_of_nat (proj1_sig x) (S n) (ltN_intro_lemma1 n k x E1))
else
(fun E1 : (proj1_sig x <? proj1_sig k) = false =>
 ltN_of_nat (S (proj1_sig x)) (S n) (ltN_intro_lemma2 n k x E1))
rewrite if_dtt
if (proj1_sig x <? proj1_sig k)
then
(fun E1 : (proj1_sig x <? proj1_sig k) = true =>
 ltN_of_nat (proj1_sig x) (S n) (ltN_intro_lemma1 n k x E1))
else
(fun E1 : (proj1_sig x <? proj1_sig k) = false =>
 ltN_of_nat (S (proj1_sig x)) (S n) (ltN_intro_lemma2 n k x E1))
Crunching:
(forall (l1 l2 : list R) (f : nat -> bool),
 pr_outcome_sum (l1 ++ l2) f =
 (pr_outcome_sum l1 f +
  pr_outcome_sum l2 (fun x : nat => f (length l1 + x)%nat))%R)
Crunching:
(pr_outcome_sum n Hn =
 (pr_outcome_sum [] Hn + pr_outcome_sum n (fun x : nat => Hn x))%R)
Crunching: (update (update x l H) l Hab = update x l Hab)
Crunching:
(pr_outcome_sum n Hn =
 (pr_outcome_sum [] Hn + pr_outcome_sum n (fun x : nat => Hn x))%R)
Crunching: (update (update x 0 H) 0 Hxij' = update x 0 Hxij')
Crunching: (update (update x 0 H) 0 Hxij' = update x 0 Hxij')
Crunching: (update (update x l H) l Hxij' = update x l Hxij')
Crunching: (update (update H EQ m) EQ P = update H EQ P)
fun S : UU0 =>
uniform_sigma_lifting (M:=[the monad of StateMonad.acto S]) 
  ?op ?t (State.naturality S)
     : forall S : UU0,
       imonad_transformer.lifting_monadT
         (M:=[the monad of StateMonad.acto S]) ?op
         (t:=imonad_transformer.FMT.Exports.imonad_transformer_FMT__to__imonad_transformer_MonadT
               ?t)
         (slifting (M:=[the monad of StateMonad.acto S]) 
            ?op ?t (State.naturality S))
where
?E : [S : UU0 |- functor]
?op : [S : UU0 |- ?E .-operation [the monad of StateMonad.acto S]]
?t : [S : UU0 |- imonad_transformer.FMT.type]
rewrite if_dtt
if (proj1_sig x <? proj1_sig k)
then
(fun E1 : (proj1_sig x <? proj1_sig k) = true =>
 ltN_of_nat (proj1_sig x) (S n) (ltN_intro_lemma1 n k x E1))
else
(fun E1 : (proj1_sig x <? proj1_sig k) = false =>
 ltN_of_nat (S (proj1_sig x)) (S n) (ltN_intro_lemma2 n k x E1))
Crunching: (update (update H EQ N) EQ HN = update H EQ HN)
rewrite if_dtt
if (proj1_sig (exist (fun k : nat => (k <? n) = true) 0 low) <? proj1_sig k)
then
(fun
   E : (proj1_sig (exist (fun k : nat => (k <? n) = true) 0 low) <?
        proj1_sig k) = true =>
 BB (exist (fun k : nat => (k <? n) = true) 0 low) =
 ltN_pop k
   (exist (fun k : nat => (k <? S n) = true)
      (proj1_sig (exist (fun k : nat => (k <? n) = true) 0 low))
      (ltN_intro_lemma1 n k (exist (fun k : nat => (k <? n) = true) 0 low) E)))
else
(fun
   E : (proj1_sig (exist (fun k : nat => (k <? n) = true) 0 low) <?
        proj1_sig k) = false =>
 BB (exist (fun k : nat => (k <? n) = true) 0 low) =
 ltN_pop k
   (exist (fun k : nat => (k <? S n) = true)
      (S (proj1_sig (exist (fun k : nat => (k <? n) = true) 0 low)))
      (ltN_intro_lemma2 n k (exist (fun k : nat => (k <? n) = true) 0 low) E)))
Crunching: (update (update m H1 a0) H2 a = update (update m H2 a) H1 a0)
Crunching:
(forall (f : nat -> H0) (i j : nat) (b b' : H0),
 i <> j -> update (update f i b) j b' = update (update f j b') i b)
Crunching:
(update (update r n Hle) Hrge1 Ha = update (update r Hrge1 Ha) n Hle)
Crunching: (update (update m H1 a0) H2 a = update (update m H2 a) H1 a0)
Crunching: (update (update m H1 a0) H2 a = update (update m H2 a) H1 a0)
Crunching: (update (update m H1 a0) H2 a = update (update m H2 a) H1 a0)
Crunching:
(forall (f : nat -> H0) (i j : nat) (b b' : H0),
 i <> j -> update (update f i b) j b' = update (update f j b') i b)
Crunching: False
Crunching:
(update (update r Hrge1 Ha) n Hle = update (update r n Hle) Hrge1 Ha)
Crunching:
(update (update r n Hle) Hrge1 Ha = update (update r Hrge1 Ha) n Hle)
Crunching: (update (update m H1 a0) H2 a = update (update m H2 a) H1 a0)
Crunching: (update (update m H1 a0) H2 a = update (update m H2 a) H1 a0)
Crunching: (perm_to_matrix 0 p = I 1)
Crunching: (update (update m H1 a0) H2 a = update (update m H2 a) H1 a0)
Crunching: Z
Crunching: ((-1 < - 0)%R -> shift f 0 = f)
Crunching: (perm_to_matrix 0 p = I 1)
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 (ltN_count (stail p)) (ltN_pred_lemma0 k k0 E)))
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 (ltN_count (stail p)) (ltN_pred_lemma0 k k0 E)))
Crunching: ((-1 < - 0)%R -> shift f 0 = f)
Crunching: ((-1 < - 0)%R -> shift f 0 = f)
Crunching:
(WF_Matrix (perm_to_matrix a n) /\
 (perm_to_matrix a n) † × perm_to_matrix a n = I (2 ^ a))
Crunching: ((-1 < - 0)%R -> shift f 0 = f)
Crunching:
(WF_Matrix (perm_to_matrix a n) /\
 (perm_to_matrix a n) † × perm_to_matrix a n = I (2 ^ a))
clear  H3  :  (False -> H2 = if0)
clear  H0  :  (False -> H2 = if1)
Crunching: ((-1 < - 0)%R -> shift f 0 = f)
Crunching:
(WF_Matrix (perm_to_matrix a n) /\
 (perm_to_matrix a n) † × perm_to_matrix a n = I (2 ^ a))
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
Crunching:
(big_sum (fun i : nat => if c i then nth i (lm :: rP) 0 else 0)
   (length (lm :: rP)) =
 ((if c 0%nat then lm else 0) +
  big_sum (fun i : nat => if c (S i) then nth i rP 0 else 0) (length rP))%R)
Crunching: (n' >= 2 ^ a \/ EQ >= 2 ^ a -> perm_to_matrix a n n' EQ = 0%R)
Crunching: ((-1 < - 0)%R -> shift f 0 = f)
Crunching:
(pr_outcome_sum (a :: l) f =
 ((if f 0%nat then a else 0) + pr_outcome_sum l (fun i : nat => f (S i)))%R)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (Z.abs_N (Z.pos Heq ÷ Z.pos Hy) = (N.pos Heq / N.pos Hy)%N)
Crunching: ((-1 < - 0)%R -> shift f 0 = f)
Crunching:
(big_sum (fun i : nat => if c i then nth i (lm :: rP) 0 else 0)
   (length (lm :: rP)) =
 ((if c 0%nat then lm else 0) +
  big_sum (fun i : nat => if c (S i) then nth i rP 0 else 0) (length rP))%R)
     = (exist (fun k : nat => (k <? 6) = true) 0 eq_refl,
       (exist (fun k : nat => (k <? 5) = true) 0 eq_refl,
       (exist (fun k : nat => (k <? 4) = true) 0 eq_refl,
       (exist (fun k : nat => (k <? 3) = true) 0 eq_refl,
       (exist (fun k : nat => (k <? 2) = true) 0 eq_refl,
       (exist (fun k : nat => (k <? 1) = true) 0 eq_refl, tt))))))
     : decr_list (fun n : nat => ltN (S n)) 6
Crunching: ((-1 < - 0)%R -> f = shift f 0)
Crunching:
((forall x : nat, x < a -> n x < a /\ r x < a /\ r (n x) = x /\ n (r x) = x) ->
 forall q : positive, Z.abs_N (Z.pos Heq ÷ Z.pos q) = (N.pos Heq / N.pos q)%N)
Crunching: (forall x y : R, Rabs x < Rabs y -> y > 0 -> x < y)
Crunching: (perm_to_matrix a n M H0 = 0%R)
Crunching:
(WF_Matrix (perm_to_matrix a n) /\
 (perm_to_matrix a n) † × perm_to_matrix a n = I (2 ^ a))
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
Crunching:
(pr_outcome_sum (a :: l) f =
 ((if f 0%nat then a else 0) + pr_outcome_sum l (fun i : nat => f (S i)))%R)
Crunching: ((-1 < - 0)%R -> shift f 0 = f)
Crunching: (Un_cv PI_2_3_7_tg 0)
Crunching:
(WF_Matrix (perm_to_matrix a n) /\
 (perm_to_matrix a n) † × perm_to_matrix a n = I (2 ^ a))
Crunching: ((-1 < - 0)%R -> shift f 0 = f)
Crunching: (perm_to_matrix a n M H0 = 0%R)
rewrite if_dtt
if (n =? S r)
then
(fun E : (n =? S r) = true =>
 ltN_of_nat 0 n
   (ltN_S_mod_lemma1 (exist (fun k : nat => (k <? n) = true) r Hr) E))
else
(fun E : (n =? S r) = false =>
 ltN_of_nat (S r) n
   (ltN_S_mod_lemma2 (exist (fun k : nat => (k <? n) = true) r Hr) E))
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
Crunching:
(forall (f : nat -> bool) (a0 : R),
 pr_outcome_sum (a0 :: a :: l) f =
 ((if f 0%nat then a0 else 0) +
  pr_outcome_sum (a :: l) (fun i : nat => f (S i)))%R)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
clear  H3  :  (False -> H2 = if0)
clear  H0  :  (False -> H2 = if1)
Crunching: False
Crunching: False
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
Crunching: (shift y j = y)
Crunching: (shift y j = y)
Crunching: (shift y j = y)
Crunching: (shift y j = y)
Crunching:
((qubit_perm_to_nat_perm n f ∘ qubit_perm_to_nat_perm n g)%prg =
 qubit_perm_to_nat_perm n (g ∘ f)%prg)
Crunching:
(big_sum (fun i : nat => if n i then nth i [a] 0 else 0) (length [a]) =
 (a + big_sum (fun i : nat => if n (S i) then nth i [] 0 else 0) (length []))%R)
Crunching:
((a + big_sum (fun i : nat => if n (S i) then nth i [] 0 else 0) (length []))%R =
 big_sum (fun i : nat => if n i then nth i [a] 0 else 0) (length [a]))
Crunching:
(big_sum (fun i : nat => if n i then nth i [a] 0 else 0) (length [a]) =
 (a + big_sum (fun i : nat => if n (S i) then nth i [] 0 else 0) (length []))%R)
Crunching:
((a + big_sum (fun i : nat => if n (S i) then nth i [] 0 else 0) (length []))%R =
 big_sum (fun i : nat => if n i then nth i [a] 0 else 0) (length [a]))
Crunching:
(big_sum (fun i : nat => if n i then nth i [a] 0 else 0) (length [a]) =
 (a + big_sum (fun i : nat => if n (S i) then nth i [] 0 else 0) (length []))%R)
Crunching:
((a + big_sum (fun i : nat => if n (S i) then nth i [] 0 else 0) (length []))%R =
 big_sum (fun i : nat => if n i then nth i [a] 0 else 0) (length [a]))
Crunching:
(big_sum (fun i : nat => if n i then nth i [a] 0 else 0) (length [a]) =
 (a + big_sum (fun i : nat => if n (S i) then nth i [] 0 else 0) (length []))%R)
Crunching:
(forall x y lb ub : nat,
 lb <= x <= ub /\ lb <= y <= ub -> lb <= (x + y) / 2 <= ub)
Crunching: False
Crunching:
(forall f g : nat -> nat,
 permutation z f ->
 (qubit_perm_to_nat_perm z f ∘ qubit_perm_to_nat_perm z g)%prg =
 qubit_perm_to_nat_perm z (g ∘ f)%prg)
Crunching: (shift y j = y)
Crunching: (shift y j = y)
Crunching: (shift y j = y)
Crunching: (shift y j = y)
Crunching: (shift y j = y)
Crunching: (shift y j = y)
Crunching: (shift y j = y)
Crunching: (shift y j = y)
Crunching: (shift y j = y)
Crunching: (shift y j = y)
Crunching: (shift y j = y)
Crunching: (shift y j = y)
Crunching:
(big_sum (fun i : nat => if c i then nth i (lm :: rP) 0 else 0)
   (length (lm :: rP)) =
 ((if c 0%nat then lm else 0) +
  big_sum (fun i : nat => if c (S i) then nth i rP 0 else 0) (length rP))%R)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.011 secs (0.01u,0.s) (failure)
Tactic call ran for 0.006 secs (0.006u,0.s) (success)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching:
(0 < 1 ->
 (forall x0 : nat, (x0 < length x)%nat -> y x0 = f2 x0) ->
 pr_outcome_sum x y = pr_outcome_sum x f2)
out of reach
Tactic call ran for 0.001 secs (0.u,0.s) (failure)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.001u,0.001s) (failure)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
Crunching:
((if b <? H5
  then
   if b + (1 + (H5 - b - 1) + 1) <=? a
   then
    I (2 ^ b)
    ⊗ (∣1⟩⟨1∣ ⊗ I (2 ^ (H5 - b - 1)) ⊗ A
       .+ ∣0⟩⟨0∣ ⊗ I (2 ^ (H5 - b - 1)) ⊗ I 2)
    ⊗ I (2 ^ (a - (b + (1 + (H5 - b - 1) + 1))))
   else Zero
  else
   if H5 <? b
   then
    if H5 + (1 + (b - H5 - 1) + 1) <=? a
    then
     I (2 ^ H5)
     ⊗ (A ⊗ I (2 ^ (b - H5 - 1)) ⊗ ∣1⟩⟨1∣
        .+ I 2 ⊗ I (2 ^ (b - H5 - 1)) ⊗ ∣0⟩⟨0∣)
     ⊗ I (2 ^ (a - (H5 + (1 + (b - H5 - 1) + 1))))
    else Zero
   else Zero)
 × (if o <? p
    then
     if o + (1 + (p - o - 1) + 1) <=? a
     then
      I (2 ^ o)
      ⊗ (∣1⟩⟨1∣ ⊗ I (2 ^ (p - o - 1)) ⊗ B
         .+ ∣0⟩⟨0∣ ⊗ I (2 ^ (p - o - 1)) ⊗ I 2)
      ⊗ I (2 ^ (a - (o + (1 + (p - o - 1) + 1))))
     else Zero
    else
     if p <? o
     then
      if p + (1 + (o - p - 1) + 1) <=? a
      then
       I (2 ^ p)
       ⊗ (B ⊗ I (2 ^ (o - p - 1)) ⊗ ∣1⟩⟨1∣
          .+ I 2 ⊗ I (2 ^ (o - p - 1)) ⊗ ∣0⟩⟨0∣)
       ⊗ I (2 ^ (a - (p + (1 + (o - p - 1) + 1))))
      else Zero
     else Zero) =
 (if o <? p
  then
   if o + (1 + (p - o - 1) + 1) <=? a
   then
    I (2 ^ o)
    ⊗ (∣1⟩⟨1∣ ⊗ I (2 ^ (p - o - 1)) ⊗ B .+ ∣0⟩⟨0∣ ⊗ I (2 ^ (p - o - 1)) ⊗ I 2)
    ⊗ I (2 ^ (a - (o + (1 + (p - o - 1) + 1))))
   else Zero
  else
   if p <? o
   then
    if p + (1 + (o - p - 1) + 1) <=? a
    then
     I (2 ^ p)
     ⊗ (B ⊗ I (2 ^ (o - p - 1)) ⊗ ∣1⟩⟨1∣
        .+ I 2 ⊗ I (2 ^ (o - p - 1)) ⊗ ∣0⟩⟨0∣)
     ⊗ I (2 ^ (a - (p + (1 + (o - p - 1) + 1))))
    else Zero
   else Zero)
 × (if b <? H5
    then
     if b + (1 + (H5 - b - 1) + 1) <=? a
     then
      I (2 ^ b)
      ⊗ (∣1⟩⟨1∣ ⊗ I (2 ^ (H5 - b - 1)) ⊗ A
         .+ ∣0⟩⟨0∣ ⊗ I (2 ^ (H5 - b - 1)) ⊗ I 2)
      ⊗ I (2 ^ (a - (b + (1 + (H5 - b - 1) + 1))))
     else Zero
    else
     if H5 <? b
     then
      if H5 + (1 + (b - H5 - 1) + 1) <=? a
      then
       I (2 ^ H5)
       ⊗ (A ⊗ I (2 ^ (b - H5 - 1)) ⊗ ∣1⟩⟨1∣
          .+ I 2 ⊗ I (2 ^ (b - H5 - 1)) ⊗ ∣0⟩⟨0∣)
       ⊗ I (2 ^ (a - (H5 + (1 + (b - H5 - 1) + 1))))
      else Zero
     else Zero))
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
Crunching:
(forall ub : nat, H2 <= m <= ub /\ H2 <= H1 <= ub -> H2 <= (m + H1) / 2 <= ub)
Crunching:
(forall x y lb ub : nat,
 lb <= x <= ub /\ lb <= y <= ub -> lb <= (x + y) / 2 <= ub)
Crunching:
(forall f2 : nat -> bool,
 (forall x : nat, (x < length s')%nat -> Rec x = f2 x) ->
 pr_outcome_sum s' Rec = pr_outcome_sum s' f2)
Crunching: False
out of reach
Tactic call ran for 0.001 secs (0.u,0.s) (failure)
Crunching:
((qubit_perm_to_nat_perm n f ∘ qubit_perm_to_nat_perm n g)%prg =
 qubit_perm_to_nat_perm n (g ∘ f)%prg)
Crunching:
((qubit_perm_to_nat_perm H e1 ∘ qubit_perm_to_nat_perm H e2)%prg =
 qubit_perm_to_nat_perm H (e2 ∘ e1)%prg)
Crunching:
(permutation f H ->
 perm_to_matrix f g × perm_to_matrix f H = perm_to_matrix f (H ∘ g)%prg)
Crunching:
(0 < 1 ->
 (forall x0 : nat, (x0 < length x)%nat -> y x0 = f2 x0) ->
 pr_outcome_sum x y = pr_outcome_sum x f2)
Crunching:
(permutation a s1 ->
 perm_to_matrix a H × perm_to_matrix a s1 = perm_to_matrix a (s1 ∘ H)%prg)
Crunching: (pr_outcome_sum m n = pr_outcome_sum m d)
Crunching: (pr_outcome_sum x l = 0)
Crunching: (forall r : R, r <= 0 -> 0 <= r -> r = 0)
Crunching:
(pad_ctrl 0 b 0 A × pad_ctrl 0 o p B = pad_ctrl 0 o p B × pad_ctrl 0 b 0 A)
Crunching: (pr_outcome_sum x l = 0)
Crunching: (GT < R0 \/ GT = R0 -> R0 < GT \/ R0 = GT -> GT = R0)
Crunching: (forall r : R, r <= 0 -> 0 <= r -> r = 0)
Crunching: (forall x y : nat, fswap H x y x = H y)
Crunching: (pr_outcome_sum x l = 0)
Crunching: (forall y : nat, fswap H f y f = H y)
Crunching: (fswap n m H m = n H)
Crunching: (GT = fst (- 0)%R)
Crunching:
(permutation f H ->
 perm_to_matrix f g × perm_to_matrix f H = perm_to_matrix f (H ∘ g)%prg)
Crunching: (fswap H H11 y H11 = H y)
Crunching: (x = 1)
Crunching: (forall z : R, z < Rmin h H' <-> z < h /\ z < H')
Crunching: (fswap t z H z = t H)
Crunching: (Hr < Rmin Hb H3 <-> Hr < Hb /\ Hr < H3)
Crunching: (Hr < Rmin Hb H3 <-> Hr < Hb /\ Hr < H3)
Crunching: ((fun _ : C => z < Hb /\ z < H1) (x - z))
Crunching: (forall x y : nat, fswap H x y x = H y)
Crunching: (forall (f : nat -> m) (x y : nat), fswap f x y x = f y)
Crunching: (z < Hb /\ z < H1)
Crunching:
(perm_to_matrix a H × perm_to_matrix a s1 = perm_to_matrix a (s1 ∘ H)%prg)
Crunching:
(permutation a s1 ->
 perm_to_matrix a H × perm_to_matrix a s1 = perm_to_matrix a (s1 ∘ H)%prg)
Crunching: (x = 1)
Crunching: (forall z : R, z < Rmin h H' <-> z < h /\ z < H')
Crunching: (Hr < Rmin Hb H3 <-> Hr < Hb /\ Hr < H3)
Crunching: (Hr < Rmin Hb H3 <-> Hr < Hb /\ Hr < H3)
rewrite if_dtt
if (n =? proj1_sig r)
then
(fun E : (n =? proj1_sig r) = true =>
 ltN_of_nat 0 (S n) (ltN_S_mod_lemma1 r E))
else
(fun E : (n =? proj1_sig r) = false =>
 ltN_of_nat (S (proj1_sig r)) (S n) (ltN_S_mod_lemma2 r E))
Crunching: ((fun _ : C => z < Hb /\ z < H1) (x - z))
Crunching:
(perm_to_matrix 0 A (S (S (S (S (S (S (S (S x))))))))
   (S (S (S (S (S (S (S (S y)))))))) =
 (if
   (S (S (S (S (S (S (S (S x))))))) =? S (S (S (S (S (S (S (S y)))))))) &&
   (S (S (S (S (S (S (S (S x))))))) <? 2 ^ 0)
  then C1
  else 0%R))
Crunching:
(perm_to_matrix a Ha =
 (fun x y : nat => if (x =? y) && (x <? 2 ^ a) then C1 else 0%R))
Crunching:
(perm_to_matrix a Ha =
 (fun x y : nat => if (x =? y) && (x <? 2 ^ a) then C1 else 0%R))
Crunching:
(perm_to_matrix a Ha =
 (fun x y : nat => if (x =? y) && (x <? 2 ^ a) then C1 else 0%R))
Crunching:
((forall x : nat, x < a -> Ha x = x) -> perm_to_matrix a Ha = I (2 ^ a))
Crunching: (z < Hb /\ z < H1)
Crunching:
(perm_to_matrix a Ha =
 (fun x y : nat => if (x =? y) && (x <? 2 ^ a) then C1 else 0%R))
Crunching:
(perm_to_matrix a Ha =
 (fun x y : nat => if (x =? y) && (x <? 2 ^ a) then C1 else 0%R))
Crunching: (fswap H x y y = H x)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
Crunching:
(forall f : nat -> bool,
 (forall i : nat, (i < length (m :: x))%nat -> f i = false) ->
 pr_outcome_sum (m :: x) f = 0)
Tactic call ran for 0.004 secs (0.004u,0.s) (success)
Crunching: (pr_outcome_sum x l = 0)
Crunching: (fswap H 0 H7 H7 = H 0)
Crunching: (forall r : R, r <= 0 -> 0 <= r -> r = 0)
out of reach
Tactic call ran for 0.004 secs (0.u,0.003s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.004 secs (0.002u,0.002s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching: (perm_to_matrix (S n) Hnm = I (2 ^ n + (2 ^ n + 0)))
Crunching: (b * a + a * b <= a * a + b * b)
Crunching: Z
Crunching: ((pr_outcome_sum y abs - 1)%R = 0)
Crunching:
(perm_to_matrix n H x y = (if true && (x <? 2 ^ n) then C1 else (- 0)%R))
Crunching: (b * a + a * b <= a * a + b * b)
Crunching: Z
Crunching: (perm_to_matrix n H x y = Cmod (I (2 ^ n) x y))
Crunching:
(perm_to_matrix n H x y = (if true && (x <? 2 ^ n) then C1 else (- 0)%R))
Crunching: (perm_to_matrix n H x y = Cmod (I (2 ^ n) x y))
Crunching: (pr_outcome_sum y f = sum_over_list y)
Crunching:
(perm_to_matrix n H x y = (if true && (x <? 2 ^ n) then C1 else (- 0)%R))
Crunching:
(forall x : R,
 sin_in 0² x ->
 (forall i : nat, (i < length y)%nat -> y0 i = true) ->
 pr_outcome_sum y y0 = sum_over_list y)
Crunching: ((pr_outcome_sum y abs - 1)%R = 0)
Crunching: (perm_to_matrix z xy yz h = 0%R)
Crunching: (fswap y_encad2 x x = y_encad2)
Crunching: (fswap y_encad2 x x = y_encad2)
Crunching: (pr_outcome_sum m del = sum_over_list m)
Crunching: (perm_to_matrix b f x y = 0%R)
Crunching: (perm_to_matrix b f x y = 0%R)
Crunching: (perm_to_matrix z p H'2 y = 0%R)
Crunching: (fswap y_encad2 x x = y_encad2)
Crunching: (perm_to_matrix z y0 r1 r2 = 0%R)
Crunching: (perm_to_matrix z y0 r1 r2 = 0%R)
Crunching: (fswap y_encad2 x x = y_encad2)
Crunching: (fswap y_encad2 x x = y_encad2)
Crunching: (fswap y_encad2 x x = y_encad2)
Crunching: (perm_to_matrix z xy yz h = 0%R)
Crunching: (fswap y_encad2 x x = y_encad2)
Crunching:
(forall y : nat, yz >= 2 ^ z \/ y >= 2 ^ z -> perm_to_matrix z xy yz y = 0%R)
Crunching: (fswap y_encad2 x x = y_encad2)
Crunching: (fswap y_encad2 x x = y_encad2)
Crunching: (fswap y_encad2 x x = y_encad2)
Crunching: (fswap y_encad2 x x = y_encad2)
Crunching: (fswap y_encad2 x x = y_encad2)
Crunching: (fswap y_encad2 x x = y_encad2)
Crunching: (∣1⟩ = basis_vector 2 1)
rewrite if_dtt
if
match (let (a, _) := k2 in a) with
| 0 => false
| S m' =>
    (fix leb (n m : nat) {struct n} : bool :=
       match n with
       | 0 => true
       | S n' => match m with
                 | 0 => false
                 | S m'0 => leb n' m'0
                 end
       end) (let (a, _) := n in a) m'
end
then
(fun
   E : match (let (a, _) := k2 in a) with
       | 0 => false
       | S m' =>
           (fix leb (n m : nat) {struct n} : bool :=
              match n with
              | 0 => true
              | S n' => match m with
                        | 0 => false
                        | S m'0 => leb n' m'0
                        end
              end) (let (a, _) := n in a) m'
       end = true =>
 exist
   (fun k : nat =>
    match H1 with
    | 0 => false
    | S m' =>
        (fix leb (n m : nat) {struct n} : bool :=
           match n with
           | 0 => true
           | S n' => match m with
                     | 0 => false
                     | S m'0 => leb n' m'0
                     end
           end) k m'
    end = true)
   match (let (a, _) := k2 in a) with
   | 0 => let (a, _) := k2 in a
   | S u => u
   end (ltN_comm_intro_lemma1 n k2 E))
else
(fun
   E : match (let (a, _) := k2 in a) with
       | 0 => false
       | S m' =>
           (fix leb (n m : nat) {struct n} : bool :=
              match n with
              | 0 => true
              | S n' => match m with
                        | 0 => false
                        | S m'0 => leb n' m'0
                        end
              end) (let (a, _) := n in a) m'
       end = false =>
 exist
   (fun k : nat =>
    match H1 with
    | 0 => false
    | S m' =>
        (fix leb (n m : nat) {struct n} : bool :=
           match n with
           | 0 => true
           | S n' => match m with
                     | 0 => false
                     | S m'0 => leb n' m'0
                     end
           end) k m'
    end = true) (let (a, _) := k2 in a) (ltN_comm_intro_lemma2 n k2 E))
Crunching: Z
Crunching: (perm_to_matrix z Hfalse x H = 0%R)
Crunching: (fswap f x x x0 = f x0)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Tactic call ran for 0.004 secs (0.004u,0.s) (success)
Crunching: Z
Crunching: (perm_to_matrix b f q p = 0%R)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching: (perm_to_matrix b f x y = 0%R)
Crunching: (perm_to_matrix b f x y = 0%R)
Crunching: (perm_to_matrix b f x y = 0%R)
Crunching: (perm_to_matrix b f x y = 0%R)
Crunching: (perm_to_matrix b f x y = 0%R)
Crunching: (perm_to_matrix b f x y = 0%R)
Crunching: (perm_to_matrix b f x y = 0%R)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching: (fswap y_encad2 x x = y_encad2)
Crunching: Z
Crunching: (fswap y_encad2 x x = y_encad2)
Crunching: (fswap y_encad2 x x = y_encad2)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (fswap y_encad2 x x = y_encad2)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching: (fswap y_encad2 x x = y_encad2)
Crunching: (fswap y_encad2 x x = y_encad2)
Crunching: (fswap y_encad2 x x = y_encad2)
Crunching: (fswap y_encad2 x x = y_encad2)
test : forall a b : word, foo a b = foo b a

test is not universe polymorphic
Arguments test a b
test is opaque
Expands to: Constant bedrock2Examples.LiveVerif.swap.LiveVerif.test
Crunching: (fswap y_encad2 x x = y_encad2)
rewrite if_dtt
if (n =? S q)
then
(fun E : (n =? S q) = true =>
 ltN_of_nat 0 n
   (ltN_S_mod_lemma1 (exist (fun k : nat => (k <? n) = true) q r) E))
else
(fun E : (n =? S q) = false =>
 ltN_of_nat (S q) n
   (ltN_S_mod_lemma2 (exist (fun k : nat => (k <? n) = true) q r) E))
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
rewrite if_dtt
if (n =? S q)
then
(fun E : (n =? S q) = true =>
 ltN_of_nat 0 n
   (ltN_S_mod_lemma1 (exist (fun k : nat => (k <? n) = true) q r) E))
else
(fun E : (n =? S q) = false =>
 ltN_of_nat (S q) n
   (ltN_S_mod_lemma2 (exist (fun k : nat => (k <? n) = true) q r) E))
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching: (fswap y_encad2 x x = y_encad2)
Crunching: (perm_to_matrix 0 x f y = 0%R)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
test :
forall {word : word 32}, word.ok word -> forall a b : word, foo a b = foo b a

test is not universe polymorphic
Arguments test {word word_ok} a b
test is opaque
Expands to: Constant bedrock2Examples.LiveVerif.swap.test
Crunching: (perm_to_matrix z p H'2 y = 0%R)
Crunching: (0%R = perm_to_matrix z p H'2 y)
Crunching: (perm_to_matrix z p H'2 y = 0%R)
Crunching: (0%R = perm_to_matrix z p H'2 y)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching: (perm_to_matrix z p H'2 y = 0%R)
out of reach
Tactic call ran for 0.002 secs (0.001u,0.s) (failure)
Crunching: (perm_to_matrix z p H'2 y = 0%R)
Crunching: (perm_to_matrix z p H'2 y = 0%R)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching: (fswap y_encad2 x x = y_encad2)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
rewrite if_dtt
if (n =? S (proj1_sig k))
then
(fun E : (n =? S (proj1_sig k)) = true =>
 ltN_of_nat 0 n (ltN_S_mod_lemma1 k E))
else
(fun E : (n =? S (proj1_sig k)) = false =>
 ltN_of_nat (S (proj1_sig k)) n (ltN_S_mod_lemma2 k E))
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Tactic call ran for 0.004 secs (0.004u,0.s) (success)
Tactic call ran for 0.004 secs (0.004u,0.s) (success)
Crunching:
(p >= 2 ^ (n + 0 * 0 + (0 - 0)) \/ q >= 1 ->
 f_to_vec (n + 0 * 0 + (0 - 0)) m p q = 0%R)
Crunching: (f_to_vec n m x del2 = 0%R)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Crunching: (f_to_vec n m x del2 = 0%R)
Crunching: (f_to_vec n m x del2 = 0%R)
Crunching: (f_to_vec n m x del2 = 0%R)
Crunching: (p * S n < p * n)
rewrite if_dtt
if
((fix eqb (n m : nat) {struct n} : bool :=
    match n with
    | 0 => match m with
           | 0 => true
           | S _ => false
           end
    | S n' => match m with
              | 0 => false
              | S m' => eqb n' m'
              end
    end) n (S (let (a, _) := let (_, y) := qr1 in y in a)))
then
(fun
   E : (fix eqb (n m : nat) {struct n} : bool :=
          match n with
          | 0 => match m with
                 | 0 => true
                 | S _ => false
                 end
          | S n' => match m with
                    | 0 => false
                    | S m' => eqb n' m'
                    end
          end) n (S (let (a, _) := let (_, y) := qr1 in y in a)) = true =>
 exist
   (fun k : nat =>
    match n with
    | 0 => false
    | S m' =>
        (fix leb (n m : nat) {struct n} : bool :=
           match n with
           | 0 => true
           | S n' => match m with
                     | 0 => false
                     | S m'0 => leb n' m'0
                     end
           end) k m'
    end = true) 0 (ltN_S_mod_lemma1 (let (_, y) := qr1 in y) E))
else
(fun
   E : (fix eqb (n m : nat) {struct n} : bool :=
          match n with
          | 0 => match m with
                 | 0 => true
                 | S _ => false
                 end
          | S n' => match m with
                    | 0 => false
                    | S m' => eqb n' m'
                    end
          end) n (S (let (a, _) := let (_, y) := qr1 in y in a)) = false =>
 exist
   (fun k : nat =>
    match n with
    | 0 => false
    | S m' =>
        (fix leb (n m : nat) {struct n} : bool :=
           match n with
           | 0 => true
           | S n' => match m with
                     | 0 => false
                     | S m'0 => leb n' m'0
                     end
           end) k m'
    end = true) (S (let (a, _) := let (_, y) := qr1 in y in a))
   (ltN_S_mod_lemma2 (let (_, y) := qr1 in y) E))
rewrite if_dtt
if
(proj1_sig (exist (fun k : nat => (k <? S n) = true) IH1 IH2) <? proj1_sig LT)
then
(fun
   E : (proj1_sig (exist (fun k : nat => (k <? S n) = true) IH1 IH2) <?
        proj1_sig LT) = true =>
 proj1_sig
   (ltN_intro
      (ltN_intro LT (exist (fun k : nat => (k <? S n) = true) IH1 IH2))
      (ltN_of_nat (Init.Nat.pred (proj1_sig LT)) (S n)
         (ltN_comm_intro_lemma1
            (exist (fun k : nat => (k <? S n) = true) IH1 IH2) LT E))))
else
(fun
   E : (proj1_sig (exist (fun k : nat => (k <? S n) = true) IH1 IH2) <?
        proj1_sig LT) = false =>
 proj1_sig
   (ltN_intro
      (ltN_intro LT (exist (fun k : nat => (k <? S n) = true) IH1 IH2))
      (ltN_of_nat (proj1_sig LT) (S n)
         (ltN_comm_intro_lemma2
            (exist (fun k : nat => (k <? S n) = true) IH1 IH2) LT E))))
rewrite if_dtt
if
(proj1_sig (exist (fun k : nat => (k <? S n) = true) IH1 IH2) <? proj1_sig LT)
then
(fun
   E : (proj1_sig (exist (fun k : nat => (k <? S n) = true) IH1 IH2) <?
        proj1_sig LT) = true =>
 eq
   (proj1_sig
      (ltN_intro
         (ltN_intro LT (exist (fun k : nat => (k <? S n) = true) IH1 IH2))
         (ltN_of_nat (Init.Nat.pred (proj1_sig LT)) 
            (S n)
            (ltN_comm_intro_lemma1
               (exist (fun k : nat => (k <? S n) = true) IH1 IH2) LT E)))))
else
(fun
   E : (proj1_sig (exist (fun k : nat => (k <? S n) = true) IH1 IH2) <?
        proj1_sig LT) = false =>
 eq
   (proj1_sig
      (ltN_intro
         (ltN_intro LT (exist (fun k : nat => (k <? S n) = true) IH1 IH2))
         (ltN_of_nat (proj1_sig LT) (S n)
            (ltN_comm_intro_lemma2
               (exist (fun k : nat => (k <? S n) = true) IH1 IH2) LT E)))))
rewrite if_dtt
if
(proj1_sig (exist (fun k : nat => (k <? 1) = true) IH1 IH2) <? proj1_sig LT)
then
(fun
   E : (proj1_sig (exist (fun k : nat => (k <? 1) = true) IH1 IH2) <?
        proj1_sig LT) = true =>
 proj1_sig
   (ltN_intro (ltN_intro LT (exist (fun k : nat => (k <? 1) = true) IH1 IH2))
      (ltN_of_nat (Init.Nat.pred (proj1_sig LT)) 1
         (ltN_comm_intro_lemma1
            (exist (fun k : nat => (k <? 1) = true) IH1 IH2) LT E))))
else
(fun
   E : (proj1_sig (exist (fun k : nat => (k <? 1) = true) IH1 IH2) <?
        proj1_sig LT) = false =>
 proj1_sig
   (ltN_intro (ltN_intro LT (exist (fun k : nat => (k <? 1) = true) IH1 IH2))
      (ltN_of_nat (proj1_sig LT) 1
         (ltN_comm_intro_lemma2
            (exist (fun k : nat => (k <? 1) = true) IH1 IH2) LT E))))
Crunching:
(pr_outcome_sum p H <= pr_outcome_sum p (fun rnd : nat => H rnd || f2 rnd))
Crunching:
(pr_outcome_sum p H <= pr_outcome_sum p (fun rnd : nat => H rnd || f2 rnd))
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching:
(pr_outcome_sum p H <= pr_outcome_sum p (fun rnd : nat => H rnd || f2 rnd))
Crunching:
(pr_outcome_sum p H <= pr_outcome_sum p (fun rnd : nat => H rnd || f2 rnd))
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching:
(pr_outcome_sum p H <= pr_outcome_sum p (fun rnd : nat => H rnd || f2 rnd))
Crunching:
(pr_outcome_sum p H <= pr_outcome_sum p (fun rnd : nat => H rnd || f2 rnd))
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching:
(pr_outcome_sum p H <= pr_outcome_sum p (fun rnd : nat => H rnd || f2 rnd))
Crunching:
(pr_outcome_sum p H <= pr_outcome_sum p (fun rnd : nat => H rnd || f2 rnd))
Crunching: (∣1⟩ = basis_vector 2 1)
rewrite if_dtt
if
(proj1_sig (exist (fun k : nat => (k <=? 0) = true) IH1 IH2) <? proj1_sig k2)
then
(fun
   E : (proj1_sig (exist (fun k : nat => (k <=? 0) = true) IH1 IH2) <?
        proj1_sig k2) = true =>
 ltN_of_nat (Init.Nat.pred (proj1_sig k2)) 1
   (ltN_comm_intro_lemma1 (exist (fun k : nat => (k <=? 0) = true) IH1 IH2)
      k2 E))
else
(fun
   E : (proj1_sig (exist (fun k : nat => (k <=? 0) = true) IH1 IH2) <?
        proj1_sig k2) = false =>
 ltN_of_nat (proj1_sig k2) 1
   (ltN_comm_intro_lemma2 (exist (fun k : nat => (k <=? 0) = true) IH1 IH2)
      k2 E))
Crunching:
(pr_outcome_sum p H <= pr_outcome_sum p (fun rnd : nat => H rnd || f2 rnd))
Crunching:
(pr_outcome_sum p H <= pr_outcome_sum p (fun rnd : nat => H rnd || f2 rnd))
Crunching:
(pr_outcome_sum p H <= pr_outcome_sum p (fun rnd : nat => H rnd || f2 rnd))
Crunching:
(pr_outcome_sum p H <= pr_outcome_sum p (fun rnd : nat => H rnd || f2 rnd))
Crunching: (p * H <= 0 + 1)
rewrite if_dtt
if
(proj1_sig (exist (fun k : nat => (k <? S n) = true) IH1 IH2) <? proj1_sig LT)
then
(fun
   E : (proj1_sig (exist (fun k : nat => (k <? S n) = true) IH1 IH2) <?
        proj1_sig LT) = true =>
 proj1_sig
   (ltN_intro
      (ltN_intro LT (exist (fun k : nat => (k <? S n) = true) IH1 IH2))
      (ltN_of_nat (Init.Nat.pred (proj1_sig LT)) (S n)
         (ltN_comm_intro_lemma1
            (exist (fun k : nat => (k <? S n) = true) IH1 IH2) LT E))))
else
(fun
   E : (proj1_sig (exist (fun k : nat => (k <? S n) = true) IH1 IH2) <?
        proj1_sig LT) = false =>
 proj1_sig
   (ltN_intro
      (ltN_intro LT (exist (fun k : nat => (k <? S n) = true) IH1 IH2))
      (ltN_of_nat (proj1_sig LT) (S n)
         (ltN_comm_intro_lemma2
            (exist (fun k : nat => (k <? S n) = true) IH1 IH2) LT E))))
Crunching:
(pr_outcome_sum p H <= pr_outcome_sum p (fun rnd : nat => H rnd || f2 rnd))
Crunching:
(pr_outcome_sum p H <= pr_outcome_sum p (fun rnd : nat => H rnd || f2 rnd))
Crunching:
(pr_outcome_sum p H <= pr_outcome_sum p (fun rnd : nat => H rnd || f2 rnd))
Crunching:
(pr_outcome_sum p H <= pr_outcome_sum p (fun rnd : nat => H rnd || f2 rnd))
rewrite if_dtt
if
((fix eqb (n m : nat) {struct n} : bool :=
    match n with
    | 0 => match m with
           | 0 => true
           | S _ => false
           end
    | S n' => match m with
              | 0 => false
              | S m' => eqb n' m'
              end
    end) k (S (let (a, _) := let (_, y) := v in y in a)))
then
(fun
   E : (fix eqb (n m : nat) {struct n} : bool :=
          match n with
          | 0 => match m with
                 | 0 => true
                 | S _ => false
                 end
          | S n' => match m with
                    | 0 => false
                    | S m' => eqb n' m'
                    end
          end) k (S (let (a, _) := let (_, y) := v in y in a)) = true =>
 exist
   (fun k0 : nat =>
    match k with
    | 0 => false
    | S m' =>
        (fix leb (n m : nat) {struct n} : bool :=
           match n with
           | 0 => true
           | S n' => match m with
                     | 0 => false
                     | S m'0 => leb n' m'0
                     end
           end) k0 m'
    end = true) 0 (ltN_S_mod_lemma1 (let (_, y) := v in y) E))
else
(fun
   E : (fix eqb (n m : nat) {struct n} : bool :=
          match n with
          | 0 => match m with
                 | 0 => true
                 | S _ => false
                 end
          | S n' => match m with
                    | 0 => false
                    | S m' => eqb n' m'
                    end
          end) k (S (let (a, _) := let (_, y) := v in y in a)) = false =>
 exist
   (fun k0 : nat =>
    match k with
    | 0 => false
    | S m' =>
        (fix leb (n m : nat) {struct n} : bool :=
           match n with
           | 0 => true
           | S n' => match m with
                     | 0 => false
                     | S m'0 => leb n' m'0
                     end
           end) k0 m'
    end = true) (S (let (a, _) := let (_, y) := v in y in a))
   (ltN_S_mod_lemma2 (let (_, y) := v in y) E))
rewrite if_dtt
if
(proj1_sig (exist (fun k : nat => (k <? S n) = true) IH1 IH2) <? proj1_sig LT)
then
(fun
   E : (proj1_sig (exist (fun k : nat => (k <? S n) = true) IH1 IH2) <?
        proj1_sig LT) = true =>
 eq
   (proj1_sig
      (ltN_intro
         (ltN_intro LT (exist (fun k : nat => (k <? S n) = true) IH1 IH2))
         (ltN_of_nat (Init.Nat.pred (proj1_sig LT)) 
            (S n)
            (ltN_comm_intro_lemma1
               (exist (fun k : nat => (k <? S n) = true) IH1 IH2) LT E)))))
else
(fun
   E : (proj1_sig (exist (fun k : nat => (k <? S n) = true) IH1 IH2) <?
        proj1_sig LT) = false =>
 eq
   (proj1_sig
      (ltN_intro
         (ltN_intro LT (exist (fun k : nat => (k <? S n) = true) IH1 IH2))
         (ltN_of_nat (proj1_sig LT) (S n)
            (ltN_comm_intro_lemma2
               (exist (fun k : nat => (k <? S n) = true) IH1 IH2) LT E)))))
rewrite if_dtt
if
(proj1_sig (exist (fun k : nat => (k <? 1) = true) IH1 IH2) <? proj1_sig LT)
then
(fun
   E : (proj1_sig (exist (fun k : nat => (k <? 1) = true) IH1 IH2) <?
        proj1_sig LT) = true =>
 proj1_sig
   (ltN_intro (ltN_intro LT (exist (fun k : nat => (k <? 1) = true) IH1 IH2))
      (ltN_of_nat (Init.Nat.pred (proj1_sig LT)) 1
         (ltN_comm_intro_lemma1
            (exist (fun k : nat => (k <? 1) = true) IH1 IH2) LT E))))
else
(fun
   E : (proj1_sig (exist (fun k : nat => (k <? 1) = true) IH1 IH2) <?
        proj1_sig LT) = false =>
 proj1_sig
   (ltN_intro (ltN_intro LT (exist (fun k : nat => (k <? 1) = true) IH1 IH2))
      (ltN_of_nat (proj1_sig LT) 1
         (ltN_comm_intro_lemma2
            (exist (fun k : nat => (k <? 1) = true) IH1 IH2) LT E))))
Crunching:
(pr_outcome_sum [] f1 < pr_outcome_sum [] (fun rnd : nat => f1 rnd || f2 rnd))
Crunching: (f_to_vec p EQ = f_to_vec p a)
out of reach
Tactic call ran for 0.006 secs (0.006u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching: (pr_outcome_sum [] leSkz <= pr_outcome_sum [] b)
Crunching: (pr_outcome_sum [] leSkz <= pr_outcome_sum [] b)
Crunching: (f_to_vec p EQ = f_to_vec p a)
Crunching: (f_to_vec p EQ = f_to_vec p a)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
Crunching: (Z.abs_N (Z.pos EQ ÷ Z.pos Hfalse) = (N.pos EQ / N.pos Hfalse)%N)
Crunching: (nat -> Z.abs_N (Z.pos p0 ÷ Z.pos q) = (N.pos p0 / N.pos q)%N)
Crunching:
(forall f1 f2 : nat -> bool,
 Forall (fun x : R => 0 <= x) LT ->
 (forall x : nat, f1 x = true -> f2 x = true) ->
 pr_outcome_sum LT f1 <= pr_outcome_sum LT f2)
Crunching: (pr_outcome_sum [] leSkz <= pr_outcome_sum [] b)
Crunching: (pr_outcome_sum [] leSkz <= pr_outcome_sum [] b)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching:
(forall f f' : nat -> bool,
 (forall i : nat, i < p -> f i = f' i) -> f_to_vec p f = f_to_vec p f')
Crunching: False
Crunching: (∣0⟩ = basis_vector 2 0)
out of reach
Tactic call ran for 0.005 secs (0.005u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching: (f_to_vec p EQ = f_to_vec p a)
Crunching: (f_to_vec p EQ = f_to_vec p a)
Crunching: (Z.abs_N (Z.pos p0 ÷ Z.pos q) = (N.pos p0 / N.pos q)%N)
Crunching:
(forall x : R,
 Un_cv (fun N : nat => sum_f_R0 (tg_alt PI_tg) N) x ->
 Z.abs_N (Z.pos a ÷ Z.pos a') = (N.pos a / N.pos a')%N)
Crunching:
(N.testbit (Z.abs_N (Z.pos EQ ÷ Z.pos q)) m =
 N.testbit (N.pos EQ / N.pos q) m)
Crunching:
(forall p q : positive, Z.abs_N (Z.pos p ÷ Z.pos q) = (N.pos p / N.pos q)%N)
Crunching:
(forall p q : positive, Z.abs_N (Z.pos p ÷ Z.pos q) = (N.pos p / N.pos q)%N)
Crunching:
(forall p q : positive, Z.abs_N (Z.pos p ÷ Z.pos q) = (N.pos p / N.pos q)%N)
Crunching:
(forall p q : positive, Z.abs_N (Z.pos p ÷ Z.pos q) = (N.pos p / N.pos q)%N)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
Crunching: (Z.abs_N (Z.pos EQ ÷ Z.pos Hfalse) = (N.pos EQ / N.pos Hfalse)%N)
Crunching: (Z.abs_N (Z.pos EQ ÷ Z.pos Hfalse) = (N.pos EQ / N.pos Hfalse)%N)
Crunching: (Z.abs_N (Z.pos EQ ÷ Z.pos Hfalse) = (N.pos EQ / N.pos Hfalse)%N)
Crunching: (Z.abs_N (Z.pos EQ ÷ Z.pos Hfalse) = (N.pos EQ / N.pos Hfalse)%N)
Crunching: (Z.abs_N (Z.pos EQ ÷ Z.pos Hfalse) = (N.pos EQ / N.pos Hfalse)%N)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
Crunching:
(N.testbit (Z.abs_N (Z.pos t ÷ Z.pos def_n0)) 0 =
 N.testbit (N.pos t / N.pos def_n0) 0)
Crunching:
(forall f1 f2 : nat -> bool,
 (forall x : nat, f1 x = true -> f2 x = true) ->
 pr_outcome_sum l f1 <= pr_outcome_sum l f2 * 1)
Crunching:
(forall f1 f2 : nat -> bool,
 (forall x : nat, f1 x = true -> f2 x = true) ->
 pr_outcome_sum l f1 <= pr_outcome_sum l f2 * 1)
Crunching: (pr_outcome_sum H b <= pr_outcome_sum H k)
Crunching: (nat -> Z.abs_N (Z.pos p0 ÷ Z.pos q) = (N.pos p0 / N.pos q)%N)
Crunching: (pr_outcome_sum N3 H5 <= pr_outcome_sum N3 n)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
out of reach
Tactic call ran for 0.007 secs (0.005u,0.002s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching: (Hl >= L \/ H1 >= 1 -> basis_vector L R Hl H1 = 0%R)
out of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
Crunching: (pr_outcome_sum x psi1 <= pr_outcome_sum x H1)
Crunching: (∣0⟩ = basis_vector 2 0)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching: (0 <= pr_outcome_sum n f)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching: (0 < pr_outcome_sum (x :: l) f \/ 0 = pr_outcome_sum (x :: l) f)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (forall y : nat, (0 >= 0)%nat \/ (y >= 0)%nat -> I 0 0%nat y = 0)
Crunching: (I 0 = Zero)
Crunching: (0 <= pr_outcome_sum (x :: l) f)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
Crunching: (q >= L \/ f >= 1 -> basis_vector L R q f = R0)
Crunching: (H >= L -> basis_vector L R H H0 = R0)
Crunching: (basis_vector L R r1 r2 = 0%R)
Crunching: (0 < pr_outcome_sum (x :: l) f \/ 0 = pr_outcome_sum (x :: l) f)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching: (I 0 = Zero)
Crunching: (1 + a < c)
Crunching: (0 <= pr_outcome_sum (x :: l) f)
Crunching: (1 + a < c)
Crunching: (1 + a < c)
Crunching: (1 + a < c)
Crunching: (1 + a < c)
Crunching: (1 + a < c)
Crunching: (1 + a < c)
Crunching: (1 + a < c)
Crunching: (1 + a < c)
Crunching: (1 + a < c)
Crunching: (Hl >= L \/ H1 >= 1 -> basis_vector L R Hl H1 = 0%R)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching: (0 < pr_outcome_sum (x :: l) f \/ 0 = pr_outcome_sum (x :: l) f)
Crunching: (0 <= pr_outcome_sum (x :: l) f)
Crunching: (list2D_to_matrix [[e]] = (basis_vector d n) † × basis_vector d n)
Crunching:
(list2D_to_matrix
   [[Σ (fun y : nat => ((basis_vector d n y 0) ^* * basis_vector d n y 0)%C)
       d]] = I 1)
Crunching:
(0%R =
 Σ (fun y : nat => ((basis_vector d n y 0) ^* * basis_vector d n y 1)%C) d)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector d n y0 0) ^* * basis_vector d n y0 (S (S y)))%C) d)
Crunching:
(0%R =
 Σ (fun y : nat => ((basis_vector d n y 1) ^* * basis_vector d n y 0)%C) d)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector d n y0 1) ^* * basis_vector d n y0 (S y))%C) d)
Crunching:
(0%R =
 Σ
   (fun y : nat =>
    ((basis_vector d n y (S (S x))) ^* * basis_vector d n y 0)%C) d)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector d n y0 (S (S x))) ^* * basis_vector d n y0 (S y))%C) d)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector (S x) x) † × basis_vector (S x) x)
Crunching:
(list2D_to_matrix
   [[(Σ
        (fun y : nat =>
         (basis_vector (S x) x y 0) ^* * basis_vector (S x) x y 0) x +
      (basis_vector (S x) x x 0) ^* * basis_vector (S x) x x 0)%C]] = 
 I 1)
Crunching:
(0%R =
 (Σ (fun y : nat => (basis_vector (S x) x y 0) ^* * basis_vector (S x) x y 1)
    x + (basis_vector (S x) x x 0) ^* * basis_vector (S x) x x 1)%C)
Crunching:
(0%R =
 (Σ
    (fun y0 : nat =>
     (basis_vector (S x) x y0 0) ^* * basis_vector (S x) x y0 (S (S y))) x +
  (basis_vector (S x) x x 0) ^* * basis_vector (S x) x x (S (S y)))%C)
Crunching:
(0%R =
 (Σ (fun y : nat => (basis_vector (S x) x y 1) ^* * basis_vector (S x) x y 0)
    x + (basis_vector (S x) x x 1) ^* * basis_vector (S x) x x 0)%C)
Crunching:
(0%R =
 (Σ
    (fun y0 : nat =>
     (basis_vector (S x) x y0 1) ^* * basis_vector (S x) x y0 (S y)) x +
  (basis_vector (S x) x x 1) ^* * basis_vector (S x) x x (S y))%C)
Crunching:
(0%R =
 (Σ
    (fun y : nat =>
     (basis_vector (S x) x y (S (S x0))) ^* * basis_vector (S x) x y 0) x +
  (basis_vector (S x) x x (S (S x0))) ^* * basis_vector (S x) x x 0)%C)
Crunching:
(0%R =
 (Σ
    (fun y0 : nat =>
     (basis_vector (S x) x y0 (S (S x0))) ^* * basis_vector (S x) x y0 (S y))
    x + (basis_vector (S x) x x (S (S x0))) ^* * basis_vector (S x) x x (S y))%C)
Crunching: (y < x -> (basis_vector x y) † × basis_vector x y = I 1)
Crunching: (list2D_to_matrix [[e]] = (basis_vector x y) † × basis_vector x y)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y0 : nat =>
        ((basis_vector x y y0 0) ^* * basis_vector x y y0 0)%C) x]] = 
 I 1)
Crunching:
(0%R =
 Σ (fun y0 : nat => ((basis_vector x y y0 0) ^* * basis_vector x y y0 1)%C) x)
Crunching:
(0%R =
 Σ
   (fun y1 : nat =>
    ((basis_vector x y y1 0) ^* * basis_vector x y y1 (S (S y0)))%C) x)
Crunching:
(0%R =
 Σ (fun y0 : nat => ((basis_vector x y y0 1) ^* * basis_vector x y y0 0)%C) x)
Crunching:
(0%R =
 Σ
   (fun y1 : nat =>
    ((basis_vector x y y1 1) ^* * basis_vector x y y1 (S y0))%C) x)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector x y y0 (S (S x0))) ^* * basis_vector x y y0 0)%C) x)
Crunching:
(0%R =
 Σ
   (fun y1 : nat =>
    ((basis_vector x y y1 (S (S x0))) ^* * basis_vector x y y1 (S y0))%C) x)
Crunching: (list2D_to_matrix [[e]] = (basis_vector x y) † × basis_vector x y)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y0 : nat =>
        ((basis_vector x y y0 0) ^* * basis_vector x y y0 0)%C) x]] = 
 I 1)
Crunching:
(0%R =
 Σ (fun y0 : nat => ((basis_vector x y y0 0) ^* * basis_vector x y y0 1)%C) x)
Crunching:
(0%R =
 Σ
   (fun y1 : nat =>
    ((basis_vector x y y1 0) ^* * basis_vector x y y1 (S (S y0)))%C) x)
Crunching:
(0%R =
 Σ (fun y0 : nat => ((basis_vector x y y0 1) ^* * basis_vector x y y0 0)%C) x)
Crunching:
(0%R =
 Σ
   (fun y1 : nat =>
    ((basis_vector x y y1 1) ^* * basis_vector x y y1 (S y0))%C) x)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector x y y0 (S (S x0))) ^* * basis_vector x y y0 0)%C) x)
Crunching:
(0%R =
 Σ
   (fun y1 : nat =>
    ((basis_vector x y y1 (S (S x0))) ^* * basis_vector x y y1 (S y0))%C) x)
Crunching: (list2D_to_matrix [[e]] = (basis_vector x y) † × basis_vector x y)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y0 : nat =>
        ((basis_vector x y y0 0) ^* * basis_vector x y y0 0)%C) x]] = 
 I 1)
Crunching:
(0%R =
 Σ (fun y0 : nat => ((basis_vector x y y0 0) ^* * basis_vector x y y0 1)%C) x)
Crunching:
(0%R =
 Σ
   (fun y1 : nat =>
    ((basis_vector x y y1 0) ^* * basis_vector x y y1 (S (S y0)))%C) x)
Crunching:
(0%R =
 Σ (fun y0 : nat => ((basis_vector x y y0 1) ^* * basis_vector x y y0 0)%C) x)
Crunching:
(0%R =
 Σ
   (fun y1 : nat =>
    ((basis_vector x y y1 1) ^* * basis_vector x y y1 (S y0))%C) x)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector x y y0 (S (S x0))) ^* * basis_vector x y y0 0)%C) x)
Crunching:
(0%R =
 Σ
   (fun y1 : nat =>
    ((basis_vector x y y1 (S (S x0))) ^* * basis_vector x y y1 (S y0))%C) x)
Crunching: (list2D_to_matrix [[e]] = (basis_vector x y) † × basis_vector x y)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y0 : nat =>
        ((basis_vector x y y0 0) ^* * basis_vector x y y0 0)%C) x]] = 
 I 1)
Crunching:
(0%R =
 Σ (fun y0 : nat => ((basis_vector x y y0 0) ^* * basis_vector x y y0 1)%C) x)
Crunching:
(0%R =
 Σ
   (fun y1 : nat =>
    ((basis_vector x y y1 0) ^* * basis_vector x y y1 (S (S y0)))%C) x)
Crunching:
(0%R =
 Σ (fun y0 : nat => ((basis_vector x y y0 1) ^* * basis_vector x y y0 0)%C) x)
Crunching:
(0%R =
 Σ
   (fun y1 : nat =>
    ((basis_vector x y y1 1) ^* * basis_vector x y y1 (S y0))%C) x)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector x y y0 (S (S x0))) ^* * basis_vector x y y0 0)%C) x)
Crunching:
(0%R =
 Σ
   (fun y1 : nat =>
    ((basis_vector x y y1 (S (S x0))) ^* * basis_vector x y y1 (S y0))%C) x)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector (S n) n) † × basis_vector (S n) n)
Crunching:
(list2D_to_matrix
   [[(Σ
        (fun y : nat =>
         (basis_vector (S n) n y 0) ^* * basis_vector (S n) n y 0) n +
      (basis_vector (S n) n n 0) ^* * basis_vector (S n) n n 0)%C]] = 
 I 1)
Crunching:
(0%R =
 (Σ (fun y : nat => (basis_vector (S n) n y 0) ^* * basis_vector (S n) n y 1)
    n + (basis_vector (S n) n n 0) ^* * basis_vector (S n) n n 1)%C)
Crunching:
(0%R =
 (Σ
    (fun y0 : nat =>
     (basis_vector (S n) n y0 0) ^* * basis_vector (S n) n y0 (S (S y))) n +
  (basis_vector (S n) n n 0) ^* * basis_vector (S n) n n (S (S y)))%C)
Crunching:
(0%R =
 (Σ (fun y : nat => (basis_vector (S n) n y 1) ^* * basis_vector (S n) n y 0)
    n + (basis_vector (S n) n n 1) ^* * basis_vector (S n) n n 0)%C)
Crunching:
(0%R =
 (Σ
    (fun y0 : nat =>
     (basis_vector (S n) n y0 1) ^* * basis_vector (S n) n y0 (S y)) n +
  (basis_vector (S n) n n 1) ^* * basis_vector (S n) n n (S y))%C)
Crunching:
(0%R =
 (Σ
    (fun y : nat =>
     (basis_vector (S n) n y (S (S x))) ^* * basis_vector (S n) n y 0) n +
  (basis_vector (S n) n n (S (S x))) ^* * basis_vector (S n) n n 0)%C)
Crunching:
(0%R =
 (Σ
    (fun y0 : nat =>
     (basis_vector (S n) n y0 (S (S x))) ^* * basis_vector (S n) n y0 (S y))
    n + (basis_vector (S n) n n (S (S x))) ^* * basis_vector (S n) n n (S y))%C)
Crunching:
(forall d n : nat, n < d -> (basis_vector d n) † × basis_vector d n = I 1)
Crunching: (list2D_to_matrix [[e]] = (basis_vector d n) † × basis_vector d n)
Crunching:
(list2D_to_matrix
   [[Σ (fun y : nat => ((basis_vector d n y 0) ^* * basis_vector d n y 0)%C)
       d]] = I 1)
Crunching:
(0%R =
 Σ (fun y : nat => ((basis_vector d n y 0) ^* * basis_vector d n y 1)%C) d)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector d n y0 0) ^* * basis_vector d n y0 (S (S y)))%C) d)
Crunching:
(0%R =
 Σ (fun y : nat => ((basis_vector d n y 1) ^* * basis_vector d n y 0)%C) d)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector d n y0 1) ^* * basis_vector d n y0 (S y))%C) d)
Crunching:
(0%R =
 Σ
   (fun y : nat =>
    ((basis_vector d n y (S (S x))) ^* * basis_vector d n y 0)%C) d)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector d n y0 (S (S x))) ^* * basis_vector d n y0 (S y))%C) d)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector (S n) n) † × basis_vector (S n) n)
Crunching:
(list2D_to_matrix
   [[(Σ
        (fun y : nat =>
         (basis_vector (S n) n y 0) ^* * basis_vector (S n) n y 0) n +
      (basis_vector (S n) n n 0) ^* * basis_vector (S n) n n 0)%C]] = 
 I 1)
Crunching:
(0%R =
 (Σ (fun y : nat => (basis_vector (S n) n y 0) ^* * basis_vector (S n) n y 1)
    n + (basis_vector (S n) n n 0) ^* * basis_vector (S n) n n 1)%C)
Crunching:
(0%R =
 (Σ
    (fun y0 : nat =>
     (basis_vector (S n) n y0 0) ^* * basis_vector (S n) n y0 (S (S y))) n +
  (basis_vector (S n) n n 0) ^* * basis_vector (S n) n n (S (S y)))%C)
Crunching:
(0%R =
 (Σ (fun y : nat => (basis_vector (S n) n y 1) ^* * basis_vector (S n) n y 0)
    n + (basis_vector (S n) n n 1) ^* * basis_vector (S n) n n 0)%C)
Crunching:
(0%R =
 (Σ
    (fun y0 : nat =>
     (basis_vector (S n) n y0 1) ^* * basis_vector (S n) n y0 (S y)) n +
  (basis_vector (S n) n n 1) ^* * basis_vector (S n) n n (S y))%C)
Crunching:
(0%R =
 (Σ
    (fun y : nat =>
     (basis_vector (S n) n y (S (S x))) ^* * basis_vector (S n) n y 0) n +
  (basis_vector (S n) n n (S (S x))) ^* * basis_vector (S n) n n 0)%C)
Crunching:
(0%R =
 (Σ
    (fun y0 : nat =>
     (basis_vector (S n) n y0 (S (S x))) ^* * basis_vector (S n) n y0 (S y))
    n + (basis_vector (S n) n n (S (S x))) ^* * basis_vector (S n) n n (S y))%C)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector (S x) x) † × basis_vector (S x) x)
Crunching:
(list2D_to_matrix
   [[(Σ
        (fun y : nat =>
         (basis_vector (S x) x y 0) ^* * basis_vector (S x) x y 0) x +
      (basis_vector (S x) x x 0) ^* * basis_vector (S x) x x 0)%C]] = 
 I 1)
Crunching:
(0%R =
 (Σ (fun y : nat => (basis_vector (S x) x y 0) ^* * basis_vector (S x) x y 1)
    x + (basis_vector (S x) x x 0) ^* * basis_vector (S x) x x 1)%C)
Crunching:
(0%R =
 (Σ
    (fun y0 : nat =>
     (basis_vector (S x) x y0 0) ^* * basis_vector (S x) x y0 (S (S y))) x +
  (basis_vector (S x) x x 0) ^* * basis_vector (S x) x x (S (S y)))%C)
Crunching:
(0%R =
 (Σ (fun y : nat => (basis_vector (S x) x y 1) ^* * basis_vector (S x) x y 0)
    x + (basis_vector (S x) x x 1) ^* * basis_vector (S x) x x 0)%C)
Crunching:
(0%R =
 (Σ
    (fun y0 : nat =>
     (basis_vector (S x) x y0 1) ^* * basis_vector (S x) x y0 (S y)) x +
  (basis_vector (S x) x x 1) ^* * basis_vector (S x) x x (S y))%C)
Crunching:
(0%R =
 (Σ
    (fun y : nat =>
     (basis_vector (S x) x y (S (S x0))) ^* * basis_vector (S x) x y 0) x +
  (basis_vector (S x) x x (S (S x0))) ^* * basis_vector (S x) x x 0)%C)
Crunching:
(0%R =
 (Σ
    (fun y0 : nat =>
     (basis_vector (S x) x y0 (S (S x0))) ^* * basis_vector (S x) x y0 (S y))
    x + (basis_vector (S x) x x (S (S x0))) ^* * basis_vector (S x) x x (S y))%C)
Crunching:
(forall rl rr r a : R,
 interval_sum H8 rl rr r ->
 interval_sum (fun x : R => H8 (x - a)%R) (rl + a) (rr + a) r)
Crunching: (y < x -> (basis_vector x y) † × basis_vector x y = I 1)
Crunching: (list2D_to_matrix [[e]] = (basis_vector x y) † × basis_vector x y)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y0 : nat =>
        ((basis_vector x y y0 0) ^* * basis_vector x y y0 0)%C) x]] = 
 I 1)
Crunching:
(0%R =
 Σ (fun y0 : nat => ((basis_vector x y y0 0) ^* * basis_vector x y y0 1)%C) x)
Crunching:
(0%R =
 Σ
   (fun y1 : nat =>
    ((basis_vector x y y1 0) ^* * basis_vector x y y1 (S (S y0)))%C) x)
Crunching:
(0%R =
 Σ (fun y0 : nat => ((basis_vector x y y0 1) ^* * basis_vector x y y0 0)%C) x)
Crunching:
(0%R =
 Σ
   (fun y1 : nat =>
    ((basis_vector x y y1 1) ^* * basis_vector x y y1 (S y0))%C) x)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector x y y0 (S (S x0))) ^* * basis_vector x y y0 0)%C) x)
Crunching:
(0%R =
 Σ
   (fun y1 : nat =>
    ((basis_vector x y y1 (S (S x0))) ^* * basis_vector x y y1 (S y0))%C) x)
Crunching: (list2D_to_matrix [[e]] = (basis_vector x y) † × basis_vector x y)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y0 : nat =>
        ((basis_vector x y y0 0) ^* * basis_vector x y y0 0)%C) x]] = 
 I 1)
Crunching:
(0%R =
 Σ (fun y0 : nat => ((basis_vector x y y0 0) ^* * basis_vector x y y0 1)%C) x)
Crunching:
(0%R =
 Σ
   (fun y1 : nat =>
    ((basis_vector x y y1 0) ^* * basis_vector x y y1 (S (S y0)))%C) x)
Crunching:
(0%R =
 Σ (fun y0 : nat => ((basis_vector x y y0 1) ^* * basis_vector x y y0 0)%C) x)
Crunching:
(0%R =
 Σ
   (fun y1 : nat =>
    ((basis_vector x y y1 1) ^* * basis_vector x y y1 (S y0))%C) x)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector x y y0 (S (S x0))) ^* * basis_vector x y y0 0)%C) x)
Crunching:
(0%R =
 Σ
   (fun y1 : nat =>
    ((basis_vector x y y1 (S (S x0))) ^* * basis_vector x y y1 (S y0))%C) x)
Crunching: (y < x -> (basis_vector x y) † × basis_vector x y = I 1)
Crunching: (list2D_to_matrix [[e]] = (basis_vector x y) † × basis_vector x y)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y0 : nat =>
        ((basis_vector x y y0 0) ^* * basis_vector x y y0 0)%C) x]] = 
 I 1)
Crunching:
(0%R =
 Σ (fun y0 : nat => ((basis_vector x y y0 0) ^* * basis_vector x y y0 1)%C) x)
Crunching:
(0%R =
 Σ
   (fun y1 : nat =>
    ((basis_vector x y y1 0) ^* * basis_vector x y y1 (S (S y0)))%C) x)
Crunching:
(0%R =
 Σ (fun y0 : nat => ((basis_vector x y y0 1) ^* * basis_vector x y y0 0)%C) x)
Crunching:
(0%R =
 Σ
   (fun y1 : nat =>
    ((basis_vector x y y1 1) ^* * basis_vector x y y1 (S y0))%C) x)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector x y y0 (S (S x0))) ^* * basis_vector x y y0 0)%C) x)
Crunching:
(0%R =
 Σ
   (fun y1 : nat =>
    ((basis_vector x y y1 (S (S x0))) ^* * basis_vector x y y1 (S y0))%C) x)
Crunching: (list2D_to_matrix [[e]] = (basis_vector x y) † × basis_vector x y)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y0 : nat =>
        ((basis_vector x y y0 0) ^* * basis_vector x y y0 0)%C) x]] = 
 I 1)
Crunching:
(0%R =
 Σ (fun y0 : nat => ((basis_vector x y y0 0) ^* * basis_vector x y y0 1)%C) x)
Crunching:
(0%R =
 Σ
   (fun y1 : nat =>
    ((basis_vector x y y1 0) ^* * basis_vector x y y1 (S (S y0)))%C) x)
Crunching:
(0%R =
 Σ (fun y0 : nat => ((basis_vector x y y0 1) ^* * basis_vector x y y0 0)%C) x)
Crunching:
(0%R =
 Σ
   (fun y1 : nat =>
    ((basis_vector x y y1 1) ^* * basis_vector x y y1 (S y0))%C) x)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector x y y0 (S (S x0))) ^* * basis_vector x y y0 0)%C) x)
Crunching:
(0%R =
 Σ
   (fun y1 : nat =>
    ((basis_vector x y y1 (S (S x0))) ^* * basis_vector x y y1 (S y0))%C) x)
Crunching: (list2D_to_matrix [[e]] = (basis_vector x y) † × basis_vector x y)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y0 : nat =>
        ((basis_vector x y y0 0) ^* * basis_vector x y y0 0)%C) x]] = 
 I 1)
Crunching:
(0%R =
 Σ (fun y0 : nat => ((basis_vector x y y0 0) ^* * basis_vector x y y0 1)%C) x)
Crunching:
(0%R =
 Σ
   (fun y1 : nat =>
    ((basis_vector x y y1 0) ^* * basis_vector x y y1 (S (S y0)))%C) x)
Crunching:
(0%R =
 Σ (fun y0 : nat => ((basis_vector x y y0 1) ^* * basis_vector x y y0 0)%C) x)
Crunching:
(0%R =
 Σ
   (fun y1 : nat =>
    ((basis_vector x y y1 1) ^* * basis_vector x y y1 (S y0))%C) x)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector x y y0 (S (S x0))) ^* * basis_vector x y y0 0)%C) x)
Crunching:
(0%R =
 Σ
   (fun y1 : nat =>
    ((basis_vector x y y1 (S (S x0))) ^* * basis_vector x y y1 (S y0))%C) x)
Crunching:
((forall r : R, IHf2 < r < f2 -> ~ n r) ->
 interval_sum (fun x : R => n (x - a)%R) (f1 + a) (f2 + a) (IHf2 - IHf1))
Crunching: (interval_sum (fun x : R => P (x + - a)%R) (rl + a) (rr + a) r)
Crunching: (interval_sum (fun x : R => P (x + - a)%R) (rl + a) (rr + a) r)
Crunching:
(forall rl rr r a : R,
 interval_sum H8 rl rr r ->
 interval_sum (fun x : R => H8 (x - a)%R) (rl + a) (rr + a) r)
Crunching: (list2D_to_matrix [[e]] = (basis_vector x y) † × basis_vector x y)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y0 : nat =>
        ((basis_vector x y y0 0) ^* * basis_vector x y y0 0)%C) x]] = 
 I 1)
Crunching:
(0%R =
 Σ (fun y0 : nat => ((basis_vector x y y0 0) ^* * basis_vector x y y0 1)%C) x)
Crunching:
(0%R =
 Σ
   (fun y1 : nat =>
    ((basis_vector x y y1 0) ^* * basis_vector x y y1 (S (S y0)))%C) x)
Crunching:
(0%R =
 Σ (fun y0 : nat => ((basis_vector x y y0 1) ^* * basis_vector x y y0 0)%C) x)
Crunching:
(0%R =
 Σ
   (fun y1 : nat =>
    ((basis_vector x y y1 1) ^* * basis_vector x y y1 (S y0))%C) x)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector x y y0 (S (S x0))) ^* * basis_vector x y y0 0)%C) x)
Crunching:
(0%R =
 Σ
   (fun y1 : nat =>
    ((basis_vector x y y1 (S (S x0))) ^* * basis_vector x y y1 (S y0))%C) x)
Crunching: (list2D_to_matrix [[e]] = (basis_vector x y) † × basis_vector x y)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y0 : nat =>
        ((basis_vector x y y0 0) ^* * basis_vector x y y0 0)%C) x]] = 
 I 1)
Crunching:
(0%R =
 Σ (fun y0 : nat => ((basis_vector x y y0 0) ^* * basis_vector x y y0 1)%C) x)
Crunching:
(0%R =
 Σ
   (fun y1 : nat =>
    ((basis_vector x y y1 0) ^* * basis_vector x y y1 (S (S y0)))%C) x)
Crunching:
(0%R =
 Σ (fun y0 : nat => ((basis_vector x y y0 1) ^* * basis_vector x y y0 0)%C) x)
Crunching:
(0%R =
 Σ
   (fun y1 : nat =>
    ((basis_vector x y y1 1) ^* * basis_vector x y y1 (S y0))%C) x)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector x y y0 (S (S x0))) ^* * basis_vector x y y0 0)%C) x)
Crunching:
(0%R =
 Σ
   (fun y1 : nat =>
    ((basis_vector x y y1 (S (S x0))) ^* * basis_vector x y y1 (S y0))%C) x)
Crunching: (forall x y : R, ~ x <= y -> x > y)
Crunching:
((forall r : R, IHf2 < r < f2 -> ~ n r) ->
 interval_sum (fun x : R => n (x - a)%R) (f1 + a) (f2 + a) (IHf2 - IHf1))
Crunching:
((forall r : R, IHf2 < r < f2 -> ~ n r) ->
 interval_sum (fun x : R => n (x - a)%R) (f1 + a) (f2 + a) (IHf2 - IHf1))
Crunching:
((forall r : R, IHf2 < r < f2 -> ~ n r) ->
 interval_sum (fun x : R => n (x - a)%R) (f1 + a) (f2 + a) (IHf2 - IHf1))
Crunching:
((forall r : R, IHf2 < r < f2 -> ~ n r) ->
 interval_sum (fun x : R => n (x - a)%R) (f1 + a) (f2 + a) (IHf2 - IHf1))
Crunching:
(interval_sum (fun x : R => n (x + - a)%R) (rl + a) (rr + a) (r2 + - r1))
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Crunching:
(WF_Matrix (basis_vector n m) /\
 (basis_vector n m) † × basis_vector n m = I 1)
Crunching: (H' < Maj2 -> Pure_State_Vector (basis_vector Maj2 H'))
Tactic call ran for 0.002 secs (0.001u,0.s) (success)
Crunching: (interval_sum b rl psi1 H1)
out of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
Crunching:
((forall x : R, HP <= x < HQ -> X x <-> n x) -> interval_sum n HP HQ m)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Crunching:
(WF_Matrix (basis_vector (S m) m) /\
 (basis_vector (S m) m) † × basis_vector (S m) m = I 1)
Crunching:
(forall (m : R -> Prop) (rr r : R),
 interval_sum n Ha rr r ->
 (forall x : R, Ha <= x < rr -> n x <-> m x) -> interval_sum m Ha rr r)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Crunching: (∣1⟩ = basis_vector 2 1)
Tactic call ran for 0.004 secs (0.004u,0.s) (success)
Crunching:
((0 < 0 -> Pure_State_Vector (basis_vector 0 0)) ->
 0 < 1 ->
 0 < 0 \/ 0 = 0 ->
 WF_Matrix (basis_vector 1 0) /\
 (basis_vector 1 0) † × basis_vector 1 0 = I 1)
Crunching:
(H1 < 1 ->
 H1 < 0 \/ H1 = 0 ->
 WF_Matrix (basis_vector 1 H1) /\
 (basis_vector 1 H1) † × basis_vector 1 H1 = I 1)
Crunching:
(H1 < 1 ->
 H1 < 0 \/ H1 = 0 ->
 WF_Matrix (basis_vector 1 H1) /\
 (basis_vector 1 H1) † × basis_vector 1 H1 = I 1)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector (S n) m) † × basis_vector (S n) n)
Crunching:
(list2D_to_matrix
   [[(Σ
        (fun y : nat =>
         (basis_vector (S n) m y 0) ^* * basis_vector (S n) n y 0) n +
      (basis_vector (S n) m n 0) ^* * basis_vector (S n) n n 0)%C]] = Zero)
Crunching:
(0%R =
 (Σ (fun y : nat => (basis_vector (S n) m y 0) ^* * basis_vector (S n) n y 1)
    n + (basis_vector (S n) m n 0) ^* * basis_vector (S n) n n 1)%C)
Crunching:
(0%R =
 (Σ
    (fun y0 : nat =>
     (basis_vector (S n) m y0 0) ^* * basis_vector (S n) n y0 (S (S y))) n +
  (basis_vector (S n) m n 0) ^* * basis_vector (S n) n n (S (S y)))%C)
Crunching:
(0%R =
 (Σ (fun y : nat => (basis_vector (S n) m y 1) ^* * basis_vector (S n) n y 0)
    n + (basis_vector (S n) m n 1) ^* * basis_vector (S n) n n 0)%C)
Crunching:
(0%R =
 (Σ
    (fun y0 : nat =>
     (basis_vector (S n) m y0 1) ^* * basis_vector (S n) n y0 (S y)) n +
  (basis_vector (S n) m n 1) ^* * basis_vector (S n) n n (S y))%C)
Crunching:
(0%R =
 (Σ
    (fun y : nat =>
     (basis_vector (S n) m y (S (S x))) ^* * basis_vector (S n) n y 0) n +
  (basis_vector (S n) m n (S (S x))) ^* * basis_vector (S n) n n 0)%C)
Crunching:
(0%R =
 (Σ
    (fun y0 : nat =>
     (basis_vector (S n) m y0 (S (S x))) ^* * basis_vector (S n) n y0 (S y))
    n + (basis_vector (S n) m n (S (S x))) ^* * basis_vector (S n) n n (S y))%C)
Crunching: (list2D_to_matrix [[e]] = (basis_vector 1 m) † × basis_vector 1 0)
Crunching: (list2D_to_matrix [[((basis_vector 1 m 0 0) ^*)%C]] = Zero)
Crunching: (0%R = ((basis_vector 1 m 0 1) ^*)%C)
Crunching: (0%R = ((basis_vector 1 m 0 (S (S x))) ^*)%C)
Crunching:
(forall m n : nat,
 m < H9 ->
 n < H9 -> m <> n -> (basis_vector H9 m) † × basis_vector H9 n = Zero)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector (S n) m) † × basis_vector (S n) n)
Crunching:
(list2D_to_matrix
   [[(Σ
        (fun y : nat =>
         (basis_vector (S n) m y 0) ^* * basis_vector (S n) n y 0) n +
      (basis_vector (S n) m n 0) ^* * basis_vector (S n) n n 0)%C]] = Zero)
Crunching:
(0%R =
 (Σ (fun y : nat => (basis_vector (S n) m y 0) ^* * basis_vector (S n) n y 1)
    n + (basis_vector (S n) m n 0) ^* * basis_vector (S n) n n 1)%C)
Crunching:
(0%R =
 (Σ
    (fun y0 : nat =>
     (basis_vector (S n) m y0 0) ^* * basis_vector (S n) n y0 (S (S y))) n +
  (basis_vector (S n) m n 0) ^* * basis_vector (S n) n n (S (S y)))%C)
Crunching:
(0%R =
 (Σ (fun y : nat => (basis_vector (S n) m y 1) ^* * basis_vector (S n) n y 0)
    n + (basis_vector (S n) m n 1) ^* * basis_vector (S n) n n 0)%C)
Crunching:
(0%R =
 (Σ
    (fun y0 : nat =>
     (basis_vector (S n) m y0 1) ^* * basis_vector (S n) n y0 (S y)) n +
  (basis_vector (S n) m n 1) ^* * basis_vector (S n) n n (S y))%C)
Crunching:
(0%R =
 (Σ
    (fun y : nat =>
     (basis_vector (S n) m y (S (S x))) ^* * basis_vector (S n) n y 0) n +
  (basis_vector (S n) m n (S (S x))) ^* * basis_vector (S n) n n 0)%C)
Crunching:
(0%R =
 (Σ
    (fun y0 : nat =>
     (basis_vector (S n) m y0 (S (S x))) ^* * basis_vector (S n) n y0 (S y))
    n + (basis_vector (S n) m n (S (S x))) ^* * basis_vector (S n) n n (S y))%C)
Crunching:
((forall x : R, rl <= x < rr -> P1 x <-> P2 x) ->
 sin_term 1 0 + sin_term 1 1 <= sin 1 -> interval_sum P2 rl rr r)
Crunching: (list2D_to_matrix [[e]] = (basis_vector 1 m) † × basis_vector 1 0)
Crunching: (list2D_to_matrix [[((basis_vector 1 m 0 0) ^*)%C]] = Zero)
Crunching: (0%R = ((basis_vector 1 m 0 1) ^*)%C)
Crunching: (0%R = ((basis_vector 1 m 0 (S (S x))) ^*)%C)
Crunching: (list2D_to_matrix [[e]] = (basis_vector 1 m) † × basis_vector 1 0)
Crunching: (list2D_to_matrix [[((basis_vector 1 m 0 0) ^*)%C]] = Zero)
Crunching: (0%R = ((basis_vector 1 m 0 1) ^*)%C)
Crunching: (0%R = ((basis_vector 1 m 0 (S (S x))) ^*)%C)
Crunching: (0 < 0 -> (basis_vector d 0) † × basis_vector d 0 = Zero)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector n m) † × basis_vector n Compat)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y : nat =>
        ((basis_vector n m y 0) ^* * basis_vector n Compat y 0)%C) n]] = Zero)
Crunching:
(0%R =
 Σ (fun y : nat => ((basis_vector n m y 0) ^* * basis_vector n Compat y 1)%C)
   n)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector n m y0 0) ^* * basis_vector n Compat y0 (S (S y)))%C) n)
Crunching:
(0%R =
 Σ (fun y : nat => ((basis_vector n m y 1) ^* * basis_vector n Compat y 0)%C)
   n)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector n m y0 1) ^* * basis_vector n Compat y0 (S y))%C) n)
Crunching:
(0%R =
 Σ
   (fun y : nat =>
    ((basis_vector n m y (S (S x))) ^* * basis_vector n Compat y 0)%C) n)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector n m y0 (S (S x))) ^* * basis_vector n Compat y0 (S y))%C)
   n)
Crunching:
(forall rr r a : R,
 interval_sum (fun x0 : R => x (x0 + a)%R) (q - a) (rr - a) r ->
 interval_sum x q rr r)
Crunching:
(forall m n : nat,
 m < H9 ->
 n < H9 -> m <> n -> (basis_vector H9 m) † × basis_vector H9 n = Zero)
Crunching:
(list2D_to_matrix [[e]] =
 (basis_vector H9 delta1) † × basis_vector H9 Hdelta1)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y : nat =>
        ((basis_vector H9 delta1 y 0) ^* * basis_vector H9 Hdelta1 y 0)%C) H9]] =
 Zero)
Crunching:
(0%R =
 Σ
   (fun y : nat =>
    ((basis_vector H9 delta1 y 0) ^* * basis_vector H9 Hdelta1 y 1)%C) H9)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector H9 delta1 y0 0) ^* * basis_vector H9 Hdelta1 y0 (S (S y)))%C)
   H9)
Crunching:
(0%R =
 Σ
   (fun y : nat =>
    ((basis_vector H9 delta1 y 1) ^* * basis_vector H9 Hdelta1 y 0)%C) H9)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector H9 delta1 y0 1) ^* * basis_vector H9 Hdelta1 y0 (S y))%C)
   H9)
Crunching:
(0%R =
 Σ
   (fun y : nat =>
    ((basis_vector H9 delta1 y (S (S x))) ^* * basis_vector H9 Hdelta1 y 0)%C)
   H9)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector H9 delta1 y0 (S (S x))) ^* *
     basis_vector H9 Hdelta1 y0 (S y))%C) H9)
Crunching:
(list2D_to_matrix [[e]] =
 (basis_vector H9 delta1) † × basis_vector H9 Hdelta1)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y : nat =>
        ((basis_vector H9 delta1 y 0) ^* * basis_vector H9 Hdelta1 y 0)%C) H9]] =
 Zero)
Crunching:
(0%R =
 Σ
   (fun y : nat =>
    ((basis_vector H9 delta1 y 0) ^* * basis_vector H9 Hdelta1 y 1)%C) H9)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector H9 delta1 y0 0) ^* * basis_vector H9 Hdelta1 y0 (S (S y)))%C)
   H9)
Crunching:
(0%R =
 Σ
   (fun y : nat =>
    ((basis_vector H9 delta1 y 1) ^* * basis_vector H9 Hdelta1 y 0)%C) H9)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector H9 delta1 y0 1) ^* * basis_vector H9 Hdelta1 y0 (S y))%C)
   H9)
Crunching:
(0%R =
 Σ
   (fun y : nat =>
    ((basis_vector H9 delta1 y (S (S x))) ^* * basis_vector H9 Hdelta1 y 0)%C)
   H9)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector H9 delta1 y0 (S (S x))) ^* *
     basis_vector H9 Hdelta1 y0 (S y))%C) H9)
Crunching:
(list2D_to_matrix [[e]] =
 (basis_vector H9 delta1) † × basis_vector H9 Hdelta1)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y : nat =>
        ((basis_vector H9 delta1 y 0) ^* * basis_vector H9 Hdelta1 y 0)%C) H9]] =
 Zero)
Crunching:
(0%R =
 Σ
   (fun y : nat =>
    ((basis_vector H9 delta1 y 0) ^* * basis_vector H9 Hdelta1 y 1)%C) H9)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector H9 delta1 y0 0) ^* * basis_vector H9 Hdelta1 y0 (S (S y)))%C)
   H9)
Crunching:
(0%R =
 Σ
   (fun y : nat =>
    ((basis_vector H9 delta1 y 1) ^* * basis_vector H9 Hdelta1 y 0)%C) H9)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector H9 delta1 y0 1) ^* * basis_vector H9 Hdelta1 y0 (S y))%C)
   H9)
Crunching:
(0%R =
 Σ
   (fun y : nat =>
    ((basis_vector H9 delta1 y (S (S x))) ^* * basis_vector H9 Hdelta1 y 0)%C)
   H9)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector H9 delta1 y0 (S (S x))) ^* *
     basis_vector H9 Hdelta1 y0 (S y))%C) H9)
Crunching:
(list2D_to_matrix [[e]] =
 (basis_vector H9 delta1) † × basis_vector H9 Hdelta1)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y : nat =>
        ((basis_vector H9 delta1 y 0) ^* * basis_vector H9 Hdelta1 y 0)%C) H9]] =
 Zero)
Crunching:
(0%R =
 Σ
   (fun y : nat =>
    ((basis_vector H9 delta1 y 0) ^* * basis_vector H9 Hdelta1 y 1)%C) H9)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector H9 delta1 y0 0) ^* * basis_vector H9 Hdelta1 y0 (S (S y)))%C)
   H9)
Crunching:
(0%R =
 Σ
   (fun y : nat =>
    ((basis_vector H9 delta1 y 1) ^* * basis_vector H9 Hdelta1 y 0)%C) H9)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector H9 delta1 y0 1) ^* * basis_vector H9 Hdelta1 y0 (S y))%C)
   H9)
Crunching:
(0%R =
 Σ
   (fun y : nat =>
    ((basis_vector H9 delta1 y (S (S x))) ^* * basis_vector H9 Hdelta1 y 0)%C)
   H9)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector H9 delta1 y0 (S (S x))) ^* *
     basis_vector H9 Hdelta1 y0 (S y))%C) H9)
Crunching:
(list2D_to_matrix [[e]] =
 (basis_vector H9 delta1) † × basis_vector H9 Hdelta1)
Crunching:
(list2D_to_matrix
   [[Σ
       (fun y : nat =>
        ((basis_vector H9 delta1 y 0) ^* * basis_vector H9 Hdelta1 y 0)%C) H9]] =
 Zero)
Crunching:
(0%R =
 Σ
   (fun y : nat =>
    ((basis_vector H9 delta1 y 0) ^* * basis_vector H9 Hdelta1 y 1)%C) H9)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector H9 delta1 y0 0) ^* * basis_vector H9 Hdelta1 y0 (S (S y)))%C)
   H9)
Crunching:
(0%R =
 Σ
   (fun y : nat =>
    ((basis_vector H9 delta1 y 1) ^* * basis_vector H9 Hdelta1 y 0)%C) H9)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector H9 delta1 y0 1) ^* * basis_vector H9 Hdelta1 y0 (S y))%C)
   H9)
Crunching:
(0%R =
 Σ
   (fun y : nat =>
    ((basis_vector H9 delta1 y (S (S x))) ^* * basis_vector H9 Hdelta1 y 0)%C)
   H9)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector H9 delta1 y0 (S (S x))) ^* *
     basis_vector H9 Hdelta1 y0 (S y))%C) H9)
Crunching:
(list2D_to_matrix [[e]] = (basis_vector (S n) m) † × basis_vector (S n) n)
Crunching:
(list2D_to_matrix
   [[(Σ
        (fun y : nat =>
         (basis_vector (S n) m y 0) ^* * basis_vector (S n) n y 0) n +
      (basis_vector (S n) m n 0) ^* * basis_vector (S n) n n 0)%C]] = Zero)
Crunching:
(0%R =
 (Σ (fun y : nat => (basis_vector (S n) m y 0) ^* * basis_vector (S n) n y 1)
    n + (basis_vector (S n) m n 0) ^* * basis_vector (S n) n n 1)%C)
Crunching:
(0%R =
 (Σ
    (fun y0 : nat =>
     (basis_vector (S n) m y0 0) ^* * basis_vector (S n) n y0 (S (S y))) n +
  (basis_vector (S n) m n 0) ^* * basis_vector (S n) n n (S (S y)))%C)
Crunching:
(0%R =
 (Σ (fun y : nat => (basis_vector (S n) m y 1) ^* * basis_vector (S n) n y 0)
    n + (basis_vector (S n) m n 1) ^* * basis_vector (S n) n n 0)%C)
Crunching:
(0%R =
 (Σ
    (fun y0 : nat =>
     (basis_vector (S n) m y0 1) ^* * basis_vector (S n) n y0 (S y)) n +
  (basis_vector (S n) m n 1) ^* * basis_vector (S n) n n (S y))%C)
Crunching:
(0%R =
 (Σ
    (fun y : nat =>
     (basis_vector (S n) m y (S (S x))) ^* * basis_vector (S n) n y 0) n +
  (basis_vector (S n) m n (S (S x))) ^* * basis_vector (S n) n n 0)%C)
Crunching:
(0%R =
 (Σ
    (fun y0 : nat =>
     (basis_vector (S n) m y0 (S (S x))) ^* * basis_vector (S n) n y0 (S y))
    n + (basis_vector (S n) m n (S (S x))) ^* * basis_vector (S n) n n (S y))%C)
Crunching: (list2D_to_matrix [[e]] = (basis_vector 1 m) † × basis_vector 1 0)
Crunching: (list2D_to_matrix [[((basis_vector 1 m 0 0) ^*)%C]] = Zero)
Crunching: (0%R = ((basis_vector 1 m 0 1) ^*)%C)
Crunching: (0%R = ((basis_vector 1 m 0 (S (S x))) ^*)%C)
Crunching: (list2D_to_matrix [[e]] = (basis_vector 1 m) † × basis_vector 1 0)
Crunching: (list2D_to_matrix [[((basis_vector 1 m 0 0) ^*)%C]] = Zero)
Crunching: (0%R = ((basis_vector 1 m 0 1) ^*)%C)
Crunching: (0%R = ((basis_vector 1 m 0 (S (S x))) ^*)%C)
Crunching: (list2D_to_matrix [[e]] = (basis_vector 1 m) † × basis_vector 1 0)
Crunching:
(forall rr r a : R,
 interval_sum (fun x0 : R => x (x0 + a)%R) (q - a) (rr - a) r ->
 interval_sum x q rr r)
Crunching: (list2D_to_matrix [[((basis_vector 1 m 0 0) ^*)%C]] = Zero)
Crunching: (0%R = ((basis_vector 1 m 0 1) ^*)%C)
Crunching: (0%R = ((basis_vector 1 m 0 (S (S x))) ^*)%C)
Crunching:
(interval_sum (fun x0 : R => x (x0 + Hneq)%R) (n - Hneq) (d - Hneq) z1 ->
 interval_sum x n d z1)
Crunching: (0 < 0 -> (basis_vector d 0) † × basis_vector d 0 = Zero)
Crunching: (list2D_to_matrix [[e]] = (basis_vector d 0) † × basis_vector d 0)
Crunching:
(list2D_to_matrix
   [[Σ (fun y : nat => ((basis_vector d 0 y 0) ^* * basis_vector d 0 y 0)%C)
       d]] = Zero)
Crunching:
(0%R =
 Σ (fun y : nat => ((basis_vector d 0 y 0) ^* * basis_vector d 0 y 1)%C) d)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector d 0 y0 0) ^* * basis_vector d 0 y0 (S (S y)))%C) d)
Crunching:
(0%R =
 Σ (fun y : nat => ((basis_vector d 0 y 1) ^* * basis_vector d 0 y 0)%C) d)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector d 0 y0 1) ^* * basis_vector d 0 y0 (S y))%C) d)
Crunching:
(0%R =
 Σ
   (fun y : nat =>
    ((basis_vector d 0 y (S (S x))) ^* * basis_vector d 0 y 0)%C) d)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector d 0 y0 (S (S x))) ^* * basis_vector d 0 y0 (S y))%C) d)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (list2D_to_matrix [[e]] = (basis_vector d m) † × basis_vector d n)
Crunching:
(list2D_to_matrix
   [[Σ (fun y : nat => ((basis_vector d m y 0) ^* * basis_vector d n y 0)%C)
       d]] = Zero)
Crunching:
(0%R =
 Σ (fun y : nat => ((basis_vector d m y 0) ^* * basis_vector d n y 1)%C) d)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector d m y0 0) ^* * basis_vector d n y0 (S (S y)))%C) d)
Crunching:
(0%R =
 Σ (fun y : nat => ((basis_vector d m y 1) ^* * basis_vector d n y 0)%C) d)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector d m y0 1) ^* * basis_vector d n y0 (S y))%C) d)
Crunching:
(0%R =
 Σ
   (fun y : nat =>
    ((basis_vector d m y (S (S x))) ^* * basis_vector d n y 0)%C) d)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector d m y0 (S (S x))) ^* * basis_vector d n y0 (S y))%C) d)
Crunching: (0 < eps / 2)
Crunching:
(forall n0 : nat,
 (forall m0 : nat,
  m0 < n0 -> 0 <> 2 -> (basis_vector (S m) 0) † × basis_vector (S m) n = Zero) ->
 0 <> 2 -> (basis_vector (S m) 0) † × basis_vector (S m) n = Zero)
Crunching: (list2D_to_matrix [[e]] = (basis_vector d 0) † × basis_vector d 0)
Crunching:
(list2D_to_matrix
   [[Σ (fun y : nat => ((basis_vector d 0 y 0) ^* * basis_vector d 0 y 0)%C)
       d]] = Zero)
Crunching:
(0%R =
 Σ (fun y : nat => ((basis_vector d 0 y 0) ^* * basis_vector d 0 y 1)%C) d)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector d 0 y0 0) ^* * basis_vector d 0 y0 (S (S y)))%C) d)
Crunching:
(0%R =
 Σ (fun y : nat => ((basis_vector d 0 y 1) ^* * basis_vector d 0 y 0)%C) d)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector d 0 y0 1) ^* * basis_vector d 0 y0 (S y))%C) d)
Crunching:
(0%R =
 Σ
   (fun y : nat =>
    ((basis_vector d 0 y (S (S x))) ^* * basis_vector d 0 y 0)%C) d)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector d 0 y0 (S (S x))) ^* * basis_vector d 0 y0 (S y))%C) d)
Crunching: (list2D_to_matrix [[e]] = (basis_vector d 0) † × basis_vector d n)
Crunching:
(list2D_to_matrix
   [[Σ (fun y : nat => ((basis_vector d 0 y 0) ^* * basis_vector d n y 0)%C)
       d]] = Zero)
Crunching:
(0%R =
 Σ (fun y : nat => ((basis_vector d 0 y 0) ^* * basis_vector d n y 1)%C) d)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector d 0 y0 0) ^* * basis_vector d n y0 (S (S y)))%C) d)
Crunching:
(0%R =
 Σ (fun y : nat => ((basis_vector d 0 y 1) ^* * basis_vector d n y 0)%C) d)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector d 0 y0 1) ^* * basis_vector d n y0 (S y))%C) d)
Crunching:
(0%R =
 Σ
   (fun y : nat =>
    ((basis_vector d 0 y (S (S x))) ^* * basis_vector d n y 0)%C) d)
Crunching:
(0%R =
 Σ
   (fun y0 : nat =>
    ((basis_vector d 0 y0 (S (S x))) ^* * basis_vector d n y0 (S y))%C) d)
Crunching: False
Crunching: False
Crunching: ((n × basis_vector a j) i 0 = n i j)
Crunching: ((A × basis_vector n j) i 0 = A i j)
Crunching: (LS > 0)
Crunching: (0 <= LS)
Crunching: (LS = (0 * 1)%R)
Crunching: (0 <= LS)
Crunching: (LS = (0 * 1)%R)
Crunching: (0 <= LS)
Crunching: (LS = (0 * 1)%R)
Crunching: ((m × basis_vector y j) i 0 = m i j)
Crunching:
((H2 × (fun i j0 : nat => if (i =? j) && (j0 =? 0) then C1 else 0%R)) i 0 =
 H2 i j)
Crunching: ((E × basis_vector y n) h 0 = E h n)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
Crunching: (LS > 0)
Crunching: (LS > 0)
Crunching: (0 <= LS)
Crunching: (LS = (0 * 1)%R)
Crunching: (0 <= LS)
Crunching: (LS = (0 * 1)%R)
Crunching: (0 <= LS)
Crunching: (LS = (0 * 1)%R)
Crunching: (0 <= LS)
Crunching: ((A × basis_vector n j) i 0 = A i j)
Crunching: (LS = (0 * 1)%R)
Crunching: (H >= 0)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: False
Crunching: False
Crunching: False
Crunching: False
rewrite if_dtt
if
match (let (a, _) := k in a) with
| 0 => false
| S m' =>
    (fix leb (n m : nat) {struct n} : bool :=
       match n with
       | 0 => true
       | S n' => match m with
                 | 0 => false
                 | S m'0 => leb n' m'0
                 end
       end) (let (a, _) := x in a) m'
end
then
(fun
   E1 : match (let (a, _) := k in a) with
        | 0 => false
        | S m' =>
            (fix leb (n m : nat) {struct n} : bool :=
               match n with
               | 0 => true
               | S n' => match m with
                         | 0 => false
                         | S m'0 => leb n' m'0
                         end
               end) (let (a, _) := x in a) m'
        end = true =>
 exist
   (fun k : nat =>
    (fix leb (n m : nat) {struct n} : bool :=
       match n with
       | 0 => true
       | S n' => match m with
                 | 0 => false
                 | S m' => leb n' m'
                 end
       end) k (S n) = true) (let (a, _) := x in a)
   (ltN_intro_lemma1 (S n) k x E1))
else
(fun
   E1 : match (let (a, _) := k in a) with
        | 0 => false
        | S m' =>
            (fix leb (n m : nat) {struct n} : bool :=
               match n with
               | 0 => true
               | S n' => match m with
                         | 0 => false
                         | S m'0 => leb n' m'0
                         end
               end) (let (a, _) := x in a) m'
        end = false =>
 exist
   (fun k : nat =>
    (fix leb (n m : nat) {struct n} : bool :=
       match n with
       | 0 => true
       | S n' => match m with
                 | 0 => false
                 | S m' => leb n' m'
                 end
       end) k (S n) = true) (S (let (a, _) := x in a))
   (ltN_intro_lemma2 (S n) k x E1))
Crunching: ((0 + 0)%R = L 0 m)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
Crunching: (1 < r2 + - r1)
Crunching: (∣1⟩ = basis_vector 2 1)
rewrite if_dtt
if
match (let (a, _) := k in a) with
| 0 => false
| S m' =>
    (fix leb (n m : nat) {struct n} : bool :=
       match n with
       | 0 => true
       | S n' => match m with
                 | 0 => false
                 | S m'0 => leb n' m'0
                 end
       end) (let (a, _) := x in a) m'
end
then
(fun
   E1 : match (let (a, _) := k in a) with
        | 0 => false
        | S m' =>
            (fix leb (n m : nat) {struct n} : bool :=
               match n with
               | 0 => true
               | S n' => match m with
                         | 0 => false
                         | S m'0 => leb n' m'0
                         end
               end) (let (a, _) := x in a) m'
        end = true =>
 exist
   (fun k : nat =>
    (fix leb (n m : nat) {struct n} : bool :=
       match n with
       | 0 => true
       | S n' => match m with
                 | 0 => false
                 | S m' => leb n' m'
                 end
       end) k (S n) = true) (let (a, _) := x in a)
   (ltN_intro_lemma1 (S n) k x E1))
else
(fun
   E1 : match (let (a, _) := k in a) with
        | 0 => false
        | S m' =>
            (fix leb (n m : nat) {struct n} : bool :=
               match n with
               | 0 => true
               | S n' => match m with
                         | 0 => false
                         | S m'0 => leb n' m'0
                         end
               end) (let (a, _) := x in a) m'
        end = false =>
 exist
   (fun k : nat =>
    (fix leb (n m : nat) {struct n} : bool :=
       match n with
       | 0 => true
       | S n' => match m with
                 | 0 => false
                 | S m' => leb n' m'
                 end
       end) k (S n) = true) (S (let (a, _) := x in a))
   (ltN_intro_lemma2 (S n) k x E1))
rewrite if_dtt
if
match (let (a, _) := k in a) with
| 0 => false
| S m' =>
    (fix leb (n m : nat) {struct n} : bool :=
       match n with
       | 0 => true
       | S n' => match m with
                 | 0 => false
                 | S m'0 => leb n' m'0
                 end
       end) (let (a, _) := y in a) m'
end
then
(fun
   E1 : match (let (a, _) := k in a) with
        | 0 => false
        | S m' =>
            (fix leb (n m : nat) {struct n} : bool :=
               match n with
               | 0 => true
               | S n' => match m with
                         | 0 => false
                         | S m'0 => leb n' m'0
                         end
               end) (let (a, _) := y in a) m'
        end = true =>
 exist
   (fun k : nat =>
    (fix leb (n m : nat) {struct n} : bool :=
       match n with
       | 0 => true
       | S n' => match m with
                 | 0 => false
                 | S m' => leb n' m'
                 end
       end) k (S n) = true) (let (a, _) := y in a)
   (ltN_intro_lemma1 (S n) k y E1))
else
(fun
   E1 : match (let (a, _) := k in a) with
        | 0 => false
        | S m' =>
            (fix leb (n m : nat) {struct n} : bool :=
               match n with
               | 0 => true
               | S n' => match m with
                         | 0 => false
                         | S m'0 => leb n' m'0
                         end
               end) (let (a, _) := y in a) m'
        end = false =>
 exist
   (fun k : nat =>
    (fix leb (n m : nat) {struct n} : bool :=
       match n with
       | 0 => true
       | S n' => match m with
                 | 0 => false
                 | S m' => leb n' m'
                 end
       end) k (S n) = true) (S (let (a, _) := y in a))
   (ltN_intro_lemma2 (S n) k y E1))
Crunching: ((ie × basis_vector d A) 0 0 = ie 0 A)
Crunching: ((n × basis_vector a j) i 0 = n i j)
     = st_get >>=
       ((fix denote (A : UU0) (p : program A) {struct p} : ?M A :=
           match p in (program T) return (?M T) with
           | @p_ret _ _ A0 v => Ret v
           | @p_bind _ _ A0 B m f => denote A0 m >>= (denote B \o f)
           | @p_cond _ _ A0 true p1 _ => denote A0 p1
           | @p_cond _ _ A0 false _ p2 => denote A0 p2
           | p_repeat n p0 =>
               (fix loop (m : nat) : ?M unit :=
                  match m with
                  | 0 => Ret tt
                  | m'.+1 => denote unit p0 >> loop m'
                  end) n
           | p_while fuel c p0 =>
               (fix loop (m : nat) : ?M unit :=
                  match m with
                  | 0 => Ret tt
                  | m'.+1 =>
                      st_get >>=
                      (fun s : nat =>
                       if c s then denote unit p0 >> loop m' else Ret tt)
                  end) fuel
           | p_get => st_get
           | p_put s' => st_put s'
           | p_mark t => st_mark t
           end) nat \o
          (fun n : nat =>
           p_do _ : unit <- p_put n.+1; p_do _ : unit <- p_mark n; p_ret n))
     : ?M nat
     = (0, (1, [:: 0]))
     : nat * (nat * seq nat)
     = (0, (1, [:: 0]))
     : nat * (nat * seq nat)
     = eT [:: 0] (eT 0 (e 1))
     : {l : seq nat &
       {a : nat &
       {s' : nat | step_star (0, p_nonce `; stop nat) l (s', stop nat a)}}}
     = (false, (2, [:: 0; 1]))
     : bool * (nat * seq nat)
     = (false, (2, [:: 0; 1]))
     : bool * (nat * seq nat)
     = eT [:: 0; 1] (eT false (e 2))
     : {l : seq nat &
       {a : bool_eqType &
       {s' : nat
       | step_star (0, p_nonce_twice `; stop bool_eqType) l
           (s', stop bool_eqType a)}}}
     = (tt, (0, [:: false; false; false; false; false; true]))
     : unit * (nat * seq bool)
     = (tt, (0, [:: false; false; false; false; false; true]))
     : unit * (nat * seq bool)
     = eT [:: false; false; false; false; false; true] (eT tt (e 0))
     : {l : seq bool &
       {a : unit &
       {s' : nat
       | step_star (5, p_countdown 100 `; stop unit) l (s', stop unit a)}}}
rewrite if_dtt
if
match (let (a, _) := k in a) with
| 0 => false
| S m' =>
    (fix leb (n m : nat) {struct n} : bool :=
       match n with
       | 0 => true
       | S n' => match m with
                 | 0 => false
                 | S m'0 => leb n' m'0
                 end
       end) (let (a, _) := x in a) m'
end
then
(fun
   E1 : match (let (a, _) := k in a) with
        | 0 => false
        | S m' =>
            (fix leb (n m : nat) {struct n} : bool :=
               match n with
               | 0 => true
               | S n' => match m with
                         | 0 => false
                         | S m'0 => leb n' m'0
                         end
               end) (let (a, _) := x in a) m'
        end = true =>
 exist
   (fun k : nat =>
    (fix leb (n m : nat) {struct n} : bool :=
       match n with
       | 0 => true
       | S n' => match m with
                 | 0 => false
                 | S m' => leb n' m'
                 end
       end) k (S n) = true) (let (a, _) := x in a)
   (ltN_intro_lemma1 (S n) k x E1))
else
(fun
   E1 : match (let (a, _) := k in a) with
        | 0 => false
        | S m' =>
            (fix leb (n m : nat) {struct n} : bool :=
               match n with
               | 0 => true
               | S n' => match m with
                         | 0 => false
                         | S m'0 => leb n' m'0
                         end
               end) (let (a, _) := x in a) m'
        end = false =>
 exist
   (fun k : nat =>
    (fix leb (n m : nat) {struct n} : bool :=
       match n with
       | 0 => true
       | S n' => match m with
                 | 0 => false
                 | S m' => leb n' m'
                 end
       end) k (S n) = true) (S (let (a, _) := x in a))
   (ltN_intro_lemma2 (S n) k x E1))
     = eT [::] (eT tt (e 21))
     : {l : seq unit &
       {a : unit &
       {s' : nat
       | step_star (0, p_multiply 3 7 `; stop unit) l (s', stop unit a)}}}
     = eT [::] (eT tt (e (1, 3)))
     : {l : seq unit &
       {a : unit &
       {s' : nat * nat
       | step_star (0, 0, p_division 22 7 `; stop unit) l (s', stop unit a)}}}
     = Some (eT [::] (eT stop unit tt (e (1, 3))))
     : option
         {l : seq unit &
         {f' : continuation &
         {s' : nat * nat
         | step_n 15 (0, 0, p_division 22 7 `; stop unit) l (s', f')}}}
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
rewrite if_dtt
if
match (let (a, _) := k in a) with
| 0 => false
| S m' =>
    (fix leb (n m : nat) {struct n} : bool :=
       match n with
       | 0 => true
       | S n' => match m with
                 | 0 => false
                 | S m'0 => leb n' m'0
                 end
       end) (let (a, _) := x in a) m'
end
then
(fun
   E1 : match (let (a, _) := k in a) with
        | 0 => false
        | S m' =>
            (fix leb (n m : nat) {struct n} : bool :=
               match n with
               | 0 => true
               | S n' => match m with
                         | 0 => false
                         | S m'0 => leb n' m'0
                         end
               end) (let (a, _) := x in a) m'
        end = true =>
 exist
   (fun k : nat =>
    (fix leb (n m : nat) {struct n} : bool :=
       match n with
       | 0 => true
       | S n' => match m with
                 | 0 => false
                 | S m' => leb n' m'
                 end
       end) k (S n) = true) (let (a, _) := x in a)
   (ltN_intro_lemma1 (S n) k x E1))
else
(fun
   E1 : match (let (a, _) := k in a) with
        | 0 => false
        | S m' =>
            (fix leb (n m : nat) {struct n} : bool :=
               match n with
               | 0 => true
               | S n' => match m with
                         | 0 => false
                         | S m'0 => leb n' m'0
                         end
               end) (let (a, _) := x in a) m'
        end = false =>
 exist
   (fun k : nat =>
    (fix leb (n m : nat) {struct n} : bool :=
       match n with
       | 0 => true
       | S n' => match m with
                 | 0 => false
                 | S m' => leb n' m'
                 end
       end) k (S n) = true) (S (let (a, _) := x in a))
   (ltN_intro_lemma2 (S n) k x E1))
rewrite if_dtt
if
match (let (a, _) := k in a) with
| 0 => false
| S m' =>
    (fix leb (n m : nat) {struct n} : bool :=
       match n with
       | 0 => true
       | S n' => match m with
                 | 0 => false
                 | S m'0 => leb n' m'0
                 end
       end) (let (a, _) := y in a) m'
end
then
(fun
   E1 : match (let (a, _) := k in a) with
        | 0 => false
        | S m' =>
            (fix leb (n m : nat) {struct n} : bool :=
               match n with
               | 0 => true
               | S n' => match m with
                         | 0 => false
                         | S m'0 => leb n' m'0
                         end
               end) (let (a, _) := y in a) m'
        end = true =>
 exist
   (fun k : nat =>
    (fix leb (n m : nat) {struct n} : bool :=
       match n with
       | 0 => true
       | S n' => match m with
                 | 0 => false
                 | S m' => leb n' m'
                 end
       end) k (S n) = true) (let (a, _) := y in a)
   (ltN_intro_lemma1 (S n) k y E1))
else
(fun
   E1 : match (let (a, _) := k in a) with
        | 0 => false
        | S m' =>
            (fix leb (n m : nat) {struct n} : bool :=
               match n with
               | 0 => true
               | S n' => match m with
                         | 0 => false
                         | S m'0 => leb n' m'0
                         end
               end) (let (a, _) := y in a) m'
        end = false =>
 exist
   (fun k : nat =>
    (fix leb (n m : nat) {struct n} : bool :=
       match n with
       | 0 => true
       | S n' => match m with
                 | 0 => false
                 | S m' => leb n' m'
                 end
       end) k (S n) = true) (S (let (a, _) := y in a))
   (ltN_intro_lemma2 (S n) k y E1))
Axioms:
ClassicalDedekindReals.sig_not_dec : forall P : Prop, {~ ~ P} + {~ P}
ClassicalDedekindReals.sig_forall_dec
  : forall P : nat -> Prop,
    (forall n : nat, {P n} + {~ P n}) ->
    {n : nat | ~ P n} + {forall n : nat, P n}
prop_ext : ClassicalFacts.prop_extensionality
lib.Axioms.proof_irr : ClassicalFacts.proof_irrelevance
Clight_core.inline_external_call_mem_events
  : forall (ef : external_function) (ge : Senv.t) 
      (vargs : list val) (m : mem) (t : Events.trace) 
      (vres : val) (m' : mem),
    ef_inline ef = true ->
    Events.external_call ef ge vargs m t vres m' ->
    {trace : list event_semantics.mem_event
    | event_semantics.ev_elim m trace m'}
Events.inline_assembly_sem : string -> signature -> Events.extcall_sem
functional_extensionality_dep
  : forall (A : Type) (B : A -> Type) (f g : forall x : A, B x),
    (forall x : A, f x = g x) -> f = g
Events.external_functions_sem : string -> signature -> Events.extcall_sem
Eqdep.Eq_rect_eq.eq_rect_eq
  : forall (U : Type) (p : U) (Q : U -> Type) (x : Q p) (h : p = p),
    x = eq_rect p Q x p h
Classical_Prop.classic : forall P : Prop, P \/ ~ P
Crunching: (LS > 0)
Crunching: (LS > 0)
Crunching: (LS > 0)
Crunching: (LS > 0)
Crunching: (0 <= LS)
Crunching: (LS = (0 * 1)%R)
Crunching: (0 <= LS)
Crunching: (LS = (0 * 1)%R)
rewrite if_dtt
if
match (let (a, _) := k in a) with
| 0 => false
| S m' =>
    (fix leb (n m : nat) {struct n} : bool :=
       match n with
       | 0 => true
       | S n' => match m with
                 | 0 => false
                 | S m'0 => leb n' m'0
                 end
       end) (let (a, _) := x in a) m'
end
then
(fun
   E1 : match (let (a, _) := k in a) with
        | 0 => false
        | S m' =>
            (fix leb (n m : nat) {struct n} : bool :=
               match n with
               | 0 => true
               | S n' => match m with
                         | 0 => false
                         | S m'0 => leb n' m'0
                         end
               end) (let (a, _) := x in a) m'
        end = true =>
 exist
   (fun k : nat =>
    (fix leb (n m : nat) {struct n} : bool :=
       match n with
       | 0 => true
       | S n' => match m with
                 | 0 => false
                 | S m' => leb n' m'
                 end
       end) k (S n) = true) (let (a, _) := x in a)
   (ltN_intro_lemma1 (S n) k x E1))
else
(fun
   E1 : match (let (a, _) := k in a) with
        | 0 => false
        | S m' =>
            (fix leb (n m : nat) {struct n} : bool :=
               match n with
               | 0 => true
               | S n' => match m with
                         | 0 => false
                         | S m'0 => leb n' m'0
                         end
               end) (let (a, _) := x in a) m'
        end = false =>
 exist
   (fun k : nat =>
    (fix leb (n m : nat) {struct n} : bool :=
       match n with
       | 0 => true
       | S n' => match m with
                 | 0 => false
                 | S m' => leb n' m'
                 end
       end) k (S n) = true) (S (let (a, _) := x in a))
   (ltN_intro_lemma2 (S n) k x E1))
rewrite if_dtt
if
match (let (a, _) := k in a) with
| 0 => false
| S m' =>
    (fix leb (n m : nat) {struct n} : bool :=
       match n with
       | 0 => true
       | S n' => match m with
                 | 0 => false
                 | S m'0 => leb n' m'0
                 end
       end) (let (a, _) := y in a) m'
end
then
(fun
   E1 : match (let (a, _) := k in a) with
        | 0 => false
        | S m' =>
            (fix leb (n m : nat) {struct n} : bool :=
               match n with
               | 0 => true
               | S n' => match m with
                         | 0 => false
                         | S m'0 => leb n' m'0
                         end
               end) (let (a, _) := y in a) m'
        end = true =>
 exist
   (fun k : nat =>
    (fix leb (n m : nat) {struct n} : bool :=
       match n with
       | 0 => true
       | S n' => match m with
                 | 0 => false
                 | S m' => leb n' m'
                 end
       end) k (S n) = true) (let (a, _) := y in a)
   (ltN_intro_lemma1 (S n) k y E1))
else
(fun
   E1 : match (let (a, _) := k in a) with
        | 0 => false
        | S m' =>
            (fix leb (n m : nat) {struct n} : bool :=
               match n with
               | 0 => true
               | S n' => match m with
                         | 0 => false
                         | S m'0 => leb n' m'0
                         end
               end) (let (a, _) := y in a) m'
        end = false =>
 exist
   (fun k : nat =>
    (fix leb (n m : nat) {struct n} : bool :=
       match n with
       | 0 => true
       | S n' => match m with
                 | 0 => false
                 | S m' => leb n' m'
                 end
       end) k (S n) = true) (S (let (a, _) := y in a))
   (ltN_intro_lemma2 (S n) k y E1))
Crunching: (N = H5)
Crunching: (N = H5)
Crunching: (N = H5)
Crunching: (N = H5)
Crunching:
(forall A B : Matrix Hn Hm,
 WF_Matrix A ->
 WF_Matrix B ->
 (forall k : nat, k < Hm -> A × basis_vector Hm k = B × basis_vector Hm k) ->
 A = B)
Crunching:
((forall k : nat, k < m -> p × basis_vector m k = q × basis_vector m k) ->
 p = q)
Crunching:
((forall k : nat, k < m -> p × basis_vector m k = q × basis_vector m k) ->
 p = q)
Crunching:
((forall k : nat, k < m -> p × basis_vector m k = q × basis_vector m k) ->
 p = q)
Crunching:
((forall k : nat, k < m -> p × basis_vector m k = q × basis_vector m k) ->
 p = q)
Crunching:
((forall k : nat, k < m -> p × basis_vector m k = q × basis_vector m k) ->
 p = q)
Crunching:
((forall k : nat, k < m -> p × basis_vector m k = q × basis_vector m k) ->
 p = q)
Crunching: (fst (A' x y) = fst (B' x y))
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 n (ltN_pred_lemma0 k k0 E)))
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 n (ltN_pred_lemma0 k k0 E)))
Crunching:
(WF_Matrix env ->
 (forall k : nat, k < H -> H6 × basis_vector H k = env × basis_vector H k) ->
 H6 = env)
     = @^~ 8
     : M nat
     = tt
     : [the monad of idfun] unit
     = @^~ None
     : [the contMonad of ContMonad.acto bool] (option nat)
     = @^~ (Some 3)
     : [the contMonad of ContMonad.acto bool] (option nat)
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 n (ltN_pred_lemma0 k k0 E)))
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 n (ltN_pred_lemma0 k k0 E)))
     = @^~ 8
     : M nat
     = tt
     : [the monad of idfun] unit
     = @^~ None
     : [the contMonad of ContMonad.acto bool] (option nat)
     = @^~ (Some 3)
     : [the contMonad of ContMonad.acto bool] (option nat)
Crunching:
((fun i j : nat => if (i =? x * 2 ^ n + y) && (j =? 0) then C1 else 0%R) =
 (fun x0 y0 : nat =>
  ((if (x0 / 2 ^ n =? x) && (y0 / 1 =? 0) then C1 else 0%R) *
   (if (x0 mod 2 ^ n =? y) && (y0 mod 1 =? 0) then C1 else 0%R))%C))
Crunching:
(∣0⟩ ⊗ (fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) =
 (fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R))
Crunching:
(∣1⟩ ⊗ (fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) =
 (fun i j : nat => if (i =? k + n) && (j =? 0) then C1 else 0%R))
Crunching:
((fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩ =
 (fun i j : nat => if (i =? 2 * k) && (j =? 0) then C1 else 0%R))
Crunching:
((fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) ⊗ ∣1⟩ =
 (fun i j : nat => if (i =? 2 * k + 1) && (j =? 0) then C1 else 0%R))
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣1⟩ = basis_vector 2 1)
clear  H0a'  :  (False -> cmpA a a' <> Lt)
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 (ltN_count (stail p)) (ltN_pred_lemma0 k k0 E)))
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 (ltN_count (stail p)) (ltN_pred_lemma0 k k0 E)))
rewrite if_dtt
if (proj1_sig k1 + proj1_sig k2 <? n)
then
(fun E : (proj1_sig k1 + proj1_sig k2 <? n) = true =>
 ltN_of_nat (proj1_sig k1 + proj1_sig k2) n E)
else
(fun E : (proj1_sig k1 + proj1_sig k2 <? n) = false =>
 ltN_of_nat (proj1_sig k1 + proj1_sig k2 - n) n (ltN_plus_mod_lemma1 k1 k2 E))
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 0 - 42 [Require~Import~Basics.Overture...] 0.016 secs (0.009u,0.006s)
Chars 260 - 319 [Ltac~show_goal~:=~match~goal~w...] 0. secs (0.u,0.s)
Chars 321 - 550 [Ltac~~show_hyp~id~:=~~~match~g...] 0. secs (0.u,0.s)
Chars 552 - 657 [Ltac~~show_hyps~:=~try~match~r...] 0. secs (0.u,0.s)
Chars 709 - 803 [Ltac~do_nat~n~tac~:=~match~n~w...] 0. secs (0.u,0.s)
Chars 858 - 947 [Ltac~~on_last_hyp~tac~:=~match...] 0. secs (0.u,0.s)
Chars 1008 - 1095 [Ltac~destruct_one_pair~:=~matc...] 0. secs (0.u,0.s)
Chars 1133 - 1183 [Ltac~destruct_pairs~:=~repeat~...] 0. secs (0.u,0.s)
Chars 1287 - 1443 [Ltac~~destruct_one_ex~:=~~~let...] 0. secs (0.u,0.s)
Chars 1488 - 1537 [Ltac~destruct_exists~:=~repeat...] 0. secs (0.u,0.s)
Chars 1599 - 1668 [Ltac~destruct_conjs~:=~repeat~...] 0. secs (0.u,0.s)
Chars 1791 - 1869 [Tactic~Notation~"destruct"~"ex...] 0. secs (0.u,0.s)
Chars 1937 - 2001 [Tactic~Notation~"destruct"~"or...] 0. secs (0.u,0.s)
Chars 2065 - 2193 [Ltac~discriminates~:=~match~go...] 0. secs (0.u,0.s)
Chars 2231 - 2306 [Ltac~revert_last~:=~match~goal...] 0. secs (0.u,0.s)
Chars 2388 - 2423 [Ltac~reverse~:=~repeat~revert_...] 0. secs (0.u,0.s)
Chars 2488 - 2633 [Ltac~~revert_until~id~:=~~~on_...] 0. secs (0.u,0.s)
Chars 2671 - 2917 [Ltac~~clear_dup~:=~~~match~goa...] 0. secs (0.u,0.s)
Chars 2919 - 2955 [Ltac~clear_dups~:=~repeat~clea...] 0. secs (0.u,0.s)
Chars 3005 - 3182 [Ltac~~clear_except~hyp~:=~~~re...] 0. secs (0.u,0.s)
Chars 3250 - 3278 [Ltac~subst_no_fail~:=~idtac.] 0. secs (0.u,0.s)
Chars 3395 - 3440 [Tactic~Notation~"subst"~"*"~:=...] 0. secs (0.u,0.s)
Chars 3442 - 3980 [Ltac~~on_application~f~tac~T~:...] 0. secs (0.u,0.s)
Chars 4082 - 4212 [Ltac~~on_call~f~tac~:=~~~match...] 0. secs (0.u,0.s)
Chars 4308 - 4377 [Ltac~destruct_call~f~:=~let~ta...] 0. secs (0.u,0.s)
Chars 4379 - 4427 [Ltac~destruct_calls~f~:=~repea...] 0. secs (0.u,0.s)
Chars 4429 - 4540 [Ltac~~destruct_call_in~f~H~:=~...] 0. secs (0.u,0.s)
Chars 4542 - 4621 [Ltac~destruct_call_as~f~l~:=~l...] 0. secs (0.u,0.s)
Chars 4623 - 4744 [Ltac~~destruct_call_as_in~f~l~...] 0. secs (0.u,0.s)
Chars 4746 - 4807 [Tactic~Notation~"destruct_call...] 0. secs (0.u,0.s)
Chars 4876 - 4972 [Tactic~Notation~"destruct_call...] 0. secs (0.u,0.s)
Chars 5039 - 5121 [Tactic~Notation~"destruct_call...] 0. secs (0.u,0.s)
Chars 5123 - 5238 [Tactic~Notation~~"destruct_cal...] 0. secs (0.u,0.s)
Chars 5285 - 5330 [Definition~fix_proto~{A~:~Type...] 0. secs (0.u,0.s)
Chars 5332 - 5444 [Ltac~~destruct_rec_calls~:=~~~...] 0. secs (0.u,0.s)
Chars 5446 - 5529 [Ltac~~destruct_all_rec_calls~:...] 0. secs (0.u,0.s)
Chars 5600 - 5632 [Ltac~autoinjection~tac~:=~idtac.] 0. secs (0.u,0.s)
Chars 5721 - 5792 [Ltac~inject~H~:=~progress~(inv...] 0. secs (0.u,0.s)
Chars 5794 - 5867 [Ltac~autoinjections~:=~repeat~...] 0. secs (0.u,0.s)
Chars 5943 - 6021 [Ltac~~destruct_nondep~H~:=~let...] 0. secs (0.u,0.s)
Chars 6123 - 6250 [Ltac~~bang~:=~~~match~goal~wit...] 0. secs (0.u,0.s)
Chars 6347 - 6462 [Tactic~Notation~"contradiction...] 0. secs (0.u,0.s)
Chars 6620 - 6813 [Ltac~~add_hypothesis~H'~p~:=~~...] 0. secs (0.u,0.s)
Chars 6874 - 6972 [Ltac~~replace_hyp~H~c~:=~~~let...] 0. secs (0.u,0.s)
Chars 7051 - 7363 [Ltac~~refine_hyp~c~:=~~~let~ta...] 0. secs (0.u,0.s)
Chars 7626 - 7866 [Ltac~~program_simplify~:=~~~si...] 0. secs (0.u,0.s)
Chars 7926 - 8073 [Ltac~~program_solve_wf~:=~~~ma...] 0. secs (0.u,0.s)
Chars 8075 - 8111 [Create~HintDb~program~discrimi...] 0. secs (0.u,0.s)
Chars 8113 - 8212 [Ltac~~program_simpl~:=~~~progr...] 0. secs (0.u,0.s)
Chars 8214 - 8249 [Obligation~Tactic~:=~program_s...] 0. secs (0.u,0.s)
Chars 8251 - 8297 [Definition~obligation~(A~:~Typ...] 0. secs (0.u,0.s)
Chars 8532 - 8789 [Tactic~Notation~"clear"~"depen...] 0. secs (0.u,0.s)
Chars 8894 - 8966 [Tactic~Notation~"revert"~"depe...] 0. secs (0.u,0.s)
Chars 9036 - 10609 [Tactic~Notation~"do_with_holes...] 0. secs (0.u,0.s)
Chars 10664 - 12238 [Tactic~Notation~"do_with_holes...] 0. secs (0.u,0.s)
Chars 12351 - 12379 [Unset~Primitive~Projections.] 0. secs (0.u,0.s)
Chars 12380 - 12417 [Class~IsGlobalAxiom~(A~:~Type)...] 0. secs (0.u,0.s)
Chars 12418 - 12444 [Set~Primitive~Projections.] 0. secs (0.u,0.s)
Chars 12445 - 12500 [#[global]Hint~Mode~IsGlobalAxi...] 0. secs (0.u,0.s)
Chars 12576 - 12644 [#[global]Instance~is_global_ax...] 0. secs (0.u,0.s)
Chars 12646 - 12719 [Ltac~is_global_axiom~A~:=~let~...] 0. secs (0.u,0.s)
Chars 12721 - 12809 [Ltac~~global_axiom~:=~try~matc...] 0. secs (0.u,0.s)
Chars 12854 - 12916 [Tactic~Notation~"srefine"~ucon...] 0. secs (0.u,0.s)
Chars 12995 - 13078 [Tactic~Notation~"nrefine"~ucon...] 0. secs (0.u,0.s)
Chars 13164 - 13255 [Tactic~Notation~"snrefine"~uco...] 0. secs (0.u,0.s)
Chars 13575 - 13663 [Tactic~Notation~"rapply"~ucons...] 0. secs (0.u,0.s)
Chars 13664 - 13754 [Tactic~Notation~"rapply'"~ucon...] 0. secs (0.u,0.s)
Chars 13756 - 13846 [Tactic~Notation~"srapply"~ucon...] 0. secs (0.u,0.s)
Chars 13847 - 13939 [Tactic~Notation~"srapply'"~uco...] 0. secs (0.u,0.s)
Chars 13941 - 14031 [Tactic~Notation~"nrapply"~ucon...] 0. secs (0.u,0.s)
Chars 14032 - 14124 [Tactic~Notation~"nrapply'"~uco...] 0. secs (0.u,0.s)
Chars 14126 - 14218 [Tactic~Notation~"snrapply"~uco...] 0. secs (0.u,0.s)
Chars 14219 - 14313 [Tactic~Notation~"snrapply'"~uc...] 0. secs (0.u,0.s)
Chars 14369 - 14718 [Ltac~~done~:=~~~trivial;~intro...] 0. secs (0.u,0.s)
Chars 14720 - 14768 [Tactic~Notation~"by"~tactic(ta...] 0. secs (0.u,0.s)
Chars 14832 - 15145 [Ltac~~by_extensionality~x~:=~~...] 0. secs (0.u,0.s)
Chars 15423 - 15504 [Tactic~Notation~"funext"~simpl...] 0. secs (0.u,0.s)
Chars 15505 - 15601 [Tactic~Notation~"funext"~simpl...] 0. secs (0.u,0.s)
Chars 15602 - 15730 [Tactic~Notation~~"funext"~simp...] 0. secs (0.u,0.s)
Chars 15731 - 15892 [Tactic~Notation~~"funext"~simp...] 0. secs (0.u,0.s)
Chars 15893 - 16087 [Tactic~Notation~~"funext"~simp...] 0. secs (0.u,0.s)
Chars 16088 - 16315 [Tactic~Notation~~"funext"~simp...] 0. secs (0.u,0.s)
Chars 16421 - 16504 [Ltac~assert_fails~tac~:=~tryif...] 0. secs (0.u,0.s)
Chars 16505 - 16596 [Ltac~~assert_succeeds~tac~:=~~...] 0. secs (0.u,0.s)
Chars 16597 - 16669 [Tactic~Notation~"assert_succee...] 0. secs (0.u,0.s)
Chars 16670 - 16736 [Tactic~Notation~"assert_fails"...] 0. secs (0.u,0.s)
Chars 16862 - 17018 [Ltac~~path_induction~:=~~~intr...] 0. secs (0.u,0.s)
Chars 17850 - 18072 [Ltac~~f_ap~:=~~~idtac;~~~~lazy...] 0. secs (0.u,0.s)
Chars 18203 - 18462 [Ltac~~expand~:=~~~idtac;~~~~ma...] 0. secs (0.u,0.s)
Chars 18781 - 19404 [Ltac~~atomic~x~:=~~~idtac;~~~~...] 0. secs (0.u,0.s)
Chars 19452 - 19531 [Ltac~head~expr~:=~match~expr~w...] 0. secs (0.u,0.s)
Chars 19612 - 20032 [Ltac~~get_constructor_head~T~:...] 0. secs (0.u,0.s)
Chars 20100 - 20239 [Ltac~~ntc_constructor~:=~~~laz...] 0. secs (0.u,0.s)
Chars 20409 - 20539 [Ltac~~case_path~x~:=~~~let~x'~...] 0. secs (0.u,0.s)
Chars 20700 - 20858 [Ltac~~revert_opaque~x~:=~~~rev...] 0. secs (0.u,0.s)
Chars 21036 - 21456 [Tactic~Notation~"transparent"~...] 0. secs (0.u,0.s)
Chars 21580 - 21756 [Tactic~Notation~~"transparent"...] 0. secs (0.u,0.s)
Chars 21757 - 21875 [Tactic~Notation~~"transparent"...] 0. secs (0.u,0.s)
Chars 21876 - 22019 [Tactic~Notation~~"transparent"...] 0. secs (0.u,0.s)
Chars 22082 - 22211 [Ltac~~remember_as~term~name~eq...] 0. secs (0.u,0.s)
Chars 22213 - 22325 [Tactic~Notation~"remember"~con...] 0. secs (0.u,0.s)
Chars 22396 - 22519 [Ltac~~recall_as~term~name~eqna...] 0. secs (0.u,0.s)
Chars 22521 - 22629 [Tactic~Notation~"recall"~const...] 0. secs (0.u,0.s)
Chars 22747 - 22946 [Ltac~~rel_hnf~:=~~~idtac;~~~~m...] 0. secs (0.u,0.s)
Chars 23295 - 23542 [Ltac~~tryif_cps~require~if_yes...] 0. secs (0.u,0.s)
Chars 24252 - 24455 [#[local]~Ltac~~peel_evars~term...] 0. secs (0.u,0.s)
Chars 24457 - 24737 [#[local]~Ltac~~pi_to_sig~ty~:=...] 0. secs (0.u,0.s)
Chars 24739 - 24844 [#[local]~Ltac~~ctor_to_sig~cto...] 0. secs (0.u,0.s)
Chars 24846 - 25005 [#[local]~Ltac~~unify_first_eva...] 0. secs (0.u,0.s)
Chars 25007 - 25228 [#[local]~Ltac~~unify_with_proj...] 0. secs (0.u,0.s)
Chars 25308 - 25509 [#[local]~Ltac~~refine_with_exi...] 0. secs (0.u,0.s)
Chars 25558 - 26965 [Ltac~~issig~:=~~~hnf;~~~~(let~...] 0. secs (0.u,0.s)
Chars 27029 - 27105 [Definition~issig_contr~(A~:~Ty...] 0. secs (0.u,0.s)
Chars 27106 - 27112 [Proof.] 0. secs (0.u,0.s)
Chars 27115 - 27121 [issig.] 0.046 secs (0.004u,0.011s)
Chars 27115 - 27121 [issig.] 0. secs (0.u,0.s)
Chars 27122 - 27130 [Defined.] 0.001 secs (0.001u,0.s)
Chars 27132 - 27211 [Definition~issig_equiv~(A~B~:~...] 0. secs (0.u,0.s)
Chars 27212 - 27218 [Proof.] 0. secs (0.u,0.s)
Chars 27221 - 27227 [issig.] 0.034 secs (0.005u,0.009s)
Chars 27221 - 27227 [issig.] 0. secs (0.u,0.s)
Chars 27228 - 27236 [Defined.] 0.001 secs (0.001u,0.s)
Chars 27238 - 27410 [Definition~issig_isequiv~{A~B~...] 0.002 secs (0.001u,0.s)
Chars 27411 - 27417 [Proof.] 0. secs (0.u,0.s)
Chars 27420 - 27426 [issig.] 0.189 secs (0.045u,0.036s)
Chars 27420 - 27426 [issig.] 0. secs (0.u,0.s)
Chars 27427 - 27435 [Defined.] 0.017 secs (0.007u,0.009s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 67 - 105 [Require~Import~Overture~PathGr...] 0.119 secs (0.082u,0.036s)
Chars 106 - 134 [#[local]Open~Scope~path_scope.] 0. secs (0.u,0.s)
Chars 439 - 469 [Generalizable~Variables~A~B~f.] 0. secs (0.u,0.s)
Chars 576 - 655 [Definition~path_contr~`{Contr~...] 0.001 secs (0.u,0.s)
Chars 770 - 836 [Definition~path2_contr~`{Contr...] 0. secs (0.u,0.s)
Chars 837 - 843 [Proof.] 0. secs (0.u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 44 - 176 [Require~Import~Basics.Overture...] 0.16 secs (0.138u,0.021s)
Chars 177 - 206 [#[local]Open~Scope~trunc_scope.] 0. secs (0.u,0.s)
Chars 207 - 235 [#[local]Open~Scope~path_scope.] 0. secs (0.u,0.s)
Chars 433 - 481 [Class~Decidable~(A~:~Type)~:=~...] 0.001 secs (0.u,0.s)
Chars 482 - 502 [Arguments~dec~A~{_}.] 0. secs (0.u,0.s)
Chars 654 - 777 [Ltac~~decide_type~A~:=~~~let~K...] 0. secs (0.u,0.s)
Chars 779 - 847 [Ltac~decide~:=~match~goal~with...] 0. secs (0.u,0.s)
Chars 849 - 934 [Class~DecidablePaths~(A~:~Type...] 0. secs (0.u,0.s)
Chars 935 - 970 [#[global]Existing~Instance~dec...] 0. secs (0.u,0.s)
Chars 972 - 1008 [Class~Stable~P~:=~~~~~stable~:...] 0.003 secs (0.003u,0.s)
Chars 1010 - 1072 [#[global]Instance~stable_decid...] 0. secs (0.u,0.s)
Chars 1073 - 1079 [Proof.] 0. secs (0.u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 80 - 107 [Require~Import~HoTT.Basics.] 0.174 secs (0.142u,0.032s)
Chars 109 - 137 [#[local]Open~Scope~path_scope.] 0. secs (0.u,0.s)
Chars 139 - 175 [Generalizable~Variables~A~B~f~...] 0. secs (0.u,0.s)
Chars 623 - 748 [Definition~transport_paths_l~{...] 0.001 secs (0.u,0.s)
Chars 749 - 755 [Proof.] 0. secs (0.u,0.s)
Chars 758 - 785 [(destruct~p,~q;~reflexivity).] 0.023 secs (0.003u,0.001s)
Chars 758 - 785 [(destruct~p,~q;~reflexivity).] 0. secs (0.u,0.s)
Chars 786 - 794 [Defined.] 0. secs (0.u,0.s)
Chars 796 - 920 [Definition~transport_paths_r~{...] 0. secs (0.u,0.s)
Chars 921 - 927 [Proof.] 0. secs (0.u,0.s)
Chars 930 - 957 [(destruct~p,~q;~reflexivity).] 0.021 secs (0.001u,0.001s)
Chars 930 - 957 [(destruct~p,~q;~reflexivity).] 0. secs (0.u,0.s)
Chars 958 - 966 [Defined.] 0. secs (0.u,0.s)
Chars 968 - 1097 [Definition~transport_paths_lr~...] 0. secs (0.u,0.s)
Chars 1098 - 1104 [Proof.] 0. secs (0.u,0.s)
Chars 0 - 22 [Require~Import~Basics.] 0.218 secs (0.148u,0.069s)
Chars 23 - 47 [Require~Import~Pos.Core.] 0.006 secs (0.004u,0.001s)
Chars 49 - 81 [#[local]Open~Scope~positive_sc...] 0. secs (0.u,0.s)
Chars 135 - 176 [Lemma~pos_add_1_r~p~:~p~+~1~=~...] 0. secs (0.u,0.s)
Chars 177 - 183 [Proof.] 0. secs (0.u,0.s)
Chars 186 - 200 [by~destruct~p.] 0.145 secs (0.001u,0.006s)
Chars 186 - 200 [by~destruct~p.] 0. secs (0.u,0.s)
Chars 201 - 205 [Qed.] 0. secs (0.u,0.s)
Chars 207 - 248 [Lemma~pos_add_1_l~p~:~1~+~p~=~...] 0. secs (0.u,0.s)
Chars 249 - 255 [Proof.] 0. secs (0.u,0.s)
Chars 258 - 272 [by~destruct~p.] 0.019 secs (0.002u,0.005s)
Chars 258 - 272 [by~destruct~p.] 0. secs (0.u,0.s)
Chars 273 - 277 [Qed.] 0. secs (0.u,0.s)
Chars 319 - 389 [Theorem~pos_add_carry_spec~p~q...] 0. secs (0.u,0.s)
Chars 390 - 396 [Proof.] 0. secs (0.u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 36 - 81 [Require~Import~Category.Core~C...] 0.018 secs (0.015u,0.002s)
Chars 26 - 56 [Require~Import~Basics.Tactics.] 0.011 secs (0.009u,0.001s)
Chars 57 - 102 [Require~Import~Category.Core~C...] 0.012 secs (0.008u,0.003s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 45 - 67 [Require~Import~Basics.] 0.222 secs (0.157u,0.064s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 68 - 96 [Require~Import~WildCat.Core.] 0.031 secs (0.017u,0.014s)
Chars 139 - 254 [#[global]~Instance~isgraph_for...] 0. secs (0.u,0.s)
Chars 255 - 261 [Proof.] 0. secs (0.u,0.s)
Chars 0 - 22 [Require~Import~Basics.] 0.223 secs (0.16u,0.062s)
Chars 264 - 286 [srapply~Build_IsGraph.] 0.032 secs (0.001u,0.009s)
Chars 289 - 337 [(intros~x~y;~exact~(forall~a~:...] 0.001 secs (0.001u,0.s)
Chars 264 - 286 [srapply~Build_IsGraph.] 0. secs (0.u,0.s)
Chars 289 - 337 [(intros~x~y;~exact~(forall~a~:...] 0. secs (0.u,0.s)
Chars 338 - 346 [Defined.] 0. secs (0.u,0.s)
Chars 348 - 490 [#[global]~Instance~is01cat_for...] 0.001 secs (0.001u,0.s)
Chars 491 - 497 [Proof.] 0. secs (0.u,0.s)
Chars 23 - 49 [Require~Import~Spaces.Pos.] 0.059 secs (0.04u,0.018s)
Chars 75 - 105 [#[local]Close~Scope~trunc_scope.] 0. secs (0.u,0.s)
Chars 106 - 134 [#[local]Close~Scope~nat_scope.] 0. secs (0.u,0.s)
Chars 136 - 168 [#[local]Open~Scope~positive_sc...] 0. secs (0.u,0.s)
Chars 327 - 409 [Inductive~Int~:~Type0~:=~~~|~n...] 0.001 secs (0.u,0.s)
Chars 411 - 435 [Declare~Scope~int_scope.] 0. secs (0.u,0.s)
Chars 436 - 463 [#[local]Open~Scope~int_scope.] 0. secs (0.u,0.s)
Chars 464 - 497 [Delimit~Scope~int_scope~with~int.] 0. secs (0.u,0.s)
Chars 538 - 592 [#[global]Instance~ispointed_In...] 0. secs (0.u,0.s)
Chars 629 - 790 [Definition~neg_inj~{z~w~:~Pos}...] 0.001 secs (0.001u,0.s)
Chars 792 - 953 [Definition~pos_inj~{z~w~:~Pos}...] 0. secs (0.u,0.s)
Chars 955 - 1124 [Definition~neg_neq_zero~{z~:~P...] 0.001 secs (0.001u,0.s)
Chars 1126 - 1296 [Definition~pos_neq_zero~{z~:~P...] 0. secs (0.u,0.s)
Chars 1298 - 1470 [Definition~neg_neq_pos~{z~w~:~...] 0.001 secs (0.u,0.001s)
Chars 1472 - 1540 [Definition~zero_neq_neg~{z~:~P...] 0.001 secs (0.001u,0.s)
Chars 1542 - 1610 [Definition~zero_neq_pos~{z~:~P...] 0.001 secs (0.u,0.s)
Chars 1612 - 1682 [Definition~pos_neq_neg~{z~w~:~...] 0.001 secs (0.001u,0.s)
Chars 1757 - 1960 [Definition~int_to_decimal_int~...] 0. secs (0.u,0.s)
Chars 1962 - 2058 [Definition~int_to_number_int~(...] 0. secs (0.u,0.s)
Chars 2060 - 2672 [Fixpoint~int_of_decimal_uint~(...] 0.001 secs (0.001u,0.s)
Chars 2674 - 2936 [Definition~int_of_decimal_int~...] 0. secs (0.u,0.s)
Chars 2938 - 3088 [Definition~int_of_number_int~(...] 0. secs (0.u,0.s)
Chars 3090 - 3158 [Number~Notation~Int~int_of_num...] 0. secs (0.u,0.s)
Chars 3265 - 3298 [Notation~"0"~:=~zero~:~int_scope.] 0. secs (0.u,0.s)
Chars 3333 - 3440 [Definition~int_double~x~:=~~~m...] 0. secs (0.u,0.s)
Chars 3442 - 3570 [Definition~int_succ_double~x~:...] 0. secs (0.u,0.s)
Chars 3572 - 3708 [Definition~int_pred_double~x~:...] 0. secs (0.u,0.s)
Chars 3754 - 4180 [Fixpoint~int_pos_sub~(x~y~:~Po...] 0.001 secs (0.u,0.s)
Chars 4202 - 4313 [Definition~int_negation~x~:=~~...] 0. secs (0.u,0.s)
Chars 4315 - 4362 [Notation~"-~x"~:=~(int_negatio...] 0. secs (0.u,0.s)
Chars 4364 - 4404 [Lemma~int_negation_negation~n~...] 0. secs (0.u,0.s)
Chars 4405 - 4411 [Proof.] 0. secs (0.u,0.s)
Chars 103 - 129 [Require~Import~Types.Prod.] 0.287 secs (0.193u,0.093s)
Chars 131 - 157 [Set~Universe~Polymorphism.] 0. secs (0.u,0.s)
Chars 158 - 181 [Set~Implicit~Arguments.] 0. secs (0.u,0.s)
Chars 182 - 210 [Generalizable~Variables~all.] 0. secs (0.u,0.s)
Chars 211 - 235 [Set~Asymmetric~Patterns.] 0. secs (0.u,0.s)
Chars 237 - 269 [#[local]Open~Scope~category_sc...] 0. secs (0.u,0.s)
Chars 270 - 302 [#[local]Open~Scope~morphism_sc...] 0. secs (0.u,0.s)
Chars 347 - 360 [Section~prod.] 0. secs (0.u,0.s)
Chars 363 - 391 [Variables~(C~D~:~PreCategory).] 0. secs (0.u,0.s)
Chars 395 - 425 [Definition~prod~:~PreCategory.] 0. secs (0.u,0.s)
Chars 82 - 110 [Require~Import~Types.Forall.] 0.321 secs (0.227u,0.093s)
Chars 112 - 138 [Set~Universe~Polymorphism.] 0. secs (0.u,0.s)
Chars 139 - 162 [Set~Implicit~Arguments.] 0. secs (0.u,0.s)
Chars 163 - 191 [Generalizable~Variables~all.] 0. secs (0.u,0.s)
Chars 192 - 216 [Set~Asymmetric~Patterns.] 0. secs (0.u,0.s)
Chars 218 - 250 [#[local]Open~Scope~category_sc...] 0. secs (0.u,0.s)
Chars 251 - 283 [#[local]Open~Scope~morphism_sc...] 0. secs (0.u,0.s)
Chars 341 - 352 [Section~pi.] 0. secs (0.u,0.s)
Chars 355 - 373 [Context~`{Funext}.] 0. secs (0.u,0.s)
Chars 376 - 394 [Variable~(A~:~Type).] 0. secs (0.u,0.s)
Chars 397 - 427 [Variable~(P~:~A~->~PreCategory).] 0. secs (0.u,0.s)
Chars 431 - 459 [Definition~pi~:~PreCategory.] 0. secs (0.u,0.s)
Chars 0 - 22 [Require~Import~Basics.] 0.217 secs (0.149u,0.067s)
Chars 54 - 86 [#[local]Unset~Elimination~Sche...] 0. secs (0.u,0.s)
Chars 88 - 116 [Module~Export~GraphQuotient.] 0. secs (0.u,0.s)
Chars 120 - 248 [#[private(matching)]~Inductive...] 0. secs (0.u,0.s)
Chars 252 - 273 [Arguments~gq~{A~R}~a.] 0. secs (0.u,0.s)
Chars 277 - 404 [Axiom~~~(gqglue@{i~j~u}~:~~~~~...] 0. secs (0.u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 408 - 722 [Definition~GraphQuotient_ind@{...] 0.002 secs (0.001u,0.001s)
Chars 726 - 1061 [Axiom~~~(GraphQuotient_ind_bet...] 0.004 secs (0.002u,0.002s)
Chars 1063 - 1081 [End~GraphQuotient.] 0. secs (0.u,0.s)
Chars 1083 - 1104 [Arguments~gq~{A~R}~a.] 0. secs (0.u,0.s)
Chars 0 - 22 [Require~Import~Basics.] 0.178 secs (0.138u,0.04s)
Chars 1107 - 1219 [Definition~GraphQuotient_rec~{...] 0. secs (0.u,0.s)
Chars 1220 - 1226 [Proof.] 0. secs (0.u,0.s)
Chars 231 - 309 [Inductive~Pos~:~Type0~:=~~~|~x...] 0.001 secs (0.001u,0.s)
Chars 311 - 340 [Declare~Scope~positive_scope.] 0. secs (0.u,0.s)
Chars 341 - 379 [Delimit~Scope~positive_scope~w...] 0. secs (0.u,0.s)
Chars 468 - 504 [Notation~"1"~:=~xH~:~positive_...] 0. secs (0.u,0.s)
Chars 505 - 549 [Notation~"p~~~1"~:=~(x1~p)~:~p...] 0. secs (0.u,0.s)
Chars 550 - 594 [Notation~"p~~~0"~:=~(x0~p)~:~p...] 0. secs (0.u,0.s)
Chars 596 - 628 [#[local]Open~Scope~positive_sc...] 0. secs (0.u,0.s)
Chars 82 - 109 [Require~Import~HoTT.Basics.] 0.176 secs (0.14u,0.036s)
Chars 650 - 754 [Fixpoint~pos_succ~x~:=~~~match...] 0. secs (0.u,0.s)
Chars 110 - 138 [#[local]Open~Scope~path_scope.] 0. secs (0.u,0.s)
Chars 140 - 166 [Generalizable~Variable~A.] 0. secs (0.u,0.s)
Chars 194 - 264 [Definition~eta_unit~(z~:~Unit)...] 0. secs (0.u,0.s)
Chars 804 - 1094 [Fixpoint~pos_peano_ind~(P~:~Po...] 0. secs (0.u,0.s)
Chars 347 - 456 [Definition~path_unit_uncurried...] 0. secs (0.u,0.s)
Chars 458 - 535 [Definition~path_unit~(z~z'~:~U...] 0. secs (0.u,0.s)
Chars 1141 - 1281 [Definition~pos_peano_ind_beta_...] 0. secs (0.u,0.s)
Chars 537 - 612 [Definition~eta_path_unit~{z~z'...] 0. secs (0.u,0.s)
Chars 613 - 619 [Proof.] 0. secs (0.u,0.s)
Chars 1283 - 1467 [Definition~pos_peano_ind_beta_...] 0. secs (0.u,0.s)
Chars 1468 - 1474 [Proof.] 0. secs (0.u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 45 - 67 [Require~Import~Basics.] 0.226 secs (0.18u,0.045s)
Chars 68 - 96 [Require~Import~WildCat.Core.] 0.031 secs (0.02u,0.01s)
Chars 124 - 202 [#[global]~Instance~isgraph_sum...] 0. secs (0.u,0.s)
Chars 203 - 209 [Proof.] 0. secs (0.u,0.s)
Chars 97 - 124 [Require~Import~HoTT.Basics.] 0.218 secs (0.15u,0.068s)
Chars 430 - 906 [(refine~~~(@Build_PreCategory~...] 0.366 secs (0.029u,0.037s)
Chars 430 - 906 [(refine~~~(@Build_PreCategory~...] 0.001 secs (0.001u,0.s)
Chars 909 - 917 [Defined.] 0.005 secs (0.003u,0.001s)
Chars 918 - 927 [End~prod.] 0.003 secs (0.002u,0.001s)
Chars 929 - 970 [#[local]Infix~"*"~:=~prod~:~ca...] 0. secs (0.u,0.s)
Chars 1025 - 1143 [#[global]~Instance~isstrict_ca...] 0. secs (0.u,0.s)
Chars 1144 - 1150 [Proof.] 0. secs (0.u,0.s)
Chars 125 - 165 [Require~Import~Types.Paths~Typ...] 0.126 secs (0.086u,0.039s)
Chars 166 - 194 [#[local]Open~Scope~path_scope.] 0. secs (0.u,0.s)
Chars 197 - 235 [Generalizable~Variables~A~B~C~...] 0. secs (0.u,0.s)
Chars 237 - 258 [Section~AssumeFunext.] 0. secs (0.u,0.s)
Chars 259 - 277 [Context~`{Funext}.] 0. secs (0.u,0.s)
Chars 606 - 701 [Definition~path_arrow~{A~B~:~T...] 0.001 secs (0.001u,0.s)
Chars 866 - 996 [Definition~ap10_path_arrow~{A~...] 0.001 secs (0.u,0.s)
Chars 998 - 1130 [Definition~apD10_path_arrow~{A...] 0.001 secs (0.u,0.s)
Chars 1132 - 1264 [Definition~ap10_path_forall~{A...] 0.001 secs (0.u,0.s)
Chars 1266 - 1391 [Definition~eta_path_arrow~{A~B...] 0.001 secs (0.u,0.s)
Chars 1393 - 1507 [Definition~path_arrow_1~{A~B~:...] 0.001 secs (0.001u,0.s)
Chars 1509 - 1620 [Definition~equiv_ap10~`{Funext...] 0.004 secs (0.004u,0.s)
Chars 1622 - 1747 [#[global]~Instance~isequiv_pat...] 0.001 secs (0.u,0.001s)
Chars 1749 - 1857 [Definition~equiv_path_arrow~{A...] 0. secs (0.u,0.s)
Chars 1883 - 2079 [Definition~path_arrow_pp~{A~B~...] 0.002 secs (0.002u,0.s)
Chars 2199 - 2378 [Definition~transport_arrow~{A~...] 0.001 secs (0.001u,0.s)
Chars 2379 - 2385 [Proof.] 0. secs (0.u,0.s)
Chars 2388 - 2412 [(destruct~p;~simpl;~auto).] 0.032 secs (0.u,0.011s)
Chars 2388 - 2412 [(destruct~p;~simpl;~auto).] 0. secs (0.u,0.s)
Chars 2413 - 2421 [Defined.] 0. secs (0.u,0.s)
Chars 2423 - 2608 [Definition~transport_arrow_toc...] 0. secs (0.u,0.s)
Chars 2609 - 2615 [Proof.] 0. secs (0.u,0.s)
Chars 1153 - 1171 [typeclasses~eauto.] 0.111 secs (0.001u,0.017s)
Chars 1153 - 1171 [typeclasses~eauto.] 0. secs (0.u,0.s)
Chars 1172 - 1176 [Qed.] 0.001 secs (0.u,0.s)
Chars 1178 - 1214 [Module~Export~CategoryProdNota...] 0. secs (0.u,0.s)
Chars 1217 - 1252 [Infix~"*"~:=~prod~:~category_s...] 0. secs (0.u,0.s)
Chars 1253 - 1279 [End~CategoryProdNotations.] 0. secs (0.u,0.s)
Chars 2618 - 2642 [(destruct~p;~simpl;~auto).] 0.039 secs (0.001u,0.01s)
Chars 2618 - 2642 [(destruct~p;~simpl;~auto).] 0. secs (0.u,0.s)
Chars 2643 - 2651 [Defined.] 0. secs (0.u,0.s)
Chars 2653 - 2827 [Definition~transport_arrow_fro...] 0. secs (0.u,0.s)
Chars 2828 - 2834 [Proof.] 0. secs (0.u,0.s)
Chars 2837 - 2861 [(destruct~p;~simpl;~auto).] 0.036 secs (0.u,0.011s)
Chars 2837 - 2861 [(destruct~p;~simpl;~auto).] 0. secs (0.u,0.s)
Chars 2862 - 2870 [Defined.] 0. secs (0.u,0.s)
Chars 2930 - 3231 [Definition~ap_transport_arrow_...] 0.003 secs (0.002u,0.s)
Chars 3232 - 3238 [Proof.] 0. secs (0.u,0.s)
Chars 3241 - 3268 [(destruct~p,~q;~reflexivity).] 0.05 secs (0.003u,0.012s)
Chars 3241 - 3268 [(destruct~p,~q;~reflexivity).] 0.001 secs (0.u,0.s)
Chars 3269 - 3277 [Defined.] 0.002 secs (0.u,0.002s)
Chars 3710 - 3940 [Definition~dpath_arrow~{A~:~Ty...] 0.001 secs (0.u,0.001s)
Chars 3941 - 3947 [Proof.] 0. secs (0.u,0.s)
Chars 3950 - 3961 [(destruct~p).] 0.034 secs (0.u,0.011s)
Chars 3964 - 3987 [(apply~equiv_path_arrow).] 0.001 secs (0.u,0.001s)
Chars 3950 - 3961 [(destruct~p).] 0. secs (0.u,0.s)
Chars 3964 - 3987 [(apply~equiv_path_arrow).] 0. secs (0.u,0.s)
Chars 3988 - 3996 [Defined.] 0. secs (0.u,0.s)
Chars 3998 - 4330 [Definition~ap10_dpath_arrow~{A...] 0.006 secs (0.002u,0.004s)
Chars 4331 - 4337 [Proof.] 0. secs (0.u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 97 - 124 [Require~Import~HoTT.Basics.] 0.219 secs (0.149u,0.069s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 125 - 186 [Require~Import~Types.Arrow~Typ...] 0.24 secs (0.177u,0.062s)
Chars 187 - 215 [#[local]Open~Scope~path_scope.] 0. secs (0.u,0.s)
Chars 218 - 256 [Generalizable~Variables~X~A~B~...] 0. secs (0.u,0.s)
Chars 1241 - 1347 [Definition~unpack_sigma~`{P~:~...] 0. secs (0.u,0.s)
Chars 1349 - 1375 [Arguments~unpack_sigma~/.] 0. secs (0.u,0.s)
Chars 1403 - 1479 [Definition~eta_sigma~`{P~:~A~-...] 0. secs (0.u,0.s)
Chars 1481 - 1504 [Arguments~eta_sigma~/.] 0. secs (0.u,0.s)
Chars 1506 - 1643 [Definition~eta2_sigma~`{P~:~fo...] 0.001 secs (0.001u,0.s)
Chars 1645 - 1669 [Arguments~eta2_sigma~/.] 0. secs (0.u,0.s)
Chars 1671 - 1848 [Definition~eta3_sigma~`{P~:~fo...] 0.002 secs (0.002u,0.s)
Chars 1850 - 1874 [Arguments~eta3_sigma~/.] 0. secs (0.u,0.s)
Chars 2203 - 2512 [Definition~path_sigma_uncurrie...] 0.002 secs (0.002u,0.s)
Chars 2699 - 2855 [Definition~path_sigma~{A~:~Typ...] 0.001 secs (0.001u,0.s)
Chars 2915 - 3103 [Definition~path_sigma_uncurrie...] 0.002 secs (0.002u,0.s)
Chars 3262 - 3610 [Definition~dpath_forall'~{A~:~...] 0.002 secs (0.002u,0.s)
Chars 3611 - 3617 [Proof.] 0. secs (0.u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 0 - 22 [Require~Import~Basics.] 0.176 secs (0.144u,0.031s)
Chars 0 - 22 [Require~Import~Basics.] 0.221 secs (0.155u,0.065s)
Chars 23 - 49 [Require~Import~Spaces.Pos.] 0.048 secs (0.041u,0.007s)
Chars 50 - 81 [Require~Import~Spaces.Int.Core.] 0.002 secs (0.u,0.001s)
Chars 83 - 110 [#[local]Open~Scope~int_scope.] 0. secs (0.u,0.s)
Chars 147 - 186 [Lemma~int_add_comm~n~m~:~n~+~m...] 0. secs (0.u,0.s)
Chars 187 - 193 [Proof.] 0. secs (0.u,0.s)
Chars 45 - 67 [Require~Import~Basics.] 0.182 secs (0.147u,0.034s)
Chars 0 - 22 [Require~Import~Basics.] 0.182 secs (0.158u,0.023s)
Chars 3620 - 3631 [(destruct~h).] 0.139 secs (0.003u,0.013s)
Chars 3634 - 3648 [(apply~1%equiv).] 0.001 secs (0.001u,0.s)
Chars 3620 - 3631 [(destruct~h).] 0. secs (0.u,0.s)
Chars 3634 - 3648 [(apply~1%equiv).] 0. secs (0.u,0.s)
Chars 3649 - 3657 [Defined.] 0.002 secs (0.002u,0.s)
Chars 3914 - 4092 [Definition~path_sigma'~{A~:~Ty...] 0.001 secs (0.u,0.s)
Chars 4144 - 4237 [Definition~pr1_path~`{P~:~A~->...] 0.001 secs (0.u,0.s)
Chars 4275 - 4326 [Notation~"p~..1"~:=~(pr1_path~...] 0. secs (0.u,0.s)
Chars 23 - 51 [Require~Import~WildCat.Core.] 0.031 secs (0.024u,0.006s)
Chars 133 - 185 [#[local]Instance~isgraph_paths...] 0. secs (0.u,0.s)
Chars 186 - 192 [Proof.] 0. secs (0.u,0.s)
Chars 4328 - 4486 [Definition~pr2_path~`{P~:~A~->...] 0.003 secs (0.002u,0.001s)
Chars 4488 - 4539 [Notation~"p~..2"~:=~(pr2_path~...] 0. secs (0.u,0.s)
Chars 4587 - 4750 [Definition~pr1_path_sigma_uncu...] 0.001 secs (0.001u,0.s)
Chars 4751 - 4757 [Proof.] 0. secs (0.u,0.s)
Chars 23 - 51 [Require~Import~WildCat.Core.] 0.025 secs (0.024u,0.s)
Chars 68 - 96 [Require~Import~WildCat.Core.] 0.025 secs (0.022u,0.002s)
Chars 157 - 184 [Declare~Scope~wc_iso_scope.] 0. secs (0.u,0.s)
Chars 0 - 22 [Require~Import~Basics.] 0.221 secs (0.157u,0.063s)
Chars 0 - 22 [Require~Import~Basics.] 0.222 secs (0.159u,0.062s)
Chars 571 - 1442 [Class~HasEquivs~(A~:~Type)~`{I...] 0.026 secs (0.019u,0.006s)
Chars 1693 - 1774 [Definition~CatEquiv~{A}~`{HasE...] 0.001 secs (0.001u,0.s)
Chars 1776 - 1814 [Notation~"a~$<~>~b"~:=~(CatEqu...] 0. secs (0.u,0.s)
Chars 1815 - 1854 [Infix~"≅"~:=~CatEquiv~:~wc_iso...] 0. secs (0.u,0.s)
Chars 1855 - 1888 [Arguments~CatEquiv~:~simpl~never.] 0. secs (0.u,0.s)
Chars 1890 - 2000 [Definition~cate_fun~{A}~`{HasE...] 0.001 secs (0.001u,0.s)
Chars 2002 - 2039 [Coercion~cate_fun~:~CatEquiv~>...] 0. secs (0.u,0.s)
Chars 23 - 51 [Require~Import~WildCat.Core.] 0.031 secs (0.023u,0.008s)
Chars 76 - 122 [#[global]Instance~isgraph_empt...] 0. secs (0.u,0.s)
Chars 2174 - 2270 [Class~CatIsEquiv~{A}~`{HasEqui...] 0.002 secs (0.001u,0.s)
Chars 123 - 129 [Proof.] 0. secs (0.u,0.s)
Chars 2272 - 2387 [#[global]~Instance~cate_isequi...] 0.002 secs (0.002u,0.s)
Chars 23 - 51 [Require~Import~WildCat.Core.] 0.031 secs (0.023u,0.008s)
Chars 75 - 119 [#[global]Instance~isgraph_unit...] 0. secs (0.u,0.s)
Chars 2389 - 2533 [Definition~Build_CatEquiv~{A}~...] 0.002 secs (0.002u,0.s)
Chars 120 - 126 [Proof.] 0. secs (0.u,0.s)
Chars 2535 - 2713 [Definition~cate_buildequiv_fun...] 0.004 secs (0.003u,0.s)
Chars 2715 - 2918 [Definition~catie_adjointify~{A...] 0.006 secs (0.004u,0.002s)
Chars 0 - 22 [Require~Import~Basics.] 0.217 secs (0.158u,0.058s)
Chars 52 - 81 [Require~Import~WildCat.Equiv.] 0.062 secs (0.051u,0.01s)
Chars 2920 - 3149 [Definition~cate_adjointify~{A}...] 0.007 secs (0.004u,0.002s)
Chars 116 - 204 [#[global]~Instance~isgraph_typ...] 0. secs (0.u,0.s)
Chars 206 - 250 [#[global]Instance~is01cat_type...] 0. secs (0.u,0.s)
Chars 251 - 257 [Proof.] 0. secs (0.u,0.s)
Chars 3221 - 3296 [Definition~cate_inv~{A}~`{HasE...] 0.001 secs (0.001u,0.s)
Chars 3297 - 3303 [Proof.] 0. secs (0.u,0.s)
Chars 195 - 207 [constructor.] 0.077 secs (0.u,0.01s)
Chars 210 - 236 [(intros~x~y;~exact~(x~=~y)).] 0. secs (0.u,0.s)
Chars 195 - 207 [constructor.] 0. secs (0.u,0.s)
Chars 210 - 236 [(intros~x~y;~exact~(x~=~y)).] 0. secs (0.u,0.s)
Chars 237 - 245 [Defined.] 0. secs (0.u,0.s)
Chars 247 - 299 [#[local]Instance~is01cat_paths...] 0. secs (0.u,0.s)
Chars 300 - 306 [Proof.] 0. secs (0.u,0.s)
Chars 45 - 108 [Require~Import~HoTT.Basics~Typ...] 0.365 secs (0.306u,0.058s)
Chars 109 - 144 [Require~Export~Tactics.BinderA...] 0.001 secs (0.001u,0.s)
Chars 1801 - 2229 [#[local]~Ltac~~path_forall_bet...] 0. secs (0.u,0.s)
Chars 2293 - 2475 [Lemma~path_forall_1_beta~`{Fun...] 0.001 secs (0.u,0.s)
Chars 2476 - 2482 [Proof.] 0. secs (0.u,0.s)
Chars 23 - 49 [Require~Import~Spaces.Pos.] 0.058 secs (0.045u,0.012s)
Chars 50 - 81 [Require~Import~Spaces.Int.Core.] 0.002 secs (0.002u,0.s)
Chars 82 - 113 [Require~Import~Spaces.Int.Spec.] 0.094 secs (0.074u,0.019s)
Chars 196 - 400 [Definition~int_iter~{A}~(f~:~A...] 0.001 secs (0.001u,0.s)
Chars 556 - 688 [Definition~int_iter_succ_l~{A}...] 0. secs (0.u,0.s)
Chars 689 - 695 [Proof.] 0. secs (0.u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 81 - 108 [Require~Import~HoTT.Basics.] 0.218 secs (0.156u,0.061s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 0 - 22 [Require~Import~Basics.] 0.179 secs (0.151u,0.027s)
Chars 109 - 147 [Require~Import~Types.Prod~Type...] 0.33 secs (0.265u,0.064s)
Chars 149 - 177 [#[local]Open~Scope~path_scope.] 0. secs (0.u,0.s)
Chars 224 - 256 [#[local]Unset~Elimination~Sche...] 0. secs (0.u,0.s)
Chars 257 - 316 [Inductive~Bool~:~Type0~:=~~~|~...] 0. secs (0.u,0.s)
Chars 317 - 365 [Scheme~Bool_ind~:=~Induction~f...] 0. secs (0.u,0.s)
Chars 366 - 415 [Scheme~Bool_rec~:=~Minimality~...] 0. secs (0.u,0.s)
Chars 463 - 496 [Definition~Bool_rect~:=~Bool_ind.] 0. secs (0.u,0.s)
Chars 498 - 519 [Add~Printing~If~Bool.] 0. secs (0.u,0.s)
Chars 521 - 546 [Declare~Scope~bool_scope.] 0. secs (0.u,0.s)
Chars 548 - 583 [Delimit~Scope~bool_scope~with~...] 0. secs (0.u,0.s)
Chars 585 - 617 [Bind~Scope~bool_scope~with~Bool.] 0. secs (0.u,0.s)
Chars 619 - 685 [Definition~andb~(b1~b2~:~Bool)...] 0. secs (0.u,0.s)
Chars 687 - 751 [Definition~orb~(b1~b2~:~Bool)~...] 0. secs (0.u,0.s)
Chars 753 - 809 [Definition~negb~(b~:~Bool)~:=~...] 0. secs (0.u,0.s)
Chars 811 - 877 [Definition~implb~(b1~b2~:~Bool...] 0. secs (0.u,0.s)
Chars 879 - 910 [Infix~"||"~:=~orb~:~bool_scope.] 0. secs (0.u,0.s)
Chars 911 - 943 [Infix~"&&"~:=~andb~:~bool_scope.] 0. secs (0.u,0.s)
Chars 944 - 977 [Infix~"->"~:=~implb~:~bool_scope.] 0. secs (0.u,0.s)
Chars 979 - 1093 [Definition~implb_true~{b}~:~im...] 0. secs (0.u,0.s)
Chars 1095 - 1173 [Definition~implb_impl~{a}~{b}~...] 0. secs (0.u,0.s)
Chars 1174 - 1180 [Proof.] 0. secs (0.u,0.s)
Chars 91 - 154 [Require~Import~Basics.Overture...] 0.538 secs (0.413u,0.125s)
Chars 156 - 185 [#[local]Open~Scope~equiv_scope.] 0. secs (0.u,0.s)
Chars 383 - 404 [Section~AssumeFunext.] 0. secs (0.u,0.s)
Chars 407 - 425 [Context~`{Funext}.] 0. secs (0.u,0.s)
Chars 530 - 581 [Lemma~ecompose_e1~{A}~{B}~(e~:...] 0. secs (0.u,0.s)
Chars 584 - 590 [Proof.] 0. secs (0.u,0.s)
Chars 4414 - 4428 [by~destruct~n.] 3.099 secs (0.001u,0.011s)
Chars 4414 - 4428 [by~destruct~n.] 0. secs (0.u,0.s)
Chars 4429 - 4433 [Qed.] 0. secs (0.u,0.s)
Chars 4455 - 4697 [Definition~int_add~x~y~:=~~~ma...] 0.001 secs (0.001u,0.s)
Chars 4699 - 4732 [Infix~"+"~:=~int_add~:~int_scope.] 0. secs (0.u,0.s)
Chars 4755 - 4786 [Definition~int_succ~x~:=~x~+~1.] 0. secs (0.u,0.s)
Chars 4811 - 4850 [Definition~int_pred~x~:=~x~+~n...] 0. secs (0.u,0.s)
Chars 4875 - 4908 [Definition~int_sub~m~n~:=~m~+~...] 0. secs (0.u,0.s)
Chars 4910 - 4943 [Infix~"-"~:=~int_sub~:~int_scope.] 0. secs (0.u,0.s)
Chars 4971 - 5205 [Definition~int_mul~x~y~:=~~~ma...] 0. secs (0.u,0.s)
Chars 5207 - 5240 [Infix~"*"~:=~int_mul~:~int_scope.] 0. secs (0.u,0.s)
Chars 5268 - 5385 [Definition~int_pow~x~y~:=~~~ma...] 0. secs (0.u,0.s)
Chars 5387 - 5420 [Infix~"^"~:=~int_pow~:~int_scope.] 0. secs (0.u,0.s)
Chars 5440 - 5569 [Definition~int_square~x~:=~~~m...] 0. secs (0.u,0.s)
Chars 5596 - 5692 [Definition~sgn~z~:=~~~match~z~...] 0. secs (0.u,0.s)
Chars 5736 - 5786 [#[global]Instance~decpaths_int...] 0. secs (0.u,0.s)
Chars 5787 - 5793 [Proof.] 0. secs (0.u,0.s)
Chars 23 - 98 [Require~Import~Types.Forall~Ty...] 0.272 secs (0.24u,0.031s)
Chars 647 - 1045 [Inductive~IW~(I~:~Type)~(A~:~T...] 0.002 secs (0.002u,0.s)
Chars 1047 - 1156 [Definition~iw_label~{A}~{B}~{I...] 0. secs (0.u,0.s)
Chars 1158 - 1328 [Definition~iw_arity~{A}~{B}~{I...] 0.001 secs (0.001u,0.s)
Chars 1330 - 1425 [Definition~path_index_iw_label...] 0. secs (0.u,0.s)
Chars 1426 - 1432 [Proof.] 0. secs (0.u,0.s)
Chars 595 - 625 [(apply~path_equiv;~reflexivity).] 0.168 secs (0.001u,0.01s)
Chars 595 - 625 [(apply~path_equiv;~reflexivity).] 0. secs (0.u,0.s)
Chars 628 - 636 [Defined.] 0. secs (0.u,0.s)
Chars 678 - 729 [Lemma~ecompose_1e~{A}~{B}~(e~:...] 0. secs (0.u,0.s)
Chars 732 - 738 [Proof.] 0. secs (0.u,0.s)
Chars 743 - 773 [(apply~path_equiv;~reflexivity).] 0.033 secs (0.001u,0.01s)
Chars 743 - 773 [(apply~path_equiv;~reflexivity).] 0. secs (0.u,0.s)
Chars 776 - 784 [Defined.] 0. secs (0.u,0.s)
Chars 825 - 936 [Definition~ecompose_e_ee~{A}~{...] 0.001 secs (0.u,0.s)
Chars 939 - 945 [Proof.] 0. secs (0.u,0.s)
Chars 950 - 980 [(apply~path_equiv;~reflexivity).] 0.03 secs (0.001u,0.01s)
Chars 950 - 980 [(apply~path_equiv;~reflexivity).] 0. secs (0.u,0.s)
Chars 983 - 991 [Defined.] 0. secs (0.u,0.s)
Chars 995 - 1106 [Definition~ecompose_ee_e~{A}~{...] 0.001 secs (0.u,0.s)
Chars 1109 - 1115 [Proof.] 0. secs (0.u,0.s)
Chars 1120 - 1150 [(apply~path_equiv;~reflexivity).] 0.03 secs (0.001u,0.01s)
Chars 1120 - 1150 [(apply~path_equiv;~reflexivity).] 0. secs (0.u,0.s)
Chars 1153 - 1161 [Defined.] 0. secs (0.u,0.s)
Chars 1196 - 1250 [Lemma~ecompose_eV~{A}~{B}~(e~:...] 0. secs (0.u,0.s)
Chars 1253 - 1259 [Proof.] 0. secs (0.u,0.s)
Chars 1264 - 1322 [(apply~path_equiv;~apply~path_...] 1.024 secs (0.002u,0.01s)
Chars 1264 - 1322 [(apply~path_equiv;~apply~path_...] 0. secs (0.u,0.s)
Chars 1325 - 1333 [Defined.] 0. secs (0.u,0.s)
Chars 1369 - 1423 [Lemma~ecompose_Ve~{A}~{B}~(e~:...] 0. secs (0.u,0.s)
Chars 1426 - 1432 [Proof.] 0. secs (0.u,0.s)
Chars 1107 - 1125 [(destruct~p;~simpl).] 5.479 secs (0.001u,0.001s)
Chars 1128 - 1174 [exact~((concat_1p~q)^~@~(conca...] 0.001 secs (0.u,0.001s)
Chars 1107 - 1125 [(destruct~p;~simpl).] 0. secs (0.u,0.s)
Chars 1128 - 1174 [exact~((concat_1p~q)^~@~(conca...] 0. secs (0.u,0.s)
Chars 1175 - 1183 [Defined.] 0. secs (0.u,0.s)
Chars 1185 - 1345 [Definition~transport_paths_Fl~...] 0. secs (0.u,0.s)
Chars 1346 - 1352 [Proof.] 0. secs (0.u,0.s)
Chars 1355 - 1382 [(destruct~p,~q;~reflexivity).] 0.028 secs (0.002u,0.002s)
Chars 1355 - 1382 [(destruct~p,~q;~reflexivity).] 0. secs (0.u,0.s)
Chars 1383 - 1391 [Defined.] 0.001 secs (0.001u,0.s)
Chars 1393 - 1552 [Definition~transport_paths_Fr~...] 0. secs (0.u,0.s)
Chars 1553 - 1559 [Proof.] 0. secs (0.u,0.s)
Chars 1437 - 1495 [(apply~path_equiv;~apply~path_...] 0.578 secs (0.003u,0.01s)
Chars 1437 - 1495 [(apply~path_equiv;~apply~path_...] 0. secs (0.u,0.s)
Chars 1498 - 1506 [Defined.] 0. secs (0.u,0.s)
Chars 1659 - 1745 [Definition~ecompose_V_ee~{A}~{...] 0. secs (0.u,0.s)
Chars 1748 - 1754 [Proof.] 0. secs (0.u,0.s)
Chars 1562 - 1573 [(destruct~p).] 0.314 secs (0.001u,0.002s)
Chars 1574 - 1600 [(symmetry;~apply~concat_p1).] 0.002 secs (0.001u,0.s)
Chars 1562 - 1573 [(destruct~p).] 0. secs (0.u,0.s)
Chars 1574 - 1600 [(symmetry;~apply~concat_p1).] 0. secs (0.u,0.s)
Chars 1601 - 1609 [Defined.] 0. secs (0.u,0.s)
Chars 1611 - 1783 [Definition~transport_paths_FlF...] 0.001 secs (0.001u,0.s)
Chars 1784 - 1790 [Proof.] 0. secs (0.u,0.s)
Chars 1759 - 1824 [(apply~path_equiv;~apply~path_...] 1.06 secs (0.002u,0.011s)
Chars 1759 - 1824 [(apply~path_equiv;~apply~path_...] 0. secs (0.u,0.s)
Chars 1827 - 1835 [Defined.] 0. secs (0.u,0.s)
Chars 1839 - 1925 [Definition~ecompose_e_Ve~{A}~{...] 0. secs (0.u,0.s)
Chars 1928 - 1934 [Proof.] 0. secs (0.u,0.s)
Chars 1793 - 1811 [(destruct~p;~simpl).] 1.026 secs (0.002u,0.001s)
Chars 1814 - 1860 [exact~((concat_1p~q)^~@~(conca...] 0.001 secs (0.u,0.s)
Chars 1793 - 1811 [(destruct~p;~simpl).] 0. secs (0.u,0.s)
Chars 1814 - 1860 [exact~((concat_1p~q)^~@~(conca...] 0. secs (0.u,0.s)
Chars 1861 - 1869 [Defined.] 0. secs (0.u,0.s)
Chars 1871 - 2087 [Definition~transport_paths_FlF...] 0.001 secs (0.001u,0.s)
Chars 2088 - 2094 [Proof.] 0. secs (0.u,0.s)
Chars 1939 - 2004 [(apply~path_equiv;~apply~path_...] 0.174 secs (0.003u,0.01s)
Chars 1939 - 2004 [(apply~path_equiv;~apply~path_...] 0. secs (0.u,0.s)
Chars 2007 - 2015 [Defined.] 0. secs (0.u,0.s)
Chars 2019 - 2105 [Definition~ecompose_ee_V~{A}~{...] 0. secs (0.u,0.s)
Chars 2108 - 2114 [Proof.] 0. secs (0.u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 60 - 129 [Require~Import~Category.Core~F...] 0.014 secs (0.011u,0.002s)
Chars 2119 - 2194 [(apply~path_equiv;~apply~path_...] 1.292 secs (0.003u,0.011s)
Chars 2119 - 2194 [(apply~path_equiv;~apply~path_...] 0.001 secs (0.001u,0.s)
Chars 2197 - 2205 [Defined.] 0. secs (0.u,0.s)
Chars 2209 - 2295 [Definition~ecompose_eV_e~{A}~{...] 0. secs (0.u,0.s)
Chars 2298 - 2304 [Proof.] 0. secs (0.u,0.s)
Chars 2309 - 2384 [(apply~path_equiv;~apply~path_...] 0.221 secs (0.002u,0.011s)
Chars 2309 - 2384 [(apply~path_equiv;~apply~path_...] 0.001 secs (0.u,0.s)
Chars 2387 - 2395 [Defined.] 0. secs (0.u,0.s)
Chars 2445 - 2531 [Definition~einv_ee~{A}~{B}~{C}...] 0.001 secs (0.001u,0.s)
Chars 2534 - 2540 [Proof.] 0. secs (0.u,0.s)
Chars 2545 - 2575 [(apply~path_equiv;~reflexivity).] 0.047 secs (0.001u,0.011s)
Chars 2545 - 2575 [(apply~path_equiv;~reflexivity).] 0. secs (0.u,0.s)
Chars 2578 - 2586 [Defined.] 0. secs (0.u,0.s)
Chars 2590 - 2676 [Definition~einv_Ve~{A}~{B}~{C}...] 0. secs (0.u,0.s)
Chars 2679 - 2685 [Proof.] 0. secs (0.u,0.s)
Chars 2690 - 2720 [(apply~path_equiv;~reflexivity).] 0.031 secs (0.001u,0.011s)
Chars 2690 - 2720 [(apply~path_equiv;~reflexivity).] 0. secs (0.u,0.s)
Chars 2723 - 2731 [Defined.] 0. secs (0.u,0.s)
Chars 2735 - 2821 [Definition~einv_eV~{A}~{B}~{C}...] 0. secs (0.u,0.s)
Chars 2824 - 2830 [Proof.] 0. secs (0.u,0.s)
Chars 2835 - 2865 [(apply~path_equiv;~reflexivity).] 0.031 secs (0.u,0.012s)
Chars 2835 - 2865 [(apply~path_equiv;~reflexivity).] 0. secs (0.u,0.s)
Chars 2868 - 2876 [Defined.] 0. secs (0.u,0.s)
Chars 2880 - 2966 [Definition~einv_VV~{A}~{B}~{C}...] 0. secs (0.u,0.s)
Chars 2969 - 2975 [Proof.] 0. secs (0.u,0.s)
Chars 2980 - 3010 [(apply~path_equiv;~reflexivity).] 0.031 secs (0.001u,0.011s)
Chars 2980 - 3010 [(apply~path_equiv;~reflexivity).] 0. secs (0.u,0.s)
Chars 3013 - 3021 [Defined.] 0. secs (0.u,0.s)
Chars 3060 - 3116 [Definition~einv_V~{A}~{B}~(e~:...] 0. secs (0.u,0.s)
Chars 3119 - 3125 [Proof.] 0. secs (0.u,0.s)
Chars 3130 - 3160 [(apply~path_equiv;~reflexivity).] 0.029 secs (0.u,0.011s)
Chars 3130 - 3160 [(apply~path_equiv;~reflexivity).] 0. secs (0.u,0.s)
Chars 3163 - 3171 [Defined.] 0. secs (0.u,0.s)
Chars 3236 - 3339 [Definition~emoveR_Me~{A}~{B}~{...] 0.001 secs (0.u,0.s)
Chars 3342 - 3348 [Proof.] 0. secs (0.u,0.s)
Chars 130 - 190 [Require~Import~Equivalences~Ho...] 0.935 secs (0.858u,0.077s)
Chars 192 - 218 [Set~Universe~Polymorphism.] 0. secs (0.u,0.s)
Chars 219 - 242 [Set~Implicit~Arguments.] 0. secs (0.u,0.s)
Chars 243 - 271 [Generalizable~Variables~all.] 0. secs (0.u,0.s)
Chars 272 - 296 [Set~Asymmetric~Patterns.] 0. secs (0.u,0.s)
Chars 298 - 330 [#[local]Open~Scope~morphism_sc...] 0. secs (0.u,0.s)
Chars 331 - 377 [#[local]Open~Scope~natural_tra...] 0. secs (0.u,0.s)
Chars 379 - 415 [Section~path_natural_transform...] 0. secs (0.u,0.s)
Chars 418 - 436 [Context~`{Funext}.] 0. secs (0.u,0.s)
Chars 440 - 468 [Variables~(C~D~:~PreCategory).] 0. secs (0.u,0.s)
Chars 471 - 499 [Variables~(F~G~:~Functor~C~D).] 0. secs (0.u,0.s)
Chars 589 - 787 [Lemma~equiv_sig_natural_transf...] 0.001 secs (0.001u,0.s)
Chars 790 - 796 [Proof.] 0. secs (0.u,0.s)
Chars 2097 - 2115 [(destruct~p;~simpl).] 3.847 secs (0.001u,0.002s)
Chars 2118 - 2174 [exact~(((ap_idmap~_)^~@~(conca...] 0.002 secs (0.001u,0.s)
Chars 2097 - 2115 [(destruct~p;~simpl).] 0. secs (0.u,0.s)
Chars 2118 - 2174 [exact~(((ap_idmap~_)^~@~(conca...] 0. secs (0.u,0.s)
Chars 2175 - 2183 [Defined.] 0.002 secs (0.002u,0.s)
Chars 2185 - 2372 [Definition~transport_paths_FFl...] 0.001 secs (0.001u,0.s)
Chars 2373 - 2379 [Proof.] 0. secs (0.u,0.s)
Chars 2382 - 2400 [(destruct~p;~simpl).] 0.038 secs (0.001u,0.002s)
Chars 2403 - 2449 [exact~((concat_1p~q)^~@~(conca...] 0.001 secs (0.u,0.001s)
Chars 2382 - 2400 [(destruct~p;~simpl).] 0. secs (0.u,0.s)
Chars 2403 - 2449 [exact~((concat_1p~q)^~@~(conca...] 0. secs (0.u,0.s)
Chars 2450 - 2458 [Defined.] 0. secs (0.u,0.s)
Chars 2460 - 2647 [Definition~transport_paths_lFF...] 0.001 secs (0.001u,0.s)
Chars 2648 - 2654 [Proof.] 0. secs (0.u,0.s)
Chars 2657 - 2675 [(destruct~p;~simpl).] 0.033 secs (0.002u,0.001s)
Chars 2678 - 2724 [exact~((concat_1p~q)^~@~(conca...] 0.001 secs (0.001u,0.s)
Chars 2657 - 2675 [(destruct~p;~simpl).] 0. secs (0.u,0.s)
Chars 2678 - 2724 [exact~((concat_1p~q)^~@~(conca...] 0. secs (0.u,0.s)
Chars 2725 - 2733 [Defined.] 0. secs (0.u,0.s)
Chars 2775 - 3022 [Definition~transport_paths2~{A...] 0.002 secs (0.002u,0.s)
Chars 3023 - 3029 [Proof.] 0. secs (0.u,0.s)
Chars 1435 - 1449 [by~destruct~w.] 7.162 secs (6.592u,0.027s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 62 - 118 [Require~Import~Category.Core~F...] 1. secs (0.924u,0.075s)
Chars 119 - 163 [Require~Import~InitialTerminal...] 0.034 secs (0.034u,0.s)
Chars 164 - 204 [Require~Import~NatCategory~Con...] 0.002 secs (0.001u,0.s)
Chars 205 - 243 [Require~Import~HoTT.Basics~HoT...] 0.01 secs (0.01u,0.s)
Chars 245 - 271 [Set~Universe~Polymorphism.] 0. secs (0.u,0.s)
Chars 272 - 295 [Set~Implicit~Arguments.] 0. secs (0.u,0.s)
Chars 296 - 324 [Generalizable~Variables~all.] 0. secs (0.u,0.s)
Chars 325 - 349 [Set~Asymmetric~Patterns.] 0. secs (0.u,0.s)
Chars 351 - 368 [Section~functors.] 0. secs (0.u,0.s)
Chars 371 - 396 [Variable~(C~:~PreCategory).] 0. secs (0.u,0.s)
Chars 446 - 687 [Definition~to_terminal~`{@IsTe...] 0.003 secs (0.003u,0.s)
Chars 748 - 1023 [Definition~from_terminal~`{@Is...] 0.002 secs (0.002u,0.s)
Chars 1074 - 1373 [Definition~from_initial~`{@IsI...] 0.002 secs (0.002u,0.s)
Chars 1374 - 1387 [End~functors.] 0.001 secs (0.001u,0.s)
Chars 1389 - 1420 [#[local]Arguments~to_terminal~/.] 0. secs (0.u,0.s)
Chars 1421 - 1454 [#[local]Arguments~from_termina...] 0. secs (0.u,0.s)
Chars 1455 - 1487 [#[local]Arguments~from_initial~/.] 0. secs (0.u,0.s)
Chars 1489 - 1554 [Definition~to_1~C~:~Functor~C~...] 0.003 secs (0.003u,0.s)
Chars 1555 - 1628 [Definition~from_1~C~c~:~Functo...] 0.003 secs (0.003u,0.s)
Chars 1629 - 1697 [Definition~from_0~C~:~Functor~...] 0.001 secs (0.001u,0.s)
Chars 1699 - 1784 [#[local]~Notation~"!~x"~:=~(@f...] 0. secs (0.u,0.s)
Chars 1870 - 1885 [Section~unique.] 0. secs (0.u,0.s)
Chars 1888 - 1906 [Context~`{Funext}.] 0. secs (0.u,0.s)
Chars 1910 - 2018 [#[global]~Instance~trunc_initi...] 0. secs (0.u,0.s)
Chars 2021 - 2027 [Proof.] 0. secs (0.u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 49 - 118 [Require~Import~Category.Core~F...] 0.015 secs (0.011u,0.003s)
Chars 119 - 159 [Require~Import~Functor.Composi...] 0. secs (0.u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 0 - 22 [Require~Import~Basics.] 0.185 secs (0.152u,0.032s)
Chars 23 - 44 [Require~Import~Types.] 0.782 secs (0.751u,0.03s)
Chars 45 - 77 [Require~Import~Diagrams.Diagram.] 0.073 secs (0.072u,0.001s)
Chars 78 - 108 [Require~Import~Diagrams.Graph.] 0. secs (0.u,0.s)
Chars 160 - 200 [Require~Import~Functor.Composi...] 1.067 secs (0.954u,0.112s)
Chars 109 - 140 [Require~Import~Diagrams.Cocone.] 0.044 secs (0.044u,0.s)
Chars 201 - 304 [Require~Import~Adjoint.Composi...] 0.061 secs (0.06u,0.s)
Chars 305 - 344 [Require~Adjoint.Composition.La...] 0. secs (0.u,0.s)
Chars 345 - 430 [Require~Import~Types.Sigma~HoT...] 0.002 secs (0.001u,0.s)
Chars 432 - 458 [Set~Universe~Polymorphism.] 0. secs (0.u,0.s)
Chars 459 - 482 [Set~Implicit~Arguments.] 0. secs (0.u,0.s)
Chars 483 - 511 [Generalizable~Variables~all.] 0. secs (0.u,0.s)
Chars 512 - 536 [Set~Asymmetric~Patterns.] 0. secs (0.u,0.s)
Chars 538 - 572 [#[local]Open~Scope~adjunction_...] 0. secs (0.u,0.s)
Chars 573 - 605 [#[local]Open~Scope~morphism_sc...] 0. secs (0.u,0.s)
Chars 607 - 634 [Section~composition_lemmas.] 0. secs (0.u,0.s)
Chars 637 - 744 [#[local]~Notation~AdjunctionWi...] 0. secs (0.u,0.s)
Chars 748 - 771 [Context~`{H0~:~Funext}.] 0. secs (0.u,0.s)
Chars 775 - 807 [Variables~(B~C~D~E~:~PreCatego...] 0. secs (0.u,0.s)
Chars 811 - 836 [Variable~(F~:~Functor~B~C).] 0. secs (0.u,0.s)
Chars 839 - 865 [Variable~(F'~:~Functor~C~B).] 0. secs (0.u,0.s)
Chars 868 - 893 [Variable~(G~:~Functor~C~D).] 0. secs (0.u,0.s)
Chars 896 - 922 [Variable~(G'~:~Functor~D~C).] 0. secs (0.u,0.s)
Chars 925 - 950 [Variable~(H~:~Functor~D~E).] 0. secs (0.u,0.s)
Chars 953 - 979 [Variable~(H'~:~Functor~E~D).] 0. secs (0.u,0.s)
Chars 983 - 1005 [Variable~(AF~:~F~-|~F').] 0. secs (0.u,0.s)
Chars 1008 - 1030 [Variable~(AG~:~G~-|~G').] 0. secs (0.u,0.s)
Chars 1033 - 1055 [Variable~(AH~:~H~-|~H').] 0. secs (0.u,0.s)
Chars 1059 - 1093 [#[local]Open~Scope~adjunction_...] 0. secs (0.u,0.s)
Chars 1097 - 1203 [Lemma~associativity~:~~~((_,~_...] 0.004 secs (0.004u,0.s)
Chars 1206 - 1212 [Proof.] 0. secs (0.u,0.s)
Chars 141 - 173 [Require~Import~Colimits.Colimit.] 0.472 secs (0.465u,0.006s)
Chars 450 - 471 [Section~ColimitSigma.] 0. secs (0.u,0.s)
Chars 475 - 537 [Context~`{Funext}~{G~:~Graph}~...] 0. secs (0.u,0.s)
Chars 578 - 615 [Definition~sigma_diagram~:~Dia...] 0. secs (0.u,0.s)
Chars 618 - 624 [Proof.] 0. secs (0.u,0.s)
Chars 629 - 651 [srapply~Build_Diagram.] 1.056 secs (0.001u,0.002s)
Chars 656 - 657 [-] 0. secs (0.u,0.s)
Chars 658 - 690 [exact~(fun~i~=>~{y~:~Y~&~D~y~i}).] 0. secs (0.u,0.s)
Chars 695 - 696 [-] 0. secs (0.u,0.s)
Chars 697 - 719 [(simpl;~intros~i~j~g~x).] 0. secs (0.u,0.s)
Chars 726 - 754 [exact~(x.1;~((D~x.1)~_f~g)~x.2).] 0.001 secs (0.001u,0.s)
Chars 629 - 651 [srapply~Build_Diagram.] 0. secs (0.u,0.s)
Chars 658 - 690 [exact~(fun~i~=>~{y~:~Y~&~D~y~i}).] 0. secs (0.u,0.s)
Chars 697 - 719 [(simpl;~intros~i~j~g~x).] 0. secs (0.u,0.s)
Chars 726 - 754 [exact~(x.1;~((D~x.1)~_f~g)~x.2).] 0. secs (0.u,0.s)
Chars 757 - 765 [Defined.] 0. secs (0.u,0.s)
Chars 848 - 917 [Definition~sigma_diagram_map~(...] 0. secs (0.u,0.s)
Chars 920 - 926 [Proof.] 0. secs (0.u,0.s)
Chars 931 - 956 [srapply~Build_DiagramMap.] 0.574 secs (0.001u,0.002s)
Chars 961 - 962 [{] 0. secs (0.u,0.s)
Chars 963 - 974 [(intros~i~x).] 0. secs (0.u,0.s)
Chars 981 - 990 [exists~y.] 0. secs (0.u,0.s)
Chars 997 - 1005 [exact~x.] 0. secs (0.u,0.s)
Chars 1006 - 1007 [}] 0. secs (0.u,0.s)
Chars 1012 - 1024 [reflexivity.] 0. secs (0.u,0.s)
Chars 931 - 956 [srapply~Build_DiagramMap.] 0. secs (0.u,0.s)
Chars 963 - 974 [(intros~i~x).] 0. secs (0.u,0.s)
Chars 981 - 990 [exists~y.] 0. secs (0.u,0.s)
Chars 997 - 1005 [exact~x.] 0. secs (0.u,0.s)
Chars 1012 - 1024 [reflexivity.] 0. secs (0.u,0.s)
Chars 1027 - 1035 [Defined.] 0. secs (0.u,0.s)
Chars 1039 - 1063 [Context~{Q~:~Y~->~Type}.] 0. secs (0.u,0.s)
Chars 1111 - 1205 [Definition~sigma_cocone~(C~:~f...] 0. secs (0.u,0.s)
Chars 1208 - 1214 [Proof.] 0. secs (0.u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 0 - 22 [Require~Import~Basics.] 0.186 secs (0.155u,0.03s)
Chars 23 - 44 [Require~Import~Types.] 0.784 secs (0.738u,0.045s)
Chars 45 - 68 [Require~Import~WildCat.] 0.848 secs (0.841u,0.006s)
Chars 69 - 128 [Require~Import~Pointed.Core~Po...] 0.195 secs (0.191u,0.003s)
Chars 130 - 161 [#[local]Open~Scope~pointed_scope.] 0. secs (0.u,0.s)
Chars 215 - 294 [Definition~pequiv_pmap_idmap~{...] 0.003 secs (0.003u,0.s)
Chars 346 - 398 [#[global]Instance~pequiv_refle...] 0. secs (0.u,0.s)
Chars 399 - 405 [Proof.] 0. secs (0.u,0.s)
Chars 0 - 24 [Set~Tactician~Benchmark.] 0. secs (0.u,0.s)
Chars 31 - 100 [Require~Import~Category.Core~F...] 0.015 secs (0.011u,0.004s)
Chars 101 - 133 [Require~Import~Functor.Identity.] 0. secs (0.u,0.s)
Chars 134 - 168 [Require~Import~Category.Morphi...] 1.066 secs (0.956u,0.109s)
Chars 169 - 248 [Require~Import~Functor.Composi...] 0. secs (0.u,0.s)
Chars 249 - 324 [Require~Import~Adjoint.Core~Ad...] 0.017 secs (0.017u,0.s)
Chars 325 - 363 [Require~Import~Functor.Pointwi...] 0.053 secs (0.052u,0.s)
Chars 364 - 404 [Require~NaturalTransformation....] 0.001 secs (0.001u,0.s)
Chars 405 - 442 [Require~Functor.Pointwise.Prop...] 0.006 secs (0.005u,0.s)
Chars 443 - 503 [Require~Import~Category.Morphi...] 0.01 secs (0.01u,0.s)
Chars 504 - 540 [Require~Import~FunctorCategory...] 0. secs (0.u,0.s)
Chars 541 - 580 [Require~NaturalTransformation....] 0. secs (0.u,0.s)
Chars 581 - 628 [Require~NaturalTransformation....] 0. secs (0.u,0.s)
Chars 629 - 706 [Import~NaturalTransformation.I...] 0. secs (0.u,0.s)
Chars 707 - 764 [Require~Import~NaturalTransfor...] 0. secs (0.u,0.s)
Chars 765 - 845 [Require~Import~Basics.PathGrou...] 0.003 secs (0.002u,0.s)
Chars 847 - 873 [Set~Universe~Polymorphism.] 0. secs (0.u,0.s)
Chars 874 - 897 [Set~Implicit~Arguments.] 0. secs (0.u,0.s)
Chars 898 - 926 [Generalizable~Variables~all.] 0. secs (0.u,0.s)
Chars 927 - 951 [Set~Asymmetric~Patterns.] 0. secs (0.u,0.s)
Chars 953 - 985 [#[local]Open~Scope~morphism_sc...] 0. secs (0.u,0.s)
Chars 986 - 1017 [#[local]Open~Scope~functor_scope.] 0. secs (0.u,0.s)
Chars 1018 - 1064 [#[local]Open~Scope~natural_tra...] 0. secs (0.u,0.s)
Chars 1066 - 1091 [Section~AdjointPointwise.] 0. secs (0.u,0.s)
Chars 1094 - 1112 [Context~`{Funext}.] 0. secs (0.u,0.s)
Chars 1116 - 1144 [Variables~(C~D~:~PreCategory).] 0. secs (0.u,0.s)
Chars 1188 - 1198 [Section~l.] 0. secs (0.u,0.s)
Chars 1203 - 1228 [Variable~(E~:~PreCategory).] 0. secs (0.u,0.s)
Chars 1234 - 1259 [Variable~(F~:~Functor~C~D).] 0. secs (0.u,0.s)
Chars 1264 - 1289 [Variable~(G~:~Functor~D~C).] 0. secs (0.u,0.s)
Chars 1295 - 1315 [Variable~(A~:~F~-|~G).] 0. secs (0.u,0.s)
Chars 1321 - 1473 [Definition~unit_l~:~~~NaturalT...] 0.001 secs (0.001u,0.s)
Chars 1478 - 1484 [Proof.] 0. secs (0.u,0.s)
Chars 1217 - 1251 [(apply~path_sigma_uncurried;~s...] 14.979 secs (13.465u,0.264s)
Chars 846 - 898 [(assert~(K~:~forall~r~:~x~=~y,...] 40.03 secs (0.u,0.005s)
Chars 901 - 902 [-] 0. secs (0.u,0.s)
Chars 903 - 954 [(intro~r;~destruct~r;~symmetry...] 0.003 secs (0.u,0.002s)
Chars 957 - 958 [-] 0. secs (0.u,0.s)
Chars 959 - 1010 [(transitivity~(path_contr~x~y)...] 0.003 secs (0.001u,0.002s)
Chars 846 - 898 [(assert~(K~:~forall~r~:~x~=~y,...] 0. secs (0.u,0.s)
Chars 903 - 954 [(intro~r;~destruct~r;~symmetry...] 0. secs (0.u,0.s)
Chars 959 - 1010 [(transitivity~(path_contr~x~y)...] 0. secs (0.u,0.s)
Chars 1011 - 1019 [Defined.] 0. secs (0.u,0.s)
Chars 1105 - 1184 [#[global]~Instance~contr_paths...] 0. secs (0.u,0.s)
Chars 1185 - 1191 [Proof.] 0. secs (0.u,0.s)
Chars 1082 - 1118 [(intros~dn;~destruct~(dec~P)~a...] 40.009 secs (0.002u,0.s)
Chars 1121 - 1122 [-] 0. secs (0.u,0.s)
Chars 1123 - 1134 [assumption.] 0. secs (0.u,0.s)
Chars 1137 - 1138 [-] 0. secs (0.u,0.s)
Chars 1139 - 1161 [(apply~Empty_rect,~dn,~n).] 0. secs (0.u,0.s)
Chars 1082 - 1118 [(intros~dn;~destruct~(dec~P)~a...] 0. secs (0.u,0.s)
Chars 1123 - 1134 [assumption.] 0. secs (0.u,0.s)
Chars 1139 - 1161 [(apply~Empty_rect,~dn,~n).] 0. secs (0.u,0.s)
Chars 1162 - 1166 [Qed.] 0. secs (0.u,0.s)
Chars 1744 - 1884 [Definition~decide_rel~{A}~{B}~...] 0. secs (0.u,0.s)
Chars 1956 - 2035 [#[global]~Instance~decidable_c...] 0. secs (0.u,0.s)
Chars 2083 - 2182 [#[global]~Instance~decidablepa...] 0. secs (0.u,0.s)
Chars 2217 - 2282 [#[global]Instance~decidable_em...] 0. secs (0.u,0.s)
Chars 2324 - 2432 [Definition~decidable_equiv~(A~...] 0. secs (0.u,0.s)
Chars 2433 - 2439 [Proof.] 0. secs (0.u,0.s)
Chars 399 - 408 [revert~q.] 40.05 secs (0.u,0.007s)
Chars 411 - 455 [(induction~p;~destruct~q;~simp...] 0.009 secs (0.005u,0.003s)
Chars 399 - 408 [revert~q.] 0. secs (0.u,0.s)
Chars 411 - 455 [(induction~p;~destruct~q;~simp...] 0.003 secs (0.003u,0.s)
Chars 456 - 460 [Qed.] 0.001 secs (0.001u,0.s)
Chars 496 - 537 [Theorem~pos_add_comm~p~q~:~p~+...] 0. secs (0.u,0.s)
Chars 538 - 544 [Proof.] 0. secs (0.u,0.s)
Chars 500 - 522 [srapply~Build_Is01Cat.] 40.05 secs (0.001u,0.01s)
Chars 525 - 526 [+] 0. secs (0.u,0.s)
Chars 527 - 556 [(intros~x~a;~exact~(Id~(x~a))).] 0. secs (0.u,0.s)
Chars 559 - 560 [+] 0. secs (0.u,0.s)
Chars 561 - 600 [(intros~x~y~z~f~g~a;~exact~(f~...] 0.001 secs (0.u,0.001s)
Chars 500 - 522 [srapply~Build_Is01Cat.] 0. secs (0.u,0.s)
Chars 527 - 556 [(intros~x~a;~exact~(Id~(x~a))).] 0. secs (0.u,0.s)
Chars 561 - 600 [(intros~x~y~z~f~g~a;~exact~(f~...] 0. secs (0.u,0.s)
Chars 601 - 609 [Defined.] 0.001 secs (0.u,0.s)
Chars 611 - 906 [#[global]~Instance~is0gpd_fora...] 0.001 secs (0.001u,0.s)
Chars 907 - 913 [Proof.] 0. secs (0.u,0.s)
Chars 622 - 633 [(destruct~p).] 40.01 secs (0.001u,0.001s)
Chars 634 - 645 [(destruct~z).] 0. secs (0.u,0.s)
Chars 1477 - 1490 [revert~P~a~f.] 40.01 secs (0.u,0.001s)
Chars 464 - 860 [(refine~~~(@Build_PreCategory~...] 40.05 secs (0.01u,0.012s)
Chars 1493 - 1514 [(induction~p;~trivial).] 0.002 secs (0.001u,0.s)
Chars 646 - 658 [reflexivity.] 0. secs (0.u,0.s)
Chars 464 - 860 [(refine~~~(@Build_PreCategory~...] 0.001 secs (0.u,0.s)
Chars 622 - 633 [(destruct~p).] 0. secs (0.u,0.s)
Chars 1517 - 1530 [(intros~P~a~f).] 0. secs (0.u,0.s)
Chars 863 - 871 [Defined.] 0.001 secs (0.001u,0.s)
Chars 1533 - 1545 [srapply~IHp.] 0. secs (0.u,0.s)
Chars 634 - 645 [(destruct~z).] 0. secs (0.u,0.s)
Chars 872 - 879 [End~pi.] 0.001 secs (0.001u,0.s)
Chars 646 - 658 [reflexivity.] 0. secs (0.u,0.s)
Chars 1477 - 1490 [revert~P~a~f.] 0. secs (0.u,0.s)
Chars 1493 - 1514 [(induction~p;~trivial).] 0.001 secs (0.u,0.s)
Chars 659 - 667 [Defined.] 0. secs (0.u,0.s)
Chars 669 - 758 [#[global]~Instance~isequiv_pat...] 0. secs (0.u,0.s)
Chars 1517 - 1530 [(intros~P~a~f).] 0. secs (0.u,0.s)
Chars 1533 - 1545 [srapply~IHp.] 0. secs (0.u,0.s)
Chars 1546 - 1550 [Qed.] 0. secs (0.u,0.s)
Chars 1552 - 1657 [Definition~pos_peano_rec~(P~:~...] 0. secs (0.u,0.s)
Chars 1659 - 1868 [Definition~pos_peano_rec_beta_...] 0. secs (0.u,0.s)
Chars 881 - 967 [#[local]~Notation~"'forall'~~x...] 0. secs (0.u,0.s)
Chars 968 - 1067 [#[local]~Notation~"'forall'~~x...] 0. secs (0.u,0.s)
Chars 1908 - 2059 [Definition~x0_inj~{z~w~:~Pos}~...] 0. secs (0.u,0.s)
Chars 1122 - 1258 [#[global]~Instance~isstrict_ca...] 0. secs (0.u,0.s)
Chars 1259 - 1265 [Proof.] 0. secs (0.u,0.s)
Chars 2061 - 2212 [Definition~x1_inj~{z~w~:~Pos}~...] 0. secs (0.u,0.s)
Chars 2214 - 2367 [Definition~x0_neq_xH~{z~:~Pos}...] 0. secs (0.u,0.s)
Chars 2369 - 2522 [Definition~x1_neq_xH~{z~:~Pos}...] 0.001 secs (0.001u,0.s)
Chars 2524 - 2681 [Definition~x0_neq_x1~{z~w~:~Po...] 0. secs (0.u,0.s)
Chars 2683 - 2757 [Definition~xH_neq_x0~{z~:~Pos}...] 0.001 secs (0.u,0.001s)
Chars 2759 - 2833 [Definition~xH_neq_x1~{z~:~Pos}...] 0.001 secs (0.001u,0.s)
Chars 2835 - 2913 [Definition~x1_neq_x0~{z~w~:~Po...] 0.001 secs (0.001u,0.s)
Chars 2971 - 3021 [#[global]Instance~decpaths_pos...] 0. secs (0.u,0.s)
Chars 1229 - 1255 [srapply~GraphQuotient_ind.] 40.04 secs (0.002u,0.006s)
Chars 3022 - 3028 [Proof.] 0. secs (0.u,0.s)
Chars 1258 - 1269 [1:~exact~c.] 0. secs (0.u,0.s)
Chars 1272 - 1285 [(intros~a~b~s).] 0. secs (0.u,0.s)
Chars 1288 - 1327 [refine~(transport_const~_~_~@~...] 0.001 secs (0.u,0.s)
Chars 1229 - 1255 [srapply~GraphQuotient_ind.] 0. secs (0.u,0.s)
Chars 1258 - 1269 [1:~exact~c.] 0. secs (0.u,0.s)
Chars 1272 - 1285 [(intros~a~b~s).] 0. secs (0.u,0.s)
Chars 1288 - 1327 [refine~(transport_const~_~_~@~...] 0. secs (0.u,0.s)
Chars 1328 - 1336 [Defined.] 0. secs (0.u,0.s)
Chars 1338 - 1515 [Definition~GraphQuotient_rec_b...] 0.001 secs (0.001u,0.s)
Chars 1516 - 1522 [Proof.] 0. secs (0.u,0.s)
Chars 1268 - 1286 [typeclasses~eauto.] 0.027 secs (0.002u,0.009s)
Chars 1268 - 1286 [typeclasses~eauto.] 0. secs (0.u,0.s)
Chars 1287 - 1291 [Qed.] 0.001 secs (0.001u,0.s)
Chars 1293 - 1342 [#[local]Set~Warnings~Append~"-...] 0. secs (0.u,0.s)
Chars 1343 - 1377 [Module~Export~CategoryPiNotati...] 0. secs (0.u,0.s)
Chars 1380 - 1465 [Notation~"'forall'~~x~..~y~,~P...] 0. secs (0.u,0.s)
Chars 1468 - 1561 [Notation~"'forall'~~x~..~y~,~P...] 0. secs (0.u,0.s)
Chars 1562 - 1586 [End~CategoryPiNotations.] 0. secs (0.u,0.s)
Chars 212 - 225 [econstructor.] 40.037 secs (0.u,0.007s)
Chars 228 - 255 [(intros~[a1|~b1]~[a2|~b2]).] 0.001 secs (0.u,0.s)
Chars 258 - 259 [+] 0. secs (0.u,0.s)
Chars 260 - 278 [exact~(a1~$->~a2).] 0. secs (0.u,0.s)
Chars 281 - 282 [+] 0. secs (0.u,0.s)
Chars 283 - 295 [exact~Empty.] 0. secs (0.u,0.s)
Chars 298 - 299 [+] 0. secs (0.u,0.s)
Chars 300 - 312 [exact~Empty.] 0. secs (0.u,0.s)
Chars 315 - 316 [+] 0. secs (0.u,0.s)
Chars 317 - 335 [exact~(b1~$->~b2).] 0. secs (0.u,0.s)
Chars 212 - 225 [econstructor.] 0. secs (0.u,0.s)
Chars 228 - 255 [(intros~[a1|~b1]~[a2|~b2]).] 0. secs (0.u,0.s)
Chars 260 - 278 [exact~(a1~$->~a2).] 0. secs (0.u,0.s)
Chars 283 - 295 [exact~Empty.] 0. secs (0.u,0.s)
Chars 300 - 312 [exact~Empty.] 0. secs (0.u,0.s)
Chars 317 - 335 [exact~(b1~$->~b2).] 0. secs (0.u,0.s)
Chars 336 - 344 [Defined.] 0. secs (0.u,0.s)
Chars 346 - 427 [#[global]~Instance~is01cat_sum...] 0.001 secs (0.001u,0.s)
Chars 428 - 434 [Proof.] 0. secs (0.u,0.s)
Chars 4340 - 4371 [(destruct~p;~simpl;~unfold~ap10).] 40.045 secs (0.003u,0.013s)
Chars 4374 - 4425 [exact~(apD10_path_forall~f~g~h...] 0.001 secs (0.001u,0.s)
Chars 4340 - 4371 [(destruct~p;~simpl;~unfold~ap10).] 0.04 secs (0.023u,0.016s)
Chars 4374 - 4425 [exact~(apD10_path_forall~f~g~h...] 0. secs (0.u,0.s)
Chars 4426 - 4434 [Defined.] 0.002 secs (0.001u,0.s)
Chars 4509 - 4619 [Definition~ap_apply_l~{A~B~:~T...] 0.001 secs (0.001u,0.s)
Chars 4621 - 4780 [Definition~ap_apply_Fl~{A~B~C~...] 0.002 secs (0.001u,0.s)
Chars 4782 - 4936 [Definition~ap_apply_Fr~{A~B~C~...] 0.001 secs (0.001u,0.s)
Chars 4938 - 5115 [Definition~ap_apply_FlFr~{A~B~...] 0.003 secs (0.003u,0.s)
Chars 5160 - 5316 [Definition~ap_lambda~{A~B~C~:~...] 0. secs (0.u,0.s)
Chars 5317 - 5323 [Proof.] 0. secs (0.u,0.s)
Chars 5326 - 5378 [(destruct~p;~symmetry;~simpl;~...] 0.073 secs (0.001u,0.013s)
Chars 5326 - 5378 [(destruct~p;~symmetry;~simpl;~...] 0. secs (0.u,0.s)
Chars 5379 - 5387 [Defined.] 0. secs (0.u,0.s)
Chars 5418 - 5562 [Definition~functor_arrow~`(f~:...] 0. secs (0.u,0.s)
Chars 5564 - 5654 [Definition~not_contrapositive~...] 0. secs (0.u,0.s)
Chars 5656 - 5915 [Definition~ap_functor_arrow~`(...] 0.002 secs (0.001u,0.s)
Chars 5981 - 6076 [#[global]~Instance~contr_arrow...] 0.001 secs (0.001u,0.s)
Chars 6078 - 6185 [#[global]~Instance~istrunc_arr...] 0.001 secs (0.001u,0.s)
Chars 6211 - 6396 [#[global]~Instance~isequiv_fun...] 0.004 secs (0.003u,0.001s)
Chars 6398 - 6569 [Definition~equiv_functor_arrow...] 0.003 secs (0.003u,0.s)
Chars 6571 - 6736 [Definition~equiv_functor_arrow...] 0. secs (0.u,0.s)
Chars 6992 - 7009 [End~AssumeFunext.] 0.013 secs (0.011u,0.002s)
Chars 7070 - 7173 [#[global]~Instance~decidable_a...] 0. secs (0.u,0.s)
Chars 7174 - 7180 [Proof.] 0. secs (0.u,0.s)
Chars 196 - 249 [(destruct~n,~m;~cbn;~trivial;~...] 40.015 secs (0.004u,0.002s)
Chars 196 - 249 [(destruct~n,~m;~cbn;~trivial;~...] 0.001 secs (0.u,0.001s)
Chars 250 - 254 [Qed.] 0. secs (0.u,0.s)
Chars 298 - 330 [Lemma~int_add_0_l~n~:~0~+~n~=~n.] 0. secs (0.u,0.s)
Chars 331 - 337 [Proof.] 0. secs (0.u,0.s)
Chars 340 - 352 [reflexivity.] 0.012 secs (0.u,0.001s)
Chars 340 - 352 [reflexivity.] 0. secs (0.u,0.s)
Chars 353 - 357 [Qed.] 0. secs (0.u,0.s)
Chars 359 - 391 [Lemma~int_add_0_r~n~:~n~+~0~=~n.] 0. secs (0.u,0.s)
Chars 392 - 398 [Proof.] 0. secs (0.u,0.s)
Chars 401 - 415 [by~destruct~n.] 0.014 secs (0.u,0.002s)
Chars 401 - 415 [by~destruct~n.] 0. secs (0.u,0.s)
Chars 416 - 420 [Qed.] 0. secs (0.u,0.s)
Chars 464 - 496 [Lemma~int_mul_0_l~n~:~0~*~n~=~0.] 0. secs (0.u,0.s)
Chars 497 - 503 [Proof.] 0. secs (0.u,0.s)
Chars 506 - 518 [reflexivity.] 0.01 secs (0.u,0.001s)
Chars 506 - 518 [reflexivity.] 0. secs (0.u,0.s)
Chars 519 - 523 [Qed.] 0. secs (0.u,0.s)
Chars 525 - 557 [Lemma~int_mul_0_r~n~:~n~*~0~=~0.] 0. secs (0.u,0.s)
Chars 558 - 564 [Proof.] 0. secs (0.u,0.s)
Chars 567 - 581 [by~destruct~n.] 0.012 secs (0.u,0.001s)
Chars 567 - 581 [by~destruct~n.] 0. secs (0.u,0.s)
Chars 582 - 586 [Qed.] 0. secs (0.u,0.s)
Chars 634 - 666 [Lemma~int_mul_1_l~n~:~1~*~n~=~n.] 0. secs (0.u,0.s)
Chars 667 - 673 [Proof.] 0. secs (0.u,0.s)
Chars 4760 - 4817 [(destruct~u~as~[u1~u2];~destru...] 40.052 secs (0.003u,0.013s)
Chars 4820 - 4841 [(destruct~pq~as~[p~q]).] 0.001 secs (0.001u,0.s)
Chars 4844 - 4892 [(destruct~p;~simpl~in~q;~destr...] 0.004 secs (0.003u,0.001s)
Chars 676 - 690 [by~destruct~n.] 0.013 secs (0.003u,0.s)
Chars 4760 - 4817 [(destruct~u~as~[u1~u2];~destru...] 0.001 secs (0.001u,0.s)
Chars 676 - 690 [by~destruct~n.] 0. secs (0.u,0.s)
Chars 4820 - 4841 [(destruct~pq~as~[p~q]).] 0. secs (0.u,0.s)
Chars 691 - 695 [Qed.] 0. secs (0.u,0.s)
Chars 697 - 729 [Lemma~int_mul_1_r~n~:~n~*~1~=~n.] 0. secs (0.u,0.s)
Chars 730 - 736 [Proof.] 0. secs (0.u,0.s)
Chars 4844 - 4892 [(destruct~p;~simpl~in~q;~destr...] 0.001 secs (0.u,0.s)
Chars 4893 - 4901 [Defined.] 0.002 secs (0.002u,0.s)
Chars 4903 - 5132 [Definition~pr2_path_sigma_uncu...] 0.003 secs (0.001u,0.001s)
Chars 5133 - 5139 [Proof.] 0. secs (0.u,0.s)
Chars 260 - 273 [econstructor.] 40.009 secs (0.u,0.001s)
Chars 276 - 277 [+] 0. secs (0.u,0.s)
Chars 278 - 297 [(intro;~exact~idmap).] 0. secs (0.u,0.s)
Chars 300 - 301 [+] 0. secs (0.u,0.s)
Chars 302 - 333 [exact~(fun~a~b~c~g~f~=>~g~o~f).] 0. secs (0.u,0.s)
Chars 260 - 273 [econstructor.] 0. secs (0.u,0.s)
Chars 3306 - 3346 [simple~refine~(cate_adjointify...] 40.011 secs (0.u,0.002s)
Chars 3349 - 3350 [-] 0. secs (0.u,0.s)
Chars 278 - 297 [(intro;~exact~idmap).] 0. secs (0.u,0.s)
Chars 302 - 333 [exact~(fun~a~b~c~g~f~=>~g~o~f).] 0. secs (0.u,0.s)
Chars 3351 - 3375 [exact~(cate_inv'~a~b~f).] 0. secs (0.u,0.s)
Chars 3378 - 3379 [-] 0. secs (0.u,0.s)
Chars 334 - 342 [Defined.] 0. secs (0.u,0.s)
Chars 344 - 442 [#[global]~Instance~is2graph_ty...] 0. secs (0.u,0.s)
Chars 3380 - 3388 [exact~f.] 0. secs (0.u,0.s)
Chars 3391 - 3392 [-] 0. secs (0.u,0.s)
Chars 584 - 667 [#[global]~Instance~isgraph_arr...] 0. secs (0.u,0.s)
Chars 3393 - 3420 [exact~(cate_issect'~a~b~f).] 0. secs (0.u,0.s)
Chars 3423 - 3424 [-] 0. secs (0.u,0.s)
Chars 669 - 732 [#[global]Instance~is01cat_arro...] 0. secs (0.u,0.s)
Chars 733 - 739 [Proof.] 0. secs (0.u,0.s)
Chars 3425 - 3452 [exact~(cate_isretr'~a~b~f).] 0. secs (0.u,0.s)
Chars 3306 - 3346 [simple~refine~(cate_adjointify...] 0. secs (0.u,0.s)
Chars 3351 - 3375 [exact~(cate_inv'~a~b~f).] 0. secs (0.u,0.s)
Chars 3380 - 3388 [exact~f.] 0. secs (0.u,0.s)
Chars 3393 - 3420 [exact~(cate_issect'~a~b~f).] 0. secs (0.u,0.s)
Chars 3425 - 3452 [exact~(cate_isretr'~a~b~f).] 0. secs (0.u,0.s)
Chars 3453 - 3461 [Defined.] 0. secs (0.u,0.s)
Chars 3463 - 3497 [Notation~"f~^-1$"~:=~(cate_inv...] 0. secs (0.u,0.s)
Chars 3499 - 3587 [Definition~cate_issect~{A}~`{H...] 0.004 secs (0.003u,0.s)
Chars 3588 - 3594 [Proof.] 0. secs (0.u,0.s)
Chars 132 - 155 [by~apply~Build_IsGraph.] 40.056 secs (0.001u,0.009s)
Chars 132 - 155 [by~apply~Build_IsGraph.] 0. secs (0.u,0.s)
Chars 156 - 164 [Defined.] 0. secs (0.u,0.s)
Chars 166 - 212 [#[global]Instance~is01cat_empt...] 0. secs (0.u,0.s)
Chars 213 - 219 [Proof.] 0. secs (0.u,0.s)
Chars 129 - 149 [(apply~Build_IsGraph).] 40.056 secs (0.u,0.01s)
Chars 152 - 171 [(intros;~exact~Unit).] 0. secs (0.u,0.s)
Chars 129 - 149 [(apply~Build_IsGraph).] 0. secs (0.u,0.s)
Chars 152 - 171 [(intros;~exact~Unit).] 0. secs (0.u,0.s)
Chars 172 - 180 [Defined.] 0. secs (0.u,0.s)
Chars 182 - 226 [#[global]Instance~is01cat_unit...] 0. secs (0.u,0.s)
Chars 227 - 233 [Proof.] 0. secs (0.u,0.s)
Chars 2485 - 2504 [path_forall_beta_t.] 40.013 secs (0.005u,0.001s)
Chars 2485 - 2504 [path_forall_beta_t.] 0. secs (0.u,0.s)
Chars 2505 - 2513 [Defined.] 0.001 secs (0.001u,0.s)
Chars 2550 - 2980 [Lemma~path_forall_recr_beta'~`...] 0.002 secs (0.002u,0.s)
Chars 2981 - 2987 [Proof.] 0. secs (0.u,0.s)
Chars 309 - 331 [unshelve~econstructor.] 40.054 secs (0.u,0.01s)
Chars 334 - 335 [-] 0. secs (0.u,0.s)
Chars 336 - 358 [(intros~a;~reflexivity).] 0. secs (0.u,0.s)
Chars 361 - 362 [-] 0. secs (0.u,0.s)
Chars 363 - 395 [(intros~a~b~c~q~p;~exact~(p~@~...] 0. secs (0.u,0.s)
Chars 309 - 331 [unshelve~econstructor.] 0. secs (0.u,0.s)
Chars 336 - 358 [(intros~a;~reflexivity).] 0. secs (0.u,0.s)
Chars 363 - 395 [(intros~a~b~c~q~p;~exact~(p~@~...] 0. secs (0.u,0.s)
Chars 396 - 404 [Defined.] 0. secs (0.u,0.s)
Chars 406 - 456 [#[local]Instance~is0gpd_paths~...] 0. secs (0.u,0.s)
Chars 457 - 463 [Proof.] 0. secs (0.u,0.s)
Chars 2990 - 3009 [path_forall_beta_t.] 0.029 secs (0.005u,0.002s)
Chars 2990 - 3009 [path_forall_beta_t.] 0. secs (0.u,0.s)
Chars 3010 - 3018 [Defined.] 0.002 secs (0.002u,0.s)
Chars 3069 - 3638 [Lemma~path_forall_recr_beta~`{...] 0.001 secs (0.001u,0.s)
Chars 3639 - 3645 [Proof.] 0. secs (0.u,0.s)
Chars 222 - 255 [(srapply~Build_Is01Cat;~intros...] 0.075 secs (0.001u,0.01s)
Chars 222 - 255 [(srapply~Build_Is01Cat;~intros...] 0. secs (0.u,0.s)
Chars 256 - 264 [Defined.] 0. secs (0.u,0.s)
Chars 266 - 310 [#[global]Instance~is0gpd_empty...] 0. secs (0.u,0.s)
Chars 311 - 317 [Proof.] 0. secs (0.u,0.s)
Chars 3648 - 3662 [etransitivity.] 0.023 secs (0.u,0.002s)
Chars 3665 - 3666 [-] 0. secs (0.u,0.s)
Chars 3667 - 3696 [(apply~path_forall_recr_beta').] 0.001 secs (0.001u,0.s)
Chars 3699 - 3700 [-] 0. secs (0.u,0.s)
Chars 3701 - 3739 [refine~(transport_path_prod'~_...] 0.001 secs (0.001u,0.s)
Chars 3648 - 3662 [etransitivity.] 0. secs (0.u,0.s)
Chars 3667 - 3696 [(apply~path_forall_recr_beta').] 0. secs (0.u,0.s)
Chars 3701 - 3739 [refine~(transport_path_prod'~_...] 0. secs (0.u,0.s)
Chars 3740 - 3748 [Defined.] 0. secs (0.u,0.s)
Chars 4076 - 4297 [Ltac~~pull_app~term~f~:=~~~let...] 0. secs (0.u,0.s)
Chars 4299 - 5495 [Ltac~~infer_path_forall_recr_b...] 0. secs (0.u,0.s)
Chars 5498 - 5895 [Ltac~~transport_path_forall_ha...] 0. secs (0.u,0.s)
Chars 5897 - 6092 [Ltac~~transport_path_forall_ha...] 0. secs (0.u,0.s)
Chars 6134 - 6404 [Lemma~path_forall_2_beta'~`{Fu...] 0.002 secs (0.002u,0.s)
Chars 6405 - 6411 [Proof.] 0. secs (0.u,0.s)
Chars 6414 - 6443 [transport_path_forall_hammer.] 0.031 secs (0.008u,0.001s)
Chars 6446 - 6544 [(repeat~match~goal~with~~~~~~~...] 0.003 secs (0.002u,0.001s)
Chars 6547 - 6559 [reflexivity.] 0. secs (0.u,0.s)
Chars 6414 - 6443 [transport_path_forall_hammer.] 0. secs (0.u,0.s)
Chars 6446 - 6544 [(repeat~match~goal~with~~~~~~~...] 0. secs (0.u,0.s)
Chars 6547 - 6559 [reflexivity.] 0. secs (0.u,0.s)
Chars 6560 - 6564 [Qed.] 0.003 secs (0.003u,0.s)
Chars 6566 - 6822 [Lemma~path_forall_2_beta~`{Fun...] 0.001 secs (0.001u,0.s)
Chars 6823 - 6829 [Proof.] 0. secs (0.u,0.s)
Chars 698 - 729 [(destruct~n~as~[n|~|~n];~trivi...] 40.037 secs (0.u,0.008s)
Chars 732 - 733 [+] 0. secs (0.u,0.s)
Chars 734 - 749 [revert~n~f~H~a.] 0. secs (0.u,0.s)
Chars 754 - 776 [srapply~pos_peano_ind.] 0.001 secs (0.u,0.s)
Chars 781 - 782 [{] 0. secs (0.u,0.s)
Chars 783 - 796 [(intros~f~H~a).] 0. secs (0.u,0.s)
Chars 803 - 812 [symmetry.] 0.001 secs (0.u,0.s)
Chars 819 - 833 [(apply~eisretr).] 0. secs (0.u,0.s)
Chars 834 - 835 [}] 0. secs (0.u,0.s)
Chars 840 - 862 [(hnf;~intros~n~p~f~H~a).] 0. secs (0.u,0.s)
Chars 867 - 902 [refine~(ap~(fun~x~=>~_~x~_)~_~...] 0.001 secs (0.001u,0.s)
Chars 907 - 935 [1:~(rewrite~int_neg_pos_succ).] 0. secs (0.u,0.s)
Chars 940 - 976 [1:~exact~(eisretr~int_succ~(ne...] 0.001 secs (0.001u,0.s)
Chars 981 - 1001 [(apply~moveL_equiv_M).] 0. secs (0.u,0.s)
Chars 1006 - 1020 [(cbn;~symmetry).] 0.001 secs (0.001u,0.s)
Chars 1025 - 1049 [srapply~pos_iter_succ_l.] 0.001 secs (0.001u,0.s)
Chars 1052 - 1053 [+] 0. secs (0.u,0.s)
Chars 1054 - 1058 [(cbn).] 0. secs (0.u,0.s)
Chars 1063 - 1083 [(rewrite~pos_add_1_r).] 0. secs (0.u,0.s)
Chars 1088 - 1112 [srapply~pos_iter_succ_l.] 0.001 secs (0.001u,0.s)
Chars 698 - 729 [(destruct~n~as~[n|~|~n];~trivi...] 0. secs (0.u,0.s)
Chars 734 - 749 [revert~n~f~H~a.] 0. secs (0.u,0.s)
Chars 754 - 776 [srapply~pos_peano_ind.] 0. secs (0.u,0.s)
Chars 783 - 796 [(intros~f~H~a).] 0. secs (0.u,0.s)
Chars 803 - 812 [symmetry.] 0. secs (0.u,0.s)
Chars 819 - 833 [(apply~eisretr).] 0. secs (0.u,0.s)
Chars 840 - 862 [(hnf;~intros~n~p~f~H~a).] 0. secs (0.u,0.s)
Chars 867 - 902 [refine~(ap~(fun~x~=>~_~x~_)~_~...] 0. secs (0.u,0.s)
Chars 907 - 935 [1:~(rewrite~int_neg_pos_succ).] 0. secs (0.u,0.s)
Chars 940 - 976 [1:~exact~(eisretr~int_succ~(ne...] 0. secs (0.u,0.s)
Chars 981 - 1001 [(apply~moveL_equiv_M).] 0. secs (0.u,0.s)
Chars 1006 - 1020 [(cbn;~symmetry).] 0. secs (0.u,0.s)
Chars 1025 - 1049 [srapply~pos_iter_succ_l.] 0. secs (0.u,0.s)
Chars 1054 - 1058 [(cbn).] 0. secs (0.u,0.s)
Chars 1063 - 1083 [(rewrite~pos_add_1_r).] 0. secs (0.u,0.s)
Chars 1088 - 1112 [srapply~pos_iter_succ_l.] 0. secs (0.u,0.s)
Chars 1113 - 1117 [Qed.] 0.001 secs (0.001u,0.s)
Chars 1119 - 1249 [Definition~int_iter_succ_r~{A}...] 0. secs (0.u,0.s)
Chars 1250 - 1256 [Proof.] 0. secs (0.u,0.s)
Chars 6832 - 6861 [transport_path_forall_hammer.] 0.057 secs (0.008u,0.001s)
Chars 6864 - 6876 [reflexivity.] 0. secs (0.u,0.s)
Chars 6832 - 6861 [transport_path_forall_hammer.] 0. secs (0.u,0.s)
Chars 6864 - 6876 [reflexivity.] 0. secs (0.u,0.s)
Chars 6877 - 6881 [Qed.] 0.002 secs (0.002u,0.s)
Chars 7346 - 7422 [Ltac~induction_hammer~H~:=~des...] 0. secs (0.u,0.s)
Chars 7582 - 8464 [Ltac~~clear_contr_path~p~:=~~~...] 0. secs (0.u,0.s)
Chars 8559 - 8632 [Ltac~clear_path_no_check~p~:=~...] 0. secs (0.u,0.s)
Chars 8633 - 8861 [Ltac~~clear_path~p~:=~~~let~t~...] 0. secs (0.u,0.s)
Chars 9265 - 9449 [Ltac~~step_clear_paths~:=~~~id...] 0. secs (0.u,0.s)
Chars 9450 - 9503 [Ltac~clear_paths~:=~progress~r...] 0. secs (0.u,0.s)
Chars 9558 - 9777 [Ltac~~step_clear_paths_in_matc...] 0. secs (0.u,0.s)
Chars 9778 - 9849 [Ltac~clear_paths_in_match~:=~p...] 0. secs (0.u,0.s)
Chars 9898 - 10076 [Definition~match_eta~{T}~{x~y~...] 0.001 secs (0.001u,0.s)
Chars 10078 - 10264 [Definition~match_eta1~{T}~{x~:...] 0.001 secs (0.001u,0.s)
Chars 10266 - 10456 [Definition~match_eta2~{T}~{x~:...] 0.001 secs (0.001u,0.s)
Chars 10595 - 11186 [Ltac~~step_path_induction_hamm...] 0. secs (0.u,0.s)
Chars 11188 - 11261 [Ltac~path_induction_hammer~:=~...] 0. secs (0.u,0.s)
Chars 11369 - 11466 [Ltac~subst_body~:=~repeat~matc...] 0. secs (0.u,0.s)
Chars 11600 - 11687 [Ltac~do_with_hyp~tac~:=~idtac;...] 0. secs (0.u,0.s)
Chars 11689 - 11748 [Ltac~rewrite_hyp'~:=~do_with_h...] 0. secs (0.u,0.s)
Chars 11749 - 11789 [Ltac~rewrite_hyp~:=~repeat~rew...] 0. secs (0.u,0.s)
Chars 11790 - 11856 [Ltac~rewrite_rev_hyp'~:=~do_wi...] 0. secs (0.u,0.s)
Chars 11857 - 11905 [Ltac~rewrite_rev_hyp~:=~repeat...] 0. secs (0.u,0.s)
Chars 11907 - 11962 [Ltac~apply_hyp'~:=~do_with_hyp...] 0. secs (0.u,0.s)
Chars 11963 - 11999 [Ltac~apply_hyp~:=~repeat~apply...] 0. secs (0.u,0.s)
Chars 12000 - 12057 [Ltac~eapply_hyp'~:=~do_with_hy...] 0. secs (0.u,0.s)
Chars 12058 - 12096 [Ltac~eapply_hyp~:=~repeat~eapp...] 0. secs (0.u,0.s)
Chars 12159 - 12275 [Ltac~~simpl_do_clear~tac~term~...] 0. secs (0.u,0.s)
Chars 13157 - 13266 [Tactic~Notation~"simpl"~"rewri...] 0. secs (0.u,0.s)
Chars 13267 - 13376 [Tactic~Notation~"simpl"~"rewri...] 0. secs (0.u,0.s)
Chars 13377 - 13486 [Tactic~Notation~"simpl"~"rewri...] 0. secs (0.u,0.s)
Chars 13488 - 13618 [Tactic~Notation~"simpl"~"rewri...] 0. secs (0.u,0.s)
Chars 13619 - 13749 [Tactic~Notation~"simpl"~"rewri...] 0. secs (0.u,0.s)
Chars 13750 - 13880 [Tactic~Notation~"simpl"~"rewri...] 0. secs (0.u,0.s)
Chars 13882 - 14006 [Tactic~Notation~"simpl"~"rewri...] 0. secs (0.u,0.s)
Chars 14007 - 14131 [Tactic~Notation~"simpl"~"rewri...] 0. secs (0.u,0.s)
Chars 14132 - 14256 [Tactic~Notation~"simpl"~"rewri...] 0. secs (0.u,0.s)
Chars 14258 - 14403 [Tactic~Notation~"simpl"~"rewri...] 0. secs (0.u,0.s)
Chars 14404 - 14549 [Tactic~Notation~~"simpl"~"rewr...] 0. secs (0.u,0.s)
Chars 14550 - 14695 [Tactic~Notation~~"simpl"~"rewr...] 0. secs (0.u,0.s)
Chars 14697 - 14829 [Tactic~Notation~"simpl"~"rewri...] 0. secs (0.u,0.s)
Chars 14830 - 14962 [Tactic~Notation~"simpl"~"rewri...] 0. secs (0.u,0.s)
Chars 14963 - 15095 [Tactic~Notation~"simpl"~"rewri...] 0. secs (0.u,0.s)
Chars 15098 - 15212 [Tactic~Notation~"simpl"~"rewri...] 0. secs (0.u,0.s)
Chars 15213 - 15327 [Tactic~Notation~"simpl"~"rewri...] 0. secs (0.u,0.s)
Chars 15328 - 15442 [Tactic~Notation~"simpl"~"rewri...] 0. secs (0.u,0.s)
Chars 15444 - 15579 [Tactic~Notation~"simpl"~"rewri...] 0. secs (0.u,0.s)
Chars 15580 - 15715 [Tactic~Notation~"simpl"~"rewri...] 0. secs (0.u,0.s)
Chars 15716 - 15851 [Tactic~Notation~"simpl"~"rewri...] 0. secs (0.u,0.s)
Chars 15853 - 15982 [Tactic~Notation~"simpl"~"rewri...] 0. secs (0.u,0.s)
Chars 15983 - 16112 [Tactic~Notation~"simpl"~"rewri...] 0. secs (0.u,0.s)
Chars 16113 - 16242 [Tactic~Notation~"simpl"~"rewri...] 0. secs (0.u,0.s)
Chars 16244 - 16394 [Tactic~Notation~~"simpl"~"rewr...] 0. secs (0.u,0.s)
Chars 16395 - 16545 [Tactic~Notation~~"simpl"~"rewr...] 0. secs (0.u,0.s)
Chars 16546 - 16696 [Tactic~Notation~~"simpl"~"rewr...] 0. secs (0.u,0.s)
Chars 16698 - 16835 [Tactic~Notation~"simpl"~"rewri...] 0. secs (0.u,0.s)
Chars 16836 - 16973 [Tactic~Notation~"simpl"~"rewri...] 0. secs (0.u,0.s)
Chars 16974 - 17111 [Tactic~Notation~"simpl"~"rewri...] 0. secs (0.u,0.s)
Chars 17114 - 17228 [Tactic~Notation~"simpl"~"rewri...] 0. secs (0.u,0.s)
Chars 17229 - 17343 [Tactic~Notation~"simpl"~"rewri...] 0. secs (0.u,0.s)
Chars 17344 - 17458 [Tactic~Notation~"simpl"~"rewri...] 0. secs (0.u,0.s)
Chars 17460 - 17595 [Tactic~Notation~"simpl"~"rewri...] 0. secs (0.u,0.s)
Chars 17596 - 17731 [Tactic~Notation~"simpl"~"rewri...] 0. secs (0.u,0.s)
Chars 17732 - 17867 [Tactic~Notation~"simpl"~"rewri...] 0. secs (0.u,0.s)
Chars 17869 - 17998 [Tactic~Notation~"simpl"~"rewri...] 0. secs (0.u,0.s)
Chars 17999 - 18128 [Tactic~Notation~"simpl"~"rewri...] 0. secs (0.u,0.s)
Chars 18129 - 18258 [Tactic~Notation~"simpl"~"rewri...] 0. secs (0.u,0.s)
Chars 18260 - 18410 [Tactic~Notation~~"simpl"~"rewr...] 0. secs (0.u,0.s)
Chars 18411 - 18561 [Tactic~Notation~~"simpl"~"rewr...] 0. secs (0.u,0.s)
Chars 18562 - 18712 [Tactic~Notation~~"simpl"~"rewr...] 0. secs (0.u,0.s)
Chars 18714 - 18851 [Tactic~Notation~"simpl"~"rewri...] 0. secs (0.u,0.s)
Chars 18852 - 18989 [Tactic~Notation~"simpl"~"rewri...] 0. secs (0.u,0.s)
Chars 18990 - 19127 [Tactic~Notation~"simpl"~"rewri...] 0. secs (0.u,0.s)
Chars 19129 - 19195 [Ltac~head_hnf~expr~:=~let~expr...] 0. secs (0.u,0.s)
Chars 19447 - 19590 [Ltac~~destruct_all_matches_the...] 0. secs (0.u,0.s)
Chars 19592 - 19681 [Ltac~~destruct_all_matches~mat...] 0. secs (0.u,0.s)
Chars 19682 - 19760 [Ltac~destruct_all_matches'~mat...] 0. secs (0.u,0.s)
Chars 19813 - 19896 [Ltac~destruct_type_matcher~T~H...] 0. secs (0.u,0.s)
Chars 19897 - 19973 [Ltac~destruct_type~T~:=~destru...] 0. secs (0.u,0.s)
Chars 19974 - 20052 [Ltac~destruct_type'~T~:=~destr...] 0. secs (0.u,0.s)
Chars 20054 - 20133 [Ltac~destruct_head_matcher~T~H...] 0. secs (0.u,0.s)
Chars 20134 - 20210 [Ltac~destruct_head~T~:=~destru...] 0. secs (0.u,0.s)
Chars 20211 - 20289 [Ltac~destruct_head'~T~:=~destr...] 0. secs (0.u,0.s)
Chars 20291 - 20378 [Ltac~destruct_head_hnf_matcher...] 0. secs (0.u,0.s)
Chars 20379 - 20463 [Ltac~~destruct_head_hnf~T~:=~~...] 0. secs (0.u,0.s)
Chars 20464 - 20550 [Ltac~~destruct_head_hnf'~T~:=~...] 0. secs (0.u,0.s)
Chars 20685 - 20925 [Ltac~~context_to_lambda~G~:=~~...] 0. secs (0.u,0.s)
Chars 5142 - 5199 [(destruct~u~as~[u1~u2];~destru...] 1.144 secs (0.005u,0.015s)
Chars 5202 - 5223 [(destruct~pq~as~[p~q]).] 0.002 secs (0.001u,0.001s)
Chars 5226 - 5274 [(destruct~p;~simpl~in~q;~destr...] 0.011 secs (0.008u,0.002s)
Chars 5142 - 5199 [(destruct~u~as~[u1~u2];~destru...] 0.002 secs (0.001u,0.s)
Chars 5202 - 5223 [(destruct~pq~as~[p~q]).] 0. secs (0.u,0.s)
Chars 5226 - 5274 [(destruct~p;~simpl~in~q;~destr...] 0.004 secs (0.004u,0.s)
Chars 5275 - 5283 [Defined.] 0.006 secs (0.005u,0.s)
Chars 5285 - 5421 [Definition~eta_path_sigma_uncu...] 0.001 secs (0.u,0.s)
Chars 5422 - 5428 [Proof.] 0. secs (0.u,0.s)
Chars 5431 - 5442 [(destruct~p).] 0.087 secs (0.001u,0.013s)
Chars 5443 - 5455 [reflexivity.] 0. secs (0.u,0.s)
Chars 5431 - 5442 [(destruct~p).] 0. secs (0.u,0.s)
Chars 5443 - 5455 [reflexivity.] 0. secs (0.u,0.s)
Chars 5456 - 5464 [Defined.] 0. secs (0.u,0.s)
Chars 5466 - 5694 [Lemma~transport_pr1_path_sigma...] 0.002 secs (0.u,0.001s)
Chars 5695 - 5701 [Proof.] 0. secs (0.u,0.s)
Chars 466 - 478 [constructor.] 1.261 secs (0.u,0.011s)
Chars 481 - 506 [(intros~x~y~p;~exact~p^).] 0. secs (0.u,0.s)
Chars 466 - 478 [constructor.] 0. secs (0.u,0.s)
Chars 481 - 506 [(intros~x~y~p;~exact~p^).] 0. secs (0.u,0.s)
Chars 507 - 515 [Defined.] 0. secs (0.u,0.s)
Chars 5704 - 5743 [(destruct~pq~as~[p~q],~u,~v;~s...] 0.104 secs (0.004u,0.015s)
Chars 5746 - 5772 [(destruct~p,~q;~simpl~in~*).] 0.003 secs (0.002u,0.s)
Chars 5775 - 5787 [reflexivity.] 0. secs (0.u,0.s)
Chars 5704 - 5743 [(destruct~pq~as~[p~q],~u,~v;~s...] 0.001 secs (0.001u,0.s)
Chars 5746 - 5772 [(destruct~p,~q;~simpl~in~*).] 0. secs (0.u,0.s)
Chars 5775 - 5787 [reflexivity.] 0. secs (0.u,0.s)
Chars 5788 - 5796 [Defined.] 0.002 secs (0.002u,0.s)
Chars 5798 - 5971 [Definition~pr1_path_sigma~`{P~...] 0.002 secs (0.002u,0.s)
Chars 6024 - 6201 [Definition~ap_pr1_path_sigma~{...] 0.002 secs (0.002u,0.s)
Chars 6203 - 6433 [Definition~pr2_path_sigma~`{P~...] 0.005 secs (0.004u,0.s)
Chars 6435 - 6573 [Definition~eta_path_sigma~`{P~...] 0.001 secs (0.001u,0.s)
Chars 6575 - 6835 [Definition~transport_pr1_path_...] 0.003 secs (0.003u,0.s)
Chars 6918 - 7027 [#[global]~Instance~isequiv_pat...] 0. secs (0.u,0.s)
Chars 7028 - 7034 [Proof.] 0. secs (0.u,0.s)
     = {| round := 3; n2 := 3; n1 := 0; nh := 0 |}
     : state
     = {| round := 4; n2 := 2; n1 := 4; nh := 0 |}
     : state
     = {| round := 5; n2 := 2; n1 := 3; nh := 5 |}
     : state
     = {| round := 2000; n2 := 1; n1 := 90; nh := 1102 |}
     : state
     = {| round := 10; n2 := 2; n1 := 3; nh := 0 |}
     : state
     = {| round := 22; n2 := 2; n1 := 2; nh := 0 |}
     : state
     = {| round := 46; n2 := 2; n1 := 1; nh := 0 |}
     : state
     = {| round := 94; n2 := 2; n1 := 0; nh := 0 |}
     : state
     = {| round := 95; n2 := 1; n1 := 95; nh := 0 |}
     : state
     = {| round := 192; n2 := 1; n1 := 94; nh := 0 |}
     : state
     = {| round := 386; n2 := 1; n1 := 93; nh := 0 |}
     : state
     = st_get >>=
       ((fix denote (A : UU0) (p : program A) {struct p} : ?M A :=
           match p in (program T) return (?M T) with
           | @p_ret _ _ A0 v => Ret v
           | @p_bind _ _ A0 B m f => denote A0 m >>= (denote B \o f)
           | @p_cond _ _ A0 true p1 _ => denote A0 p1
           | @p_cond _ _ A0 false _ p2 => denote A0 p2
           | p_repeat n p0 =>
               (fix loop (m : nat) : ?M unit :=
                  match m with
                  | 0 => Ret tt
                  | m'.+1 => denote unit p0 >> loop m'
                  end) n
           | p_while fuel c p0 =>
               (fix loop (m : nat) : ?M unit :=
                  match m with
                  | 0 => Ret tt
                  | m'.+1 =>
                      st_get >>=
                      (fun s : nat =>
                       if c s then denote unit p0 >> loop m' else Ret tt)
                  end) fuel
           | p_get => st_get
           | p_put s' => st_put s'
           | p_mark t => st_mark t
           end) nat \o
          (fun n : nat =>
           p_do _ : unit <- p_put n.+1; p_do _ : unit <- p_mark n; p_ret n))
     : ?M nat
     = (0, (1, [:: 0]))
     : nat * (nat * seq nat)
     = (0, (1, [:: 0]))
     : nat * (nat * seq nat)
     = eT [:: 0] (eT 0 (e 1))
     : {l : seq nat &
       {a : nat &
       {s' : nat | step_star (0, p_nonce `; stop nat) l (s', stop nat a)}}}
     = (false, (2, [:: 0; 1]))
     : bool * (nat * seq nat)
     = (false, (2, [:: 0; 1]))
     : bool * (nat * seq nat)
     = eT [:: 0; 1] (eT false (e 2))
     : {l : seq nat &
       {a : bool_eqType &
       {s' : nat
       | step_star (0, p_nonce_twice `; stop bool_eqType) l
           (s', stop bool_eqType a)}}}
     = (tt, (0, [:: false; false; false; false; false; true]))
     : unit * (nat * seq bool)
     = (tt, (0, [:: false; false; false; false; false; true]))
     : unit * (nat * seq bool)
     = eT [:: false; false; false; false; false; true] (eT tt (e 0))
     : {l : seq bool &
       {a : unit &
       {s' : nat
       | step_star (5, p_countdown 100 `; stop unit) l (s', stop unit a)}}}
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 (ltN_count (stail p)) (ltN_pred_lemma0 k k0 E)))
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 (ltN_count (stail p)) (ltN_pred_lemma0 k k0 E)))
     = eT [::] (eT tt (e 21))
     : {l : seq unit &
       {a : unit &
       {s' : nat
       | step_star (0, p_multiply 3 7 `; stop unit) l (s', stop unit a)}}}
     = eT [::] (eT tt (e (1, 3)))
     : {l : seq unit &
       {a : unit &
       {s' : nat * nat
       | step_star (0, 0, p_division 22 7 `; stop unit) l (s', stop unit a)}}}
     = Some (eT [::] (eT stop unit tt (e (1, 3))))
     : option
         {l : seq unit &
         {f' : continuation &
         {s' : nat * nat
         | step_n 15 (0, 0, p_division 22 7 `; stop unit) l (s', f')}}}
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
rewrite if_dtt
if (n =? S r)
then
(fun E : (n =? S r) = true =>
 ltN_of_nat 0 n
   (ltN_S_mod_lemma1 (exist (fun k : nat => (k <? n) = true) r Hr) E))
else
(fun E : (n =? S r) = false =>
 ltN_of_nat (S r) n
   (ltN_S_mod_lemma2 (exist (fun k : nat => (k <? n) = true) r Hr) E))
rewrite if_dtt
if (n =? proj1_sig r)
then
(fun E : (n =? proj1_sig r) = true =>
 ltN_of_nat 0 (S n) (ltN_S_mod_lemma1 r E))
else
(fun E : (n =? proj1_sig r) = false =>
 ltN_of_nat (S (proj1_sig r)) (S n) (ltN_S_mod_lemma2 r E))
rewrite if_dtt
if (n =? S (proj1_sig k))
then
(fun E : (n =? S (proj1_sig k)) = true =>
 ltN_of_nat 0 n (ltN_S_mod_lemma1 k E))
else
(fun E : (n =? S (proj1_sig k)) = false =>
 ltN_of_nat (S (proj1_sig k)) n (ltN_S_mod_lemma2 k E))
out of reach
Tactic call ran for 0.003 secs (0.002u,0.001s) (failure)
clear  H1  :  (False -> b1 = false)
clear  Ha  :  (False -> False)
clear  Ha  :  (False -> False)
clear  Ha  :  (False -> False)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Tactic call ran for 0.019 secs (0.009u,0.01s) (success)
Tactic call ran for 0.006 secs (0.006u,0.s) (success)
Tactic call ran for 0.006 secs (0.006u,0.s) (success)
Tactic call ran for 0.01 secs (0.008u,0.001s) (success)
Tactic call ran for 0.006 secs (0.006u,0.s) (success)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.001u,0.001s) (failure)
out of reach
Tactic call ran for 0.004 secs (0.003u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.001 secs (0.u,0.s) (failure)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
clear  H0a'  :  (False -> cmpA a a' <> Lt)
Tactic call ran for 0.015 secs (0.015u,0.s) (success)
Tactic call ran for 0.015 secs (0.015u,0.s) (success)
Tactic call ran for 0.005 secs (0.005u,0.s) (success)
Tactic call ran for 0.004 secs (0.004u,0.s) (success)
Tactic call ran for 0.005 secs (0.005u,0.s) (success)
Tactic call ran for 0.004 secs (0.003u,0.s) (success)
Tactic call ran for 0.004 secs (0.004u,0.s) (success)
     = @^~ 8
     : M nat
     = tt
     : [the monad of idfun] unit
     = @^~ None
     : [the contMonad of ContMonad.acto bool] (option nat)
     = @^~ (Some 3)
     : [the contMonad of ContMonad.acto bool] (option nat)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
rewrite if_dtt
if (proj1_sig k1 + proj1_sig k2 <? n)
then
(fun E : (proj1_sig k1 + proj1_sig k2 <? n) = true =>
 ltN_of_nat (proj1_sig k1 + proj1_sig k2) n E)
else
(fun E : (proj1_sig k1 + proj1_sig k2 <? n) = false =>
 ltN_of_nat (proj1_sig k1 + proj1_sig k2 - n) n (ltN_plus_mod_lemma1 k1 k2 E))
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
Tactic call ran for 0.002 secs (0.001u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.001u,0.001s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.005 secs (0.003u,0.001s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.005 secs (0.005u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.001u,0.001s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.001u,0.001s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.002u,0.001s) (failure)
out of reach
Tactic call ran for 0.005 secs (0.005u,0.s) (failure)
out of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
out of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
out of reach
Tactic call ran for 0.004 secs (0.002u,0.001s) (failure)
out of reach
Tactic call ran for 0.004 secs (0.003u,0.s) (failure)
out of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
out of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
out of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
out of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
out of reach
Tactic call ran for 0.004 secs (0.004u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.003u,0.s) (failure)
Finished transaction in 393.509 secs (390.713u,2.766s) (successful)
Finished transaction in 35.511 secs (35.198u,0.309s) (successful)
Finished transaction in 35.829 secs (35.546u,0.28s) (successful)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.001 secs (0.u,0.s) (failure)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.001 secs (0.u,0.s) (failure)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
rewrite if_dtt
if
match (let (a, _) := k0 in a) with
| 0 => false
| S m' =>
    (fix leb (n m : nat) {struct n} : bool :=
       match n with
       | 0 => true
       | S n' => match m with
                 | 0 => false
                 | S m'0 => leb n' m'0
                 end
       end) f m'
end
then
(fun
   E1 : match (let (a, _) := k0 in a) with
        | 0 => false
        | S m' =>
            (fix leb (n m : nat) {struct n} : bool :=
               match n with
               | 0 => true
               | S n' => match m with
                         | 0 => false
                         | S m'0 => leb n' m'0
                         end
               end) f m'
        end = true =>
 exist
   (fun k : nat =>
    (fix leb (n m : nat) {struct n} : bool :=
       match n with
       | 0 => true
       | S n' => match m with
                 | 0 => false
                 | S m' => leb n' m'
                 end
       end) k n = true) f
   (ltN_intro_lemma1 n k0
      (exist
         (fun k : nat =>
          match n with
          | 0 => false
          | S m' =>
              (fix leb (n m : nat) {struct n} : bool :=
                 match n with
                 | 0 => true
                 | S n' =>
                     match m with
                     | 0 => false
                     | S m'0 => leb n' m'0
                     end
                 end) k m'
          end = true) f low) E1))
else
(fun
   E1 : match (let (a, _) := k0 in a) with
        | 0 => false
        | S m' =>
            (fix leb (n m : nat) {struct n} : bool :=
               match n with
               | 0 => true
               | S n' => match m with
                         | 0 => false
                         | S m'0 => leb n' m'0
                         end
               end) f m'
        end = false =>
 exist
   (fun k : nat =>
    (fix leb (n m : nat) {struct n} : bool :=
       match n with
       | 0 => true
       | S n' => match m with
                 | 0 => false
                 | S m' => leb n' m'
                 end
       end) k n = true) (S f)
   (ltN_intro_lemma2 n k0
      (exist
         (fun k : nat =>
          match n with
          | 0 => false
          | S m' =>
              (fix leb (n m : nat) {struct n} : bool :=
                 match n with
                 | 0 => true
                 | S n' =>
                     match m with
                     | 0 => false
                     | S m'0 => leb n' m'0
                     end
                 end) k m'
          end = true) f low) E1))
rewrite if_dtt
if
match (let (a, _) := k0 in a) with
| 0 => false
| S m' =>
    (fix leb (n m : nat) {struct n} : bool :=
       match n with
       | 0 => true
       | S n' => match m with
                 | 0 => false
                 | S m'0 => leb n' m'0
                 end
       end) f m'
end
then
(fun
   E1 : match (let (a, _) := k0 in a) with
        | 0 => false
        | S m' =>
            (fix leb (n m : nat) {struct n} : bool :=
               match n with
               | 0 => true
               | S n' => match m with
                         | 0 => false
                         | S m'0 => leb n' m'0
                         end
               end) f m'
        end = true =>
 exist
   (fun k : nat =>
    (fix leb (n m : nat) {struct n} : bool :=
       match n with
       | 0 => true
       | S n' => match m with
                 | 0 => false
                 | S m' => leb n' m'
                 end
       end) k n = true) f
   (ltN_intro_lemma1 n k0
      (exist
         (fun k : nat =>
          match n with
          | 0 => false
          | S m' =>
              (fix leb (n m : nat) {struct n} : bool :=
                 match n with
                 | 0 => true
                 | S n' =>
                     match m with
                     | 0 => false
                     | S m'0 => leb n' m'0
                     end
                 end) k m'
          end = true) f low) E1))
else
(fun
   E1 : match (let (a, _) := k0 in a) with
        | 0 => false
        | S m' =>
            (fix leb (n m : nat) {struct n} : bool :=
               match n with
               | 0 => true
               | S n' => match m with
                         | 0 => false
                         | S m'0 => leb n' m'0
                         end
               end) f m'
        end = false =>
 exist
   (fun k : nat =>
    (fix leb (n m : nat) {struct n} : bool :=
       match n with
       | 0 => true
       | S n' => match m with
                 | 0 => false
                 | S m' => leb n' m'
                 end
       end) k n = true) (S f)
   (ltN_intro_lemma2 n k0
      (exist
         (fun k : nat =>
          match n with
          | 0 => false
          | S m' =>
              (fix leb (n m : nat) {struct n} : bool :=
                 match n with
                 | 0 => true
                 | S n' =>
                     match m with
                     | 0 => false
                     | S m'0 => leb n' m'0
                     end
                 end) k m'
          end = true) f low) E1))
     = @^~ 8
     : M nat
     = tt
     : [the monad of idfun] unit
     = @^~ None
     : [the contMonad of ContMonad.acto bool] (option nat)
     = @^~ (Some 3)
     : [the contMonad of ContMonad.acto bool] (option nat)
Tactic call ran for 0.014 secs (0.014u,0.s) (success)
Tactic call ran for 0.007 secs (0.006u,0.s) (success)
Tactic call ran for 0.01 secs (0.005u,0.004s) (success)
clear  H1  :  (False -> adot' y x = true)
clear  H1  :  (False -> adot' y x = true)
Tactic call ran for 0.01 secs (0.01u,0.s) (success)
Tactic call ran for 0.004 secs (0.002u,0.002s) (success)
Tactic call ran for 0.008 secs (0.007u,0.s) (success)
Tactic call ran for 0.002 secs (0.u,0.001s) (success)
Tactic call ran for 0.008 secs (0.008u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.008 secs (0.008u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.016 secs (0.016u,0.s) (success)
Tactic call ran for 0.008 secs (0.008u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.019 secs (0.019u,0.s) (success)
Tactic call ran for 0.016 secs (0.016u,0.s) (success)
Tactic call ran for 0.008 secs (0.008u,0.s) (success)
Tactic call ran for 0.016 secs (0.016u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Warning: gather_SEP with numeric arguments is deprecated
Tactic call ran for 0.041 secs (0.019u,0.022s) (success)
Warning: gather_SEP with numeric arguments is deprecated
Tactic call ran for 0.016 secs (0.016u,0.s) (success)
Warning: gather_SEP with numeric arguments is deprecated
Warning: gather_SEP with numeric arguments is deprecated
Warning: gather_SEP with numeric arguments is deprecated
Tactic call ran for 0.017 secs (0.016u,0.001s) (success)
Warning: gather_SEP with numeric arguments is deprecated
Warning: gather_SEP with numeric arguments is deprecated
Warning: gather_SEP with numeric arguments is deprecated
Warning: gather_SEP with numeric arguments is deprecated
Warning: gather_SEP with numeric arguments is deprecated
Warning: gather_SEP with numeric arguments is deprecated
Warning: gather_SEP with numeric arguments is deprecated
Tactic call ran for 0.016 secs (0.016u,0.s) (success)
Warning: gather_SEP with numeric arguments is deprecated
Warning: gather_SEP with numeric arguments is deprecated
Tactic call ran for 0.009 secs (0.008u,0.001s) (success)
Tactic call ran for 0.009 secs (0.009u,0.s) (success)
Tactic call ran for 0.008 secs (0.008u,0.s) (success)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.001u,0.001s) (failure)
out of reach
Tactic call ran for 0.001 secs (0.u,0.s) (failure)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
Tactic call ran for 0.013 secs (0.013u,0.s) (success)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
clear  IHn  :  (False -> n <= n')
clear  IHn  :  (False -> n <= n')
clear  IHn  :  (False -> n <= n')
Tactic call ran for 0.003 secs (0.003u,0.s) (success)
clear  IHn  :  (False -> n <= n')
clear  IHn  :  (False -> n <= n')
clear  IHn  :  (False -> n <= n')
clear  IHn  :  (False -> n <= n')
Tactic call ran for 0.004 secs (0.004u,0.s) (success)
Tactic call ran for 0.005 secs (0.005u,0.s) (success)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
Tactic call ran for 0.005 secs (0.005u,0.s) (success)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.003 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.001 secs (0.001u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.002u,0.s) (failure)
out of reach
Tactic call ran for 0.002 secs (0.001u,0.s) (failure)
Warning: (map fst l) is not simplified in Hyp_eq
Warning: (map fst z) is not simplified in Hi
     = @^~ 8
     : M nat
     = tt
     : [the monad of idfun] unit
     = @^~ None
     : [the contMonad of ContMonad.acto bool] (option nat)
     = @^~ (Some 3)
     : [the contMonad of ContMonad.acto bool] (option nat)
type_is_by_reference: type -> bool
is_numeric_type: type -> bool
type_is_by_value: type -> bool
is_long_type: type -> bool
is_pointer_type: type -> bool
is_anyfloat_type: type -> bool
is_ptrofs_type: type -> bool
bool_type: type -> bool
is_int32_type: type -> bool
is_int_type: type -> bool
is_scalar_type: type -> bool
is_float_type: type -> bool
is_single_type: type -> bool
type_is_volatile: type -> bool
same_base_type: type -> type -> bool
is_neutral_cast: type -> type -> bool
eqb_type: type -> type -> bool
composite_compute.complete_legal_cosu_type: composite_env -> type -> bool
complete_type: composite_env -> type -> bool
complete_or_function_type: composite_env -> type -> bool
align_mem.LegalAlignasStrong.legal_alignas_type:
  composite_env -> Maps.PTree.t Z -> Maps.PTree.t bool -> type -> bool
align_mem.LegalAlignasFacts.LegalAlignas.legal_alignas_type:
  composite_env -> Maps.PTree.t Z -> Maps.PTree.t bool -> type -> bool
align_mem.LegalAlignasStrict.legal_alignas_type:
  composite_env -> Maps.PTree.t Z -> Maps.PTree.t bool -> type -> bool
align_mem.LegalAlignasStrongFacts.LegalAlignas.legal_alignas_type:
  composite_env -> Maps.PTree.t Z -> Maps.PTree.t bool -> type -> bool
align_mem.LegalAlignasStrictFacts.LegalAlignas.legal_alignas_type:
  composite_env -> Maps.PTree.t Z -> Maps.PTree.t bool -> type -> bool
Crunching:
(exists r1 r2 : R,
   interval_sum abs n a r1 /\ interval_sum abs a b r2 /\ Hb = (r1 + r2)%R)
Crunching:
(n <= a <= b ->
 exists r1 r2 : R,
   interval_sum abs n a r1 /\ interval_sum abs a b r2 /\ Hb = (r1 + r2)%R)
Crunching:
(exists r1 r2 : R,
   interval_sum abs n a r1 /\ interval_sum abs a b r2 /\ Hb = (r1 + r2)%R)
Crunching:
(exists r1 r2 : R,
   interval_sum p q rm r1 /\ interval_sum p rm rr r2 /\ r = (r1 + r2)%R)
Crunching:
(exists r1 r2 : R,
   interval_sum p q rm r1 /\ interval_sum p rm rr r2 /\ r = (r1 + r2)%R)
Crunching:
(exists r1 r2 : R,
   interval_sum abs n rm r1 /\ interval_sum abs rm x r2 /\ y = (r1 + r2)%R)
Crunching:
(sin_in R0² H2 ->
 exists r2 : R,
   interval_sum abs n a R0 /\ interval_sum abs a b r2 /\ Hb = (R0 + r2)%R)
Crunching:
(exists r1 r2 : R,
   interval_sum abs n a r1 /\ interval_sum abs a b r2 /\ Hb = (r1 + r2)%R)
Crunching:
(exists r1 r2 : R,
   interval_sum abs n a r1 /\ interval_sum abs a b r2 /\ Hb = (r1 + r2)%R)
Crunching:
(n <= a <= b ->
 exists r1 r2 : R,
   interval_sum abs n a r1 /\ interval_sum abs a b r2 /\ Hb = (r1 + r2)%R)
Crunching:
(sin_in R0² H2 ->
 exists r2 : R,
   interval_sum abs n a R0 /\ interval_sum abs a b r2 /\ Hb = (R0 + r2)%R)
Crunching:
(exists r1 r2 : R,
   interval_sum abs n a r1 /\ interval_sum abs a b r2 /\ Hb = (r1 + r2)%R)
Crunching: (ConstructiveCauchyReals.CRealEq (Rrepr r1) (Rrepr r2))
Crunching: ((r2 - r1)%R = y)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (ρ = Mρ)
Crunching: (ρ = Mρ)
Crunching: (ρ = Mρ)
Crunching: (ConstructiveCauchyReals.CRealEq (Rrepr r1) (Rrepr r2))
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (Rmin a b = b)
Crunching: ((r2 - r1)%R = y)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Finished transaction in 8.563 secs (8.494u,0.07s) (successful)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (interval_sum p a b Q -> P = Q)
Crunching: (interval_sum p a b Q -> P = Q)
Crunching: (interval_sum p a b Q -> P = Q)
Crunching: (q = psi3)
Crunching: (q = psi3)
Crunching: (ρ = Mρ)
Crunching: (ρ = Mρ)
Crunching: (ρ = Mρ)
Crunching: (ρ = Mρ)
Crunching: (ρ = Mρ)
Crunching: (Z.abs_N (Z.pos LT ÷ Z.pos q) = (N.pos LT / N.pos q)%N)
Debug:
In environment
n : int
_Hyp_ : 2%:~R <= n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: ba_casoratian n; n%:~R]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          (add one
             match match l with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end with
             | [::] => zero
             | x :: _ => x
             end) zero))" (cannot unify "false" and 
"true").
Debug:
In environment
n : nat
IHn : 2%:~R <= n -> ba_casoratian n = 6%:~R / (n%:~R + 1) ^ 3
h : 2%:~R <= n.+1
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: ba_casoratian n.+1; n%:R]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          (add
             (add one
                match match l with
                      | [::] => [::]
                      | _ :: x0 => x0
                      end with
                | [::] => zero
                | x :: _ => x
                end) one) zero))" (cannot unify "false" and 
"true").
Crunching: (Z.abs_N (Z.pos LT ÷ Z.pos q) = (N.pos LT / N.pos q)%N)
Crunching: (Z.abs_N (Z.pos LT ÷ Z.pos q) = (N.pos LT / N.pos q)%N)
Debug:
In environment
n : int
r_ge0 : 2%:~R <= n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: ba_casoratian n; n%:~R]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          (add
             match match l with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end with
             | [::] => zero
             | x :: _ => x
             end one) zero))" (cannot unify "false" and 
"true").
Debug:
In environment
n : int
_Hyp_ : 2%:~R <= n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: ba_casoratian n; n%:~R]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          (add one
             match match l with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end with
             | [::] => zero
             | x :: _ => x
             end) zero))" (cannot unify "false" and 
"true").
Crunching: (Z.abs_N (Z.pos p ÷ Z.pos q) = (N.pos p / N.pos q)%N)
Crunching: (Z.abs_N (Z.pos LT ÷ Z.pos q) = (N.pos LT / N.pos q)%N)
Crunching: (Z.abs_N (Z.pos LT ÷ Z.pos q) = (N.pos LT / N.pos q)%N)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (pr_P p1 x2)
Crunching: (pr_P p1 x2)
Crunching: (1 = 0)
Crunching: (1 = 0)
Crunching: Type
Crunching: Type
Crunching: Type
Crunching:
(interval_sum (fun rnd : R => Hf (sample f rnd) = true) 0 x
   (pr_outcome_sum f Hf))
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: Type
Crunching:
(interval_sum (fun rnd : R => f (sample l rnd) = true) 0 r
   (pr_outcome_sum l f))
Crunching:
(interval_sum (fun rnd : R => r (sample Od' rnd) = true) 0 r0
   (pr_outcome_sum Od' r))
Crunching:
(interval_sum (fun rnd : R => n (sample Od' rnd) = true) 
   (IZR (Z.succ (-1))) H (pr_outcome_sum Od' n))
Crunching:
(interval_sum (fun _ : R => Hf 0%nat = true) 0 r (pr_outcome_sum [] Hf))
Crunching: Type
Crunching: Type
Crunching:
(interval_sum (fun rnd : R => Hf (sample f rnd) = true) 0 x
   (pr_outcome_sum f Hf))
Crunching:
(interval_sum (fun rnd : R => Hf (sample f rnd) = true) 0 x
   (pr_outcome_sum f Hf))
Crunching: False
Crunching: False
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: Type
Crunching:
(interval_sum (fun rnd : R => f (sample l rnd) = true) 0 r
   (pr_outcome_sum l f))
Crunching:
(interval_sum (fun rnd : R => f (sample [] rnd) = true) 0 1
   (pr_outcome_sum [] f))
Crunching:
(pr_P (fun rnd : R => y (sample x rnd) = true) (pr_outcome_sum x y))
Crunching:
(interval_sum (fun rnd : R => f (sample [] rnd) = true) 0 1
   (pr_outcome_sum [] f))
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching:
(pr_outcome_sum [] H8 <= LT ->
 exists r0 : R,
   0 <= r0 <= LT /\
   interval_sum (fun rnd : R => H8 (sample [] rnd) = true) 0 1 r0)
Finished transaction in 60.419 secs (60.296u,0.128s) (successful)
Crunching:
(exists r0 : R,
   0 <= r0 <= r /\ pr_P (fun rnd : R => f (sample l rnd) = true) r0)
Debug:
In environment
i, j : nat
pExtEnum := fun E : countFieldType => nat -> {poly E}
 : countFieldType -> Type
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: b_over_a_seq (2 + (j - 2) + (i - (2 + (j - 2))))%N;
         b_over_a_seq (2 + (j - 2))%N;
         \sum_(2 + (j - 2) <= k < 2 + (j - 2) + (i - (2 + (j - 2))))
            6%:~R / (k%:~R + 1) ^ 3 / (a (int.shift 1 k) * a k)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (∣0⟩ = basis_vector 2 0)
Debug:
In environment
i, j : nat
pExtEnum := fun E : countFieldType => nat -> {poly E}
 : countFieldType -> Type
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: b_over_a_seq (2 + (j - 2) + (i - (2 + (j - 2))))%N;
         b_over_a_seq (2 + (j - 2))%N;
         \sum_(2 + (j - 2) <= k < 2 + (j - 2) + (i - (2 + (j - 2))))
            6%:~R / (k%:~R + 1) ^ 3 / (a (int.shift 1 k) * a k)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching:
(exists r0 : R,
   0 <= r0 <= f /\
   interval_sum (fun rnd : R => H8 (sample [] rnd) = true) 0 1 r0)
Debug:
In environment
i, j : nat
pExtEnum := fun E : countFieldType => nat -> {poly E}
 : countFieldType -> Type
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: b_over_a_seq (2 + (j - 2) + (i - (2 + (j - 2))))%N;
         b_over_a_seq (2 + (j - 2))%N;
         \sum_(2 + (j - 2) <= k < 2 + (j - 2) + (i - (2 + (j - 2))))
            6%:~R / (k%:~R + 1) ^ 3 / (a (int.shift 1 k) * a k)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching: (list2D_to_matrix [[e]; [e0]] = / √ 2 .* ∣ 0 ⟩ .+ / √ 2 .* ∣ 1 ⟩)
Crunching:
(list2D_to_matrix [[e]; [e0]] =
 hadamard × list2D_to_matrix [[/ √ 2]; [/ √ 2]])
Crunching:
(list2D_to_matrix
   [[C1 / √ 2 * / √ 2 + C1 / √ 2 * / √ 2];
   [C1 / √ 2 * / √ 2 + - (C1 / √ 2) * / √ 2]] = ∣ 0 ⟩)
Crunching:
(list2D_to_matrix [[e]; [e0]] = / √ 2 .* ∣ 0 ⟩ .+ - / √ 2 .* ∣ 1 ⟩)
Crunching:
(list2D_to_matrix [[e]; [e0]] =
 hadamard × list2D_to_matrix [[/ √ 2]; [- / √ 2]])
Crunching:
(list2D_to_matrix
   [[C1 / √ 2 * / √ 2 + C1 / √ 2 * - / √ 2];
   [C1 / √ 2 * / √ 2 + - (C1 / √ 2) * - / √ 2]] = 
 ∣ 1 ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift θ × ∣ true ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = phase_shift θ × ∣ false ⟩)
Crunching: (list2D_to_matrix [[0]; [Cexp θ]] = Cexp (true * θ) .* ∣ true ⟩)
Crunching: (list2D_to_matrix [[C1]; [0]] = Cexp (false * θ) .* ∣ false ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = hadamard × ∣ true ⟩)
Crunching: (list2D_to_matrix [[e]; [e0]] = hadamard × ∣ false ⟩)
Crunching:
(list2D_to_matrix [[C1 / √ 2]; [- (C1 / √ 2)]] =
 / √ 2 .* (∣ 0 ⟩ .+ (-1) ^ true .* ∣ 1 ⟩))
Crunching:
(list2D_to_matrix [[C1 / √ 2]; [C1 / √ 2]] =
 / √ 2 .* (∣ 0 ⟩ .+ (-1) ^ false .* ∣ 1 ⟩))
Crunching:
(big_sum (fun i : nat => if H13 i then nth i y 0 else 0) (length y) <= r ->
 exists r0 : R,
   0 <= r0 <= r /\ pr_P (fun rnd : R => H13 (sample y rnd) = true) r0)
Crunching: ((∣ 0 ⟩) ⊤ = ⟨ 0 ∣)
Crunching: ((∣ 1 ⟩) ⊤ = ⟨ 1 ∣)
Crunching: ((⟨ 0 ∣) ⊤ = ∣ 0 ⟩)
Crunching: ((⟨ 1 ∣) ⊤ = ∣ 1 ⟩)
Crunching: ((⟨ 1 ∣) † = ∣ 1 ⟩)
Crunching: ((∣ 1 ⟩) † = ⟨ 1 ∣)
Crunching: ((⟨ 0 ∣) † = ∣ 0 ⟩)
Crunching: ((∣ 0 ⟩) † = ⟨ 0 ∣)
Debug:
In environment
i, j : nat
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: b_over_a_seq (2 + (j - 2) + (i - (2 + (j - 2))))%N;
         b_over_a_seq (2 + (j - 2))%N;
         \sum_(2 + (j - 2) <= k < 2 + (j - 2) + (i - (2 + (j - 2))))
            6%:~R / (k%:~R + 1) ^ 3 / (a (int.shift 1 k) * a k)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
i, j : nat
pExtEnum := fun E : countFieldType => nat -> {poly E}
 : countFieldType -> Type
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: b_over_a_seq (2 + (j - 2) + (i - (2 + (j - 2))))%N;
         b_over_a_seq (2 + (j - 2))%N;
         \sum_(2 + (j - 2) <= k < 2 + (j - 2) + (i - (2 + (j - 2))))
            6%:~R / (k%:~R + 1) ^ 3 / (a (int.shift 1 k) * a k)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching:
(exists r0 : R,
   0 <= r0 <= r /\ pr_P (fun rnd : R => f (sample l rnd) = true) r0)
Crunching: (~ Forall (fun x : R => 0 <= x) l)
Debug:
In environment
i, j : nat
A' := b_over_a_seq i - b_over_a_seq j : rat_Ring
s : (2 - j)%N = 0
char0_Q : [char rat] =i pred0
x : (j <= i)%N
Unable to unify "true" with "false".
Crunching:
(exists r0 : R,
   0 <= r0 <= r /\ pr_P (fun rnd : R => f (sample [] rnd) = true) r0)
Crunching:
(exists r0 : R,
   0 <= r0 <= lg2 /\
   interval_sum (fun rnd : R => q (sample [] rnd) = true) 0 1 r0)
Crunching:
(exists r0 : R,
   0 <= r0 <= lg2 /\
   interval_sum (fun rnd : R => q (sample [] rnd) = true) 0 1 r0)
Crunching:
(exists r0 : R,
   0 <= r0 <= lg2 /\
   interval_sum (fun rnd : R => q (sample [] rnd) = true) 0 1 r0)
Debug:
In environment
i, j : nat
Ha : (1 < j)%N
H : (j <= i)%N
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: b_over_a_seq i; b_over_a_seq j;
         \sum_(j <= k < i | (j <= i)%N)
            6%:~R / (k%:~R + 1) ^ 3 / (a (int.shift 1 k) * a k)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching:
(Hyp > 0 -> 0 < Hyp -> Hx = m * Hyp + 0 <-> Hx / Hyp = m /\ Hx mod Hyp = 0)
Debug:
In environment
i, j : nat
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: b_over_a_seq (2 + (j - 2) + (i - (2 + (j - 2))))%N;
         b_over_a_seq (2 + (j - 2))%N;
         \sum_(2 + (j - 2) <= k < 2 + (j - 2) + (i - (2 + (j - 2))))
            6%:~R / (k%:~R + 1) ^ 3 / (a (int.shift 1 k) * a k)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (∣0⟩ = basis_vector 2 0)
Debug:
In environment
i, j : nat
pExtEnum := fun E : countFieldType => nat -> {poly E}
 : countFieldType -> Type
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: b_over_a_seq (2 + (j - 2) + (i - (2 + (j - 2))))%N;
         b_over_a_seq (2 + (j - 2))%N;
         \sum_(2 + (j - 2) <= k < 2 + (j - 2) + (i - (2 + (j - 2))))
            6%:~R / (k%:~R + 1) ^ 3 / (a (int.shift 1 k) * a k)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching: (0 = IH * b + a <-> 0 / b = IH /\ 0 mod b = a)
Crunching: (0 = IH * H4 + M -> 0 = IH /\ 0 = M)
Crunching:
(Forall (fun x : R => 0 + - 0 <= x) (Cmod2 (C1 * (r, r0)) :: map Cmod2 l))
Crunching:
(forall x : nat,
 basis_vector (2 ^ (0 + 0)) (Hn * 2 ^ 0 + z) x =
 (basis_vector (2 ^ 0) Hn ⊗ basis_vector (2 ^ 0) z) x)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching:
(sum_over_list (map Cmod2 (vec_to_list' m H3)) =
 big_sum
   (fun i : nat =>
    (Cmod (H3 (i + N0 - m)%nat 0%nat) *
     (Cmod (H3 (i + N0 - m)%nat 0%nat) * 1))%R) m)
Crunching:
(forall x : nat,
 basis_vector (2 ^ (0 + 0)) (Hn * 2 ^ 0 + z) x =
 (basis_vector (2 ^ 0) Hn ⊗ basis_vector (2 ^ 0) z) x)
Crunching:
(forall x : nat,
 basis_vector (2 ^ (0 + 0)) (Hn * 2 ^ 0 + z) x =
 (basis_vector (2 ^ 0) Hn ⊗ basis_vector (2 ^ 0) z) x)
Crunching:
(basis_vector (2 ^ (0 + m)) (Hn * 2 ^ m + a) =
 basis_vector (2 ^ 0) Hn ⊗ basis_vector (2 ^ m) a)
Crunching:
(0 < 1 ->
 0 < eps / 2 ->
 exists N : nat,
   forall n : nat,
   (n >= N)%nat ->
   Rabs (?Un n - sum_over_list (map Cmod2 (vec_to_list' d l))) < eps)
Crunching:
(basis_vector (2 ^ (n + m)) (Hn * 2 ^ m + h) =
 basis_vector (2 ^ n) Hn ⊗ basis_vector (2 ^ m) h)
Crunching:
(sum_over_list (map Cmod2 (vec_to_list' n a)) =
 big_sum
   (fun i : nat =>
    (Cmod (a (i + m - n)%nat 0%nat) * (Cmod (a (i + m - n)%nat 0%nat) * 1))%R)
   n)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: False
Crunching:
(H < 2 ^ n ->
 basis_vector (2 ^ (a + n)) (0 * 2 ^ n + H) =
 basis_vector (2 ^ a) 0 ⊗ basis_vector (2 ^ n) H)
Crunching:
(H < 2 ^ n ->
 basis_vector (2 ^ (a + n)) (0 * 2 ^ n + H) =
 basis_vector (2 ^ a) 0 ⊗ basis_vector (2 ^ n) H)
Crunching:
((fun i j : nat => if (i =? x * 2 ^ n + y) && (j =? 0) then C1 else 0%R) =
 (fun x0 y0 : nat =>
  ((if (x0 / 2 ^ n =? x) && (y0 / 1 =? 0) then C1 else 0%R) *
   (if (x0 mod 2 ^ n =? y) && (y0 mod 1 =? 0) then C1 else 0%R))%C))
Crunching:
(sum_over_list (map Cmod2 (vec_to_list' m H3)) =
 big_sum
   (fun i : nat =>
    (Cmod (H3 (i + N0 - m)%nat 0%nat) *
     (Cmod (H3 (i + N0 - m)%nat 0%nat) * 1))%R) m)
Crunching: Type
Crunching: Type
Crunching:
(forall p : positive, IZR (Z.succ (Z.succ 0)) * INR (Pos.to_nat p) = IPR_2 p)
Crunching: Type
Crunching: (S (funbool_to_nat 0 f) <= 0)
Crunching:
(big_sum (fun i : nat => nth i (map Cmod2 (vec_to_list Hy)) 0)
   (length (map Cmod2 (vec_to_list Hy))) =
 big_sum (fun i : nat => (Cmod (Hy i 0%nat) ^ 2)%R) Hx)
Crunching:
(big_sum (fun i : nat => nth i (map Cmod2 (vec_to_list Hy)) 0)
   (length (map Cmod2 (vec_to_list Hy))) =
 big_sum (fun i : nat => (Cmod (Hy i 0%nat) ^ 2)%R) Hx)
Crunching: Type
Crunching: (Z.abs_N (Z.rem (Z.pos p) (Z.pos q)) = (N.pos p mod N.pos q)%N)
Crunching:
(big_sum (fun i : nat => nth i (map Cmod2 (vec_to_list Hy)) 0)
   (length (map Cmod2 (vec_to_list Hy))) =
 big_sum (fun i : nat => (Cmod (Hy i 0%nat) ^ 2)%R) Hx)
Crunching: (x - z <= y)
Crunching: (funbool_to_nat Ha n < 2 ^ Ha)
Crunching: (funbool_to_nat Ha n < 2 ^ Ha)
Crunching: (S (funbool_to_nat Ha n) <= 2 ^ Ha)
Crunching:
(big_sum (fun i : nat => nth i (map Cmod2 (vec_to_list ψ)) 0)
   (length (map Cmod2 (vec_to_list ψ))) <=
 big_sum (fun i : nat => (Cmod (ψ i 0%nat) * (Cmod (ψ i 0%nat) * 1))%R) d)
Crunching: Type
Crunching:
((forall (x : R) (n : nat), cos_approx x n = cos_approx (- x) n) ->
 funbool_to_nat (S n) f = funbool_to_nat (S n) f')
Crunching:
((forall (x : R) (n : nat), cos_approx x n = cos_approx (- x) n) ->
 funbool_to_nat (S n) f = funbool_to_nat (S n) f')
Crunching:
(big_sum (fun i : nat => nth i (map Cmod2 (vec_to_list Hy)) 0)
   (length (map Cmod2 (vec_to_list Hy))) =
 big_sum (fun i : nat => (Cmod (Hy i 0%nat) ^ 2)%R) Hx)
Crunching:
(big_sum (fun i : nat => nth i (map Cmod2 (vec_to_list Hy)) 0)
   (length (map Cmod2 (vec_to_list Hy))) =
 big_sum (fun i : nat => (Cmod (Hy i 0%nat) ^ 2)%R) Hx)
Debug:
In environment
n : int
sAD : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: b' (int.shift 2 n); annotated_recs_c.P_cf0 n; 
        b' n; annotated_recs_c.P_cf1 n; b' (int.shift 1 n);
         annotated_recs_c.P_cf2 n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Debug:
In environment
n : int
hmn : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: b' (int.shift 2 n); annotated_recs_c.P_cf0 n; 
        b' n; annotated_recs_c.P_cf1 n; b' (int.shift 1 n);
         annotated_recs_c.P_cf2 n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Debug:
In environment
n : int
pAI : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: b' (int.shift 2 n); annotated_recs_c.P_cf0 n; 
        b' n; annotated_recs_c.P_cf1 n; b' (int.shift 1 n);
         annotated_recs_c.P_cf2 n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Debug:
In environment
n : int
sAD : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: b' (int.shift 2 n); annotated_recs_c.P_cf0 n; 
        b' n; annotated_recs_c.P_cf1 n; b' (int.shift 1 n);
         annotated_recs_c.P_cf2 n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Debug:
In environment
n : int
i : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: b' (int.shift 2 n); annotated_recs_c.P_cf0 n; 
        b' n; annotated_recs_c.P_cf1 n; b' (int.shift 1 n);
         annotated_recs_c.P_cf2 n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Crunching: ((- (PI / 2) < 0)%R -> funbool_to_nat H f = funbool_to_nat H f')
Crunching:
(big_sum (fun i : nat => nth i (map Cmod2 (vec_to_list Hy)) 0)
   (length (map Cmod2 (vec_to_list Hy))) =
 big_sum (fun i : nat => (Cmod (Hy i 0%nat) ^ 2)%R) Hx)
Debug:
In environment
n : int
hmn : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: b' (int.shift 2 n); annotated_recs_c.P_cf0 n; 
        b' n; annotated_recs_c.P_cf1 n; b' (int.shift 1 n);
         annotated_recs_c.P_cf2 n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Debug:
In environment
n : int
pAI : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: b' (int.shift 2 n); annotated_recs_c.P_cf0 n; 
        b' n; annotated_recs_c.P_cf1 n; b' (int.shift 1 n);
         annotated_recs_c.P_cf2 n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Debug:
In environment
n : int
sAD : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: b' (int.shift 2 n); annotated_recs_c.P_cf0 n; 
        b' n; annotated_recs_c.P_cf1 n; b' (int.shift 1 n);
         annotated_recs_c.P_cf2 n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Debug:
In environment
n : int
i : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: b' (int.shift 2 n); annotated_recs_c.P_cf0 n; 
        b' n; annotated_recs_c.P_cf1 n; b' (int.shift 1 n);
         annotated_recs_c.P_cf2 n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Crunching: (cos 1 <= 1 - 1 / 2 + 1 / 24)
Crunching: (cos 1 <= 1 - 1 / 2 + 1 / 24)
Crunching:
((forall r1 r2 r3 r4 : R, r1 = r2 -> (r2 < r4)%R -> r4 = r3 -> (r1 < r3)%R) ->
 ~ (forall x : nat, x < S n -> f x = f' x))
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching:
(exp_in 0 1 ->
 (forall (x : R) (n : nat), cos_approx x n = cos_approx (- x) n) ->
 funbool_to_nat (S n) f = funbool_to_nat (S n) f')
Crunching:
((forall (x : R) (n : nat), cos_approx x n = cos_approx (- x) n) ->
 funbool_to_nat (S n) f = funbool_to_nat (S n) f')
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (distribution (apply_u u))
Crunching: (i = i -> f i = N0 i)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (Forall (fun x : R => 0 <= x) (apply_u H))
Crunching:
(Nat.testbit (funbool_to_nat l H1) m = Nat.testbit (funbool_to_nat l Hy) m)
Crunching:
(Nat.testbit (funbool_to_nat l H1) m = Nat.testbit (funbool_to_nat l Hy) m)
Crunching:
(Nat.testbit (funbool_to_nat l H1) m = Nat.testbit (funbool_to_nat l Hy) m)
Crunching:
(Nat.testbit (funbool_to_nat l H1) m = Nat.testbit (funbool_to_nat l Hy) m)
Crunching: (0 < PI / 2 -> WF_Unitary y -> distribution (apply_u y))
Crunching:
(Nat.testbit (funbool_to_nat l H1) m = Nat.testbit (funbool_to_nat l Hy) m)
Crunching: (Forall (fun x : R => 0 <= x) (apply_u H))
Crunching:
(Nat.testbit (funbool_to_nat l H1) m = Nat.testbit (funbool_to_nat l Hy) m)
Crunching:
(Nat.testbit (funbool_to_nat l H1) m = Nat.testbit (funbool_to_nat l Hy) m)
Crunching:
(Nat.testbit (funbool_to_nat l H1) m = Nat.testbit (funbool_to_nat l Hy) m)
Crunching: U
Crunching:
(Nat.testbit (funbool_to_nat l H1) m = Nat.testbit (funbool_to_nat l Hy) m)
Crunching:
(Nat.testbit (funbool_to_nat l H1) m = Nat.testbit (funbool_to_nat l Hy) m)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching:
((forall x0 : nat, x0 < x -> k x0 = pk x0) ->
 funbool_to_nat x k = funbool_to_nat x pk)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (distribution (apply_u u))
Crunching: (Forall (fun x : R => R0 <= x) (apply_u SF))
Crunching:
(forall k : nat,
 k < abs ->
 funbool_to_nat abs Hcase =
 2 ^ (abs - k) * funbool_to_nat k Hcase +
 funbool_to_nat (abs - k) (shift Hcase k))
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (distribution (apply_u u))
Crunching:
(forall k : nat,
 k < abs ->
 funbool_to_nat abs Hcase =
 2 ^ (abs - k) * funbool_to_nat k Hcase +
 funbool_to_nat (abs - k) (shift Hcase k))
Crunching: (Forall (fun x : R => 0 <= x) (apply_u H))
Crunching:
(funbool_to_nat (S H1) H =
 2 ^ (S H1 - H1) * funbool_to_nat H1 H +
 funbool_to_nat (S H1 - H1) (shift H H1))
Crunching: (forall u : Square (2 ^ H2), length (apply_u u) = (2 ^ H2)%nat)
Crunching:
(nat -> forall u : Square (2 ^ H2), length (apply_u u) = (2 ^ H2)%nat)
Crunching: (forall u : Square (2 ^ H2), length (apply_u u) = (2 ^ H2)%nat)
Crunching:
(nat -> forall u : Square (2 ^ H2), length (apply_u u) = (2 ^ H2)%nat)
Crunching: (length (apply_u LT) = (2 ^ H2)%nat)
Crunching: (length (apply_u y) = (2 ^ UIP_refl)%nat)
Crunching: (0 < 2 -> length (apply_u y) = (2 ^ UIP_refl)%nat)
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf0 (Posz 1); b 1;
         annotated_recs_c.P_cf1 (Posz 1);
         let n' := Posz 0 in
         -
         (annotated_recs_c.P_cf0 n' * b 0 + annotated_recs_c.P_cf1 n' * b 1) /
         annotated_recs_c.P_cf2 n']
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf0 (Posz 1); b 1;
         annotated_recs_c.P_cf1 (Posz 1); annotated_recs_c.P_cf0 (Posz 0);
         b 0; annotated_recs_c.P_cf1 (Posz 0);
         annotated_recs_c.P_cf2 (Posz 0)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match
                    match
                      match l with
                      | [::] => [::]
                      | _ :: x0 => x0
                      end
                    with
                    | [::] => [::]
                    | _ :: x0 => x0
                    end
                  with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf0 (Posz 1); b 1;
         annotated_recs_c.P_cf1 (Posz 1);
         let n' := Posz 0 in
         -
         (annotated_recs_c.P_cf0 n' * b 0 + annotated_recs_c.P_cf1 n' * b 1) /
         annotated_recs_c.P_cf2 n']
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf0 (Posz 1); b 1;
         annotated_recs_c.P_cf1 (Posz 1); annotated_recs_c.P_cf0 (Posz 0);
         b 0; annotated_recs_c.P_cf1 (Posz 0);
         annotated_recs_c.P_cf2 (Posz 0)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match
                    match
                      match l with
                      | [::] => [::]
                      | _ :: x0 => x0
                      end
                    with
                    | [::] => [::]
                    | _ :: x0 => x0
                    end
                  with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf0 (Posz 1); b 1;
         annotated_recs_c.P_cf1 (Posz 1); annotated_recs_c.P_cf0 (Posz 0);
         b 0; annotated_recs_c.P_cf1 (Posz 0);
         annotated_recs_c.P_cf2 (Posz 0)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match
                    match
                      match l with
                      | [::] => [::]
                      | _ :: x0 => x0
                      end
                    with
                    | [::] => [::]
                    | _ :: x0 => x0
                    end
                  with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf0 (Posz 1); b 1;
         annotated_recs_c.P_cf1 (Posz 1); annotated_recs_c.P_cf0 (Posz 0);
         b 0; annotated_recs_c.P_cf1 (Posz 0);
         annotated_recs_c.P_cf2 (Posz 0)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match
                    match
                      match l with
                      | [::] => [::]
                      | _ :: x0 => x0
                      end
                    with
                    | [::] => [::]
                    | _ :: x0 => x0
                    end
                  with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf0 (Posz 1); b 1;
         annotated_recs_c.P_cf1 (Posz 1); annotated_recs_c.P_cf0 (Posz 0);
         b 0; annotated_recs_c.P_cf1 (Posz 0);
         annotated_recs_c.P_cf2 (Posz 0)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match
                    match
                      match l with
                      | [::] => [::]
                      | _ :: x0 => x0
                      end
                    with
                    | [::] => [::]
                    | _ :: x0 => x0
                    end
                  with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf0 (Posz 1); b 1;
         annotated_recs_c.P_cf1 (Posz 1);
         let n' := Posz 0 in
         -
         (annotated_recs_c.P_cf0 n' * b 0 + annotated_recs_c.P_cf1 n' * b 1) /
         annotated_recs_c.P_cf2 n']
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf0 (Posz 1); b 1;
         annotated_recs_c.P_cf1 (Posz 1); annotated_recs_c.P_cf0 (Posz 0);
         b 0; annotated_recs_c.P_cf1 (Posz 0);
         annotated_recs_c.P_cf2 (Posz 0)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match
                    match
                      match l with
                      | [::] => [::]
                      | _ :: x0 => x0
                      end
                    with
                    | [::] => [::]
                    | _ :: x0 => x0
                    end
                  with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf0 (Posz 1); b 1;
         annotated_recs_c.P_cf1 (Posz 1); annotated_recs_c.P_cf0 (Posz 0);
         b 0; annotated_recs_c.P_cf1 (Posz 0);
         annotated_recs_c.P_cf2 (Posz 0)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match
                    match
                      match l with
                      | [::] => [::]
                      | _ :: x0 => x0
                      end
                    with
                    | [::] => [::]
                    | _ :: x0 => x0
                    end
                  with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf0 (Posz 1); b 1;
         annotated_recs_c.P_cf1 (Posz 1); annotated_recs_c.P_cf0 (Posz 0);
         b 0; annotated_recs_c.P_cf1 (Posz 0);
         annotated_recs_c.P_cf2 (Posz 0)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match
                    match
                      match l with
                      | [::] => [::]
                      | _ :: x0 => x0
                      end
                    with
                    | [::] => [::]
                    | _ :: x0 => x0
                    end
                  with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf0 (Posz 1); b 1;
         annotated_recs_c.P_cf1 (Posz 1); annotated_recs_c.P_cf0 (Posz 0);
         b 0; annotated_recs_c.P_cf1 (Posz 0);
         annotated_recs_c.P_cf2 (Posz 0)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match
                    match
                      match l with
                      | [::] => [::]
                      | _ :: x0 => x0
                      end
                    with
                    | [::] => [::]
                    | _ :: x0 => x0
                    end
                  with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf0 (Posz 1); b 1;
         annotated_recs_c.P_cf1 (Posz 1); annotated_recs_c.P_cf0 (Posz 0);
         b 0; annotated_recs_c.P_cf1 (Posz 0);
         annotated_recs_c.P_cf2 (Posz 0)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match
                    match
                      match l with
                      | [::] => [::]
                      | _ :: x0 => x0
                      end
                    with
                    | [::] => [::]
                    | _ :: x0 => x0
                    end
                  with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Crunching:
(forall k : nat,
 k < abs ->
 funbool_to_nat abs Hcase =
 2 ^ (abs - k) * funbool_to_nat k Hcase +
 funbool_to_nat (abs - k) (shift Hcase k))
Crunching: (forall u : Square (2 ^ H2), length (apply_u u) = (2 ^ H2)%nat)
Crunching:
(nat -> forall u : Square (2 ^ H2), length (apply_u u) = (2 ^ H2)%nat)
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf0 (Posz 1); b 1;
         annotated_recs_c.P_cf1 (Posz 1);
         let n' := Posz 0 in
         -
         (annotated_recs_c.P_cf0 n' * b 0 + annotated_recs_c.P_cf1 n' * b 1) /
         annotated_recs_c.P_cf2 n']
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf0 (Posz 1); b 1;
         annotated_recs_c.P_cf1 (Posz 1); annotated_recs_c.P_cf0 (Posz 0);
         b 0; annotated_recs_c.P_cf1 (Posz 0);
         annotated_recs_c.P_cf2 (Posz 0)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match
                    match
                      match l with
                      | [::] => [::]
                      | _ :: x0 => x0
                      end
                    with
                    | [::] => [::]
                    | _ :: x0 => x0
                    end
                  with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf0 (Posz 1); b 1;
         annotated_recs_c.P_cf1 (Posz 1); annotated_recs_c.P_cf0 (Posz 0);
         b 0; annotated_recs_c.P_cf1 (Posz 0);
         annotated_recs_c.P_cf2 (Posz 0)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match
                    match
                      match l with
                      | [::] => [::]
                      | _ :: x0 => x0
                      end
                    with
                    | [::] => [::]
                    | _ :: x0 => x0
                    end
                  with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf0 (Posz 1); b 1;
         annotated_recs_c.P_cf1 (Posz 1); annotated_recs_c.P_cf0 (Posz 0);
         b 0; annotated_recs_c.P_cf1 (Posz 0);
         annotated_recs_c.P_cf2 (Posz 0)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match
                    match
                      match l with
                      | [::] => [::]
                      | _ :: x0 => x0
                      end
                    with
                    | [::] => [::]
                    | _ :: x0 => x0
                    end
                  with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf0 (Posz 1); b 1;
         annotated_recs_c.P_cf1 (Posz 1); annotated_recs_c.P_cf0 (Posz 0);
         b 0; annotated_recs_c.P_cf1 (Posz 0);
         annotated_recs_c.P_cf2 (Posz 0)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match
                    match
                      match l with
                      | [::] => [::]
                      | _ :: x0 => x0
                      end
                    with
                    | [::] => [::]
                    | _ :: x0 => x0
                    end
                  with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf0 (Posz 1); b 1;
         annotated_recs_c.P_cf1 (Posz 1); annotated_recs_c.P_cf0 (Posz 0);
         b 0; annotated_recs_c.P_cf1 (Posz 0);
         annotated_recs_c.P_cf2 (Posz 0)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match
                    match
                      match l with
                      | [::] => [::]
                      | _ :: x0 => x0
                      end
                    with
                    | [::] => [::]
                    | _ :: x0 => x0
                    end
                  with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Crunching: (length (apply_u LT) = (2 ^ H2)%nat)
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf0 (Posz 1); b 1;
         annotated_recs_c.P_cf1 (Posz 1);
         let n' := Posz 0 in
         -
         (annotated_recs_c.P_cf0 n' * b 0 + annotated_recs_c.P_cf1 n' * b 1) /
         annotated_recs_c.P_cf2 n']
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf0 (Posz 1); b 1;
         annotated_recs_c.P_cf1 (Posz 1); annotated_recs_c.P_cf0 (Posz 0);
         b 0; annotated_recs_c.P_cf1 (Posz 0);
         annotated_recs_c.P_cf2 (Posz 0)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match
                    match
                      match l with
                      | [::] => [::]
                      | _ :: x0 => x0
                      end
                    with
                    | [::] => [::]
                    | _ :: x0 => x0
                    end
                  with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf0 (Posz 1); b 1;
         annotated_recs_c.P_cf1 (Posz 1); annotated_recs_c.P_cf0 (Posz 0);
         b 0; annotated_recs_c.P_cf1 (Posz 0);
         annotated_recs_c.P_cf2 (Posz 0)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match
                    match
                      match l with
                      | [::] => [::]
                      | _ :: x0 => x0
                      end
                    with
                    | [::] => [::]
                    | _ :: x0 => x0
                    end
                  with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Crunching: (length (apply_u y) = (2 ^ UIP_refl)%nat)
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf0 (Posz 1); b 1;
         annotated_recs_c.P_cf1 (Posz 1); annotated_recs_c.P_cf0 (Posz 0);
         b 0; annotated_recs_c.P_cf1 (Posz 0);
         annotated_recs_c.P_cf2 (Posz 0)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match
                    match
                      match l with
                      | [::] => [::]
                      | _ :: x0 => x0
                      end
                    with
                    | [::] => [::]
                    | _ :: x0 => x0
                    end
                  with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Crunching: (0 < 2 -> length (apply_u y) = (2 ^ UIP_refl)%nat)
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf0 (Posz 1); b 1;
         annotated_recs_c.P_cf1 (Posz 1); annotated_recs_c.P_cf0 (Posz 0);
         b 0; annotated_recs_c.P_cf1 (Posz 0);
         annotated_recs_c.P_cf2 (Posz 0)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match
                    match
                      match l with
                      | [::] => [::]
                      | _ :: x0 => x0
                      end
                    with
                    | [::] => [::]
                    | _ :: x0 => x0
                    end
                  with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf0 (Posz 1); b 1;
         annotated_recs_c.P_cf1 (Posz 1); annotated_recs_c.P_cf0 (Posz 0);
         b 0; annotated_recs_c.P_cf1 (Posz 0);
         annotated_recs_c.P_cf2 (Posz 0)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match
                    match
                      match l with
                      | [::] => [::]
                      | _ :: x0 => x0
                      end
                    with
                    | [::] => [::]
                    | _ :: x0 => x0
                    end
                  with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Crunching: (length (apply_u u) = (2 ^ q)%nat)
Crunching: ((2 ^ q)%nat = length (apply_u u))
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf0 (Posz 1); b 1;
         annotated_recs_c.P_cf1 (Posz 1);
         let n' := Posz 0 in
         -
         (annotated_recs_c.P_cf0 n' * b 0 + annotated_recs_c.P_cf1 n' * b 1) /
         annotated_recs_c.P_cf2 n']
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf0 (Posz 1); b 1;
         annotated_recs_c.P_cf1 (Posz 1); annotated_recs_c.P_cf0 (Posz 0);
         b 0; annotated_recs_c.P_cf1 (Posz 0);
         annotated_recs_c.P_cf2 (Posz 0)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match
                    match
                      match l with
                      | [::] => [::]
                      | _ :: x0 => x0
                      end
                    with
                    | [::] => [::]
                    | _ :: x0 => x0
                    end
                  with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf0 (Posz 1); b 1;
         annotated_recs_c.P_cf1 (Posz 1); annotated_recs_c.P_cf0 (Posz 0);
         b 0; annotated_recs_c.P_cf1 (Posz 0);
         annotated_recs_c.P_cf2 (Posz 0)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match
                    match
                      match l with
                      | [::] => [::]
                      | _ :: x0 => x0
                      end
                    with
                    | [::] => [::]
                    | _ :: x0 => x0
                    end
                  with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Crunching:
(forall k : nat,
 k < abs ->
 funbool_to_nat abs Hcase =
 2 ^ (abs - k) * funbool_to_nat k Hcase +
 funbool_to_nat (abs - k) (shift Hcase k))
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf0 (Posz 1); b 1;
         annotated_recs_c.P_cf1 (Posz 1); annotated_recs_c.P_cf0 (Posz 0);
         b 0; annotated_recs_c.P_cf1 (Posz 0);
         annotated_recs_c.P_cf2 (Posz 0)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match
                    match
                      match l with
                      | [::] => [::]
                      | _ :: x0 => x0
                      end
                    with
                    | [::] => [::]
                    | _ :: x0 => x0
                    end
                  with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf0 (Posz 1); b 1;
         annotated_recs_c.P_cf1 (Posz 1); annotated_recs_c.P_cf0 (Posz 0);
         b 0; annotated_recs_c.P_cf1 (Posz 0);
         annotated_recs_c.P_cf2 (Posz 0)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match
                    match
                      match l with
                      | [::] => [::]
                      | _ :: x0 => x0
                      end
                    with
                    | [::] => [::]
                    | _ :: x0 => x0
                    end
                  with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf0 (Posz 1); b 1;
         annotated_recs_c.P_cf1 (Posz 1); annotated_recs_c.P_cf0 (Posz 0);
         b 0; annotated_recs_c.P_cf1 (Posz 0);
         annotated_recs_c.P_cf2 (Posz 0)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match
                    match
                      match l with
                      | [::] => [::]
                      | _ :: x0 => x0
                      end
                    with
                    | [::] => [::]
                    | _ :: x0 => x0
                    end
                  with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Crunching:
((2 ^ H2)%nat =
 length (map Cmod2 (vec_to_list (u × basis_vector (2 ^ H2) 0))))
Crunching:
((2 ^ H2)%nat =
 length (map Cmod2 (vec_to_list (u × basis_vector (2 ^ H2) 0))))
Crunching:
((2 ^ H2)%nat =
 length (map Cmod2 (vec_to_list (u × basis_vector (2 ^ H2) 0))))
Crunching:
(length (map Cmod2 (vec_to_list (u × basis_vector (2 ^ H2) 0))) =
 (2 ^ H2)%nat)
Crunching:
(length (map Cmod2 (vec_to_list (u × basis_vector (2 ^ H2) 0))) =
 (2 ^ H2)%nat)
Crunching:
(length (map Cmod2 (vec_to_list (u × basis_vector (2 ^ H2) 0))) =
 (2 ^ H2)%nat)
Crunching:
((2 ^ H2)%nat =
 length (map Cmod2 (vec_to_list (u × basis_vector (2 ^ H2) 0))))
Crunching:
((2 ^ H2)%nat =
 length (map Cmod2 (vec_to_list (u × basis_vector (2 ^ H2) 0))))
Crunching:
((2 ^ H2)%nat =
 length (map Cmod2 (vec_to_list (u × basis_vector (2 ^ H2) 0))))
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf0 (Posz 1); b 1;
         annotated_recs_c.P_cf1 (Posz 1);
         let n' := Posz 0 in
         -
         (annotated_recs_c.P_cf0 n' * b 0 + annotated_recs_c.P_cf1 n' * b 1) /
         annotated_recs_c.P_cf2 n']
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf0 (Posz 1); b 1;
         annotated_recs_c.P_cf1 (Posz 1); annotated_recs_c.P_cf0 (Posz 0);
         b 0; annotated_recs_c.P_cf1 (Posz 0);
         annotated_recs_c.P_cf2 (Posz 0)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match
                    match
                      match l with
                      | [::] => [::]
                      | _ :: x0 => x0
                      end
                    with
                    | [::] => [::]
                    | _ :: x0 => x0
                    end
                  with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Crunching:
(length (map Cmod2 (vec_to_list (u × basis_vector (2 ^ H2) 0))) =
 (2 ^ H2)%nat)
Crunching:
(length (map Cmod2 (vec_to_list (u × basis_vector (2 ^ H2) 0))) =
 (2 ^ H2)%nat)
Crunching:
(length (map Cmod2 (vec_to_list (u × basis_vector (2 ^ H2) 0))) =
 (2 ^ H2)%nat)
Crunching:
((2 ^ H2)%nat =
 length (map Cmod2 (vec_to_list (u × basis_vector (2 ^ H2) 0))))
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf0 (Posz 1); b 1;
         annotated_recs_c.P_cf1 (Posz 1); annotated_recs_c.P_cf0 (Posz 0);
         b 0; annotated_recs_c.P_cf1 (Posz 0);
         annotated_recs_c.P_cf2 (Posz 0)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match
                    match
                      match l with
                      | [::] => [::]
                      | _ :: x0 => x0
                      end
                    with
                    | [::] => [::]
                    | _ :: x0 => x0
                    end
                  with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Crunching:
((2 ^ H2)%nat =
 length (map Cmod2 (vec_to_list (u × basis_vector (2 ^ H2) 0))))
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf0 (Posz 1); b 1;
         annotated_recs_c.P_cf1 (Posz 1); annotated_recs_c.P_cf0 (Posz 0);
         b 0; annotated_recs_c.P_cf1 (Posz 0);
         annotated_recs_c.P_cf2 (Posz 0)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match
                    match
                      match l with
                      | [::] => [::]
                      | _ :: x0 => x0
                      end
                    with
                    | [::] => [::]
                    | _ :: x0 => x0
                    end
                  with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Crunching:
((2 ^ H2)%nat =
 length (map Cmod2 (vec_to_list (u × basis_vector (2 ^ H2) 0))))
Crunching:
(length (map Cmod2 (vec_to_list (u × basis_vector (2 ^ H2) 0))) =
 (2 ^ H2)%nat)
Crunching:
(forall k : nat,
 k < abs ->
 funbool_to_nat abs Hcase =
 2 ^ (abs - k) * funbool_to_nat k Hcase +
 funbool_to_nat (abs - k) (shift Hcase k))
Crunching:
(length (map Cmod2 (vec_to_list (u × basis_vector (2 ^ H2) 0))) =
 (2 ^ H2)%nat)
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf0 (Posz 1); b 1;
         annotated_recs_c.P_cf1 (Posz 1); annotated_recs_c.P_cf0 (Posz 0);
         b 0; annotated_recs_c.P_cf1 (Posz 0);
         annotated_recs_c.P_cf2 (Posz 0)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match
                    match
                      match l with
                      | [::] => [::]
                      | _ :: x0 => x0
                      end
                    with
                    | [::] => [::]
                    | _ :: x0 => x0
                    end
                  with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Crunching:
(length (map Cmod2 (vec_to_list (u × basis_vector (2 ^ H2) 0))) =
 (2 ^ H2)%nat)
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf1 (Posz 1);
         let n' := Posz 0 in
         -
         (annotated_recs_c.P_cf0 n' * b 0 + annotated_recs_c.P_cf1 n' * b 1) /
         annotated_recs_c.P_cf2 n'; annotated_recs_c.P_cf0 (Posz 1); 
        b 1]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching:
((2 ^ H2)%nat =
 length (map Cmod2 (vec_to_list (u × basis_vector (2 ^ H2) 0))))
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf1 (Posz 1); annotated_recs_c.P_cf0 (Posz 0);
         b 0; annotated_recs_c.P_cf1 (Posz 0); b 1;
         annotated_recs_c.P_cf2 (Posz 0); annotated_recs_c.P_cf0 (Posz 1)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Crunching:
(length (map Cmod2 (vec_to_list (u × basis_vector (2 ^ H2) 0))) =
 (2 ^ H2)%nat)
Crunching:
((2 ^ H2)%nat =
 length (map Cmod2 (vec_to_list (u × basis_vector (2 ^ H2) 0))))
Crunching:
((2 ^ H2)%nat =
 length (map Cmod2 (vec_to_list (u × basis_vector (2 ^ H2) 0))))
Crunching:
(length (map Cmod2 (vec_to_list (u × basis_vector (2 ^ H2) 0))) =
 (2 ^ H2)%nat)
Crunching:
((2 ^ H2)%nat =
 length (map Cmod2 (vec_to_list (u × basis_vector (2 ^ H2) 0))))
Crunching:
(length (map Cmod2 (vec_to_list (u × basis_vector (2 ^ H2) 0))) =
 (2 ^ H2)%nat)
Crunching:
(length (map Cmod2 (vec_to_list (u × basis_vector (2 ^ H2) 0))) =
 (2 ^ H2)%nat)
Crunching: (forall u : Square (2 ^ H2), length (apply_u u) = (2 ^ H2)%nat)
Crunching:
(nat -> forall u : Square (2 ^ H2), length (apply_u u) = (2 ^ H2)%nat)
Crunching:
((forall u : Square (2 ^ x0), length (apply_u u) = (2 ^ x0)%nat) ->
 forall u : Square (2 ^ x0 + (2 ^ x0 + 0)),
 length (apply_u u) = (2 ^ x0 + (2 ^ x0 + 0))%nat)
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf0 (Posz 1); b 1;
         annotated_recs_c.P_cf1 (Posz 1); annotated_recs_c.P_cf0 (Posz 0);
         b 0; annotated_recs_c.P_cf1 (Posz 0);
         annotated_recs_c.P_cf2 (Posz 0)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match
                    match
                      match l with
                      | [::] => [::]
                      | _ :: x0 => x0
                      end
                    with
                    | [::] => [::]
                    | _ :: x0 => x0
                    end
                  with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf0 (Posz 1); b 1;
         annotated_recs_c.P_cf1 (Posz 1); annotated_recs_c.P_cf0 (Posz 0);
         b 0; annotated_recs_c.P_cf1 (Posz 0);
         annotated_recs_c.P_cf2 (Posz 0)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match
                    match
                      match l with
                      | [::] => [::]
                      | _ :: x0 => x0
                      end
                    with
                    | [::] => [::]
                    | _ :: x0 => x0
                    end
                  with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Crunching: (length (apply_u H1) = (2 ^ S l)%nat)
Crunching: (I 1 = basis_vector 1 0)
Crunching: (basis_vector 1 0 = I 1)
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf0 (Posz 1); b 1;
         annotated_recs_c.P_cf1 (Posz 1);
         let n' := Posz 0 in
         -
         (annotated_recs_c.P_cf0 n' * b 0 + annotated_recs_c.P_cf1 n' * b 1) /
         annotated_recs_c.P_cf2 n']
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf0 (Posz 1); b 1;
         annotated_recs_c.P_cf1 (Posz 1); annotated_recs_c.P_cf0 (Posz 0);
         b 0; annotated_recs_c.P_cf1 (Posz 0);
         annotated_recs_c.P_cf2 (Posz 0)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match
                    match
                      match l with
                      | [::] => [::]
                      | _ :: x0 => x0
                      end
                    with
                    | [::] => [::]
                    | _ :: x0 => x0
                    end
                  with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Crunching: (length (apply_u LT) = (2 ^ H2)%nat)
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf0 (Posz 1); b 1;
         annotated_recs_c.P_cf1 (Posz 1); annotated_recs_c.P_cf0 (Posz 0);
         b 0; annotated_recs_c.P_cf1 (Posz 0);
         annotated_recs_c.P_cf2 (Posz 0)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match
                    match
                      match l with
                      | [::] => [::]
                      | _ :: x0 => x0
                      end
                    with
                    | [::] => [::]
                    | _ :: x0 => x0
                    end
                  with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf0 (Posz 1); b 1;
         annotated_recs_c.P_cf1 (Posz 1); annotated_recs_c.P_cf0 (Posz 0);
         b 0; annotated_recs_c.P_cf1 (Posz 0);
         annotated_recs_c.P_cf2 (Posz 0)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match
                    match
                      match l with
                      | [::] => [::]
                      | _ :: x0 => x0
                      end
                    with
                    | [::] => [::]
                    | _ :: x0 => x0
                    end
                  with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf0 (Posz 1); b 1;
         annotated_recs_c.P_cf1 (Posz 1); annotated_recs_c.P_cf0 (Posz 0);
         b 0; annotated_recs_c.P_cf1 (Posz 0);
         annotated_recs_c.P_cf2 (Posz 0)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match
                    match
                      match l with
                      | [::] => [::]
                      | _ :: x0 => x0
                      end
                    with
                    | [::] => [::]
                    | _ :: x0 => x0
                    end
                  with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf1 (Posz 1);
         let n' := Posz 0 in
         -
         (annotated_recs_c.P_cf0 n' * b 0 + annotated_recs_c.P_cf1 n' * b 1) /
         annotated_recs_c.P_cf2 n'; annotated_recs_c.P_cf0 (Posz 1); 
        b 1]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf1 (Posz 1); annotated_recs_c.P_cf0 (Posz 0);
         b 0; annotated_recs_c.P_cf1 (Posz 0); b 1;
         annotated_recs_c.P_cf2 (Posz 0); annotated_recs_c.P_cf0 (Posz 1)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf1 (Posz 1); annotated_recs_c.P_cf0 (Posz 0);
         b 0; annotated_recs_c.P_cf1 (Posz 0); b 1;
         annotated_recs_c.P_cf2 (Posz 0); annotated_recs_c.P_cf0 (Posz 1)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf1 (Posz 1); annotated_recs_c.P_cf0 (Posz 0);
         b 0; annotated_recs_c.P_cf1 (Posz 0); b 1;
         annotated_recs_c.P_cf2 (Posz 0); annotated_recs_c.P_cf0 (Posz 1)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf1 (Posz 1); annotated_recs_c.P_cf0 (Posz 0);
         b 0; annotated_recs_c.P_cf1 (Posz 0); b 1;
         annotated_recs_c.P_cf2 (Posz 0); annotated_recs_c.P_cf0 (Posz 1)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf0 (Posz 2); annotated_recs_c.P_cf0 (Posz 0);
         b 0; annotated_recs_c.P_cf1 (Posz 0); b 1;
         annotated_recs_c.P_cf2 (Posz 0); annotated_recs_c.P_cf1 (Posz 2);
         annotated_recs_c.P_cf0 (Posz 1); annotated_recs_c.P_cf1 (Posz 1);
         annotated_recs_c.P_cf2 (Posz 1); annotated_recs_c.P_cf2 (Posz 2)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             match
               match
                 match
                   match
                     match
                       match
                         match
                           match
                             match ...
                                   ...
                                   ...
                                   end with
                             | [::] => [::]
                             | _ :: x0 => x0
                             end
                           with
                           | [::] => [::]
                           | _ :: x0 => x0
                           end
                         with
                         | [::] => [::]
                         | _ :: x0 => x0
                         end
                       with
                       | [::] => [::]
                       | _ :: x0 => x0
                       end
                     with
                     | [::] => [::]
                     | _ :: x0 => x0
                     end
                   with
                   | [::] => [::]
                   | _ :: x0 => x0
                   end
                 with
                 | [::] => [::]
                 | _ :: x0 => x0
                 end
               with
               | [::] => [::]
               | _ :: x0 => x0
               end
             with
             | [::] => zero
             | x :: _ => x
             end zero))
       (andb_
          (negb_
             (Feqb
                match
                  match
                    match
                      match
                        match
                          match
                            match
                              match
                                match ... with
                                | ... => [::]
                                | ... => x0
                                end
                              with
                              | [::] => [::]
                              | _ :: x0 => x0
                              end
                            with
                            | [::] => [::]
                            | _ :: x0 => x0
                            end
                          with
                          | [::] => [::]
                          | _ :: x0 => x0
                          end
                        with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end
                      with
                      | [::] => [::]
                      | _ :: x0 => x0
                      end
                    with
                    | [::] => [::]
                    | _ :: x0 => x0
                    end
                  with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => zero
                | x :: _ => x
                end zero))
          (negb_
             (Feqb
                match
                  match
                    match
                      match
                        match
                          match l with
                          | [::] => [::]
                          | _ :: x0 => x0
                          end
                        with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end
                      with
                      | [::] => [::]
                      | _ :: x0 => x0
                      end
                    with
                    | [::] => [::]
                    | _ :: x0 => x0
                    end
                  with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => zero
                | x :: _ => x
                end zero))))" (cannot unify "false" and 
"true").
Crunching: (Forall (fun x : R => 0 <= x) (repeat n x))
Crunching: (I 1 = basis_vector 1 0)
Crunching: (x = 0 -> Forall (fun x : R => 0 <= x) (repeat x H))
Crunching: (a / b - / b = (-1 + a) / b)
Crunching: (x = 0 -> Forall (fun x : R => 0 <= x) (repeat x H))
Crunching:
(forall y : nat, f >= 2 ^ RS' \/ y >= 1 -> f_to_vec RS' H f y = 0%R)
Crunching: (x = 0 -> Forall (fun x : R => 0 <= x) (repeat x H))
Crunching: (Forall (fun x : R => 0 <= x) (repeat n x))
Crunching: (0 < l -> Forall (fun x : R => 0 <= x) (repeat l x))
Crunching: (fst a = fst n)
Crunching:
(r + (binlist_to_nat (r0 ++ []) + (binlist_to_nat (r0 ++ []) + 0)) =
 r + (binlist_to_nat r0 + (binlist_to_nat r0 + 0)) +
 (2 ^ length r0 + (2 ^ length r0 + 0)) * 0)
Crunching:
(ConstructiveCauchyReals.CRealLe (Rrepr (PI_2_3_7_tg N))
   (Rrepr (PI_2_3_7_tg (S N))))
Crunching:
(r + (binlist_to_nat r0 + (binlist_to_nat r0 + 0)) +
 (2 ^ length r0 + (2 ^ length r0 + 0)) * 0 =
 r + (binlist_to_nat (r0 ++ []) + (binlist_to_nat (r0 ++ []) + 0)))
Crunching:
(r + (binlist_to_nat (r0 ++ []) + (binlist_to_nat (r0 ++ []) + 0)) =
 r + (binlist_to_nat r0 + (binlist_to_nat r0 + 0)) +
 (2 ^ length r0 + (2 ^ length r0 + 0)) * 0)
Crunching: (PI_2_3_7_tg (S N) = (2 * (PI_2_3_7_tg N * / 2))%R)
Crunching: (lb <= (n + IH) / 2)
Crunching: (lb <= (IH + n) / 2)
Crunching: (lb <= (n + IH) / 2)
Crunching: (x = 0 -> Forall (fun x : R => 0 <= x) (repeat x H))
Crunching: (x = 0 -> Forall (fun x : R => 0 <= x) (repeat x H))
Debug:
In environment
n : int
sHG : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_v.P_horner b' n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
def_gf : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_v.P_horner b' n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
Hnd : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_v.P_horner b' n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
sHG : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_v.P_horner b' n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching: (lb <= (n + IH) / 2)
Debug:
In environment
n : int
def_gf : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_v.P_horner b' n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching: (lb <= (IH + n) / 2)
Debug:
In environment
n : int
Hnd : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_v.P_horner b' n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching: (lb <= (n + IH) / 2)
Debug:
In environment
n : int
sHG : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_v.P_horner b' n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching: (lb <= (IH + n) / 2)
Debug:
In environment
n : int
def_gf : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_v.P_horner b' n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching: (lb <= (n + IH) / 2)
Debug:
In environment
n : int
Hnd : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_v.P_horner b' n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
sHG : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_v.P_horner b' n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching: (lb <= (IH + n) / 2)
Debug:
In environment
n : int
def_gf : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_v.P_horner b' n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching: (lb <= (n + IH) / 2)
Debug:
In environment
n : int
Hnd : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_v.P_horner b' n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
sHG : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_v.P_horner b' n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
x_p : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_v.P_horner b' n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching: (lb <= (IH + n) / 2)
Debug:
In environment
n : int
def_gf : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_v.P_horner b' n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching: (sum_over_list (repeat x m) = (INR m * x)%R)
Debug:
In environment
n : int
H : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_v.P_horner b' n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
Hnd : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_v.P_horner b' n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
sHG : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_v.P_horner b' n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching: (lb <= (n + IH) / 2)
Debug:
In environment
n : int
x_p : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_v.P_horner b' n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching: (lb <= (IH + n) / 2)
Debug:
In environment
n : int
def_gf : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_v.P_horner b' n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
H : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_v.P_horner b' n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching: (lb <= (n + IH) / 2)
Debug:
In environment
n : int
Hnd : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_v.P_horner b' n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
x : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_v.P_horner b' n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
sHG : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_v.P_horner b' n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching: (sum_over_list (repeat x m) = (INR m * x)%R)
Debug:
In environment
n : int
x_p : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_v.P_horner b' n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching: (sum_over_list (repeat x m) = (INR m * x)%R)
Debug:
In environment
n : int
def_gf : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_v.P_horner b' n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
H : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_v.P_horner b' n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching: (H17 <= fst (Nat.divmod IH 1 0 1))
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (H17 <= fst (Nat.divmod IH 1 0 1))
Crunching: (H17 <= fst (Nat.divmod IH 1 0 1))
Crunching: (H17 <= fst (Nat.divmod IH 1 0 1))
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (0 = (INR m * x)%R)
Crunching: ((INR m * x)%R = sum_over_list (repeat x m))
Crunching: (sum_over_list (repeat x m) = (INR m * x)%R)
Crunching: (sum_over_list (repeat x m) = (INR m * x)%R)
Crunching: (sum_over_list (repeat x m) = (INR m * x)%R)
Crunching: (1%R = 0%R)
Crunching: (forall x : R, sin_in R0² x -> 1%Z = 0%Z)
Crunching: (IPR 1 = R0)
Crunching: False
Debug:
In environment
w : int -> rat
n : forall n : int,
    is_true ((Posz 2 : int) <= (n : int)) ->
    annotated_recs_v.P_horner w n = 0
Hnil : int
A : is_true ((Posz 2 : int) <= (Hnil : int))
telQ := annotated_recs_v.P_cf0 Hnil * w Hnil +
        annotated_recs_v.P_cf1 Hnil * w (int.shift 1 Hnil)
 : GRing.Zmodule.sort (GRing.Ring.zmodType rat_Ring)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: w (int.shift 4 Hnil); telQ; annotated_recs_v.P_cf2 Hnil;
         w (int.shift 2 Hnil); annotated_recs_v.P_cf3 Hnil;
         w (int.shift 3 Hnil); annotated_recs_v.P_cf4 Hnil]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (negb_
       (Feqb
          match
            match
              match
                match
                  match
                    match
                      match l with
                      | [::] => [::]
                      | _ :: x0 => x0
                      end
                    with
                    | [::] => [::]
                    | _ :: x0 => x0
                    end
                  with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => [::]
                | _ :: x0 => x0
                end
              with
              | [::] => [::]
              | _ :: x0 => x0
              end
            with
            | [::] => [::]
            | _ :: x0 => x0
            end
          with
          | [::] => zero
          | x :: _ => x
          end zero))" (cannot unify "false" and "true").
Crunching: (0 <= l1 < 1 -> (Hfalse <= sample (uniform Hfalse a) l1 < a)%nat)
Crunching: (forall a b : C, a / b - / b = (-1 + a) / b)
Crunching: (1%R = 0%R)
Crunching: (0 <= sample (uniform 0 u) r < u)%nat
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (p <= sample (uniform p IH) H)%nat
zeta_3_irrational : ~ (exists r : rat, (z3 == r%:CR)%CR)

zeta_3_irrational is not universe polymorphic
zeta_3_irrational is opaque
Expands to: Constant mathcomp.apery.z3irrational.zeta_3_irrational
Crunching: (binlist_to_nat (repeat true (S Hn)) = 2 ^ S Hn - 1)
Crunching: (binlist_to_nat (repeat true (S Hn)) = 2 ^ S Hn - 1)
Crunching: (binlist_to_nat (repeat true (S Hn)) = 2 ^ S Hn - 1)
Crunching: (binlist_to_nat (repeat true (S Hn)) = 2 ^ S Hn - 1)
Crunching: (binlist_to_nat (repeat true (S Hn)) = 2 ^ S Hn - 1)
Crunching: (binlist_to_nat (repeat true (S Hn)) = 2 ^ S Hn - 1)
Crunching: (2 ^ S Hn - 1 = binlist_to_nat (repeat true (S Hn)))
Crunching: (binlist_to_nat (repeat true (S Hn)) = 2 ^ S Hn - 1)
Crunching: (binlist_to_nat (repeat true (S c)) = 2 ^ S c - 1)
Crunching: (2 ^ S Hn - 1 = binlist_to_nat (repeat true (S Hn)))
Crunching: (binlist_to_nat (repeat true (S Hn)) = 2 ^ S Hn - 1)
Closed under the global context
Crunching: (0 <= H < 1 -> (p <= sample (uniform p IH) H < IH)%nat)
Crunching: (p <= sample (uniform p IH) H)%nat
Crunching: (binlist_to_nat (repeat true (S Hn)) = 2 ^ S Hn - 1)
Crunching: (binlist_to_nat (repeat true (S Hn)) = 2 ^ S Hn - 1)
Crunching: (binlist_to_nat (repeat true (S Hn)) = 2 ^ S Hn - 1)
Crunching: (binlist_to_nat (repeat true (S Hn)) = 2 ^ S Hn - 1)
Crunching: (2 ^ S Hn - 1 = binlist_to_nat (repeat true (S Hn)))
Crunching: (binlist_to_nat (repeat true (S Hn)) = 2 ^ S Hn - 1)
Crunching: (binlist_to_nat (repeat true (S c)) = 2 ^ S c - 1)
Crunching: (2 ^ S Hn - 1 = binlist_to_nat (repeat true (S Hn)))
Crunching: (binlist_to_nat (repeat true (S Hn)) = 2 ^ S Hn - 1)
Crunching: (binlist_to_nat (repeat true (S c)) = 2 ^ S c - 1)
Crunching: (2 ^ S Hn - 1 = binlist_to_nat (repeat true (S Hn)))
Crunching: (binlist_to_nat (repeat true (S Hn)) = 2 ^ S Hn - 1)
Crunching: (binlist_to_nat (repeat true (S c)) = 2 ^ S c - 1)
Debug: Unable to unify "true" with "false".
Crunching: (2 ^ S Hn - 1 = binlist_to_nat (repeat true (S Hn)))
Crunching: (binlist_to_nat (repeat true (S Hn)) = 2 ^ S Hn - 1)
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: rho 2]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: rho 2]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: rho 2]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: rho 2]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching: (binlist_to_nat (repeat true (S c)) = 2 ^ S c - 1)
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: rho 2]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching: (2 ^ S Hn - 1 = binlist_to_nat (repeat true (S Hn)))
Crunching: (binlist_to_nat (repeat true (S Hn)) = 2 ^ S Hn - 1)
Crunching: (binlist_to_nat (repeat true (S c)) = 2 ^ S c - 1)
Debug: Unable to unify "true" with "false".
Crunching: (2 ^ S Hn - 1 = binlist_to_nat (repeat true (S Hn)))
Crunching: (binlist_to_nat (repeat true (S Hn)) = 2 ^ S Hn - 1)
Crunching: (binlist_to_nat (repeat true (S c)) = 2 ^ S c - 1)
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: rho 2]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: rho 2]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: rho 2]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: rho 2]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching: (binlist_to_nat (repeat true (S c)) = 2 ^ S c - 1)
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: rho 2]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: rho 2]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: rho 2]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: rho 2]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching: (binlist_to_nat (repeat true (S c)) = 2 ^ S c - 1)
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: rho 2]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: rho 2]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: rho 2]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching: (2 ^ S Hn - 1 = binlist_to_nat (repeat true (S Hn)))
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: rho 2]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching: (binlist_to_nat (repeat true (S Hn)) = 2 ^ S Hn - 1)
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: rho 2]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: rho 2]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: rho 2]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: rho 2]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: rho 2]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: rho 2]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: rho 2]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: rho 2]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: rho 2]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching: (binlist_to_nat (repeat true (S c)) = 2 ^ S c - 1)
Crunching: (2 ^ S c - 1 = binlist_to_nat (repeat true (S c)))
Crunching: (binlist_to_nat (repeat true (S c)) = 2 ^ S c - 1)
Crunching: (binlist_to_nat (repeat true (S c)) = 2 ^ S c - 1)
Crunching: (2 ^ S Hn - 1 = binlist_to_nat (repeat true (S Hn)))
Crunching: (binlist_to_nat (repeat true (S Hn)) = 2 ^ S Hn - 1)
Crunching: (binlist_to_nat (repeat true (S c)) = 2 ^ S c - 1)
Crunching: (2 ^ S c - 1 = binlist_to_nat (repeat true (S c)))
Crunching: (binlist_to_nat (repeat true (S c)) = 2 ^ S c - 1)
Crunching: (nat_to_binlist len n = nat_to_binlist' n)
Crunching: (nat_to_binlist len n = nat_to_binlist' n)
Crunching:
(binlist_to_nat (nat_to_binlist H3 0) = binlist_to_nat (nat_to_binlist' 0))
Crunching: (nat_to_binlist len n = nat_to_binlist' n)
Crunching: (nat_to_binlist len n = nat_to_binlist' n)
Crunching: (nat_to_binlist len n = nat_to_binlist' n)
Crunching:
(binlist_to_nat (nat_to_binlist H3 0) = binlist_to_nat (nat_to_binlist' 0))
Crunching:
(binlist_to_nat (nat_to_binlist H3 0) = binlist_to_nat (nat_to_binlist' 0))
Crunching: (nat_to_binlist len n = nat_to_binlist' n)
Crunching: (nat_to_binlist len n = nat_to_binlist' n)
Crunching: (nat_to_binlist len n = nat_to_binlist' n)
Crunching: False
Crunching: False
Crunching: False
Crunching: False
Crunching: False
Crunching: False
Crunching: False
Crunching: False
Crunching: False
Crunching: False
Crunching: False
Crunching: False
Crunching: False
Crunching: False
Crunching: False
Crunching: False
Crunching: False
Crunching: False
Crunching: False
Crunching: False
Crunching: False
Crunching: False
Crunching: False
Crunching: False
Crunching: False
Crunching: False
Crunching: False
Crunching: False
Crunching: False
Crunching:
(binlist_to_nat (nat_to_binlist H3 0) = binlist_to_nat (nat_to_binlist' 0))
Crunching: False
Crunching: False
Crunching: False
Crunching: False
Crunching: False
Crunching: False
Crunching: False
Crunching: False
Crunching: False
Crunching: False
Crunching:
(binlist_to_nat (nat_to_binlist H3 0) = binlist_to_nat (nat_to_binlist' 0))
Crunching: False
Crunching: (0 <> √ 2)
Crunching:
(binlist_to_nat (nat_to_binlist y 0) = binlist_to_nat (nat_to_binlist' 0))
Crunching: False
Crunching: False
Crunching: False
Crunching: False
Crunching: False
Crunching: False
Crunching: False
Crunching: False
Crunching: (nat_to_binlist len n = nat_to_binlist' n)
Crunching: False
Crunching: (nat_to_binlist len n = nat_to_binlist' n)
Crunching: (nat_to_binlist len n = nat_to_binlist' n)
Crunching: False
Crunching: False
Crunching: False
Crunching: False
Crunching: False
Crunching: False
Crunching: False
Crunching: (0 <> √ 2)
Crunching: False
Crunching:
(binlist_to_nat (nat_to_binlist a H) = binlist_to_nat (nat_to_binlist' H))
Crunching: (nat_to_binlist len n = nat_to_binlist' n)
Crunching: (0 <> √ 2)
Crunching: False
Crunching: False
Crunching: False
Debug:
In environment
m : ?Goal0 ?Goal1 /\
    (forall B : {set ?Goal}, ?Goal0 B -> B \subset ?Goal1 -> B = ?Goal1)
n : int
a : forall B : {set ?Goal}, ?Goal0 B -> B \subset ?Goal1 -> B = ?Goal1
b : int
H : annotated_recs_c.precond.Sn n b
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: c (int.shift 1 n) b; annotated_recs_c.Sn_cf0_0 n b; c n b]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching: False
Crunching: False
Crunching: False
Crunching: False
Crunching: False
Crunching: False
Crunching: False
Crunching: False
Crunching: False
Crunching: False
Crunching: False
Crunching: False
Crunching: False
Crunching: False
Crunching: False
Crunching: False
Crunching: False
Crunching: False
Crunching: (0 <> √ 2)
Crunching: False
Crunching: (binlist_to_nat (nat_to_binlist H5 H6) = H6)
Debug:
In environment
m : ?Goal0 ?Goal1 /\
    (forall B : {set ?Goal}, ?Goal0 B -> B \subset ?Goal1 -> B = ?Goal1)
n : int
a : forall B : {set ?Goal}, ?Goal0 B -> B \subset ?Goal1 -> B = ?Goal1
b : int
H : annotated_recs_c.precond.Sn n b
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: c (int.shift 1 n) b; annotated_recs_c.Sn_cf0_0 n b; c n b]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching: False
Crunching: False
Crunching: False
Crunching: False
Crunching: False
Crunching: False
Crunching: False
Crunching: False
Crunching: False
Crunching: False
Crunching: False
Crunching: False
Debug:
In environment
n : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: b' n;
         reducebig 0 (bigopz.index_iotaz 0 (n + 1))
           (fun k : int =>
            BigBody k +%R true
              (match n with
               | Posz n1 =>
                   match k with
                   | Posz m1 => binomial_rec n1 m1 true true
                   | Negz m1 => binomial_rec n1 m1 true false
                   end
               | Negz n1 =>
                   match k with
                   | Posz m1 => binomial_rec n1 m1 false true
                   | Negz m1 => binomial_rec n1 m1 false false
                   end
               end%:~R ^ Posz 2 *
               match n + k with
               | Posz n1 =>
                   match k with
                   | Posz m1 => binomial_rec n1 m1 true true
                   | Negz m1 => binomial_rec n1 m1 true false
                   end
               | Negz n1 =>
                   match k with
                   | Posz m1 => binomial_rec n1 m1 false true
                   | Negz m1 => binomial_rec n1 m1 false false
                   end
               end%:~R ^ Posz 2 *
               (reducebig 0 (bigopz.index_iotaz 1 (n + 1))
                  (fun k0 : int => BigBody k0 +%R true (k0%:~R ^ Posz 3)^-1) +
                reducebig 0 (bigopz.index_iotaz 1 (k + 1))
                  (fun m : int =>
                   BigBody m +%R true
                     ((-1) ^ (m + 1) /
                      ((Posz 2)%:~R * m%:~R ^ Posz 3 *
                       match n with
                       | Posz n1 =>
                           match m with
                           | Posz m1 => binomial_rec n1 m1 true true
                           | Negz m1 => binomial_rec n1 m1 true false
                           end
                       | Negz n1 =>
                           match m with
                           | Posz m1 => binomial_rec n1 m1 false true
                           | Negz m1 => binomial_rec n1 m1 false false
                           end
                       end%:~R *
                       match n + m with
                       | Posz n1 =>
                           match m with
                           | Posz m1 => binomial_rec n1 m1 true true
                           | Negz m1 => binomial_rec n1 m1 true false
                           end
                       | Negz n1 =>
                           match m with
                           | Posz m1 => binomial_rec n1 m1 false true
                           | Negz m1 => binomial_rec n1 m1 false false
                           end
                       end%:~R))))))]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching: (√ (x + y) <= √ x + √ y)
Crunching: (forall x : nat, fst a (2 ^ a + x) = S (fst a x))
Crunching: (√ (x + y) <= √ x + √ y)
Debug:
In environment
n : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: b' n;
         reducebig 0 (bigopz.index_iotaz 0 (n + 1))
           (fun k : int =>
            BigBody k +%R true
              (match n with
               | Posz n1 =>
                   match k with
                   | Posz m1 => binomial_rec n1 m1 true true
                   | Negz m1 => binomial_rec n1 m1 true false
                   end
               | Negz n1 =>
                   match k with
                   | Posz m1 => binomial_rec n1 m1 false true
                   | Negz m1 => binomial_rec n1 m1 false false
                   end
               end%:~R ^ Posz 2 *
               match n + k with
               | Posz n1 =>
                   match k with
                   | Posz m1 => binomial_rec n1 m1 true true
                   | Negz m1 => binomial_rec n1 m1 true false
                   end
               | Negz n1 =>
                   match k with
                   | Posz m1 => binomial_rec n1 m1 false true
                   | Negz m1 => binomial_rec n1 m1 false false
                   end
               end%:~R ^ Posz 2 *
               (reducebig 0 (bigopz.index_iotaz 1 (n + 1))
                  (fun k0 : int => BigBody k0 +%R true (k0%:~R ^ Posz 3)^-1) +
                reducebig 0 (bigopz.index_iotaz 1 (k + 1))
                  (fun m : int =>
                   BigBody m +%R true
                     ((-1) ^ (m + 1) /
                      ((Posz 2)%:~R * m%:~R ^ Posz 3 *
                       match n with
                       | Posz n1 =>
                           match m with
                           | Posz m1 => binomial_rec n1 m1 true true
                           | Negz m1 => binomial_rec n1 m1 true false
                           end
                       | Negz n1 =>
                           match m with
                           | Posz m1 => binomial_rec n1 m1 false true
                           | Negz m1 => binomial_rec n1 m1 false false
                           end
                       end%:~R *
                       match n + m with
                       | Posz n1 =>
                           match m with
                           | Posz m1 => binomial_rec n1 m1 true true
                           | Negz m1 => binomial_rec n1 m1 true false
                           end
                       | Negz n1 =>
                           match m with
                           | Posz m1 => binomial_rec n1 m1 false true
                           | Negz m1 => binomial_rec n1 m1 false false
                           end
                       end%:~R))))))]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching: (binlist_to_nat (nat_to_binlist H5 H6) = H6)
Crunching: False
Crunching:
(adapted_couple ?f@{x:=y; y:=y; x0:=y0; y0:=y0}
   ?a@{x:=y; y:=y; x0:=y0; y0:=y0} ?b@{x:=y; y:=y; x0:=y0; y0:=y0}
   ?l1@{x:=y; y:=y; x0:=y0; y0:=y0} ?lf1@{x:=y; y:=y; x0:=y0; y0:=y0})
Debug:
In environment
m : ?Goal0 ?Goal1 /\
    (forall B : {set ?Goal}, ?Goal0 B -> B \subset ?Goal1 -> B = ?Goal1)
injf, H : int
H0 : annotated_recs_c.precond.Sn injf H
a : H != injf + 1
b : injf != -1
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: c (int.shift 1 injf) H; annotated_recs_c.Sn_cf0_0 injf H; c injf H]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching: (Morphisms.respectful eq or (Rlt x) (eq x))
Debug:
In environment
H, k_ : int
H0 : k_ != H + 1
H1 : H != -1
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: c (int.shift 1 H) k_; annotated_recs_c.Sn_cf0_0 H k_; c H k_]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching: (binlist_to_nat (repeat false Hocc) = 0)
Crunching: False
Crunching:
(adapted_couple ?f@{x:=y; y:=y; x0:=y0; y0:=y0}
   ?a@{x:=y; y:=y; x0:=y0; y0:=y0} ?b@{x:=y; y:=y; x0:=y0; y0:=y0}
   ?l1@{x:=y; y:=y; x0:=y0; y0:=y0} ?lf1@{x:=y; y:=y; x0:=y0; y0:=y0})
Crunching:
((if b <? H5
  then
   if b + (1 + (H5 - b - 1) + 1) <=? a
   then
    I (2 ^ b)
    ⊗ (∣1⟩⟨1∣ ⊗ I (2 ^ (H5 - b - 1)) ⊗ A
       .+ ∣0⟩⟨0∣ ⊗ I (2 ^ (H5 - b - 1)) ⊗ I 2)
    ⊗ I (2 ^ (a - (b + (1 + (H5 - b - 1) + 1))))
   else Zero
  else
   if H5 <? b
   then
    if H5 + (1 + (b - H5 - 1) + 1) <=? a
    then
     I (2 ^ H5)
     ⊗ (A ⊗ I (2 ^ (b - H5 - 1)) ⊗ ∣1⟩⟨1∣
        .+ I 2 ⊗ I (2 ^ (b - H5 - 1)) ⊗ ∣0⟩⟨0∣)
     ⊗ I (2 ^ (a - (H5 + (1 + (b - H5 - 1) + 1))))
    else Zero
   else Zero)
 × (if o <? p
    then
     if o + (1 + (p - o - 1) + 1) <=? a
     then
      I (2 ^ o)
      ⊗ (∣1⟩⟨1∣ ⊗ I (2 ^ (p - o - 1)) ⊗ B
         .+ ∣0⟩⟨0∣ ⊗ I (2 ^ (p - o - 1)) ⊗ I 2)
      ⊗ I (2 ^ (a - (o + (1 + (p - o - 1) + 1))))
     else Zero
    else
     if p <? o
     then
      if p + (1 + (o - p - 1) + 1) <=? a
      then
       I (2 ^ p)
       ⊗ (B ⊗ I (2 ^ (o - p - 1)) ⊗ ∣1⟩⟨1∣
          .+ I 2 ⊗ I (2 ^ (o - p - 1)) ⊗ ∣0⟩⟨0∣)
       ⊗ I (2 ^ (a - (p + (1 + (o - p - 1) + 1))))
      else Zero
     else Zero) =
 (if o <? p
  then
   if o + (1 + (p - o - 1) + 1) <=? a
   then
    I (2 ^ o)
    ⊗ (∣1⟩⟨1∣ ⊗ I (2 ^ (p - o - 1)) ⊗ B .+ ∣0⟩⟨0∣ ⊗ I (2 ^ (p - o - 1)) ⊗ I 2)
    ⊗ I (2 ^ (a - (o + (1 + (p - o - 1) + 1))))
   else Zero
  else
   if p <? o
   then
    if p + (1 + (o - p - 1) + 1) <=? a
    then
     I (2 ^ p)
     ⊗ (B ⊗ I (2 ^ (o - p - 1)) ⊗ ∣1⟩⟨1∣
        .+ I 2 ⊗ I (2 ^ (o - p - 1)) ⊗ ∣0⟩⟨0∣)
     ⊗ I (2 ^ (a - (p + (1 + (o - p - 1) + 1))))
    else Zero
   else Zero)
 × (if b <? H5
    then
     if b + (1 + (H5 - b - 1) + 1) <=? a
     then
      I (2 ^ b)
      ⊗ (∣1⟩⟨1∣ ⊗ I (2 ^ (H5 - b - 1)) ⊗ A
         .+ ∣0⟩⟨0∣ ⊗ I (2 ^ (H5 - b - 1)) ⊗ I 2)
      ⊗ I (2 ^ (a - (b + (1 + (H5 - b - 1) + 1))))
     else Zero
    else
     if H5 <? b
     then
      if H5 + (1 + (b - H5 - 1) + 1) <=? a
      then
       I (2 ^ H5)
       ⊗ (A ⊗ I (2 ^ (b - H5 - 1)) ⊗ ∣1⟩⟨1∣
          .+ I 2 ⊗ I (2 ^ (b - H5 - 1)) ⊗ ∣0⟩⟨0∣)
       ⊗ I (2 ^ (a - (H5 + (1 + (b - H5 - 1) + 1))))
      else Zero
     else Zero))
Crunching: (Morphisms.respectful eq or (Rlt x) (eq x))
Crunching: (√ (x + y) <= √ x + √ y)
Debug:
In environment
n : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: b' n;
         reducebig 0 (bigopz.index_iotaz 0 (n + 1))
           (fun k : int =>
            BigBody k +%R true
              (match n with
               | Posz n1 =>
                   match k with
                   | Posz m1 => binomial_rec n1 m1 true true
                   | Negz m1 => binomial_rec n1 m1 true false
                   end
               | Negz n1 =>
                   match k with
                   | Posz m1 => binomial_rec n1 m1 false true
                   | Negz m1 => binomial_rec n1 m1 false false
                   end
               end%:~R ^ Posz 2 *
               match n + k with
               | Posz n1 =>
                   match k with
                   | Posz m1 => binomial_rec n1 m1 true true
                   | Negz m1 => binomial_rec n1 m1 true false
                   end
               | Negz n1 =>
                   match k with
                   | Posz m1 => binomial_rec n1 m1 false true
                   | Negz m1 => binomial_rec n1 m1 false false
                   end
               end%:~R ^ Posz 2 *
               (reducebig 0 (bigopz.index_iotaz 1 (n + 1))
                  (fun k0 : int => BigBody k0 +%R true (k0%:~R ^ Posz 3)^-1) +
                reducebig 0 (bigopz.index_iotaz 1 (k + 1))
                  (fun m : int =>
                   BigBody m +%R true
                     ((-1) ^ (m + 1) /
                      ((Posz 2)%:~R * m%:~R ^ Posz 3 *
                       match n with
                       | Posz n1 =>
                           match m with
                           | Posz m1 => binomial_rec n1 m1 true true
                           | Negz m1 => binomial_rec n1 m1 true false
                           end
                       | Negz n1 =>
                           match m with
                           | Posz m1 => binomial_rec n1 m1 false true
                           | Negz m1 => binomial_rec n1 m1 false false
                           end
                       end%:~R *
                       match n + m with
                       | Posz n1 =>
                           match m with
                           | Posz m1 => binomial_rec n1 m1 true true
                           | Negz m1 => binomial_rec n1 m1 true false
                           end
                       | Negz n1 =>
                           match m with
                           | Posz m1 => binomial_rec n1 m1 false true
                           | Negz m1 => binomial_rec n1 m1 false false
                           end
                       end%:~R))))))]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching: (forall n : nat, nat_to_binlist' n = [] -> 0 = n)
Crunching: (forall x : nat, fst a (2 ^ a + x) = S (fst a x))
Crunching: (forall n : nat, nat_to_binlist' n = [] -> 0 = n)
Crunching: (forall x : nat, fst a (2 ^ a + x) = S (fst a x))
Crunching: (forall n : nat, nat_to_binlist' n = [] -> 0 = n)
Crunching: (forall n : nat, nat_to_binlist' n = [] -> 0 = n)
Crunching: (forall n : nat, nat_to_binlist' n = [] -> 0 = n)
Crunching: (√ (x + y) <= √ x + √ y)
Crunching: (forall n : nat, nat_to_binlist' n = [] -> 0 = n)
Crunching: False
Crunching:
(adapted_couple ?f@{x:=y; y:=y; x0:=y0; y0:=y0}
   ?a@{x:=y; y:=y; x0:=y0; y0:=y0} ?b@{x:=y; y:=y; x0:=y0; y0:=y0}
   ?l1@{x:=y; y:=y; x0:=y0; y0:=y0} ?lf1@{x:=y; y:=y; x0:=y0; y0:=y0})
Crunching: (Morphisms.respectful eq or (Rlt x) (eq x))
Crunching: (forall n : nat, nat_to_binlist' n = [] -> 0 = n)
Crunching: (forall n : nat, nat_to_binlist' n = [] -> 0 = n)
Crunching: (forall n : nat, nat_to_binlist' n = [] -> 0 = n)
Crunching:
(pad_ctrl 0 b 0 A × pad_ctrl 0 o p B = pad_ctrl 0 o p B × pad_ctrl 0 b 0 A)
Crunching: (forall n : nat, nat_to_binlist' n = [] -> 0 = n)
Crunching: (forall n : nat, nat_to_binlist' n = [] -> 0 = n)
Crunching: (snd p 0 = LT)
Debug:
In environment
n : int
nge2 : is_true ((Posz 2 : int) <= (n : int))
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching: ((forall m : nat, (m < LT)%nat -> snd p 0 = m) -> snd p 0 = LT)
Crunching: (forall n : nat, nat_to_binlist' n = [] -> 0 = n)
Debug:
In environment
n : int
EQ : is_true ((Posz 2 : int) <= (n : int))
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
z_ne_0 : is_true ((Posz 2 : int) <= (n : int))
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
nge2 : is_true ((Posz 2 : int) <= (n : int))
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching: (forall n : nat, nat_to_binlist' n = [] -> 0 = n)
Debug:
In environment
n : int
EQ : is_true ((Posz 2 : int) <= (n : int))
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
z_ne_0 : is_true ((Posz 2 : int) <= (n : int))
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching: (forall n : nat, nat_to_binlist' n = [] -> 0 = n)
Crunching: (forall n : nat, nat_to_binlist' n = [] -> 0 = n)
Crunching: (forall n : nat, nat_to_binlist' n = [] -> 0 = n)
Debug:
In environment
n : int
nge2 : is_true ((Posz 2 : int) <= (n : int))
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: (((((match n with
              | Posz elpi_ctx_entry_2_ => iterop elpi_ctx_entry_2_ addq 1 0
              | Negz elpi_ctx_entry_2_ =>
                  (-
                   match elpi_ctx_entry_2_ with
                   | 0 => 1%Q
                   | _.+1 =>
                       match
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 =>
                                match loop i with
                                | {| valq := y |} =>
                                    fracq
                                      (let (y1, y2) := y in
                                       match y2 with
                                       | Posz 1 =>
                                           match y1 with
                                           | Posz 0 => (1%R, 1%R)
                                           | Posz 1 => (Posz 2, 1%R)
                                           | Posz
                                             (_.+2 as elpi_ctx_entry_14_) =>
                                               (Posz elpi_ctx_entry_14_.+1,
                                               1%R)
                                           | Negz _ => ((1 + y1)%R, 1%R)
                                           end
                                       | _ => ((1 * y2 + y1)%R, y2)
                                       end)
                                end
                            end) elpi_ctx_entry_2_
                       with
                       | {| valq := y |} =>
                           fracq
                             (let (y1, y2) := y in
                              match y2 with
                              | Posz 1 =>
                                  match y1 with
                                  | Posz 0 => (1%R, 1%R)
                                  | Posz 1 => (Posz 2, 1%R)
                                  | Posz (_.+2 as elpi_ctx_entry_10_) =>
                                      (Posz elpi_ctx_entry_10_.+1, 1%R)
                                  | Negz _ => ((1 + y1)%R, 1%R)
                                  end
                              | _ => ((1 * y2 + y1)%R, y2)
                              end)
                       end
                   end)%Q
              end + rat_of_Z 2)%Q *
             ((match n with
               | Posz elpi_ctx_entry_2_ => iterop elpi_ctx_entry_2_ addq 1 0
               | Negz elpi_ctx_entry_2_ =>
                   (-
                    match elpi_ctx_entry_2_ with
                    | 0 => 1%Q
                    | _.+1 =>
                        match
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 =>
                                 match loop i with
                                 | {| valq := y |} =>
                                     fracq
                                       (let (y1, y2) := y in
                                        match y2 with
                                        | Posz 1 =>
                                            match y1 with
                                            | Posz 0 => (1%R, 1%R)
                                            | Posz 1 => (Posz 2, 1%R)
                                            | Posz
                                              (_.+2 as elpi_ctx_entry_14_) =>
                                                (Posz elpi_ctx_entry_14_.+1,
                                                1%R)
                                            | Negz _ => ((1 + y1)%R, 1%R)
                                            end
                                        | _ => ((1 * y2 + y1)%R, y2)
                                        end)
                                 end
                             end) elpi_ctx_entry_2_
                        with
                        | {| valq := y |} =>
                            fracq
                              (let (y1, y2) := y in
                               match y2 with
                               | Posz 1 =>
                                   match y1 with
                                   | Posz 0 => (1%R, 1%R)
                                   | Posz 1 => (Posz 2, 1%R)
                                   | Posz (_.+2 as elpi_ctx_entry_10_) =>
                                       (Posz elpi_ctx_entry_10_.+1, 1%R)
                                   | Negz _ => ((1 + y1)%R, 1%R)
                                   end
                               | _ => ((1 * y2 + y1)%R, y2)
                               end)
                        end
                    end)%Q
               end + rat_of_Z 2)%Q *
              (match n with
               | Posz elpi_ctx_entry_2_ => iterop elpi_ctx_entry_2_ addq 1 0
               | Negz elpi_ctx_entry_2_ =>
                   (-
                    match elpi_ctx_entry_2_ with
                    | 0 => 1%Q
                    | _.+1 =>
                        match
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 =>
                                 match loop i with
                                 | {| valq := y |} =>
                                     fracq
                                       (let (y1, y2) := y in
                                        match y2 with
                                        | Posz 1 =>
                                            match y1 with
                                            | Posz 0 => (1%R, 1%R)
                                            | Posz 1 => (Posz 2, 1%R)
                                            | Posz
                                              (_.+2 as elpi_ctx_entry_14_) =>
                                                (Posz elpi_ctx_entry_14_.+1,
                                                1%R)
                                            | Negz _ => ((1 + y1)%R, 1%R)
                                            end
                                        | _ => ((1 * y2 + y1)%R, y2)
                                        end)
                                 end
                             end) elpi_ctx_entry_2_
                        with
                        | {| valq := y |} =>
                            fracq
                              (let (y1, y2) := y in
                               match y2 with
                               | Posz 1 =>
                                   match y1 with
                                   | Posz 0 => (1%R, 1%R)
                                   | Posz 1 => (Posz 2, 1%R)
                                   | Posz (_.+2 as elpi_ctx_entry_10_) =>
                                       (Posz elpi_ctx_entry_10_.+1, 1%R)
                                   | Negz _ => ((1 + y1)%R, 1%R)
                                   end
                               | _ => ((1 * y2 + y1)%R, y2)
                               end)
                        end
                    end)%Q
               end + rat_of_Z 2)%Q)%Q)%Q *
            reducebig 0%R
              (bigopz.index_iotaz 0
                 (intZmod.addz (intZmod.addz n (Posz 1)) (Posz 1) + 1))
              (fun k : int =>
               BigBody k +%R true
                 (match intZmod.addz (intZmod.addz n (Posz 1)) (Posz 1) with
                  | Posz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 true true
                      | Negz m1 => binomial_rec n1 m1 true false
                      end
                  | Negz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 false true
                      | Negz m1 => binomial_rec n1 m1 false false
                      end
                  end%:~R ^ Posz 2 *
                  match
                    intZmod.addz (intZmod.addz n (Posz 1)) (Posz 1) + k
                  with
                  | Posz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 true true
                      | Negz m1 => binomial_rec n1 m1 true false
                      end
                  | Negz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 false true
                      | Negz m1 => binomial_rec n1 m1 false false
                      end
                  end%:~R ^ Posz 2 *
                  (reducebig 0
                     (bigopz.index_iotaz 1
                        (intZmod.addz (intZmod.addz n (Posz 1)) (Posz 1) + 1))
                     (fun k0 : int =>
                      BigBody k0 +%R true (k0%:~R ^ Posz 3)^-1) +
                   reducebig 0 (bigopz.index_iotaz 1 (k + 1))
                     (fun m : int =>
                      BigBody m +%R true
                        ((-1) ^ (m + 1) /
                         ((Posz 2)%:~R * m%:~R ^ Posz 3 *
                          match
                            intZmod.addz (intZmod.addz n (Posz 1)) (Posz 1)
                          with
                          | Posz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 true true
                              | Negz m1 => binomial_rec n1 m1 true false
                              end
                          | Negz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 false true
                              | Negz m1 => binomial_rec n1 m1 false false
                              end
                          end%:~R *
                          match
                            intZmod.addz (intZmod.addz n (Posz 1)) (Posz 1) +
                            m
                          with
                          | Posz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 true true
                              | Negz m1 => binomial_rec n1 m1 true false
                              end
                          | Negz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 false true
                              | Negz m1 => binomial_rec n1 m1 false false
                              end
                          end%:~R)))))%R))%Q +
           ((((- rat_of_Z 1)%Q *
              (((rat_of_Z 17 *
                 (match n with
                  | Posz elpi_ctx_entry_2_ =>
                      iterop elpi_ctx_entry_2_ addq 1 0
                  | Negz elpi_ctx_entry_2_ =>
                      (-
                       match elpi_ctx_entry_2_ with
                       | 0 => 1%Q
                       | _.+1 =>
                           match
                             (fix loop (m : nat) : rat :=
                                match m with
                                | 0 => 0
                                | 1 => 1
                                | (_.+1 as i).+1 =>
                                    match loop i with
                                    | {| valq := y |} =>
                                        fracq
                                          (let (y1, y2) := y in
                                           match y2 with
                                           | Posz 1 =>
                                               match y1 with
                                               | Posz 0 => (1%R, 1%R)
                                               | Posz 1 => (Posz 2, 1%R)
                                               | Posz ... =>
                                                 (
                                                 Posz elpi_ctx_entry_14_.+1,
                                                 1%R)
                                               | Negz _ => ((...)%R, 1%R)
                                               end
                                           | _ => ((1 * y2 + y1)%R, y2)
                                           end)
                                    end
                                end) elpi_ctx_entry_2_
                           with
                           | {| valq := y |} =>
                               fracq
                                 (let (y1, y2) := y in
                                  match y2 with
                                  | Posz 1 =>
                                      match y1 with
                                      | Posz 0 => (1%R, 1%R)
                                      | Posz 1 => (Posz 2, 1%R)
                                      | Posz (_.+2 as elpi_ctx_entry_10_) =>
                                          (Posz elpi_ctx_entry_10_.+1, 1%R)
                                      | Negz _ => ((1 + y1)%R, 1%R)
                                      end
                                  | _ => ((1 * y2 + y1)%R, y2)
                                  end)
                           end
                       end)%Q
                  end *
                  match n with
                  | Posz elpi_ctx_entry_2_ =>
                      iterop elpi_ctx_entry_2_ addq 1 0
                  | Negz elpi_ctx_entry_2_ =>
                      (-
                       match elpi_ctx_entry_2_ with
                       | 0 => 1%Q
                       | _.+1 =>
                           match
                             (fix loop (m : nat) : rat :=
                                match m with
                                | 0 => 0
                                | 1 => 1
                                | (_.+1 as i).+1 =>
                                    match loop i with
                                    | {| valq := y |} =>
                                        fracq
                                          (let (y1, y2) := y in
                                           match y2 with
                                           | Posz 1 =>
                                               match y1 with
                                               | Posz 0 => (1%R, 1%R)
                                               | Posz 1 => (Posz 2, 1%R)
                                               | Posz ... =>
                                                 (
                                                 Posz elpi_ctx_entry_14_.+1,
                                                 1%R)
                                               | Negz _ => ((...)%R, 1%R)
                                               end
                                           | _ => ((1 * y2 + y1)%R, y2)
                                           end)
                                    end
                                end) elpi_ctx_entry_2_
                           with
                           | {| valq := y |} =>
                               fracq
                                 (let (y1, y2) := y in
                                  match y2 with
                                  | Posz 1 =>
                                      match y1 with
                                      | Posz 0 => (1%R, 1%R)
                                      | Posz 1 => (Posz 2, 1%R)
                                      | Posz (_.+2 as elpi_ctx_entry_10_) =>
                                          (Posz elpi_ctx_entry_10_.+1, 1%R)
                                      | Negz _ => ((1 + y1)%R, 1%R)
                                      end
                                  | _ => ((1 * y2 + y1)%R, y2)
                                  end)
                           end
                       end)%Q
                  end)%Q)%Q +
                (rat_of_Z 51 *
                 match n with
                 | Posz elpi_ctx_entry_2_ =>
                     iterop elpi_ctx_entry_2_ addq 1 0
                 | Negz elpi_ctx_entry_2_ =>
                     (-
                      match elpi_ctx_entry_2_ with
                      | 0 => 1%Q
                      | _.+1 =>
                          match
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as i).+1 =>
                                   match loop i with
                                   | {| valq := y |} =>
                                       fracq
                                         (let (y1, y2) := y in
                                          match y2 with
                                          | Posz 1 =>
                                              match y1 with
                                              | Posz 0 => (1%R, 1%R)
                                              | Posz 1 => (Posz 2, 1%R)
                                              | Posz
                                                (_.+2 as elpi_ctx_entry_14_) =>
                                                 (
                                                 Posz elpi_ctx_entry_14_.+1,
                                                 1%R)
                                              | Negz _ => ((1 + y1)%R, 1%R)
                                              end
                                          | _ => ((1 * y2 + y1)%R, y2)
                                          end)
                                   end
                               end) elpi_ctx_entry_2_
                          with
                          | {| valq := y |} =>
                              fracq
                                (let (y1, y2) := y in
                                 match y2 with
                                 | Posz 1 =>
                                     match y1 with
                                     | Posz 0 => (1%R, 1%R)
                                     | Posz 1 => (Posz 2, 1%R)
                                     | Posz (_.+2 as elpi_ctx_entry_10_) =>
                                         (Posz elpi_ctx_entry_10_.+1, 1%R)
                                     | Negz _ => ((1 + y1)%R, 1%R)
                                     end
                                 | _ => ((1 * y2 + y1)%R, y2)
                                 end)
                          end
                      end)%Q
                 end)%Q)%Q + rat_of_Z 39)%Q)%Q *
             ((rat_of_Z 2 *
               match n with
               | Posz elpi_ctx_entry_2_ => iterop elpi_ctx_entry_2_ addq 1 0
               | Negz elpi_ctx_entry_2_ =>
                   (-
                    match elpi_ctx_entry_2_ with
                    | 0 => 1%Q
                    | _.+1 =>
                        match
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 =>
                                 match loop i with
                                 | {| valq := y |} =>
                                     fracq
                                       (let (y1, y2) := y in
                                        match y2 with
                                        | Posz 1 =>
                                            match y1 with
                                            | Posz 0 => (1%R, 1%R)
                                            | Posz 1 => (Posz 2, 1%R)
                                            | Posz
                                              (_.+2 as elpi_ctx_entry_14_) =>
                                                (Posz elpi_ctx_entry_14_.+1,
                                                1%R)
                                            | Negz _ => ((1 + y1)%R, 1%R)
                                            end
                                        | _ => ((1 * y2 + y1)%R, y2)
                                        end)
                                 end
                             end) elpi_ctx_entry_2_
                        with
                        | {| valq := y |} =>
                            fracq
                              (let (y1, y2) := y in
                               match y2 with
                               | Posz 1 =>
                                   match y1 with
                                   | Posz 0 => (1%R, 1%R)
                                   | Posz 1 => (Posz 2, 1%R)
                                   | Posz (_.+2 as elpi_ctx_entry_10_) =>
                                       (Posz elpi_ctx_entry_10_.+1, 1%R)
                                   | Negz _ => ((1 + y1)%R, 1%R)
                                   end
                               | _ => ((1 * y2 + y1)%R, y2)
                               end)
                        end
                    end)%Q
               end)%Q + rat_of_Z 3)%Q)%Q *
            reducebig 0%R
              (bigopz.index_iotaz 0 (intZmod.addz n (Posz 1) + 1))
              (fun k : int =>
               BigBody k +%R true
                 (match intZmod.addz n (Posz 1) with
                  | Posz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 true true
                      | Negz m1 => binomial_rec n1 m1 true false
                      end
                  | Negz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 false true
                      | Negz m1 => binomial_rec n1 m1 false false
                      end
                  end%:~R ^ Posz 2 *
                  match intZmod.addz n (Posz 1) + k with
                  | Posz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 true true
                      | Negz m1 => binomial_rec n1 m1 true false
                      end
                  | Negz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 false true
                      | Negz m1 => binomial_rec n1 m1 false false
                      end
                  end%:~R ^ Posz 2 *
                  (reducebig 0
                     (bigopz.index_iotaz 1 (intZmod.addz n (Posz 1) + 1))
                     (fun k0 : int =>
                      BigBody k0 +%R true (k0%:~R ^ Posz 3)^-1) +
                   reducebig 0 (bigopz.index_iotaz 1 (k + 1))
                     (fun m : int =>
                      BigBody m +%R true
                        ((-1) ^ (m + 1) /
                         ((Posz 2)%:~R * m%:~R ^ Posz 3 *
                          match intZmod.addz n (Posz 1) with
                          | Posz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 true true
                              | Negz m1 => binomial_rec n1 m1 true false
                              end
                          | Negz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 false true
                              | Negz m1 => binomial_rec n1 m1 false false
                              end
                          end%:~R *
                          match intZmod.addz n (Posz 1) + m with
                          | Posz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 true true
                              | Negz m1 => binomial_rec n1 m1 true false
                              end
                          | Negz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 false true
                              | Negz m1 => binomial_rec n1 m1 false false
                              end
                          end%:~R)))))%R))%Q)%Q +
          (((match n with
             | Posz elpi_ctx_entry_2_ => iterop elpi_ctx_entry_2_ addq 1 0
             | Negz elpi_ctx_entry_2_ =>
                 (-
                  match elpi_ctx_entry_2_ with
                  | 0 => 1%Q
                  | _.+1 =>
                      match
                        (fix loop (m : nat) : rat :=
                           match m with
                           | 0 => 0
                           | 1 => 1
                           | (_.+1 as i).+1 =>
                               match loop i with
                               | {| valq := y |} =>
                                   fracq
                                     (let (y1, y2) := y in
                                      match y2 with
                                      | Posz 1 =>
                                          match y1 with
                                          | Posz 0 => (1%R, 1%R)
                                          | Posz 1 => (Posz 2, 1%R)
                                          | Posz (_.+2 as elpi_ctx_entry_14_) =>
                                              (Posz elpi_ctx_entry_14_.+1,
                                              1%R)
                                          | Negz _ => ((1 + y1)%R, 1%R)
                                          end
                                      | _ => ((1 * y2 + y1)%R, y2)
                                      end)
                               end
                           end) elpi_ctx_entry_2_
                      with
                      | {| valq := y |} =>
                          fracq
                            (let (y1, y2) := y in
                             match y2 with
                             | Posz 1 =>
                                 match y1 with
                                 | Posz 0 => (1%R, 1%R)
                                 | Posz 1 => (Posz 2, 1%R)
                                 | Posz (_.+2 as elpi_ctx_entry_10_) =>
                                     (Posz elpi_ctx_entry_10_.+1, 1%R)
                                 | Negz _ => ((1 + y1)%R, 1%R)
                                 end
                             | _ => ((1 * y2 + y1)%R, y2)
                             end)
                      end
                  end)%Q
             end + rat_of_Z 1)%Q *
            ((match n with
              | Posz elpi_ctx_entry_2_ => iterop elpi_ctx_entry_2_ addq 1 0
              | Negz elpi_ctx_entry_2_ =>
                  (-
                   match elpi_ctx_entry_2_ with
                   | 0 => 1%Q
                   | _.+1 =>
                       match
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 =>
                                match loop i with
                                | {| valq := y |} =>
                                    fracq
                                      (let (y1, y2) := y in
                                       match y2 with
                                       | Posz 1 =>
                                           match y1 with
                                           | Posz 0 => (1%R, 1%R)
                                           | Posz 1 => (Posz 2, 1%R)
                                           | Posz
                                             (_.+2 as elpi_ctx_entry_14_) =>
                                               (Posz elpi_ctx_entry_14_.+1,
                                               1%R)
                                           | Negz _ => ((1 + y1)%R, 1%R)
                                           end
                                       | _ => ((1 * y2 + y1)%R, y2)
                                       end)
                                end
                            end) elpi_ctx_entry_2_
                       with
                       | {| valq := y |} =>
                           fracq
                             (let (y1, y2) := y in
                              match y2 with
                              | Posz 1 =>
                                  match y1 with
                                  | Posz 0 => (1%R, 1%R)
                                  | Posz 1 => (Posz 2, 1%R)
                                  | Posz (_.+2 as elpi_ctx_entry_10_) =>
                                      (Posz elpi_ctx_entry_10_.+1, 1%R)
                                  | Negz _ => ((1 + y1)%R, 1%R)
                                  end
                              | _ => ((1 * y2 + y1)%R, y2)
                              end)
                       end
                   end)%Q
              end + rat_of_Z 1)%Q *
             (match n with
              | Posz elpi_ctx_entry_2_ => iterop elpi_ctx_entry_2_ addq 1 0
              | Negz elpi_ctx_entry_2_ =>
                  (-
                   match elpi_ctx_entry_2_ with
                   | 0 => 1%Q
                   | _.+1 =>
                       match
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 =>
                                match loop i with
                                | {| valq := y |} =>
                                    fracq
                                      (let (y1, y2) := y in
                                       match y2 with
                                       | Posz 1 =>
                                           match y1 with
                                           | Posz 0 => (1%R, 1%R)
                                           | Posz 1 => (Posz 2, 1%R)
                                           | Posz
                                             (_.+2 as elpi_ctx_entry_14_) =>
                                               (Posz elpi_ctx_entry_14_.+1,
                                               1%R)
                                           | Negz _ => ((1 + y1)%R, 1%R)
                                           end
                                       | _ => ((1 * y2 + y1)%R, y2)
                                       end)
                                end
                            end) elpi_ctx_entry_2_
                       with
                       | {| valq := y |} =>
                           fracq
                             (let (y1, y2) := y in
                              match y2 with
                              | Posz 1 =>
                                  match y1 with
                                  | Posz 0 => (1%R, 1%R)
                                  | Posz 1 => (Posz 2, 1%R)
                                  | Posz (_.+2 as elpi_ctx_entry_10_) =>
                                      (Posz elpi_ctx_entry_10_.+1, 1%R)
                                  | Negz _ => ((1 + y1)%R, 1%R)
                                  end
                              | _ => ((1 * y2 + y1)%R, y2)
                              end)
                       end
                   end)%Q
              end + rat_of_Z 1)%Q)%Q)%Q *
           reducebig 0%R (bigopz.index_iotaz 0 (n + 1))
             (fun k : int =>
              BigBody k +%R true
                (match n with
                 | Posz n1 =>
                     match k with
                     | Posz m1 => binomial_rec n1 m1 true true
                     | Negz m1 => binomial_rec n1 m1 true false
                     end
                 | Negz n1 =>
                     match k with
                     | Posz m1 => binomial_rec n1 m1 false true
                     | Negz m1 => binomial_rec n1 m1 false false
                     end
                 end%:~R ^ Posz 2 *
                 match n + k with
                 | Posz n1 =>
                     match k with
                     | Posz m1 => binomial_rec n1 m1 true true
                     | Negz m1 => binomial_rec n1 m1 true false
                     end
                 | Negz n1 =>
                     match k with
                     | Posz m1 => binomial_rec n1 m1 false true
                     | Negz m1 => binomial_rec n1 m1 false false
                     end
                 end%:~R ^ Posz 2 *
                 (reducebig 0 (bigopz.index_iotaz 1 (n + 1))
                    (fun k0 : int => BigBody k0 +%R true (k0%:~R ^ Posz 3)^-1) +
                  reducebig 0 (bigopz.index_iotaz 1 (k + 1))
                    (fun m : int =>
                     BigBody m +%R true
                       ((-1) ^ (m + 1) /
                        ((Posz 2)%:~R * m%:~R ^ Posz 3 *
                         match n with
                         | Posz n1 =>
                             match m with
                             | Posz m1 => binomial_rec n1 m1 true true
                             | Negz m1 => binomial_rec n1 m1 true false
                             end
                         | Negz n1 =>
                             match m with
                             | Posz m1 => binomial_rec n1 m1 false true
                             | Negz m1 => binomial_rec n1 m1 false false
                             end
                         end%:~R *
                         match n + m with
                         | Posz n1 =>
                             match m with
                             | Posz m1 => binomial_rec n1 m1 true true
                             | Negz m1 => binomial_rec n1 m1 true false
                             end
                         | Negz n1 =>
                             match m with
                             | Posz m1 => binomial_rec n1 m1 false true
                             | Negz m1 => binomial_rec n1 m1 false false
                             end
                         end%:~R)))))%R))%Q)%Q; 0%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
nge2 : is_true ((Posz 2 : int) <= (n : int))
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching: (forall n : nat, nat_to_binlist' n = [] -> 0 = n)
Debug:
In environment
n : int
hx : is_true ((Posz 2 : int) <= (n : int))
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
hallGpi : is_true ((Posz 2 : int) <= (n : int))
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching: (forall n : nat, nat_to_binlist' n = [] -> 0 = n)
Crunching:
((sin PI)² = 0 ->
 forall n : nat, (forall m : nat, (m < n)%nat -> snd p 0 = m) -> snd p 0 = n)
Crunching: (snd p 0 = LT)
Crunching: (snd p 0 = LT)
Crunching: (snd p 0 = LT)
Crunching: ((forall m : nat, (m < LT)%nat -> snd p 0 = m) -> snd p 0 = LT)
Crunching: (snd p 0 = LT)
Crunching: (snd p 0 = Heq)
Crunching: (snd p 0 = Heq)
Debug:
In environment
n : int
EQ : is_true ((Posz 2 : int) <= (n : int))
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: (((((match n with
              | Posz elpi_ctx_entry_2_ => iterop elpi_ctx_entry_2_ addq 1 0
              | Negz elpi_ctx_entry_2_ =>
                  (-
                   match elpi_ctx_entry_2_ with
                   | 0 => 1%Q
                   | _.+1 =>
                       match
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 =>
                                match loop i with
                                | {| valq := y |} =>
                                    fracq
                                      (let (y1, y2) := y in
                                       match y2 with
                                       | Posz 1 =>
                                           match y1 with
                                           | Posz 0 => (1%R, 1%R)
                                           | Posz 1 => (Posz 2, 1%R)
                                           | Posz
                                             (_.+2 as elpi_ctx_entry_14_) =>
                                               (Posz elpi_ctx_entry_14_.+1,
                                               1%R)
                                           | Negz _ => ((1 + y1)%R, 1%R)
                                           end
                                       | _ => ((1 * y2 + y1)%R, y2)
                                       end)
                                end
                            end) elpi_ctx_entry_2_
                       with
                       | {| valq := y |} =>
                           fracq
                             (let (y1, y2) := y in
                              match y2 with
                              | Posz 1 =>
                                  match y1 with
                                  | Posz 0 => (1%R, 1%R)
                                  | Posz 1 => (Posz 2, 1%R)
                                  | Posz (_.+2 as elpi_ctx_entry_10_) =>
                                      (Posz elpi_ctx_entry_10_.+1, 1%R)
                                  | Negz _ => ((1 + y1)%R, 1%R)
                                  end
                              | _ => ((1 * y2 + y1)%R, y2)
                              end)
                       end
                   end)%Q
              end + rat_of_Z 2)%Q *
             ((match n with
               | Posz elpi_ctx_entry_2_ => iterop elpi_ctx_entry_2_ addq 1 0
               | Negz elpi_ctx_entry_2_ =>
                   (-
                    match elpi_ctx_entry_2_ with
                    | 0 => 1%Q
                    | _.+1 =>
                        match
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 =>
                                 match loop i with
                                 | {| valq := y |} =>
                                     fracq
                                       (let (y1, y2) := y in
                                        match y2 with
                                        | Posz 1 =>
                                            match y1 with
                                            | Posz 0 => (1%R, 1%R)
                                            | Posz 1 => (Posz 2, 1%R)
                                            | Posz
                                              (_.+2 as elpi_ctx_entry_14_) =>
                                                (Posz elpi_ctx_entry_14_.+1,
                                                1%R)
                                            | Negz _ => ((1 + y1)%R, 1%R)
                                            end
                                        | _ => ((1 * y2 + y1)%R, y2)
                                        end)
                                 end
                             end) elpi_ctx_entry_2_
                        with
                        | {| valq := y |} =>
                            fracq
                              (let (y1, y2) := y in
                               match y2 with
                               | Posz 1 =>
                                   match y1 with
                                   | Posz 0 => (1%R, 1%R)
                                   | Posz 1 => (Posz 2, 1%R)
                                   | Posz (_.+2 as elpi_ctx_entry_10_) =>
                                       (Posz elpi_ctx_entry_10_.+1, 1%R)
                                   | Negz _ => ((1 + y1)%R, 1%R)
                                   end
                               | _ => ((1 * y2 + y1)%R, y2)
                               end)
                        end
                    end)%Q
               end + rat_of_Z 2)%Q *
              (match n with
               | Posz elpi_ctx_entry_2_ => iterop elpi_ctx_entry_2_ addq 1 0
               | Negz elpi_ctx_entry_2_ =>
                   (-
                    match elpi_ctx_entry_2_ with
                    | 0 => 1%Q
                    | _.+1 =>
                        match
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 =>
                                 match loop i with
                                 | {| valq := y |} =>
                                     fracq
                                       (let (y1, y2) := y in
                                        match y2 with
                                        | Posz 1 =>
                                            match y1 with
                                            | Posz 0 => (1%R, 1%R)
                                            | Posz 1 => (Posz 2, 1%R)
                                            | Posz
                                              (_.+2 as elpi_ctx_entry_14_) =>
                                                (Posz elpi_ctx_entry_14_.+1,
                                                1%R)
                                            | Negz _ => ((1 + y1)%R, 1%R)
                                            end
                                        | _ => ((1 * y2 + y1)%R, y2)
                                        end)
                                 end
                             end) elpi_ctx_entry_2_
                        with
                        | {| valq := y |} =>
                            fracq
                              (let (y1, y2) := y in
                               match y2 with
                               | Posz 1 =>
                                   match y1 with
                                   | Posz 0 => (1%R, 1%R)
                                   | Posz 1 => (Posz 2, 1%R)
                                   | Posz (_.+2 as elpi_ctx_entry_10_) =>
                                       (Posz elpi_ctx_entry_10_.+1, 1%R)
                                   | Negz _ => ((1 + y1)%R, 1%R)
                                   end
                               | _ => ((1 * y2 + y1)%R, y2)
                               end)
                        end
                    end)%Q
               end + rat_of_Z 2)%Q)%Q)%Q *
            reducebig 0%R
              (bigopz.index_iotaz 0
                 (intZmod.addz (intZmod.addz n (Posz 1)) (Posz 1) + 1))
              (fun k : int =>
               BigBody k +%R true
                 (match intZmod.addz (intZmod.addz n (Posz 1)) (Posz 1) with
                  | Posz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 true true
                      | Negz m1 => binomial_rec n1 m1 true false
                      end
                  | Negz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 false true
                      | Negz m1 => binomial_rec n1 m1 false false
                      end
                  end%:~R ^ Posz 2 *
                  match
                    intZmod.addz (intZmod.addz n (Posz 1)) (Posz 1) + k
                  with
                  | Posz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 true true
                      | Negz m1 => binomial_rec n1 m1 true false
                      end
                  | Negz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 false true
                      | Negz m1 => binomial_rec n1 m1 false false
                      end
                  end%:~R ^ Posz 2 *
                  (reducebig 0
                     (bigopz.index_iotaz 1
                        (intZmod.addz (intZmod.addz n (Posz 1)) (Posz 1) + 1))
                     (fun k0 : int =>
                      BigBody k0 +%R true (k0%:~R ^ Posz 3)^-1) +
                   reducebig 0 (bigopz.index_iotaz 1 (k + 1))
                     (fun m : int =>
                      BigBody m +%R true
                        ((-1) ^ (m + 1) /
                         ((Posz 2)%:~R * m%:~R ^ Posz 3 *
                          match
                            intZmod.addz (intZmod.addz n (Posz 1)) (Posz 1)
                          with
                          | Posz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 true true
                              | Negz m1 => binomial_rec n1 m1 true false
                              end
                          | Negz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 false true
                              | Negz m1 => binomial_rec n1 m1 false false
                              end
                          end%:~R *
                          match
                            intZmod.addz (intZmod.addz n (Posz 1)) (Posz 1) +
                            m
                          with
                          | Posz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 true true
                              | Negz m1 => binomial_rec n1 m1 true false
                              end
                          | Negz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 false true
                              | Negz m1 => binomial_rec n1 m1 false false
                              end
                          end%:~R)))))%R))%Q +
           ((((- rat_of_Z 1)%Q *
              (((rat_of_Z 17 *
                 (match n with
                  | Posz elpi_ctx_entry_2_ =>
                      iterop elpi_ctx_entry_2_ addq 1 0
                  | Negz elpi_ctx_entry_2_ =>
                      (-
                       match elpi_ctx_entry_2_ with
                       | 0 => 1%Q
                       | _.+1 =>
                           match
                             (fix loop (m : nat) : rat :=
                                match m with
                                | 0 => 0
                                | 1 => 1
                                | (_.+1 as i).+1 =>
                                    match loop i with
                                    | {| valq := y |} =>
                                        fracq
                                          (let (y1, y2) := y in
                                           match y2 with
                                           | Posz 1 =>
                                               match y1 with
                                               | Posz 0 => (1%R, 1%R)
                                               | Posz 1 => (Posz 2, 1%R)
                                               | Posz ... =>
                                                 (
                                                 Posz elpi_ctx_entry_14_.+1,
                                                 1%R)
                                               | Negz _ => ((...)%R, 1%R)
                                               end
                                           | _ => ((1 * y2 + y1)%R, y2)
                                           end)
                                    end
                                end) elpi_ctx_entry_2_
                           with
                           | {| valq := y |} =>
                               fracq
                                 (let (y1, y2) := y in
                                  match y2 with
                                  | Posz 1 =>
                                      match y1 with
                                      | Posz 0 => (1%R, 1%R)
                                      | Posz 1 => (Posz 2, 1%R)
                                      | Posz (_.+2 as elpi_ctx_entry_10_) =>
                                          (Posz elpi_ctx_entry_10_.+1, 1%R)
                                      | Negz _ => ((1 + y1)%R, 1%R)
                                      end
                                  | _ => ((1 * y2 + y1)%R, y2)
                                  end)
                           end
                       end)%Q
                  end *
                  match n with
                  | Posz elpi_ctx_entry_2_ =>
                      iterop elpi_ctx_entry_2_ addq 1 0
                  | Negz elpi_ctx_entry_2_ =>
                      (-
                       match elpi_ctx_entry_2_ with
                       | 0 => 1%Q
                       | _.+1 =>
                           match
                             (fix loop (m : nat) : rat :=
                                match m with
                                | 0 => 0
                                | 1 => 1
                                | (_.+1 as i).+1 =>
                                    match loop i with
                                    | {| valq := y |} =>
                                        fracq
                                          (let (y1, y2) := y in
                                           match y2 with
                                           | Posz 1 =>
                                               match y1 with
                                               | Posz 0 => (1%R, 1%R)
                                               | Posz 1 => (Posz 2, 1%R)
                                               | Posz ... =>
                                                 (
                                                 Posz elpi_ctx_entry_14_.+1,
                                                 1%R)
                                               | Negz _ => ((...)%R, 1%R)
                                               end
                                           | _ => ((1 * y2 + y1)%R, y2)
                                           end)
                                    end
                                end) elpi_ctx_entry_2_
                           with
                           | {| valq := y |} =>
                               fracq
                                 (let (y1, y2) := y in
                                  match y2 with
                                  | Posz 1 =>
                                      match y1 with
                                      | Posz 0 => (1%R, 1%R)
                                      | Posz 1 => (Posz 2, 1%R)
                                      | Posz (_.+2 as elpi_ctx_entry_10_) =>
                                          (Posz elpi_ctx_entry_10_.+1, 1%R)
                                      | Negz _ => ((1 + y1)%R, 1%R)
                                      end
                                  | _ => ((1 * y2 + y1)%R, y2)
                                  end)
                           end
                       end)%Q
                  end)%Q)%Q +
                (rat_of_Z 51 *
                 match n with
                 | Posz elpi_ctx_entry_2_ =>
                     iterop elpi_ctx_entry_2_ addq 1 0
                 | Negz elpi_ctx_entry_2_ =>
                     (-
                      match elpi_ctx_entry_2_ with
                      | 0 => 1%Q
                      | _.+1 =>
                          match
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as i).+1 =>
                                   match loop i with
                                   | {| valq := y |} =>
                                       fracq
                                         (let (y1, y2) := y in
                                          match y2 with
                                          | Posz 1 =>
                                              match y1 with
                                              | Posz 0 => (1%R, 1%R)
                                              | Posz 1 => (Posz 2, 1%R)
                                              | Posz
                                                (_.+2 as elpi_ctx_entry_14_) =>
                                                 (
                                                 Posz elpi_ctx_entry_14_.+1,
                                                 1%R)
                                              | Negz _ => ((1 + y1)%R, 1%R)
                                              end
                                          | _ => ((1 * y2 + y1)%R, y2)
                                          end)
                                   end
                               end) elpi_ctx_entry_2_
                          with
                          | {| valq := y |} =>
                              fracq
                                (let (y1, y2) := y in
                                 match y2 with
                                 | Posz 1 =>
                                     match y1 with
                                     | Posz 0 => (1%R, 1%R)
                                     | Posz 1 => (Posz 2, 1%R)
                                     | Posz (_.+2 as elpi_ctx_entry_10_) =>
                                         (Posz elpi_ctx_entry_10_.+1, 1%R)
                                     | Negz _ => ((1 + y1)%R, 1%R)
                                     end
                                 | _ => ((1 * y2 + y1)%R, y2)
                                 end)
                          end
                      end)%Q
                 end)%Q)%Q + rat_of_Z 39)%Q)%Q *
             ((rat_of_Z 2 *
               match n with
               | Posz elpi_ctx_entry_2_ => iterop elpi_ctx_entry_2_ addq 1 0
               | Negz elpi_ctx_entry_2_ =>
                   (-
                    match elpi_ctx_entry_2_ with
                    | 0 => 1%Q
                    | _.+1 =>
                        match
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 =>
                                 match loop i with
                                 | {| valq := y |} =>
                                     fracq
                                       (let (y1, y2) := y in
                                        match y2 with
                                        | Posz 1 =>
                                            match y1 with
                                            | Posz 0 => (1%R, 1%R)
                                            | Posz 1 => (Posz 2, 1%R)
                                            | Posz
                                              (_.+2 as elpi_ctx_entry_14_) =>
                                                (Posz elpi_ctx_entry_14_.+1,
                                                1%R)
                                            | Negz _ => ((1 + y1)%R, 1%R)
                                            end
                                        | _ => ((1 * y2 + y1)%R, y2)
                                        end)
                                 end
                             end) elpi_ctx_entry_2_
                        with
                        | {| valq := y |} =>
                            fracq
                              (let (y1, y2) := y in
                               match y2 with
                               | Posz 1 =>
                                   match y1 with
                                   | Posz 0 => (1%R, 1%R)
                                   | Posz 1 => (Posz 2, 1%R)
                                   | Posz (_.+2 as elpi_ctx_entry_10_) =>
                                       (Posz elpi_ctx_entry_10_.+1, 1%R)
                                   | Negz _ => ((1 + y1)%R, 1%R)
                                   end
                               | _ => ((1 * y2 + y1)%R, y2)
                               end)
                        end
                    end)%Q
               end)%Q + rat_of_Z 3)%Q)%Q *
            reducebig 0%R
              (bigopz.index_iotaz 0 (intZmod.addz n (Posz 1) + 1))
              (fun k : int =>
               BigBody k +%R true
                 (match intZmod.addz n (Posz 1) with
                  | Posz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 true true
                      | Negz m1 => binomial_rec n1 m1 true false
                      end
                  | Negz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 false true
                      | Negz m1 => binomial_rec n1 m1 false false
                      end
                  end%:~R ^ Posz 2 *
                  match intZmod.addz n (Posz 1) + k with
                  | Posz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 true true
                      | Negz m1 => binomial_rec n1 m1 true false
                      end
                  | Negz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 false true
                      | Negz m1 => binomial_rec n1 m1 false false
                      end
                  end%:~R ^ Posz 2 *
                  (reducebig 0
                     (bigopz.index_iotaz 1 (intZmod.addz n (Posz 1) + 1))
                     (fun k0 : int =>
                      BigBody k0 +%R true (k0%:~R ^ Posz 3)^-1) +
                   reducebig 0 (bigopz.index_iotaz 1 (k + 1))
                     (fun m : int =>
                      BigBody m +%R true
                        ((-1) ^ (m + 1) /
                         ((Posz 2)%:~R * m%:~R ^ Posz 3 *
                          match intZmod.addz n (Posz 1) with
                          | Posz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 true true
                              | Negz m1 => binomial_rec n1 m1 true false
                              end
                          | Negz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 false true
                              | Negz m1 => binomial_rec n1 m1 false false
                              end
                          end%:~R *
                          match intZmod.addz n (Posz 1) + m with
                          | Posz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 true true
                              | Negz m1 => binomial_rec n1 m1 true false
                              end
                          | Negz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 false true
                              | Negz m1 => binomial_rec n1 m1 false false
                              end
                          end%:~R)))))%R))%Q)%Q +
          (((match n with
             | Posz elpi_ctx_entry_2_ => iterop elpi_ctx_entry_2_ addq 1 0
             | Negz elpi_ctx_entry_2_ =>
                 (-
                  match elpi_ctx_entry_2_ with
                  | 0 => 1%Q
                  | _.+1 =>
                      match
                        (fix loop (m : nat) : rat :=
                           match m with
                           | 0 => 0
                           | 1 => 1
                           | (_.+1 as i).+1 =>
                               match loop i with
                               | {| valq := y |} =>
                                   fracq
                                     (let (y1, y2) := y in
                                      match y2 with
                                      | Posz 1 =>
                                          match y1 with
                                          | Posz 0 => (1%R, 1%R)
                                          | Posz 1 => (Posz 2, 1%R)
                                          | Posz (_.+2 as elpi_ctx_entry_14_) =>
                                              (Posz elpi_ctx_entry_14_.+1,
                                              1%R)
                                          | Negz _ => ((1 + y1)%R, 1%R)
                                          end
                                      | _ => ((1 * y2 + y1)%R, y2)
                                      end)
                               end
                           end) elpi_ctx_entry_2_
                      with
                      | {| valq := y |} =>
                          fracq
                            (let (y1, y2) := y in
                             match y2 with
                             | Posz 1 =>
                                 match y1 with
                                 | Posz 0 => (1%R, 1%R)
                                 | Posz 1 => (Posz 2, 1%R)
                                 | Posz (_.+2 as elpi_ctx_entry_10_) =>
                                     (Posz elpi_ctx_entry_10_.+1, 1%R)
                                 | Negz _ => ((1 + y1)%R, 1%R)
                                 end
                             | _ => ((1 * y2 + y1)%R, y2)
                             end)
                      end
                  end)%Q
             end + rat_of_Z 1)%Q *
            ((match n with
              | Posz elpi_ctx_entry_2_ => iterop elpi_ctx_entry_2_ addq 1 0
              | Negz elpi_ctx_entry_2_ =>
                  (-
                   match elpi_ctx_entry_2_ with
                   | 0 => 1%Q
                   | _.+1 =>
                       match
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 =>
                                match loop i with
                                | {| valq := y |} =>
                                    fracq
                                      (let (y1, y2) := y in
                                       match y2 with
                                       | Posz 1 =>
                                           match y1 with
                                           | Posz 0 => (1%R, 1%R)
                                           | Posz 1 => (Posz 2, 1%R)
                                           | Posz
                                             (_.+2 as elpi_ctx_entry_14_) =>
                                               (Posz elpi_ctx_entry_14_.+1,
                                               1%R)
                                           | Negz _ => ((1 + y1)%R, 1%R)
                                           end
                                       | _ => ((1 * y2 + y1)%R, y2)
                                       end)
                                end
                            end) elpi_ctx_entry_2_
                       with
                       | {| valq := y |} =>
                           fracq
                             (let (y1, y2) := y in
                              match y2 with
                              | Posz 1 =>
                                  match y1 with
                                  | Posz 0 => (1%R, 1%R)
                                  | Posz 1 => (Posz 2, 1%R)
                                  | Posz (_.+2 as elpi_ctx_entry_10_) =>
                                      (Posz elpi_ctx_entry_10_.+1, 1%R)
                                  | Negz _ => ((1 + y1)%R, 1%R)
                                  end
                              | _ => ((1 * y2 + y1)%R, y2)
                              end)
                       end
                   end)%Q
              end + rat_of_Z 1)%Q *
             (match n with
              | Posz elpi_ctx_entry_2_ => iterop elpi_ctx_entry_2_ addq 1 0
              | Negz elpi_ctx_entry_2_ =>
                  (-
                   match elpi_ctx_entry_2_ with
                   | 0 => 1%Q
                   | _.+1 =>
                       match
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 =>
                                match loop i with
                                | {| valq := y |} =>
                                    fracq
                                      (let (y1, y2) := y in
                                       match y2 with
                                       | Posz 1 =>
                                           match y1 with
                                           | Posz 0 => (1%R, 1%R)
                                           | Posz 1 => (Posz 2, 1%R)
                                           | Posz
                                             (_.+2 as elpi_ctx_entry_14_) =>
                                               (Posz elpi_ctx_entry_14_.+1,
                                               1%R)
                                           | Negz _ => ((1 + y1)%R, 1%R)
                                           end
                                       | _ => ((1 * y2 + y1)%R, y2)
                                       end)
                                end
                            end) elpi_ctx_entry_2_
                       with
                       | {| valq := y |} =>
                           fracq
                             (let (y1, y2) := y in
                              match y2 with
                              | Posz 1 =>
                                  match y1 with
                                  | Posz 0 => (1%R, 1%R)
                                  | Posz 1 => (Posz 2, 1%R)
                                  | Posz (_.+2 as elpi_ctx_entry_10_) =>
                                      (Posz elpi_ctx_entry_10_.+1, 1%R)
                                  | Negz _ => ((1 + y1)%R, 1%R)
                                  end
                              | _ => ((1 * y2 + y1)%R, y2)
                              end)
                       end
                   end)%Q
              end + rat_of_Z 1)%Q)%Q)%Q *
           reducebig 0%R (bigopz.index_iotaz 0 (n + 1))
             (fun k : int =>
              BigBody k +%R true
                (match n with
                 | Posz n1 =>
                     match k with
                     | Posz m1 => binomial_rec n1 m1 true true
                     | Negz m1 => binomial_rec n1 m1 true false
                     end
                 | Negz n1 =>
                     match k with
                     | Posz m1 => binomial_rec n1 m1 false true
                     | Negz m1 => binomial_rec n1 m1 false false
                     end
                 end%:~R ^ Posz 2 *
                 match n + k with
                 | Posz n1 =>
                     match k with
                     | Posz m1 => binomial_rec n1 m1 true true
                     | Negz m1 => binomial_rec n1 m1 true false
                     end
                 | Negz n1 =>
                     match k with
                     | Posz m1 => binomial_rec n1 m1 false true
                     | Negz m1 => binomial_rec n1 m1 false false
                     end
                 end%:~R ^ Posz 2 *
                 (reducebig 0 (bigopz.index_iotaz 1 (n + 1))
                    (fun k0 : int => BigBody k0 +%R true (k0%:~R ^ Posz 3)^-1) +
                  reducebig 0 (bigopz.index_iotaz 1 (k + 1))
                    (fun m : int =>
                     BigBody m +%R true
                       ((-1) ^ (m + 1) /
                        ((Posz 2)%:~R * m%:~R ^ Posz 3 *
                         match n with
                         | Posz n1 =>
                             match m with
                             | Posz m1 => binomial_rec n1 m1 true true
                             | Negz m1 => binomial_rec n1 m1 true false
                             end
                         | Negz n1 =>
                             match m with
                             | Posz m1 => binomial_rec n1 m1 false true
                             | Negz m1 => binomial_rec n1 m1 false false
                             end
                         end%:~R *
                         match n + m with
                         | Posz n1 =>
                             match m with
                             | Posz m1 => binomial_rec n1 m1 true true
                             | Negz m1 => binomial_rec n1 m1 true false
                             end
                         | Negz n1 =>
                             match m with
                             | Posz m1 => binomial_rec n1 m1 false true
                             | Negz m1 => binomial_rec n1 m1 false false
                             end
                         end%:~R)))))%R))%Q)%Q; 0%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
EQ : is_true ((Posz 2 : int) <= (n : int))
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
z_ne_0 : is_true ((Posz 2 : int) <= (n : int))
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: (((((match n with
              | Posz elpi_ctx_entry_2_ => iterop elpi_ctx_entry_2_ addq 1 0
              | Negz elpi_ctx_entry_2_ =>
                  (-
                   match elpi_ctx_entry_2_ with
                   | 0 => 1%Q
                   | _.+1 =>
                       match
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 =>
                                match loop i with
                                | {| valq := y |} =>
                                    fracq
                                      (let (y1, y2) := y in
                                       match y2 with
                                       | Posz 1 =>
                                           match y1 with
                                           | Posz 0 => (1%R, 1%R)
                                           | Posz 1 => (Posz 2, 1%R)
                                           | Posz
                                             (_.+2 as elpi_ctx_entry_14_) =>
                                               (Posz elpi_ctx_entry_14_.+1,
                                               1%R)
                                           | Negz _ => ((1 + y1)%R, 1%R)
                                           end
                                       | _ => ((1 * y2 + y1)%R, y2)
                                       end)
                                end
                            end) elpi_ctx_entry_2_
                       with
                       | {| valq := y |} =>
                           fracq
                             (let (y1, y2) := y in
                              match y2 with
                              | Posz 1 =>
                                  match y1 with
                                  | Posz 0 => (1%R, 1%R)
                                  | Posz 1 => (Posz 2, 1%R)
                                  | Posz (_.+2 as elpi_ctx_entry_10_) =>
                                      (Posz elpi_ctx_entry_10_.+1, 1%R)
                                  | Negz _ => ((1 + y1)%R, 1%R)
                                  end
                              | _ => ((1 * y2 + y1)%R, y2)
                              end)
                       end
                   end)%Q
              end + rat_of_Z 2)%Q *
             ((match n with
               | Posz elpi_ctx_entry_2_ => iterop elpi_ctx_entry_2_ addq 1 0
               | Negz elpi_ctx_entry_2_ =>
                   (-
                    match elpi_ctx_entry_2_ with
                    | 0 => 1%Q
                    | _.+1 =>
                        match
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 =>
                                 match loop i with
                                 | {| valq := y |} =>
                                     fracq
                                       (let (y1, y2) := y in
                                        match y2 with
                                        | Posz 1 =>
                                            match y1 with
                                            | Posz 0 => (1%R, 1%R)
                                            | Posz 1 => (Posz 2, 1%R)
                                            | Posz
                                              (_.+2 as elpi_ctx_entry_14_) =>
                                                (Posz elpi_ctx_entry_14_.+1,
                                                1%R)
                                            | Negz _ => ((1 + y1)%R, 1%R)
                                            end
                                        | _ => ((1 * y2 + y1)%R, y2)
                                        end)
                                 end
                             end) elpi_ctx_entry_2_
                        with
                        | {| valq := y |} =>
                            fracq
                              (let (y1, y2) := y in
                               match y2 with
                               | Posz 1 =>
                                   match y1 with
                                   | Posz 0 => (1%R, 1%R)
                                   | Posz 1 => (Posz 2, 1%R)
                                   | Posz (_.+2 as elpi_ctx_entry_10_) =>
                                       (Posz elpi_ctx_entry_10_.+1, 1%R)
                                   | Negz _ => ((1 + y1)%R, 1%R)
                                   end
                               | _ => ((1 * y2 + y1)%R, y2)
                               end)
                        end
                    end)%Q
               end + rat_of_Z 2)%Q *
              (match n with
               | Posz elpi_ctx_entry_2_ => iterop elpi_ctx_entry_2_ addq 1 0
               | Negz elpi_ctx_entry_2_ =>
                   (-
                    match elpi_ctx_entry_2_ with
                    | 0 => 1%Q
                    | _.+1 =>
                        match
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 =>
                                 match loop i with
                                 | {| valq := y |} =>
                                     fracq
                                       (let (y1, y2) := y in
                                        match y2 with
                                        | Posz 1 =>
                                            match y1 with
                                            | Posz 0 => (1%R, 1%R)
                                            | Posz 1 => (Posz 2, 1%R)
                                            | Posz
                                              (_.+2 as elpi_ctx_entry_14_) =>
                                                (Posz elpi_ctx_entry_14_.+1,
                                                1%R)
                                            | Negz _ => ((1 + y1)%R, 1%R)
                                            end
                                        | _ => ((1 * y2 + y1)%R, y2)
                                        end)
                                 end
                             end) elpi_ctx_entry_2_
                        with
                        | {| valq := y |} =>
                            fracq
                              (let (y1, y2) := y in
                               match y2 with
                               | Posz 1 =>
                                   match y1 with
                                   | Posz 0 => (1%R, 1%R)
                                   | Posz 1 => (Posz 2, 1%R)
                                   | Posz (_.+2 as elpi_ctx_entry_10_) =>
                                       (Posz elpi_ctx_entry_10_.+1, 1%R)
                                   | Negz _ => ((1 + y1)%R, 1%R)
                                   end
                               | _ => ((1 * y2 + y1)%R, y2)
                               end)
                        end
                    end)%Q
               end + rat_of_Z 2)%Q)%Q)%Q *
            reducebig 0%R
              (bigopz.index_iotaz 0
                 (intZmod.addz (intZmod.addz n (Posz 1)) (Posz 1) + 1))
              (fun k : int =>
               BigBody k +%R true
                 (match intZmod.addz (intZmod.addz n (Posz 1)) (Posz 1) with
                  | Posz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 true true
                      | Negz m1 => binomial_rec n1 m1 true false
                      end
                  | Negz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 false true
                      | Negz m1 => binomial_rec n1 m1 false false
                      end
                  end%:~R ^ Posz 2 *
                  match
                    intZmod.addz (intZmod.addz n (Posz 1)) (Posz 1) + k
                  with
                  | Posz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 true true
                      | Negz m1 => binomial_rec n1 m1 true false
                      end
                  | Negz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 false true
                      | Negz m1 => binomial_rec n1 m1 false false
                      end
                  end%:~R ^ Posz 2 *
                  (reducebig 0
                     (bigopz.index_iotaz 1
                        (intZmod.addz (intZmod.addz n (Posz 1)) (Posz 1) + 1))
                     (fun k0 : int =>
                      BigBody k0 +%R true (k0%:~R ^ Posz 3)^-1) +
                   reducebig 0 (bigopz.index_iotaz 1 (k + 1))
                     (fun m : int =>
                      BigBody m +%R true
                        ((-1) ^ (m + 1) /
                         ((Posz 2)%:~R * m%:~R ^ Posz 3 *
                          match
                            intZmod.addz (intZmod.addz n (Posz 1)) (Posz 1)
                          with
                          | Posz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 true true
                              | Negz m1 => binomial_rec n1 m1 true false
                              end
                          | Negz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 false true
                              | Negz m1 => binomial_rec n1 m1 false false
                              end
                          end%:~R *
                          match
                            intZmod.addz (intZmod.addz n (Posz 1)) (Posz 1) +
                            m
                          with
                          | Posz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 true true
                              | Negz m1 => binomial_rec n1 m1 true false
                              end
                          | Negz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 false true
                              | Negz m1 => binomial_rec n1 m1 false false
                              end
                          end%:~R)))))%R))%Q +
           ((((- rat_of_Z 1)%Q *
              (((rat_of_Z 17 *
                 (match n with
                  | Posz elpi_ctx_entry_2_ =>
                      iterop elpi_ctx_entry_2_ addq 1 0
                  | Negz elpi_ctx_entry_2_ =>
                      (-
                       match elpi_ctx_entry_2_ with
                       | 0 => 1%Q
                       | _.+1 =>
                           match
                             (fix loop (m : nat) : rat :=
                                match m with
                                | 0 => 0
                                | 1 => 1
                                | (_.+1 as i).+1 =>
                                    match loop i with
                                    | {| valq := y |} =>
                                        fracq
                                          (let (y1, y2) := y in
                                           match y2 with
                                           | Posz 1 =>
                                               match y1 with
                                               | Posz 0 => (1%R, 1%R)
                                               | Posz 1 => (Posz 2, 1%R)
                                               | Posz ... =>
                                                 (
                                                 Posz elpi_ctx_entry_14_.+1,
                                                 1%R)
                                               | Negz _ => ((...)%R, 1%R)
                                               end
                                           | _ => ((1 * y2 + y1)%R, y2)
                                           end)
                                    end
                                end) elpi_ctx_entry_2_
                           with
                           | {| valq := y |} =>
                               fracq
                                 (let (y1, y2) := y in
                                  match y2 with
                                  | Posz 1 =>
                                      match y1 with
                                      | Posz 0 => (1%R, 1%R)
                                      | Posz 1 => (Posz 2, 1%R)
                                      | Posz (_.+2 as elpi_ctx_entry_10_) =>
                                          (Posz elpi_ctx_entry_10_.+1, 1%R)
                                      | Negz _ => ((1 + y1)%R, 1%R)
                                      end
                                  | _ => ((1 * y2 + y1)%R, y2)
                                  end)
                           end
                       end)%Q
                  end *
                  match n with
                  | Posz elpi_ctx_entry_2_ =>
                      iterop elpi_ctx_entry_2_ addq 1 0
                  | Negz elpi_ctx_entry_2_ =>
                      (-
                       match elpi_ctx_entry_2_ with
                       | 0 => 1%Q
                       | _.+1 =>
                           match
                             (fix loop (m : nat) : rat :=
                                match m with
                                | 0 => 0
                                | 1 => 1
                                | (_.+1 as i).+1 =>
                                    match loop i with
                                    | {| valq := y |} =>
                                        fracq
                                          (let (y1, y2) := y in
                                           match y2 with
                                           | Posz 1 =>
                                               match y1 with
                                               | Posz 0 => (1%R, 1%R)
                                               | Posz 1 => (Posz 2, 1%R)
                                               | Posz ... =>
                                                 (
                                                 Posz elpi_ctx_entry_14_.+1,
                                                 1%R)
                                               | Negz _ => ((...)%R, 1%R)
                                               end
                                           | _ => ((1 * y2 + y1)%R, y2)
                                           end)
                                    end
                                end) elpi_ctx_entry_2_
                           with
                           | {| valq := y |} =>
                               fracq
                                 (let (y1, y2) := y in
                                  match y2 with
                                  | Posz 1 =>
                                      match y1 with
                                      | Posz 0 => (1%R, 1%R)
                                      | Posz 1 => (Posz 2, 1%R)
                                      | Posz (_.+2 as elpi_ctx_entry_10_) =>
                                          (Posz elpi_ctx_entry_10_.+1, 1%R)
                                      | Negz _ => ((1 + y1)%R, 1%R)
                                      end
                                  | _ => ((1 * y2 + y1)%R, y2)
                                  end)
                           end
                       end)%Q
                  end)%Q)%Q +
                (rat_of_Z 51 *
                 match n with
                 | Posz elpi_ctx_entry_2_ =>
                     iterop elpi_ctx_entry_2_ addq 1 0
                 | Negz elpi_ctx_entry_2_ =>
                     (-
                      match elpi_ctx_entry_2_ with
                      | 0 => 1%Q
                      | _.+1 =>
                          match
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as i).+1 =>
                                   match loop i with
                                   | {| valq := y |} =>
                                       fracq
                                         (let (y1, y2) := y in
                                          match y2 with
                                          | Posz 1 =>
                                              match y1 with
                                              | Posz 0 => (1%R, 1%R)
                                              | Posz 1 => (Posz 2, 1%R)
                                              | Posz
                                                (_.+2 as elpi_ctx_entry_14_) =>
                                                 (
                                                 Posz elpi_ctx_entry_14_.+1,
                                                 1%R)
                                              | Negz _ => ((1 + y1)%R, 1%R)
                                              end
                                          | _ => ((1 * y2 + y1)%R, y2)
                                          end)
                                   end
                               end) elpi_ctx_entry_2_
                          with
                          | {| valq := y |} =>
                              fracq
                                (let (y1, y2) := y in
                                 match y2 with
                                 | Posz 1 =>
                                     match y1 with
                                     | Posz 0 => (1%R, 1%R)
                                     | Posz 1 => (Posz 2, 1%R)
                                     | Posz (_.+2 as elpi_ctx_entry_10_) =>
                                         (Posz elpi_ctx_entry_10_.+1, 1%R)
                                     | Negz _ => ((1 + y1)%R, 1%R)
                                     end
                                 | _ => ((1 * y2 + y1)%R, y2)
                                 end)
                          end
                      end)%Q
                 end)%Q)%Q + rat_of_Z 39)%Q)%Q *
             ((rat_of_Z 2 *
               match n with
               | Posz elpi_ctx_entry_2_ => iterop elpi_ctx_entry_2_ addq 1 0
               | Negz elpi_ctx_entry_2_ =>
                   (-
                    match elpi_ctx_entry_2_ with
                    | 0 => 1%Q
                    | _.+1 =>
                        match
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 =>
                                 match loop i with
                                 | {| valq := y |} =>
                                     fracq
                                       (let (y1, y2) := y in
                                        match y2 with
                                        | Posz 1 =>
                                            match y1 with
                                            | Posz 0 => (1%R, 1%R)
                                            | Posz 1 => (Posz 2, 1%R)
                                            | Posz
                                              (_.+2 as elpi_ctx_entry_14_) =>
                                                (Posz elpi_ctx_entry_14_.+1,
                                                1%R)
                                            | Negz _ => ((1 + y1)%R, 1%R)
                                            end
                                        | _ => ((1 * y2 + y1)%R, y2)
                                        end)
                                 end
                             end) elpi_ctx_entry_2_
                        with
                        | {| valq := y |} =>
                            fracq
                              (let (y1, y2) := y in
                               match y2 with
                               | Posz 1 =>
                                   match y1 with
                                   | Posz 0 => (1%R, 1%R)
                                   | Posz 1 => (Posz 2, 1%R)
                                   | Posz (_.+2 as elpi_ctx_entry_10_) =>
                                       (Posz elpi_ctx_entry_10_.+1, 1%R)
                                   | Negz _ => ((1 + y1)%R, 1%R)
                                   end
                               | _ => ((1 * y2 + y1)%R, y2)
                               end)
                        end
                    end)%Q
               end)%Q + rat_of_Z 3)%Q)%Q *
            reducebig 0%R
              (bigopz.index_iotaz 0 (intZmod.addz n (Posz 1) + 1))
              (fun k : int =>
               BigBody k +%R true
                 (match intZmod.addz n (Posz 1) with
                  | Posz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 true true
                      | Negz m1 => binomial_rec n1 m1 true false
                      end
                  | Negz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 false true
                      | Negz m1 => binomial_rec n1 m1 false false
                      end
                  end%:~R ^ Posz 2 *
                  match intZmod.addz n (Posz 1) + k with
                  | Posz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 true true
                      | Negz m1 => binomial_rec n1 m1 true false
                      end
                  | Negz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 false true
                      | Negz m1 => binomial_rec n1 m1 false false
                      end
                  end%:~R ^ Posz 2 *
                  (reducebig 0
                     (bigopz.index_iotaz 1 (intZmod.addz n (Posz 1) + 1))
                     (fun k0 : int =>
                      BigBody k0 +%R true (k0%:~R ^ Posz 3)^-1) +
                   reducebig 0 (bigopz.index_iotaz 1 (k + 1))
                     (fun m : int =>
                      BigBody m +%R true
                        ((-1) ^ (m + 1) /
                         ((Posz 2)%:~R * m%:~R ^ Posz 3 *
                          match intZmod.addz n (Posz 1) with
                          | Posz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 true true
                              | Negz m1 => binomial_rec n1 m1 true false
                              end
                          | Negz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 false true
                              | Negz m1 => binomial_rec n1 m1 false false
                              end
                          end%:~R *
                          match intZmod.addz n (Posz 1) + m with
                          | Posz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 true true
                              | Negz m1 => binomial_rec n1 m1 true false
                              end
                          | Negz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 false true
                              | Negz m1 => binomial_rec n1 m1 false false
                              end
                          end%:~R)))))%R))%Q)%Q +
          (((match n with
             | Posz elpi_ctx_entry_2_ => iterop elpi_ctx_entry_2_ addq 1 0
             | Negz elpi_ctx_entry_2_ =>
                 (-
                  match elpi_ctx_entry_2_ with
                  | 0 => 1%Q
                  | _.+1 =>
                      match
                        (fix loop (m : nat) : rat :=
                           match m with
                           | 0 => 0
                           | 1 => 1
                           | (_.+1 as i).+1 =>
                               match loop i with
                               | {| valq := y |} =>
                                   fracq
                                     (let (y1, y2) := y in
                                      match y2 with
                                      | Posz 1 =>
                                          match y1 with
                                          | Posz 0 => (1%R, 1%R)
                                          | Posz 1 => (Posz 2, 1%R)
                                          | Posz (_.+2 as elpi_ctx_entry_14_) =>
                                              (Posz elpi_ctx_entry_14_.+1,
                                              1%R)
                                          | Negz _ => ((1 + y1)%R, 1%R)
                                          end
                                      | _ => ((1 * y2 + y1)%R, y2)
                                      end)
                               end
                           end) elpi_ctx_entry_2_
                      with
                      | {| valq := y |} =>
                          fracq
                            (let (y1, y2) := y in
                             match y2 with
                             | Posz 1 =>
                                 match y1 with
                                 | Posz 0 => (1%R, 1%R)
                                 | Posz 1 => (Posz 2, 1%R)
                                 | Posz (_.+2 as elpi_ctx_entry_10_) =>
                                     (Posz elpi_ctx_entry_10_.+1, 1%R)
                                 | Negz _ => ((1 + y1)%R, 1%R)
                                 end
                             | _ => ((1 * y2 + y1)%R, y2)
                             end)
                      end
                  end)%Q
             end + rat_of_Z 1)%Q *
            ((match n with
              | Posz elpi_ctx_entry_2_ => iterop elpi_ctx_entry_2_ addq 1 0
              | Negz elpi_ctx_entry_2_ =>
                  (-
                   match elpi_ctx_entry_2_ with
                   | 0 => 1%Q
                   | _.+1 =>
                       match
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 =>
                                match loop i with
                                | {| valq := y |} =>
                                    fracq
                                      (let (y1, y2) := y in
                                       match y2 with
                                       | Posz 1 =>
                                           match y1 with
                                           | Posz 0 => (1%R, 1%R)
                                           | Posz 1 => (Posz 2, 1%R)
                                           | Posz
                                             (_.+2 as elpi_ctx_entry_14_) =>
                                               (Posz elpi_ctx_entry_14_.+1,
                                               1%R)
                                           | Negz _ => ((1 + y1)%R, 1%R)
                                           end
                                       | _ => ((1 * y2 + y1)%R, y2)
                                       end)
                                end
                            end) elpi_ctx_entry_2_
                       with
                       | {| valq := y |} =>
                           fracq
                             (let (y1, y2) := y in
                              match y2 with
                              | Posz 1 =>
                                  match y1 with
                                  | Posz 0 => (1%R, 1%R)
                                  | Posz 1 => (Posz 2, 1%R)
                                  | Posz (_.+2 as elpi_ctx_entry_10_) =>
                                      (Posz elpi_ctx_entry_10_.+1, 1%R)
                                  | Negz _ => ((1 + y1)%R, 1%R)
                                  end
                              | _ => ((1 * y2 + y1)%R, y2)
                              end)
                       end
                   end)%Q
              end + rat_of_Z 1)%Q *
             (match n with
              | Posz elpi_ctx_entry_2_ => iterop elpi_ctx_entry_2_ addq 1 0
              | Negz elpi_ctx_entry_2_ =>
                  (-
                   match elpi_ctx_entry_2_ with
                   | 0 => 1%Q
                   | _.+1 =>
                       match
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 =>
                                match loop i with
                                | {| valq := y |} =>
                                    fracq
                                      (let (y1, y2) := y in
                                       match y2 with
                                       | Posz 1 =>
                                           match y1 with
                                           | Posz 0 => (1%R, 1%R)
                                           | Posz 1 => (Posz 2, 1%R)
                                           | Posz
                                             (_.+2 as elpi_ctx_entry_14_) =>
                                               (Posz elpi_ctx_entry_14_.+1,
                                               1%R)
                                           | Negz _ => ((1 + y1)%R, 1%R)
                                           end
                                       | _ => ((1 * y2 + y1)%R, y2)
                                       end)
                                end
                            end) elpi_ctx_entry_2_
                       with
                       | {| valq := y |} =>
                           fracq
                             (let (y1, y2) := y in
                              match y2 with
                              | Posz 1 =>
                                  match y1 with
                                  | Posz 0 => (1%R, 1%R)
                                  | Posz 1 => (Posz 2, 1%R)
                                  | Posz (_.+2 as elpi_ctx_entry_10_) =>
                                      (Posz elpi_ctx_entry_10_.+1, 1%R)
                                  | Negz _ => ((1 + y1)%R, 1%R)
                                  end
                              | _ => ((1 * y2 + y1)%R, y2)
                              end)
                       end
                   end)%Q
              end + rat_of_Z 1)%Q)%Q)%Q *
           reducebig 0%R (bigopz.index_iotaz 0 (n + 1))
             (fun k : int =>
              BigBody k +%R true
                (match n with
                 | Posz n1 =>
                     match k with
                     | Posz m1 => binomial_rec n1 m1 true true
                     | Negz m1 => binomial_rec n1 m1 true false
                     end
                 | Negz n1 =>
                     match k with
                     | Posz m1 => binomial_rec n1 m1 false true
                     | Negz m1 => binomial_rec n1 m1 false false
                     end
                 end%:~R ^ Posz 2 *
                 match n + k with
                 | Posz n1 =>
                     match k with
                     | Posz m1 => binomial_rec n1 m1 true true
                     | Negz m1 => binomial_rec n1 m1 true false
                     end
                 | Negz n1 =>
                     match k with
                     | Posz m1 => binomial_rec n1 m1 false true
                     | Negz m1 => binomial_rec n1 m1 false false
                     end
                 end%:~R ^ Posz 2 *
                 (reducebig 0 (bigopz.index_iotaz 1 (n + 1))
                    (fun k0 : int => BigBody k0 +%R true (k0%:~R ^ Posz 3)^-1) +
                  reducebig 0 (bigopz.index_iotaz 1 (k + 1))
                    (fun m : int =>
                     BigBody m +%R true
                       ((-1) ^ (m + 1) /
                        ((Posz 2)%:~R * m%:~R ^ Posz 3 *
                         match n with
                         | Posz n1 =>
                             match m with
                             | Posz m1 => binomial_rec n1 m1 true true
                             | Negz m1 => binomial_rec n1 m1 true false
                             end
                         | Negz n1 =>
                             match m with
                             | Posz m1 => binomial_rec n1 m1 false true
                             | Negz m1 => binomial_rec n1 m1 false false
                             end
                         end%:~R *
                         match n + m with
                         | Posz n1 =>
                             match m with
                             | Posz m1 => binomial_rec n1 m1 true true
                             | Negz m1 => binomial_rec n1 m1 true false
                             end
                         | Negz n1 =>
                             match m with
                             | Posz m1 => binomial_rec n1 m1 false true
                             | Negz m1 => binomial_rec n1 m1 false false
                             end
                         end%:~R)))))%R))%Q)%Q; 0%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
z_ne_0 : is_true ((Posz 2 : int) <= (n : int))
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (snd 0 a = a)
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (snd 0 a = a)
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Debug:
In environment
n : int
H' : (2 : int) <= (n : int)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner a n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner b 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner b 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner b 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner b 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner b 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Debug:
In environment
n : int
c10 := v (int.shift 1 n) 0 : rat
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner a n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner b 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner b 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner b 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner b 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Debug:
In environment
rootC0 : forall (t : ringType) (p : {poly GRing.Ring.sort t}),
         root p^:P 0%:P = root p 0
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_horner
           (fun n : int =>
            reducebig 0 (bigopz.index_iotaz 0 (n + 1))
              (fun k : int =>
               BigBody k +%R true
                 (match n with
                  | Posz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 true true
                      | Negz m1 => binomial_rec n1 m1 true false
                      end
                  | Negz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 false true
                      | Negz m1 => binomial_rec n1 m1 false false
                      end
                  end%:~R ^ Posz 2 *
                  match n + k with
                  | Posz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 true true
                      | Negz m1 => binomial_rec n1 m1 true false
                      end
                  | Negz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 false true
                      | Negz m1 => binomial_rec n1 m1 false false
                      end
                  end%:~R ^ Posz 2 *
                  (reducebig 0 (bigopz.index_iotaz 1 (n + 1))
                     (fun k0 : int =>
                      BigBody k0 +%R true (k0%:~R ^ Posz 3)^-1) +
                   reducebig 0 (bigopz.index_iotaz 1 (k + 1))
                     (fun m : int =>
                      BigBody m +%R true
                        ((-1) ^ (m + 1) /
                         ((Posz 2)%:~R * m%:~R ^ Posz 3 *
                          match n with
                          | Posz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 true true
                              | Negz m1 => binomial_rec n1 m1 true false
                              end
                          | Negz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 false true
                              | Negz m1 => binomial_rec n1 m1 false false
                              end
                          end%:~R *
                          match n + m with
                          | Posz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 true true
                              | Negz m1 => binomial_rec n1 m1 true false
                              end
                          | Negz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 false true
                              | Negz m1 => binomial_rec n1 m1 false false
                              end
                          end%:~R))))))) 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner b 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner b 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Debug:
In environment
rootC0 : forall (t : ringType) (p : {poly GRing.Ring.sort t}),
         root p^:P 0%:P = root p 0
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_horner
           (fun n : int =>
            reducebig 0 (bigopz.index_iotaz 0 (n + 1))
              (fun k : int =>
               BigBody k +%R true
                 (match n with
                  | Posz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 true true
                      | Negz m1 => binomial_rec n1 m1 true false
                      end
                  | Negz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 false true
                      | Negz m1 => binomial_rec n1 m1 false false
                      end
                  end%:~R ^ Posz 2 *
                  match n + k with
                  | Posz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 true true
                      | Negz m1 => binomial_rec n1 m1 true false
                      end
                  | Negz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 false true
                      | Negz m1 => binomial_rec n1 m1 false false
                      end
                  end%:~R ^ Posz 2 *
                  (reducebig 0 (bigopz.index_iotaz 1 (n + 1))
                     (fun k0 : int =>
                      BigBody k0 +%R true (k0%:~R ^ Posz 3)^-1) +
                   reducebig 0 (bigopz.index_iotaz 1 (k + 1))
                     (fun m : int =>
                      BigBody m +%R true
                        ((-1) ^ (m + 1) /
                         ((Posz 2)%:~R * m%:~R ^ Posz 3 *
                          match n with
                          | Posz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 true true
                              | Negz m1 => binomial_rec n1 m1 true false
                              end
                          | Negz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 false true
                              | Negz m1 => binomial_rec n1 m1 false false
                              end
                          end%:~R *
                          match n + m with
                          | Posz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 true true
                              | Negz m1 => binomial_rec n1 m1 true false
                              end
                          | Negz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 false true
                              | Negz m1 => binomial_rec n1 m1 false false
                              end
                          end%:~R))))))) 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Crunching: (length (incr_bin (r :: r0)) = S (length (r :: r0)))
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner b 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching:
(forall l : list bool,
 Exists (fun b : bool => b = true -> False) l ->
 (fix length (l0 : list bool) : nat :=
    match l0 with
    | [] => 0
    | _ :: l' => S (length l')
    end)
   ((fix incr_bin (l0 : list bool) : list bool :=
       match l0 with
       | [] => [true]
       | true :: t => false :: incr_bin t
       | false :: t => true :: t
       end) l) =
 (fix length (l0 : list bool) : nat :=
    match l0 with
    | [] => 0
    | _ :: l' => S (length l')
    end) l)
Crunching:
(forall l : list bool,
 Exists (fun b : bool => b = true -> False) l ->
 (fix length (l0 : list bool) : nat :=
    match l0 with
    | [] => 0
    | _ :: l' => S (length l')
    end)
   ((fix incr_bin (l0 : list bool) : list bool :=
       match l0 with
       | [] => [true]
       | true :: t => false :: incr_bin t
       | false :: t => true :: t
       end) l) =
 (fix length (l0 : list bool) : nat :=
    match l0 with
    | [] => 0
    | _ :: l' => S (length l')
    end) l)
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner b 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching:
(forall l : list bool,
 Exists (fun b : bool => b = true -> False) l ->
 (fix length (l0 : list bool) : nat :=
    match l0 with
    | [] => 0
    | _ :: l' => S (length l')
    end)
   ((fix incr_bin (l0 : list bool) : list bool :=
       match l0 with
       | [] => [true]
       | true :: t => false :: incr_bin t
       | false :: t => true :: t
       end) l) =
 (fix length (l0 : list bool) : nat :=
    match l0 with
    | [] => 0
    | _ :: l' => S (length l')
    end) l)
Debug:
In environment
rootC0 : forall (t : ringType) (p : {poly GRing.Ring.sort t}),
         root p^:P 0%:P = root p 0
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_horner
           (fun n : int =>
            reducebig 0 (bigopz.index_iotaz 0 (n + 1))
              (fun k : int =>
               BigBody k +%R true
                 (match n with
                  | Posz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 true true
                      | Negz m1 => binomial_rec n1 m1 true false
                      end
                  | Negz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 false true
                      | Negz m1 => binomial_rec n1 m1 false false
                      end
                  end%:~R ^ Posz 2 *
                  match n + k with
                  | Posz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 true true
                      | Negz m1 => binomial_rec n1 m1 true false
                      end
                  | Negz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 false true
                      | Negz m1 => binomial_rec n1 m1 false false
                      end
                  end%:~R ^ Posz 2 *
                  (reducebig 0 (bigopz.index_iotaz 1 (n + 1))
                     (fun k0 : int =>
                      BigBody k0 +%R true (k0%:~R ^ Posz 3)^-1) +
                   reducebig 0 (bigopz.index_iotaz 1 (k + 1))
                     (fun m : int =>
                      BigBody m +%R true
                        ((-1) ^ (m + 1) /
                         ((Posz 2)%:~R * m%:~R ^ Posz 3 *
                          match n with
                          | Posz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 true true
                              | Negz m1 => binomial_rec n1 m1 true false
                              end
                          | Negz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 false true
                              | Negz m1 => binomial_rec n1 m1 false false
                              end
                          end%:~R *
                          match n + m with
                          | Posz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 true true
                              | Negz m1 => binomial_rec n1 m1 true false
                              end
                          | Negz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 false true
                              | Negz m1 => binomial_rec n1 m1 false false
                              end
                          end%:~R))))))) 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner b 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching:
(forall l : list bool,
 Exists (fun b : bool => b = true -> False) l ->
 (fix length (l0 : list bool) : nat :=
    match l0 with
    | [] => 0
    | _ :: l' => S (length l')
    end)
   ((fix incr_bin (l0 : list bool) : list bool :=
       match l0 with
       | [] => [true]
       | true :: t => false :: incr_bin t
       | false :: t => true :: t
       end) l) =
 (fix length (l0 : list bool) : nat :=
    match l0 with
    | [] => 0
    | _ :: l' => S (length l')
    end) l)
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner b 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
rootC0 : forall (t : ringType) (p : {poly GRing.Ring.sort t}),
         root p^:P 0%:P = root p 0
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_horner
           (fun n : int =>
            reducebig 0 (bigopz.index_iotaz 0 (n + 1))
              (fun k : int =>
               BigBody k +%R true
                 (match n with
                  | Posz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 true true
                      | Negz m1 => binomial_rec n1 m1 true false
                      end
                  | Negz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 false true
                      | Negz m1 => binomial_rec n1 m1 false false
                      end
                  end%:~R ^ Posz 2 *
                  match n + k with
                  | Posz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 true true
                      | Negz m1 => binomial_rec n1 m1 true false
                      end
                  | Negz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 false true
                      | Negz m1 => binomial_rec n1 m1 false false
                      end
                  end%:~R ^ Posz 2 *
                  (reducebig 0 (bigopz.index_iotaz 1 (n + 1))
                     (fun k0 : int =>
                      BigBody k0 +%R true (k0%:~R ^ Posz 3)^-1) +
                   reducebig 0 (bigopz.index_iotaz 1 (k + 1))
                     (fun m : int =>
                      BigBody m +%R true
                        ((-1) ^ (m + 1) /
                         ((Posz 2)%:~R * m%:~R ^ Posz 3 *
                          match n with
                          | Posz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 true true
                              | Negz m1 => binomial_rec n1 m1 true false
                              end
                          | Negz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 false true
                              | Negz m1 => binomial_rec n1 m1 false false
                              end
                          end%:~R *
                          match n + m with
                          | Posz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 true true
                              | Negz m1 => binomial_rec n1 m1 true false
                              end
                          | Negz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 false true
                              | Negz m1 => binomial_rec n1 m1 false false
                              end
                          end%:~R))))))) 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner b 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching:
(forall l : list bool,
 Exists (fun b : bool => b = true -> False) l ->
 (fix length (l0 : list bool) : nat :=
    match l0 with
    | [] => 0
    | _ :: l' => S (length l')
    end)
   ((fix incr_bin (l0 : list bool) : list bool :=
       match l0 with
       | [] => [true]
       | true :: t => false :: incr_bin t
       | false :: t => true :: t
       end) l) =
 (fix length (l0 : list bool) : nat :=
    match l0 with
    | [] => 0
    | _ :: l' => S (length l')
    end) l)
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner b 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
rootC0 : forall (t : ringType) (p : {poly GRing.Ring.sort t}),
         root p^:P 0%:P = root p 0
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_horner
           (fun n : int =>
            reducebig 0 (bigopz.index_iotaz 0 (n + 1))
              (fun k : int =>
               BigBody k +%R true
                 (match n with
                  | Posz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 true true
                      | Negz m1 => binomial_rec n1 m1 true false
                      end
                  | Negz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 false true
                      | Negz m1 => binomial_rec n1 m1 false false
                      end
                  end%:~R ^ Posz 2 *
                  match n + k with
                  | Posz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 true true
                      | Negz m1 => binomial_rec n1 m1 true false
                      end
                  | Negz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 false true
                      | Negz m1 => binomial_rec n1 m1 false false
                      end
                  end%:~R ^ Posz 2 *
                  (reducebig 0 (bigopz.index_iotaz 1 (n + 1))
                     (fun k0 : int =>
                      BigBody k0 +%R true (k0%:~R ^ Posz 3)^-1) +
                   reducebig 0 (bigopz.index_iotaz 1 (k + 1))
                     (fun m : int =>
                      BigBody m +%R true
                        ((-1) ^ (m + 1) /
                         ((Posz 2)%:~R * m%:~R ^ Posz 3 *
                          match n with
                          | Posz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 true true
                              | Negz m1 => binomial_rec n1 m1 true false
                              end
                          | Negz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 false true
                              | Negz m1 => binomial_rec n1 m1 false false
                              end
                          end%:~R *
                          match n + m with
                          | Posz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 true true
                              | Negz m1 => binomial_rec n1 m1 true false
                              end
                          | Negz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 false true
                              | Negz m1 => binomial_rec n1 m1 false false
                              end
                          end%:~R))))))) 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
valq : int * int
i : is_true ((0 < valq.2) && coprime `|valq.1| `|valq.2|)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner b 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner b 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner b 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner b 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
H : int
n : nat
a : int
b : annotated_recs_d.precond.Sn H n a
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: d (int.shift 1 H) n a; annotated_recs_d.Sn_cf0_0_0 H n a; d H n a]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
rootC0 : forall (t : ringType) (p : {poly GRing.Ring.sort t}),
         root p^:P 0%:P = root p 0
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_horner
           (fun n : int =>
            reducebig 0 (bigopz.index_iotaz 0 (n + 1))
              (fun k : int =>
               BigBody k +%R true
                 (match n with
                  | Posz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 true true
                      | Negz m1 => binomial_rec n1 m1 true false
                      end
                  | Negz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 false true
                      | Negz m1 => binomial_rec n1 m1 false false
                      end
                  end%:~R ^ Posz 2 *
                  match n + k with
                  | Posz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 true true
                      | Negz m1 => binomial_rec n1 m1 true false
                      end
                  | Negz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 false true
                      | Negz m1 => binomial_rec n1 m1 false false
                      end
                  end%:~R ^ Posz 2 *
                  (reducebig 0 (bigopz.index_iotaz 1 (n + 1))
                     (fun k0 : int =>
                      BigBody k0 +%R true (k0%:~R ^ Posz 3)^-1) +
                   reducebig 0 (bigopz.index_iotaz 1 (k + 1))
                     (fun m : int =>
                      BigBody m +%R true
                        ((-1) ^ (m + 1) /
                         ((Posz 2)%:~R * m%:~R ^ Posz 3 *
                          match n with
                          | Posz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 true true
                              | Negz m1 => binomial_rec n1 m1 true false
                              end
                          | Negz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 false true
                              | Negz m1 => binomial_rec n1 m1 false false
                              end
                          end%:~R *
                          match n + m with
                          | Posz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 true true
                              | Negz m1 => binomial_rec n1 m1 true false
                              end
                          | Negz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 false true
                              | Negz m1 => binomial_rec n1 m1 false false
                              end
                          end%:~R))))))) 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
valq : int * int
i : is_true ((0 < valq.2) && coprime `|valq.1| `|valq.2|)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner b 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner b 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner b 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching:
(forall l : list bool,
 Exists (fun b : bool => b = true -> False) l ->
 (fix length (l0 : list bool) : nat :=
    match l0 with
    | [] => 0
    | _ :: l' => S (length l')
    end)
   ((fix incr_bin (l0 : list bool) : list bool :=
       match l0 with
       | [] => [true]
       | true :: t => false :: incr_bin t
       | false :: t => true :: t
       end) l) =
 (fix length (l0 : list bool) : nat :=
    match l0 with
    | [] => 0
    | _ :: l' => S (length l')
    end) l)
Debug:
In environment
rootC0 : forall (t : ringType) (p : {poly GRing.Ring.sort t}),
         root p^:P 0%:P = root p 0
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_horner
           (fun n : int =>
            reducebig 0 (bigopz.index_iotaz 0 (n + 1))
              (fun k : int =>
               BigBody k +%R true
                 (match n with
                  | Posz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 true true
                      | Negz m1 => binomial_rec n1 m1 true false
                      end
                  | Negz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 false true
                      | Negz m1 => binomial_rec n1 m1 false false
                      end
                  end%:~R ^ Posz 2 *
                  match n + k with
                  | Posz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 true true
                      | Negz m1 => binomial_rec n1 m1 true false
                      end
                  | Negz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 false true
                      | Negz m1 => binomial_rec n1 m1 false false
                      end
                  end%:~R ^ Posz 2 *
                  (reducebig 0 (bigopz.index_iotaz 1 (n + 1))
                     (fun k0 : int =>
                      BigBody k0 +%R true (k0%:~R ^ Posz 3)^-1) +
                   reducebig 0 (bigopz.index_iotaz 1 (k + 1))
                     (fun m : int =>
                      BigBody m +%R true
                        ((-1) ^ (m + 1) /
                         ((Posz 2)%:~R * m%:~R ^ Posz 3 *
                          match n with
                          | Posz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 true true
                              | Negz m1 => binomial_rec n1 m1 true false
                              end
                          | Negz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 false true
                              | Negz m1 => binomial_rec n1 m1 false false
                              end
                          end%:~R *
                          match n + m with
                          | Posz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 true true
                              | Negz m1 => binomial_rec n1 m1 true false
                              end
                          | Negz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 false true
                              | Negz m1 => binomial_rec n1 m1 false false
                              end
                          end%:~R))))))) 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner b 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
rootC0 : forall (t : ringType) (p : {poly GRing.Ring.sort t}),
         root p^:P 0%:P = root p 0
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_horner
           (fun n : int =>
            reducebig 0 (bigopz.index_iotaz 0 (n + 1))
              (fun k : int =>
               BigBody k +%R true
                 (match n with
                  | Posz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 true true
                      | Negz m1 => binomial_rec n1 m1 true false
                      end
                  | Negz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 false true
                      | Negz m1 => binomial_rec n1 m1 false false
                      end
                  end%:~R ^ Posz 2 *
                  match n + k with
                  | Posz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 true true
                      | Negz m1 => binomial_rec n1 m1 true false
                      end
                  | Negz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 false true
                      | Negz m1 => binomial_rec n1 m1 false false
                      end
                  end%:~R ^ Posz 2 *
                  (reducebig 0 (bigopz.index_iotaz 1 (n + 1))
                     (fun k0 : int =>
                      BigBody k0 +%R true (k0%:~R ^ Posz 3)^-1) +
                   reducebig 0 (bigopz.index_iotaz 1 (k + 1))
                     (fun m : int =>
                      BigBody m +%R true
                        ((-1) ^ (m + 1) /
                         ((Posz 2)%:~R * m%:~R ^ Posz 3 *
                          match n with
                          | Posz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 true true
                              | Negz m1 => binomial_rec n1 m1 true false
                              end
                          | Negz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 false true
                              | Negz m1 => binomial_rec n1 m1 false false
                              end
                          end%:~R *
                          match n + m with
                          | Posz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 true true
                              | Negz m1 => binomial_rec n1 m1 true false
                              end
                          | Negz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 false true
                              | Negz m1 => binomial_rec n1 m1 false false
                              end
                          end%:~R))))))) 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
valq : int * int
i : is_true ((0 < valq.2) && coprime `|valq.1| `|valq.2|)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner b 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner b 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner b 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
rootC0 : forall (t : ringType) (p : {poly GRing.Ring.sort t}),
         root p^:P 0%:P = root p 0
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_horner
           (fun n : int =>
            reducebig 0 (bigopz.index_iotaz 0 (n + 1))
              (fun k : int =>
               BigBody k +%R true
                 (match n with
                  | Posz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 true true
                      | Negz m1 => binomial_rec n1 m1 true false
                      end
                  | Negz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 false true
                      | Negz m1 => binomial_rec n1 m1 false false
                      end
                  end%:~R ^ Posz 2 *
                  match n + k with
                  | Posz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 true true
                      | Negz m1 => binomial_rec n1 m1 true false
                      end
                  | Negz n1 =>
                      match k with
                      | Posz m1 => binomial_rec n1 m1 false true
                      | Negz m1 => binomial_rec n1 m1 false false
                      end
                  end%:~R ^ Posz 2 *
                  (reducebig 0 (bigopz.index_iotaz 1 (n + 1))
                     (fun k0 : int =>
                      BigBody k0 +%R true (k0%:~R ^ Posz 3)^-1) +
                   reducebig 0 (bigopz.index_iotaz 1 (k + 1))
                     (fun m : int =>
                      BigBody m +%R true
                        ((-1) ^ (m + 1) /
                         ((Posz 2)%:~R * m%:~R ^ Posz 3 *
                          match n with
                          | Posz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 true true
                              | Negz m1 => binomial_rec n1 m1 true false
                              end
                          | Negz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 false true
                              | Negz m1 => binomial_rec n1 m1 false false
                              end
                          end%:~R *
                          match n + m with
                          | Posz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 true true
                              | Negz m1 => binomial_rec n1 m1 true false
                              end
                          | Negz n1 =>
                              match m with
                              | Posz m1 => binomial_rec n1 m1 false true
                              | Negz m1 => binomial_rec n1 m1 false false
                              end
                          end%:~R))))))) 0]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner b 1]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner b 1]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner b 1]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner b 1]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner b 1]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
ltn_trans : forall n m p : nat,
            is_true (m < n)%N -> is_true (n < p)%N -> is_true (m < p)%N
eq_by_mem : forall s1 s2 : seq (Equality.sort nat_eqType),
            is_true (sorted (fun m : nat => [eta leq m.+1]) s1) ->
            is_true (sorted (fun m : nat => [eta leq m.+1]) s2) ->
            s1 =i s2 -> s1 = s2
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner b 1]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner b 1]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
ltn_trans : forall n m p : nat,
            is_true (m < n)%N -> is_true (n < p)%N -> is_true (m < p)%N
eq_by_mem : forall s1 s2 : seq (Equality.sort nat_eqType),
            is_true (sorted (fun m : nat => [eta leq m.+1]) s1) ->
            is_true (sorted (fun m : nat => [eta leq m.+1]) s2) ->
            s1 =i s2 -> s1 = s2
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner b 1]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner b 1]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
ltn_trans : forall n m p : nat,
            is_true (m < n)%N -> is_true (n < p)%N -> is_true (m < p)%N
eq_by_mem : forall s1 s2 : seq (Equality.sort nat_eqType),
            is_true (sorted (fun m : nat => [eta leq m.+1]) s1) ->
            is_true (sorted (fun m : nat => [eta leq m.+1]) s2) ->
            s1 =i s2 -> s1 = s2
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner b 1]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: (((((1%Q + rat_of_Z 2)%Q *
             ((1%Q + rat_of_Z 2)%Q * (1%Q + rat_of_Z 2)%Q)%Q)%Q *
            ((-
              ((((1%Q + rat_of_Z 1)%Q *
                 ((1%Q + rat_of_Z 1)%Q * (1%Q + rat_of_Z 1)%Q)%Q)%Q *
                b (Posz 1))%Q +
               ((((- rat_of_Z 1)%Q *
                  (((rat_of_Z 17 * (1%Q * 1%Q)%Q)%Q + (rat_of_Z 51 * 1%Q)%Q)%Q +
                   rat_of_Z 39)%Q)%Q * ((rat_of_Z 2 * 1%Q)%Q + rat_of_Z 3)%Q)%Q *
                ((-
                  ((((0%Q + rat_of_Z 1)%Q *
                     ((0%Q + rat_of_Z 1)%Q * (0%Q + rat_of_Z 1)%Q)%Q)%Q *
                    b (Posz 0))%Q +
                   ((((- rat_of_Z 1)%Q *
                      (((rat_of_Z 17 * (0%Q * 0%Q)%Q)%Q +
                        (rat_of_Z 51 * 0%Q)%Q)%Q + 
                       rat_of_Z 39)%Q)%Q *
                     ((rat_of_Z 2 * 0%Q)%Q + rat_of_Z 3)%Q)%Q * 
                    b (Posz 1))%Q)%Q)%Q *
                 (((0%Q + rat_of_Z 2)%Q *
                   ((0%Q + rat_of_Z 2)%Q * (0%Q + rat_of_Z 2)%Q)%Q)%Q^-1)%Q)%Q)%Q)%Q)%Q *
             (((1%Q + rat_of_Z 2)%Q *
               ((1%Q + rat_of_Z 2)%Q * (1%Q + rat_of_Z 2)%Q)%Q)%Q^-1)%Q)%Q)%Q +
           ((((- rat_of_Z 1)%Q *
              (((rat_of_Z 17 * (1%Q * 1%Q)%Q)%Q + (rat_of_Z 51 * 1%Q)%Q)%Q +
               rat_of_Z 39)%Q)%Q * ((rat_of_Z 2 * 1%Q)%Q + rat_of_Z 3)%Q)%Q *
            ((-
              ((((0%Q + rat_of_Z 1)%Q *
                 ((0%Q + rat_of_Z 1)%Q * (0%Q + rat_of_Z 1)%Q)%Q)%Q *
                b (Posz 0))%Q +
               ((((- rat_of_Z 1)%Q *
                  (((rat_of_Z 17 * (0%Q * 0%Q)%Q)%Q + (rat_of_Z 51 * 0%Q)%Q)%Q +
                   rat_of_Z 39)%Q)%Q * ((rat_of_Z 2 * 0%Q)%Q + rat_of_Z 3)%Q)%Q *
                b (Posz 1))%Q)%Q)%Q *
             (((0%Q + rat_of_Z 2)%Q *
               ((0%Q + rat_of_Z 2)%Q * (0%Q + rat_of_Z 2)%Q)%Q)%Q^-1)%Q)%Q)%Q)%Q +
          (((1%Q + rat_of_Z 1)%Q *
            ((1%Q + rat_of_Z 1)%Q * (1%Q + rat_of_Z 1)%Q)%Q)%Q * 
           b (Posz 1))%Q)%Q; 0%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: (((((1%Q + rat_of_Z 2)%Q *
             ((1%Q + rat_of_Z 2)%Q * (1%Q + rat_of_Z 2)%Q)%Q)%Q *
            ((-
              ((((1%Q + rat_of_Z 1)%Q *
                 ((1%Q + rat_of_Z 1)%Q * (1%Q + rat_of_Z 1)%Q)%Q)%Q *
                b (Posz 1))%Q +
               ((((- rat_of_Z 1)%Q *
                  (((rat_of_Z 17 * (1%Q * 1%Q)%Q)%Q + (rat_of_Z 51 * 1%Q)%Q)%Q +
                   rat_of_Z 39)%Q)%Q * ((rat_of_Z 2 * 1%Q)%Q + rat_of_Z 3)%Q)%Q *
                ((-
                  ((((0%Q + rat_of_Z 1)%Q *
                     ((0%Q + rat_of_Z 1)%Q * (0%Q + rat_of_Z 1)%Q)%Q)%Q *
                    b (Posz 0))%Q +
                   ((((- rat_of_Z 1)%Q *
                      (((rat_of_Z 17 * (0%Q * 0%Q)%Q)%Q +
                        (rat_of_Z 51 * 0%Q)%Q)%Q + 
                       rat_of_Z 39)%Q)%Q *
                     ((rat_of_Z 2 * 0%Q)%Q + rat_of_Z 3)%Q)%Q * 
                    b (Posz 1))%Q)%Q)%Q *
                 (((0%Q + rat_of_Z 2)%Q *
                   ((0%Q + rat_of_Z 2)%Q * (0%Q + rat_of_Z 2)%Q)%Q)%Q^-1)%Q)%Q)%Q)%Q)%Q *
             (((1%Q + rat_of_Z 2)%Q *
               ((1%Q + rat_of_Z 2)%Q * (1%Q + rat_of_Z 2)%Q)%Q)%Q^-1)%Q)%Q)%Q +
           ((((- rat_of_Z 1)%Q *
              (((rat_of_Z 17 * (1%Q * 1%Q)%Q)%Q + (rat_of_Z 51 * 1%Q)%Q)%Q +
               rat_of_Z 39)%Q)%Q * ((rat_of_Z 2 * 1%Q)%Q + rat_of_Z 3)%Q)%Q *
            ((-
              ((((0%Q + rat_of_Z 1)%Q *
                 ((0%Q + rat_of_Z 1)%Q * (0%Q + rat_of_Z 1)%Q)%Q)%Q *
                b (Posz 0))%Q +
               ((((- rat_of_Z 1)%Q *
                  (((rat_of_Z 17 * (0%Q * 0%Q)%Q)%Q + (rat_of_Z 51 * 0%Q)%Q)%Q +
                   rat_of_Z 39)%Q)%Q * ((rat_of_Z 2 * 0%Q)%Q + rat_of_Z 3)%Q)%Q *
                b (Posz 1))%Q)%Q)%Q *
             (((0%Q + rat_of_Z 2)%Q *
               ((0%Q + rat_of_Z 2)%Q * (0%Q + rat_of_Z 2)%Q)%Q)%Q^-1)%Q)%Q)%Q)%Q +
          (((1%Q + rat_of_Z 1)%Q *
            ((1%Q + rat_of_Z 1)%Q * (1%Q + rat_of_Z 1)%Q)%Q)%Q * 
           b (Posz 1))%Q)%Q; 0%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner b 1]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
ltn_trans : forall n m p : nat,
            is_true (m < n)%N -> is_true (n < p)%N -> is_true (m < p)%N
eq_by_mem : forall s1 s2 : seq (Equality.sort nat_eqType),
            is_true (sorted (fun m : nat => [eta leq m.+1]) s1) ->
            is_true (sorted (fun m : nat => [eta leq m.+1]) s2) ->
            s1 =i s2 -> s1 = s2
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner b 1]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
ltn_trans : forall n m p : nat,
            is_true (m < n)%N -> is_true (n < p)%N -> is_true (m < p)%N
eq_by_mem : forall s1 s2 : seq (Equality.sort nat_eqType),
            is_true (sorted (fun m : nat => [eta leq m.+1]) s1) ->
            is_true (sorted (fun m : nat => [eta leq m.+1]) s2) ->
            s1 =i s2 -> s1 = s2
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner b 1]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching: (fst n (b * S f + f) = b)
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: (((((1%Q + rat_of_Z 2)%Q *
             ((1%Q + rat_of_Z 2)%Q * (1%Q + rat_of_Z 2)%Q)%Q)%Q *
            ((-
              ((((1%Q + rat_of_Z 1)%Q *
                 ((1%Q + rat_of_Z 1)%Q * (1%Q + rat_of_Z 1)%Q)%Q)%Q *
                b (Posz 1))%Q +
               ((((- rat_of_Z 1)%Q *
                  (((rat_of_Z 17 * (1%Q * 1%Q)%Q)%Q + (rat_of_Z 51 * 1%Q)%Q)%Q +
                   rat_of_Z 39)%Q)%Q * ((rat_of_Z 2 * 1%Q)%Q + rat_of_Z 3)%Q)%Q *
                ((-
                  ((((0%Q + rat_of_Z 1)%Q *
                     ((0%Q + rat_of_Z 1)%Q * (0%Q + rat_of_Z 1)%Q)%Q)%Q *
                    b (Posz 0))%Q +
                   ((((- rat_of_Z 1)%Q *
                      (((rat_of_Z 17 * (0%Q * 0%Q)%Q)%Q +
                        (rat_of_Z 51 * 0%Q)%Q)%Q + 
                       rat_of_Z 39)%Q)%Q *
                     ((rat_of_Z 2 * 0%Q)%Q + rat_of_Z 3)%Q)%Q * 
                    b (Posz 1))%Q)%Q)%Q *
                 (((0%Q + rat_of_Z 2)%Q *
                   ((0%Q + rat_of_Z 2)%Q * (0%Q + rat_of_Z 2)%Q)%Q)%Q^-1)%Q)%Q)%Q)%Q)%Q *
             (((1%Q + rat_of_Z 2)%Q *
               ((1%Q + rat_of_Z 2)%Q * (1%Q + rat_of_Z 2)%Q)%Q)%Q^-1)%Q)%Q)%Q +
           ((((- rat_of_Z 1)%Q *
              (((rat_of_Z 17 * (1%Q * 1%Q)%Q)%Q + (rat_of_Z 51 * 1%Q)%Q)%Q +
               rat_of_Z 39)%Q)%Q * ((rat_of_Z 2 * 1%Q)%Q + rat_of_Z 3)%Q)%Q *
            ((-
              ((((0%Q + rat_of_Z 1)%Q *
                 ((0%Q + rat_of_Z 1)%Q * (0%Q + rat_of_Z 1)%Q)%Q)%Q *
                b (Posz 0))%Q +
               ((((- rat_of_Z 1)%Q *
                  (((rat_of_Z 17 * (0%Q * 0%Q)%Q)%Q + (rat_of_Z 51 * 0%Q)%Q)%Q +
                   rat_of_Z 39)%Q)%Q * ((rat_of_Z 2 * 0%Q)%Q + rat_of_Z 3)%Q)%Q *
                b (Posz 1))%Q)%Q)%Q *
             (((0%Q + rat_of_Z 2)%Q *
               ((0%Q + rat_of_Z 2)%Q * (0%Q + rat_of_Z 2)%Q)%Q)%Q^-1)%Q)%Q)%Q)%Q +
          (((1%Q + rat_of_Z 1)%Q *
            ((1%Q + rat_of_Z 1)%Q * (1%Q + rat_of_Z 1)%Q)%Q)%Q * 
           b (Posz 1))%Q)%Q; 0%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: (((((1%Q + rat_of_Z 2)%Q *
             ((1%Q + rat_of_Z 2)%Q * (1%Q + rat_of_Z 2)%Q)%Q)%Q *
            ((-
              ((((1%Q + rat_of_Z 1)%Q *
                 ((1%Q + rat_of_Z 1)%Q * (1%Q + rat_of_Z 1)%Q)%Q)%Q *
                b (Posz 1))%Q +
               ((((- rat_of_Z 1)%Q *
                  (((rat_of_Z 17 * (1%Q * 1%Q)%Q)%Q + (rat_of_Z 51 * 1%Q)%Q)%Q +
                   rat_of_Z 39)%Q)%Q * ((rat_of_Z 2 * 1%Q)%Q + rat_of_Z 3)%Q)%Q *
                ((-
                  ((((0%Q + rat_of_Z 1)%Q *
                     ((0%Q + rat_of_Z 1)%Q * (0%Q + rat_of_Z 1)%Q)%Q)%Q *
                    b (Posz 0))%Q +
                   ((((- rat_of_Z 1)%Q *
                      (((rat_of_Z 17 * (0%Q * 0%Q)%Q)%Q +
                        (rat_of_Z 51 * 0%Q)%Q)%Q + 
                       rat_of_Z 39)%Q)%Q *
                     ((rat_of_Z 2 * 0%Q)%Q + rat_of_Z 3)%Q)%Q * 
                    b (Posz 1))%Q)%Q)%Q *
                 (((0%Q + rat_of_Z 2)%Q *
                   ((0%Q + rat_of_Z 2)%Q * (0%Q + rat_of_Z 2)%Q)%Q)%Q^-1)%Q)%Q)%Q)%Q)%Q *
             (((1%Q + rat_of_Z 2)%Q *
               ((1%Q + rat_of_Z 2)%Q * (1%Q + rat_of_Z 2)%Q)%Q)%Q^-1)%Q)%Q)%Q +
           ((((- rat_of_Z 1)%Q *
              (((rat_of_Z 17 * (1%Q * 1%Q)%Q)%Q + (rat_of_Z 51 * 1%Q)%Q)%Q +
               rat_of_Z 39)%Q)%Q * ((rat_of_Z 2 * 1%Q)%Q + rat_of_Z 3)%Q)%Q *
            ((-
              ((((0%Q + rat_of_Z 1)%Q *
                 ((0%Q + rat_of_Z 1)%Q * (0%Q + rat_of_Z 1)%Q)%Q)%Q *
                b (Posz 0))%Q +
               ((((- rat_of_Z 1)%Q *
                  (((rat_of_Z 17 * (0%Q * 0%Q)%Q)%Q + (rat_of_Z 51 * 0%Q)%Q)%Q +
                   rat_of_Z 39)%Q)%Q * ((rat_of_Z 2 * 0%Q)%Q + rat_of_Z 3)%Q)%Q *
                b (Posz 1))%Q)%Q)%Q *
             (((0%Q + rat_of_Z 2)%Q *
               ((0%Q + rat_of_Z 2)%Q * (0%Q + rat_of_Z 2)%Q)%Q)%Q^-1)%Q)%Q)%Q)%Q +
          (((1%Q + rat_of_Z 1)%Q *
            ((1%Q + rat_of_Z 1)%Q * (1%Q + rat_of_Z 1)%Q)%Q)%Q * 
           b (Posz 1))%Q)%Q; 0%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
H, H' : int
Bdiag : is_true ((0 < H') && coprime `|H| `|H'|)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: (((((1%Q + rat_of_Z 2)%Q *
             ((1%Q + rat_of_Z 2)%Q * (1%Q + rat_of_Z 2)%Q)%Q)%Q *
            [rat H // H'])%Q +
           ((((- rat_of_Z 1)%Q *
              (((rat_of_Z 17 * (1%Q * 1%Q)%Q)%Q + (rat_of_Z 51 * 1%Q)%Q)%Q +
               rat_of_Z 39)%Q)%Q * ((rat_of_Z 2 * 1%Q)%Q + rat_of_Z 3)%Q)%Q *
            ((-
              ((((0%Q + rat_of_Z 1)%Q *
                 ((0%Q + rat_of_Z 1)%Q * (0%Q + rat_of_Z 1)%Q)%Q)%Q *
                b (Posz 0))%Q +
               ((((- rat_of_Z 1)%Q *
                  (((rat_of_Z 17 * (0%Q * 0%Q)%Q)%Q + (rat_of_Z 51 * 0%Q)%Q)%Q +
                   rat_of_Z 39)%Q)%Q * ((rat_of_Z 2 * 0%Q)%Q + rat_of_Z 3)%Q)%Q *
                b (Posz 1))%Q)%Q)%Q *
             (((0%Q + rat_of_Z 2)%Q *
               ((0%Q + rat_of_Z 2)%Q * (0%Q + rat_of_Z 2)%Q)%Q)%Q^-1)%Q)%Q)%Q)%Q +
          (((1%Q + rat_of_Z 1)%Q *
            ((1%Q + rat_of_Z 1)%Q * (1%Q + rat_of_Z 1)%Q)%Q)%Q * 
           b (Posz 1))%Q)%Q; 0%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
H, H' : int
Bdiag : is_true ((0 < H') && coprime `|H| `|H'|)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: 0%Q;
         (((((1%Q + rat_of_Z 2)%Q *
             ((1%Q + rat_of_Z 2)%Q * (1%Q + rat_of_Z 2)%Q)%Q)%Q *
            [rat H // H'])%Q +
           ((((- rat_of_Z 1)%Q *
              (((rat_of_Z 17 * (1%Q * 1%Q)%Q)%Q + (rat_of_Z 51 * 1%Q)%Q)%Q +
               rat_of_Z 39)%Q)%Q * ((rat_of_Z 2 * 1%Q)%Q + rat_of_Z 3)%Q)%Q *
            ((-
              ((((0%Q + rat_of_Z 1)%Q *
                 ((0%Q + rat_of_Z 1)%Q * (0%Q + rat_of_Z 1)%Q)%Q)%Q *
                b (Posz 0))%Q +
               ((((- rat_of_Z 1)%Q *
                  (((rat_of_Z 17 * (0%Q * 0%Q)%Q)%Q + (rat_of_Z 51 * 0%Q)%Q)%Q +
                   rat_of_Z 39)%Q)%Q * ((rat_of_Z 2 * 0%Q)%Q + rat_of_Z 3)%Q)%Q *
                b (Posz 1))%Q)%Q)%Q *
             (((0%Q + rat_of_Z 2)%Q *
               ((0%Q + rat_of_Z 2)%Q * (0%Q + rat_of_Z 2)%Q)%Q)%Q^-1)%Q)%Q)%Q)%Q +
          (((1%Q + rat_of_Z 1)%Q *
            ((1%Q + rat_of_Z 1)%Q * (1%Q + rat_of_Z 1)%Q)%Q)%Q * 
           b (Posz 1))%Q)%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
H, H' : int
Bdiag : is_true ((0 < H') && coprime `|H| `|H'|)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: (((((1%Q + rat_of_Z 2)%Q *
             ((1%Q + rat_of_Z 2)%Q * (1%Q + rat_of_Z 2)%Q)%Q)%Q *
            [rat H // H'])%Q +
           ((((- rat_of_Z 1)%Q *
              (((rat_of_Z 17 * (1%Q * 1%Q)%Q)%Q + (rat_of_Z 51 * 1%Q)%Q)%Q +
               rat_of_Z 39)%Q)%Q * ((rat_of_Z 2 * 1%Q)%Q + rat_of_Z 3)%Q)%Q *
            ((-
              ((((0%Q + rat_of_Z 1)%Q *
                 ((0%Q + rat_of_Z 1)%Q * (0%Q + rat_of_Z 1)%Q)%Q)%Q *
                b (Posz 0))%Q +
               ((((- rat_of_Z 1)%Q *
                  (((rat_of_Z 17 * (0%Q * 0%Q)%Q)%Q + (rat_of_Z 51 * 0%Q)%Q)%Q +
                   rat_of_Z 39)%Q)%Q * ((rat_of_Z 2 * 0%Q)%Q + rat_of_Z 3)%Q)%Q *
                b (Posz 1))%Q)%Q)%Q *
             (((0%Q + rat_of_Z 2)%Q *
               ((0%Q + rat_of_Z 2)%Q * (0%Q + rat_of_Z 2)%Q)%Q)%Q^-1)%Q)%Q)%Q)%Q +
          (((1%Q + rat_of_Z 1)%Q *
            ((1%Q + rat_of_Z 1)%Q * (1%Q + rat_of_Z 1)%Q)%Q)%Q * 
           b (Posz 1))%Q)%Q; 0%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
H, H' : int
Bdiag : is_true ((0 < H') && coprime `|H| `|H'|)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: 0%Q;
         (((((1%Q + rat_of_Z 2)%Q *
             ((1%Q + rat_of_Z 2)%Q * (1%Q + rat_of_Z 2)%Q)%Q)%Q *
            [rat H // H'])%Q +
           ((((- rat_of_Z 1)%Q *
              (((rat_of_Z 17 * (1%Q * 1%Q)%Q)%Q + (rat_of_Z 51 * 1%Q)%Q)%Q +
               rat_of_Z 39)%Q)%Q * ((rat_of_Z 2 * 1%Q)%Q + rat_of_Z 3)%Q)%Q *
            ((-
              ((((0%Q + rat_of_Z 1)%Q *
                 ((0%Q + rat_of_Z 1)%Q * (0%Q + rat_of_Z 1)%Q)%Q)%Q *
                b (Posz 0))%Q +
               ((((- rat_of_Z 1)%Q *
                  (((rat_of_Z 17 * (0%Q * 0%Q)%Q)%Q + (rat_of_Z 51 * 0%Q)%Q)%Q +
                   rat_of_Z 39)%Q)%Q * ((rat_of_Z 2 * 0%Q)%Q + rat_of_Z 3)%Q)%Q *
                b (Posz 1))%Q)%Q)%Q *
             (((0%Q + rat_of_Z 2)%Q *
               ((0%Q + rat_of_Z 2)%Q * (0%Q + rat_of_Z 2)%Q)%Q)%Q^-1)%Q)%Q)%Q)%Q +
          (((1%Q + rat_of_Z 1)%Q *
            ((1%Q + rat_of_Z 1)%Q * (1%Q + rat_of_Z 1)%Q)%Q)%Q * 
           b (Posz 1))%Q)%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner b 1]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner b 1]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
ltn_trans : forall n m p : nat,
            is_true (m < n)%N -> is_true (n < p)%N -> is_true (m < p)%N
eq_by_mem : forall s1 s2 : seq (Equality.sort nat_eqType),
            is_true (sorted (fun m : nat => [eta leq m.+1]) s1) ->
            is_true (sorted (fun m : nat => [eta leq m.+1]) s2) ->
            s1 =i s2 -> s1 = s2
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner b 1]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
ltn_trans : forall n m p : nat,
            is_true (m < n)%N -> is_true (n < p)%N -> is_true (m < p)%N
eq_by_mem : forall s1 s2 : seq (Equality.sort nat_eqType),
            is_true (sorted (fun m : nat => [eta leq m.+1]) s1) ->
            is_true (sorted (fun m : nat => [eta leq m.+1]) s2) ->
            s1 =i s2 -> s1 = s2
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: annotated_recs_c.P_horner b 1]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: (((((1%Q + rat_of_Z 2)%Q *
             ((1%Q + rat_of_Z 2)%Q * (1%Q + rat_of_Z 2)%Q)%Q)%Q *
            ((-
              ((((1%Q + rat_of_Z 1)%Q *
                 ((1%Q + rat_of_Z 1)%Q * (1%Q + rat_of_Z 1)%Q)%Q)%Q *
                b (Posz 1))%Q +
               ((((- rat_of_Z 1)%Q *
                  (((rat_of_Z 17 * (1%Q * 1%Q)%Q)%Q + (rat_of_Z 51 * 1%Q)%Q)%Q +
                   rat_of_Z 39)%Q)%Q * ((rat_of_Z 2 * 1%Q)%Q + rat_of_Z 3)%Q)%Q *
                ((-
                  ((((0%Q + rat_of_Z 1)%Q *
                     ((0%Q + rat_of_Z 1)%Q * (0%Q + rat_of_Z 1)%Q)%Q)%Q *
                    b (Posz 0))%Q +
                   ((((- rat_of_Z 1)%Q *
                      (((rat_of_Z 17 * (0%Q * 0%Q)%Q)%Q +
                        (rat_of_Z 51 * 0%Q)%Q)%Q + 
                       rat_of_Z 39)%Q)%Q *
                     ((rat_of_Z 2 * 0%Q)%Q + rat_of_Z 3)%Q)%Q * 
                    b (Posz 1))%Q)%Q)%Q *
                 (((0%Q + rat_of_Z 2)%Q *
                   ((0%Q + rat_of_Z 2)%Q * (0%Q + rat_of_Z 2)%Q)%Q)%Q^-1)%Q)%Q)%Q)%Q)%Q *
             (((1%Q + rat_of_Z 2)%Q *
               ((1%Q + rat_of_Z 2)%Q * (1%Q + rat_of_Z 2)%Q)%Q)%Q^-1)%Q)%Q)%Q +
           ((((- rat_of_Z 1)%Q *
              (((rat_of_Z 17 * (1%Q * 1%Q)%Q)%Q + (rat_of_Z 51 * 1%Q)%Q)%Q +
               rat_of_Z 39)%Q)%Q * ((rat_of_Z 2 * 1%Q)%Q + rat_of_Z 3)%Q)%Q *
            ((-
              ((((0%Q + rat_of_Z 1)%Q *
                 ((0%Q + rat_of_Z 1)%Q * (0%Q + rat_of_Z 1)%Q)%Q)%Q *
                b (Posz 0))%Q +
               ((((- rat_of_Z 1)%Q *
                  (((rat_of_Z 17 * (0%Q * 0%Q)%Q)%Q + (rat_of_Z 51 * 0%Q)%Q)%Q +
                   rat_of_Z 39)%Q)%Q * ((rat_of_Z 2 * 0%Q)%Q + rat_of_Z 3)%Q)%Q *
                b (Posz 1))%Q)%Q)%Q *
             (((0%Q + rat_of_Z 2)%Q *
               ((0%Q + rat_of_Z 2)%Q * (0%Q + rat_of_Z 2)%Q)%Q)%Q^-1)%Q)%Q)%Q)%Q +
          (((1%Q + rat_of_Z 1)%Q *
            ((1%Q + rat_of_Z 1)%Q * (1%Q + rat_of_Z 1)%Q)%Q)%Q * 
           b (Posz 1))%Q)%Q; 0%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: (((((1%Q + rat_of_Z 2)%Q *
             ((1%Q + rat_of_Z 2)%Q * (1%Q + rat_of_Z 2)%Q)%Q)%Q *
            ((-
              ((((1%Q + rat_of_Z 1)%Q *
                 ((1%Q + rat_of_Z 1)%Q * (1%Q + rat_of_Z 1)%Q)%Q)%Q *
                b (Posz 1))%Q +
               ((((- rat_of_Z 1)%Q *
                  (((rat_of_Z 17 * (1%Q * 1%Q)%Q)%Q + (rat_of_Z 51 * 1%Q)%Q)%Q +
                   rat_of_Z 39)%Q)%Q * ((rat_of_Z 2 * 1%Q)%Q + rat_of_Z 3)%Q)%Q *
                ((-
                  ((((0%Q + rat_of_Z 1)%Q *
                     ((0%Q + rat_of_Z 1)%Q * (0%Q + rat_of_Z 1)%Q)%Q)%Q *
                    b (Posz 0))%Q +
                   ((((- rat_of_Z 1)%Q *
                      (((rat_of_Z 17 * (0%Q * 0%Q)%Q)%Q +
                        (rat_of_Z 51 * 0%Q)%Q)%Q + 
                       rat_of_Z 39)%Q)%Q *
                     ((rat_of_Z 2 * 0%Q)%Q + rat_of_Z 3)%Q)%Q * 
                    b (Posz 1))%Q)%Q)%Q *
                 (((0%Q + rat_of_Z 2)%Q *
                   ((0%Q + rat_of_Z 2)%Q * (0%Q + rat_of_Z 2)%Q)%Q)%Q^-1)%Q)%Q)%Q)%Q)%Q *
             (((1%Q + rat_of_Z 2)%Q *
               ((1%Q + rat_of_Z 2)%Q * (1%Q + rat_of_Z 2)%Q)%Q)%Q^-1)%Q)%Q)%Q +
           ((((- rat_of_Z 1)%Q *
              (((rat_of_Z 17 * (1%Q * 1%Q)%Q)%Q + (rat_of_Z 51 * 1%Q)%Q)%Q +
               rat_of_Z 39)%Q)%Q * ((rat_of_Z 2 * 1%Q)%Q + rat_of_Z 3)%Q)%Q *
            ((-
              ((((0%Q + rat_of_Z 1)%Q *
                 ((0%Q + rat_of_Z 1)%Q * (0%Q + rat_of_Z 1)%Q)%Q)%Q *
                b (Posz 0))%Q +
               ((((- rat_of_Z 1)%Q *
                  (((rat_of_Z 17 * (0%Q * 0%Q)%Q)%Q + (rat_of_Z 51 * 0%Q)%Q)%Q +
                   rat_of_Z 39)%Q)%Q * ((rat_of_Z 2 * 0%Q)%Q + rat_of_Z 3)%Q)%Q *
                b (Posz 1))%Q)%Q)%Q *
             (((0%Q + rat_of_Z 2)%Q *
               ((0%Q + rat_of_Z 2)%Q * (0%Q + rat_of_Z 2)%Q)%Q)%Q^-1)%Q)%Q)%Q)%Q +
          (((1%Q + rat_of_Z 1)%Q *
            ((1%Q + rat_of_Z 1)%Q * (1%Q + rat_of_Z 1)%Q)%Q)%Q * 
           b (Posz 1))%Q)%Q; 0%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
_Hyp_, h' : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf2 n;
         reducebig 0 (bigopz.index_iotaz 0 (int.shift 1 (int.shift 1 n) + 1))
           (fun k : int =>
            BigBody k +%R true
              (match int.shift 1 (int.shift 1 n) with
               | Posz n1 =>
                   match k with
                   | Posz m1 => binomial_rec n1 m1 true true
                   | Negz m1 => binomial_rec n1 m1 true false
                   end
               | Negz n1 =>
                   match k with
                   | Posz m1 => binomial_rec n1 m1 false true
                   | Negz m1 => binomial_rec n1 m1 false false
                   end
               end%:~R ^ Posz 2 *
               match int.shift 1 (int.shift 1 n) + k with
               | Posz n1 =>
                   match k with
                   | Posz m1 => binomial_rec n1 m1 true true
                   | Negz m1 => binomial_rec n1 m1 true false
                   end
               | Negz n1 =>
                   match k with
                   | Posz m1 => binomial_rec n1 m1 false true
                   | Negz m1 => binomial_rec n1 m1 false false
                   end
               end%:~R ^ Posz 2 *
               (reducebig 0
                  (bigopz.index_iotaz 1 (int.shift 1 (int.shift 1 n) + 1))
                  (fun k0 : int => BigBody k0 +%R true (k0%:~R ^ Posz 3)^-1) +
                reducebig 0 (bigopz.index_iotaz 1 (k + 1))
                  (fun m : int =>
                   BigBody m +%R true
                     ((-1) ^ (m + 1) /
                      ((Posz 2)%:~R * m%:~R ^ Posz 3 *
                       match int.shift 1 (int.shift 1 n) with
                       | Posz n1 =>
                           match m with
                           | Posz m1 => binomial_rec n1 m1 true true
                           | Negz m1 => binomial_rec n1 m1 true false
                           end
                       | Negz n1 =>
                           match m with
                           | Posz m1 => binomial_rec n1 m1 false true
                           | Negz m1 => binomial_rec n1 m1 false false
                           end
                       end%:~R *
                       match int.shift 1 (int.shift 1 n) + m with
                       | Posz n1 =>
                           match m with
                           | Posz m1 => binomial_rec n1 m1 true true
                           | Negz m1 => binomial_rec n1 m1 true false
                           end
                       | Negz n1 =>
                           match m with
                           | Posz m1 => binomial_rec n1 m1 false true
                           | Negz m1 => binomial_rec n1 m1 false false
                           end
                       end%:~R)))))); annotated_recs_c.P_cf1 n;
         reducebig 0 (bigopz.index_iotaz 0 (int.shift 1 n + 1))
           (fun k : int =>
            BigBody k +%R true
              (match int.shift 1 n with
               | Posz n1 =>
                   match k with
                   | Posz m1 => binomial_rec n1 m1 true true
                   | Negz m1 => binomial_rec n1 m1 true false
                   end
               | Negz n1 =>
                   match k with
                   | Posz m1 => binomial_rec n1 m1 false true
                   | Negz m1 => binomial_rec n1 m1 false false
                   end
               end%:~R ^ Posz 2 *
               match int.shift 1 n + k with
               | Posz n1 =>
                   match k with
                   | Posz m1 => binomial_rec n1 m1 true true
                   | Negz m1 => binomial_rec n1 m1 true false
                   end
               | Negz n1 =>
                   match k with
                   | Posz m1 => binomial_rec n1 m1 false true
                   | Negz m1 => binomial_rec n1 m1 false false
                   end
               end%:~R ^ Posz 2 *
               (reducebig 0 (bigopz.index_iotaz 1 (int.shift 1 n + 1))
                  (fun k0 : int => BigBody k0 +%R true (k0%:~R ^ Posz 3)^-1) +
                reducebig 0 (bigopz.index_iotaz 1 (k + 1))
                  (fun m : int =>
                   BigBody m +%R true
                     ((-1) ^ (m + 1) /
                      ((Posz 2)%:~R * m%:~R ^ Posz 3 *
                       match int.shift 1 n with
                       | Posz n1 =>
                           match m with
                           | Posz m1 => binomial_rec n1 m1 true true
                           | Negz m1 => binomial_rec n1 m1 true false
                           end
                       | Negz n1 =>
                           match m with
                           | Posz m1 => binomial_rec n1 m1 false true
                           | Negz m1 => binomial_rec n1 m1 false false
                           end
                       end%:~R *
                       match int.shift 1 n + m with
                       | Posz n1 =>
                           match m with
                           | Posz m1 => binomial_rec n1 m1 true true
                           | Negz m1 => binomial_rec n1 m1 true false
                           end
                       | Negz n1 =>
                           match m with
                           | Posz m1 => binomial_rec n1 m1 false true
                           | Negz m1 => binomial_rec n1 m1 false false
                           end
                       end%:~R)))))); annotated_recs_c.P_cf0 n;
         reducebig 0 (bigopz.index_iotaz 0 (n + 1))
           (fun k : int =>
            BigBody k +%R true
              (match n with
               | Posz n1 =>
                   match k with
                   | Posz m1 => binomial_rec n1 m1 true true
                   | Negz m1 => binomial_rec n1 m1 true false
                   end
               | Negz n1 =>
                   match k with
                   | Posz m1 => binomial_rec n1 m1 false true
                   | Negz m1 => binomial_rec n1 m1 false false
                   end
               end%:~R ^ Posz 2 *
               match n + k with
               | Posz n1 =>
                   match k with
                   | Posz m1 => binomial_rec n1 m1 true true
                   | Negz m1 => binomial_rec n1 m1 true false
                   end
               | Negz n1 =>
                   match k with
                   | Posz m1 => binomial_rec n1 m1 false true
                   | Negz m1 => binomial_rec n1 m1 false false
                   end
               end%:~R ^ Posz 2 *
               (reducebig 0 (bigopz.index_iotaz 1 (n + 1))
                  (fun k0 : int => BigBody k0 +%R true (k0%:~R ^ Posz 3)^-1) +
                reducebig 0 (bigopz.index_iotaz 1 (k + 1))
                  (fun m : int =>
                   BigBody m +%R true
                     ((-1) ^ (m + 1) /
                      ((Posz 2)%:~R * m%:~R ^ Posz 3 *
                       match n with
                       | Posz n1 =>
                           match m with
                           | Posz m1 => binomial_rec n1 m1 true true
                           | Negz m1 => binomial_rec n1 m1 true false
                           end
                       | Negz n1 =>
                           match m with
                           | Posz m1 => binomial_rec n1 m1 false true
                           | Negz m1 => binomial_rec n1 m1 false false
                           end
                       end%:~R *
                       match n + m with
                       | Posz n1 =>
                           match m with
                           | Posz m1 => binomial_rec n1 m1 true true
                           | Negz m1 => binomial_rec n1 m1 true false
                           end
                       | Negz n1 =>
                           match m with
                           | Posz m1 => binomial_rec n1 m1 false true
                           | Negz m1 => binomial_rec n1 m1 false false
                           end
                       end%:~R))))))]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
EQ, h' : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf2 n;
         reducebig 0 (bigopz.index_iotaz 0 (int.shift 1 (int.shift 1 n) + 1))
           (fun k : int =>
            BigBody k +%R true
              (match int.shift 1 (int.shift 1 n) with
               | Posz n1 =>
                   match k with
                   | Posz m1 => binomial_rec n1 m1 true true
                   | Negz m1 => binomial_rec n1 m1 true false
                   end
               | Negz n1 =>
                   match k with
                   | Posz m1 => binomial_rec n1 m1 false true
                   | Negz m1 => binomial_rec n1 m1 false false
                   end
               end%:~R ^ Posz 2 *
               match int.shift 1 (int.shift 1 n) + k with
               | Posz n1 =>
                   match k with
                   | Posz m1 => binomial_rec n1 m1 true true
                   | Negz m1 => binomial_rec n1 m1 true false
                   end
               | Negz n1 =>
                   match k with
                   | Posz m1 => binomial_rec n1 m1 false true
                   | Negz m1 => binomial_rec n1 m1 false false
                   end
               end%:~R ^ Posz 2 *
               (reducebig 0
                  (bigopz.index_iotaz 1 (int.shift 1 (int.shift 1 n) + 1))
                  (fun k0 : int => BigBody k0 +%R true (k0%:~R ^ Posz 3)^-1) +
                reducebig 0 (bigopz.index_iotaz 1 (k + 1))
                  (fun m : int =>
                   BigBody m +%R true
                     ((-1) ^ (m + 1) /
                      ((Posz 2)%:~R * m%:~R ^ Posz 3 *
                       match int.shift 1 (int.shift 1 n) with
                       | Posz n1 =>
                           match m with
                           | Posz m1 => binomial_rec n1 m1 true true
                           | Negz m1 => binomial_rec n1 m1 true false
                           end
                       | Negz n1 =>
                           match m with
                           | Posz m1 => binomial_rec n1 m1 false true
                           | Negz m1 => binomial_rec n1 m1 false false
                           end
                       end%:~R *
                       match int.shift 1 (int.shift 1 n) + m with
                       | Posz n1 =>
                           match m with
                           | Posz m1 => binomial_rec n1 m1 true true
                           | Negz m1 => binomial_rec n1 m1 true false
                           end
                       | Negz n1 =>
                           match m with
                           | Posz m1 => binomial_rec n1 m1 false true
                           | Negz m1 => binomial_rec n1 m1 false false
                           end
                       end%:~R)))))); annotated_recs_c.P_cf1 n;
         reducebig 0 (bigopz.index_iotaz 0 (int.shift 1 n + 1))
           (fun k : int =>
            BigBody k +%R true
              (match int.shift 1 n with
               | Posz n1 =>
                   match k with
                   | Posz m1 => binomial_rec n1 m1 true true
                   | Negz m1 => binomial_rec n1 m1 true false
                   end
               | Negz n1 =>
                   match k with
                   | Posz m1 => binomial_rec n1 m1 false true
                   | Negz m1 => binomial_rec n1 m1 false false
                   end
               end%:~R ^ Posz 2 *
               match int.shift 1 n + k with
               | Posz n1 =>
                   match k with
                   | Posz m1 => binomial_rec n1 m1 true true
                   | Negz m1 => binomial_rec n1 m1 true false
                   end
               | Negz n1 =>
                   match k with
                   | Posz m1 => binomial_rec n1 m1 false true
                   | Negz m1 => binomial_rec n1 m1 false false
                   end
               end%:~R ^ Posz 2 *
               (reducebig 0 (bigopz.index_iotaz 1 (int.shift 1 n + 1))
                  (fun k0 : int => BigBody k0 +%R true (k0%:~R ^ Posz 3)^-1) +
                reducebig 0 (bigopz.index_iotaz 1 (k + 1))
                  (fun m : int =>
                   BigBody m +%R true
                     ((-1) ^ (m + 1) /
                      ((Posz 2)%:~R * m%:~R ^ Posz 3 *
                       match int.shift 1 n with
                       | Posz n1 =>
                           match m with
                           | Posz m1 => binomial_rec n1 m1 true true
                           | Negz m1 => binomial_rec n1 m1 true false
                           end
                       | Negz n1 =>
                           match m with
                           | Posz m1 => binomial_rec n1 m1 false true
                           | Negz m1 => binomial_rec n1 m1 false false
                           end
                       end%:~R *
                       match int.shift 1 n + m with
                       | Posz n1 =>
                           match m with
                           | Posz m1 => binomial_rec n1 m1 true true
                           | Negz m1 => binomial_rec n1 m1 true false
                           end
                       | Negz n1 =>
                           match m with
                           | Posz m1 => binomial_rec n1 m1 false true
                           | Negz m1 => binomial_rec n1 m1 false false
                           end
                       end%:~R)))))); annotated_recs_c.P_cf0 n;
         reducebig 0 (bigopz.index_iotaz 0 (n + 1))
           (fun k : int =>
            BigBody k +%R true
              (match n with
               | Posz n1 =>
                   match k with
                   | Posz m1 => binomial_rec n1 m1 true true
                   | Negz m1 => binomial_rec n1 m1 true false
                   end
               | Negz n1 =>
                   match k with
                   | Posz m1 => binomial_rec n1 m1 false true
                   | Negz m1 => binomial_rec n1 m1 false false
                   end
               end%:~R ^ Posz 2 *
               match n + k with
               | Posz n1 =>
                   match k with
                   | Posz m1 => binomial_rec n1 m1 true true
                   | Negz m1 => binomial_rec n1 m1 true false
                   end
               | Negz n1 =>
                   match k with
                   | Posz m1 => binomial_rec n1 m1 false true
                   | Negz m1 => binomial_rec n1 m1 false false
                   end
               end%:~R ^ Posz 2 *
               (reducebig 0 (bigopz.index_iotaz 1 (n + 1))
                  (fun k0 : int => BigBody k0 +%R true (k0%:~R ^ Posz 3)^-1) +
                reducebig 0 (bigopz.index_iotaz 1 (k + 1))
                  (fun m : int =>
                   BigBody m +%R true
                     ((-1) ^ (m + 1) /
                      ((Posz 2)%:~R * m%:~R ^ Posz 3 *
                       match n with
                       | Posz n1 =>
                           match m with
                           | Posz m1 => binomial_rec n1 m1 true true
                           | Negz m1 => binomial_rec n1 m1 true false
                           end
                       | Negz n1 =>
                           match m with
                           | Posz m1 => binomial_rec n1 m1 false true
                           | Negz m1 => binomial_rec n1 m1 false false
                           end
                       end%:~R *
                       match n + m with
                       | Posz n1 =>
                           match m with
                           | Posz m1 => binomial_rec n1 m1 true true
                           | Negz m1 => binomial_rec n1 m1 true false
                           end
                       | Negz n1 =>
                           match m with
                           | Posz m1 => binomial_rec n1 m1 false true
                           | Negz m1 => binomial_rec n1 m1 false false
                           end
                       end%:~R))))))]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
eq_uv : is_true ((0 <= n) == true)
h' : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf2 n; b (int.shift 1 (int.shift 1 n));
         annotated_recs_c.P_cf1 n; b (int.shift 1 n);
         annotated_recs_c.P_cf0 n; b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching: ((a0 + b) * (a0 ^ IH + b ^ IH) <= 2 * (a0 * a0 ^ IH + b * b ^ IH))
Crunching: ((a0 + b) * (a0 ^ IH + b ^ IH) <= 2 * (a0 * a0 ^ IH + b * b ^ IH))
Debug:
In environment
n : int
_Hyp_, h' : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf2 n; b (int.shift 1 (int.shift 1 n));
         annotated_recs_c.P_cf1 n; b (int.shift 1 n);
         annotated_recs_c.P_cf0 n; b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
_Hyp_, h' : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf2 n;
         reducebig 0 (bigopz.index_iotaz 0 (int.shift 1 (int.shift 1 n) + 1))
           (fun k : int =>
            BigBody k +%R true
              (match int.shift 1 (int.shift 1 n) with
               | Posz n1 =>
                   match k with
                   | Posz m1 => binomial_rec n1 m1 true true
                   | Negz m1 => binomial_rec n1 m1 true false
                   end
               | Negz n1 =>
                   match k with
                   | Posz m1 => binomial_rec n1 m1 false true
                   | Negz m1 => binomial_rec n1 m1 false false
                   end
               end%:~R ^ Posz 2 *
               match int.shift 1 (int.shift 1 n) + k with
               | Posz n1 =>
                   match k with
                   | Posz m1 => binomial_rec n1 m1 true true
                   | Negz m1 => binomial_rec n1 m1 true false
                   end
               | Negz n1 =>
                   match k with
                   | Posz m1 => binomial_rec n1 m1 false true
                   | Negz m1 => binomial_rec n1 m1 false false
                   end
               end%:~R ^ Posz 2 *
               (reducebig 0
                  (bigopz.index_iotaz 1 (int.shift 1 (int.shift 1 n) + 1))
                  (fun k0 : int => BigBody k0 +%R true (k0%:~R ^ Posz 3)^-1) +
                reducebig 0 (bigopz.index_iotaz 1 (k + 1))
                  (fun m : int =>
                   BigBody m +%R true
                     ((-1) ^ (m + 1) /
                      ((Posz 2)%:~R * m%:~R ^ Posz 3 *
                       match int.shift 1 (int.shift 1 n) with
                       | Posz n1 =>
                           match m with
                           | Posz m1 => binomial_rec n1 m1 true true
                           | Negz m1 => binomial_rec n1 m1 true false
                           end
                       | Negz n1 =>
                           match m with
                           | Posz m1 => binomial_rec n1 m1 false true
                           | Negz m1 => binomial_rec n1 m1 false false
                           end
                       end%:~R *
                       match int.shift 1 (int.shift 1 n) + m with
                       | Posz n1 =>
                           match m with
                           | Posz m1 => binomial_rec n1 m1 true true
                           | Negz m1 => binomial_rec n1 m1 true false
                           end
                       | Negz n1 =>
                           match m with
                           | Posz m1 => binomial_rec n1 m1 false true
                           | Negz m1 => binomial_rec n1 m1 false false
                           end
                       end%:~R)))))); annotated_recs_c.P_cf1 n;
         reducebig 0 (bigopz.index_iotaz 0 (int.shift 1 n + 1))
           (fun k : int =>
            BigBody k +%R true
              (match int.shift 1 n with
               | Posz n1 =>
                   match k with
                   | Posz m1 => binomial_rec n1 m1 true true
                   | Negz m1 => binomial_rec n1 m1 true false
                   end
               | Negz n1 =>
                   match k with
                   | Posz m1 => binomial_rec n1 m1 false true
                   | Negz m1 => binomial_rec n1 m1 false false
                   end
               end%:~R ^ Posz 2 *
               match int.shift 1 n + k with
               | Posz n1 =>
                   match k with
                   | Posz m1 => binomial_rec n1 m1 true true
                   | Negz m1 => binomial_rec n1 m1 true false
                   end
               | Negz n1 =>
                   match k with
                   | Posz m1 => binomial_rec n1 m1 false true
                   | Negz m1 => binomial_rec n1 m1 false false
                   end
               end%:~R ^ Posz 2 *
               (reducebig 0 (bigopz.index_iotaz 1 (int.shift 1 n + 1))
                  (fun k0 : int => BigBody k0 +%R true (k0%:~R ^ Posz 3)^-1) +
                reducebig 0 (bigopz.index_iotaz 1 (k + 1))
                  (fun m : int =>
                   BigBody m +%R true
                     ((-1) ^ (m + 1) /
                      ((Posz 2)%:~R * m%:~R ^ Posz 3 *
                       match int.shift 1 n with
                       | Posz n1 =>
                           match m with
                           | Posz m1 => binomial_rec n1 m1 true true
                           | Negz m1 => binomial_rec n1 m1 true false
                           end
                       | Negz n1 =>
                           match m with
                           | Posz m1 => binomial_rec n1 m1 false true
                           | Negz m1 => binomial_rec n1 m1 false false
                           end
                       end%:~R *
                       match int.shift 1 n + m with
                       | Posz n1 =>
                           match m with
                           | Posz m1 => binomial_rec n1 m1 true true
                           | Negz m1 => binomial_rec n1 m1 true false
                           end
                       | Negz n1 =>
                           match m with
                           | Posz m1 => binomial_rec n1 m1 false true
                           | Negz m1 => binomial_rec n1 m1 false false
                           end
                       end%:~R)))))); annotated_recs_c.P_cf0 n;
         reducebig 0 (bigopz.index_iotaz 0 (n + 1))
           (fun k : int =>
            BigBody k +%R true
              (match n with
               | Posz n1 =>
                   match k with
                   | Posz m1 => binomial_rec n1 m1 true true
                   | Negz m1 => binomial_rec n1 m1 true false
                   end
               | Negz n1 =>
                   match k with
                   | Posz m1 => binomial_rec n1 m1 false true
                   | Negz m1 => binomial_rec n1 m1 false false
                   end
               end%:~R ^ Posz 2 *
               match n + k with
               | Posz n1 =>
                   match k with
                   | Posz m1 => binomial_rec n1 m1 true true
                   | Negz m1 => binomial_rec n1 m1 true false
                   end
               | Negz n1 =>
                   match k with
                   | Posz m1 => binomial_rec n1 m1 false true
                   | Negz m1 => binomial_rec n1 m1 false false
                   end
               end%:~R ^ Posz 2 *
               (reducebig 0 (bigopz.index_iotaz 1 (n + 1))
                  (fun k0 : int => BigBody k0 +%R true (k0%:~R ^ Posz 3)^-1) +
                reducebig 0 (bigopz.index_iotaz 1 (k + 1))
                  (fun m : int =>
                   BigBody m +%R true
                     ((-1) ^ (m + 1) /
                      ((Posz 2)%:~R * m%:~R ^ Posz 3 *
                       match n with
                       | Posz n1 =>
                           match m with
                           | Posz m1 => binomial_rec n1 m1 true true
                           | Negz m1 => binomial_rec n1 m1 true false
                           end
                       | Negz n1 =>
                           match m with
                           | Posz m1 => binomial_rec n1 m1 false true
                           | Negz m1 => binomial_rec n1 m1 false false
                           end
                       end%:~R *
                       match n + m with
                       | Posz n1 =>
                           match m with
                           | Posz m1 => binomial_rec n1 m1 true true
                           | Negz m1 => binomial_rec n1 m1 true false
                           end
                       | Negz n1 =>
                           match m with
                           | Posz m1 => binomial_rec n1 m1 false true
                           | Negz m1 => binomial_rec n1 m1 false false
                           end
                       end%:~R))))))]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching: (forall y : nat, (y < 2 ^ l)%nat -> fst l (H'1 * 2 ^ l + y) = H'1)
Debug:
In environment
n : int
pn, h' : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf2 n;
         reducebig 0 (bigopz.index_iotaz 0 (int.shift 1 (int.shift 1 n) + 1))
           (fun k : int =>
            BigBody k +%R true
              (match int.shift 1 (int.shift 1 n) with
               | Posz n1 =>
                   match k with
                   | Posz m1 => binomial_rec n1 m1 true true
                   | Negz m1 => binomial_rec n1 m1 true false
                   end
               | Negz n1 =>
                   match k with
                   | Posz m1 => binomial_rec n1 m1 false true
                   | Negz m1 => binomial_rec n1 m1 false false
                   end
               end%:~R ^ Posz 2 *
               match int.shift 1 (int.shift 1 n) + k with
               | Posz n1 =>
                   match k with
                   | Posz m1 => binomial_rec n1 m1 true true
                   | Negz m1 => binomial_rec n1 m1 true false
                   end
               | Negz n1 =>
                   match k with
                   | Posz m1 => binomial_rec n1 m1 false true
                   | Negz m1 => binomial_rec n1 m1 false false
                   end
               end%:~R ^ Posz 2 *
               (reducebig 0
                  (bigopz.index_iotaz 1 (int.shift 1 (int.shift 1 n) + 1))
                  (fun k0 : int => BigBody k0 +%R true (k0%:~R ^ Posz 3)^-1) +
                reducebig 0 (bigopz.index_iotaz 1 (k + 1))
                  (fun m : int =>
                   BigBody m +%R true
                     ((-1) ^ (m + 1) /
                      ((Posz 2)%:~R * m%:~R ^ Posz 3 *
                       match int.shift 1 (int.shift 1 n) with
                       | Posz n1 =>
                           match m with
                           | Posz m1 => binomial_rec n1 m1 true true
                           | Negz m1 => binomial_rec n1 m1 true false
                           end
                       | Negz n1 =>
                           match m with
                           | Posz m1 => binomial_rec n1 m1 false true
                           | Negz m1 => binomial_rec n1 m1 false false
                           end
                       end%:~R *
                       match int.shift 1 (int.shift 1 n) + m with
                       | Posz n1 =>
                           match m with
                           | Posz m1 => binomial_rec n1 m1 true true
                           | Negz m1 => binomial_rec n1 m1 true false
                           end
                       | Negz n1 =>
                           match m with
                           | Posz m1 => binomial_rec n1 m1 false true
                           | Negz m1 => binomial_rec n1 m1 false false
                           end
                       end%:~R)))))); annotated_recs_c.P_cf1 n;
         reducebig 0 (bigopz.index_iotaz 0 (int.shift 1 n + 1))
           (fun k : int =>
            BigBody k +%R true
              (match int.shift 1 n with
               | Posz n1 =>
                   match k with
                   | Posz m1 => binomial_rec n1 m1 true true
                   | Negz m1 => binomial_rec n1 m1 true false
                   end
               | Negz n1 =>
                   match k with
                   | Posz m1 => binomial_rec n1 m1 false true
                   | Negz m1 => binomial_rec n1 m1 false false
                   end
               end%:~R ^ Posz 2 *
               match int.shift 1 n + k with
               | Posz n1 =>
                   match k with
                   | Posz m1 => binomial_rec n1 m1 true true
                   | Negz m1 => binomial_rec n1 m1 true false
                   end
               | Negz n1 =>
                   match k with
                   | Posz m1 => binomial_rec n1 m1 false true
                   | Negz m1 => binomial_rec n1 m1 false false
                   end
               end%:~R ^ Posz 2 *
               (reducebig 0 (bigopz.index_iotaz 1 (int.shift 1 n + 1))
                  (fun k0 : int => BigBody k0 +%R true (k0%:~R ^ Posz 3)^-1) +
                reducebig 0 (bigopz.index_iotaz 1 (k + 1))
                  (fun m : int =>
                   BigBody m +%R true
                     ((-1) ^ (m + 1) /
                      ((Posz 2)%:~R * m%:~R ^ Posz 3 *
                       match int.shift 1 n with
                       | Posz n1 =>
                           match m with
                           | Posz m1 => binomial_rec n1 m1 true true
                           | Negz m1 => binomial_rec n1 m1 true false
                           end
                       | Negz n1 =>
                           match m with
                           | Posz m1 => binomial_rec n1 m1 false true
                           | Negz m1 => binomial_rec n1 m1 false false
                           end
                       end%:~R *
                       match int.shift 1 n + m with
                       | Posz n1 =>
                           match m with
                           | Posz m1 => binomial_rec n1 m1 true true
                           | Negz m1 => binomial_rec n1 m1 true false
                           end
                       | Negz n1 =>
                           match m with
                           | Posz m1 => binomial_rec n1 m1 false true
                           | Negz m1 => binomial_rec n1 m1 false false
                           end
                       end%:~R)))))); annotated_recs_c.P_cf0 n;
         reducebig 0 (bigopz.index_iotaz 0 (n + 1))
           (fun k : int =>
            BigBody k +%R true
              (match n with
               | Posz n1 =>
                   match k with
                   | Posz m1 => binomial_rec n1 m1 true true
                   | Negz m1 => binomial_rec n1 m1 true false
                   end
               | Negz n1 =>
                   match k with
                   | Posz m1 => binomial_rec n1 m1 false true
                   | Negz m1 => binomial_rec n1 m1 false false
                   end
               end%:~R ^ Posz 2 *
               match n + k with
               | Posz n1 =>
                   match k with
                   | Posz m1 => binomial_rec n1 m1 true true
                   | Negz m1 => binomial_rec n1 m1 true false
                   end
               | Negz n1 =>
                   match k with
                   | Posz m1 => binomial_rec n1 m1 false true
                   | Negz m1 => binomial_rec n1 m1 false false
                   end
               end%:~R ^ Posz 2 *
               (reducebig 0 (bigopz.index_iotaz 1 (n + 1))
                  (fun k0 : int => BigBody k0 +%R true (k0%:~R ^ Posz 3)^-1) +
                reducebig 0 (bigopz.index_iotaz 1 (k + 1))
                  (fun m : int =>
                   BigBody m +%R true
                     ((-1) ^ (m + 1) /
                      ((Posz 2)%:~R * m%:~R ^ Posz 3 *
                       match n with
                       | Posz n1 =>
                           match m with
                           | Posz m1 => binomial_rec n1 m1 true true
                           | Negz m1 => binomial_rec n1 m1 true false
                           end
                       | Negz n1 =>
                           match m with
                           | Posz m1 => binomial_rec n1 m1 false true
                           | Negz m1 => binomial_rec n1 m1 false false
                           end
                       end%:~R *
                       match n + m with
                       | Posz n1 =>
                           match m with
                           | Posz m1 => binomial_rec n1 m1 true true
                           | Negz m1 => binomial_rec n1 m1 true false
                           end
                       | Negz n1 =>
                           match m with
                           | Posz m1 => binomial_rec n1 m1 false true
                           | Negz m1 => binomial_rec n1 m1 false false
                           end
                       end%:~R))))))]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
EQ, h' : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf2 n; b (int.shift 1 (int.shift 1 n));
         annotated_recs_c.P_cf1 n; b (int.shift 1 n);
         annotated_recs_c.P_cf0 n; b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
EQ, h' : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf2 n;
         reducebig 0 (bigopz.index_iotaz 0 (int.shift 1 (int.shift 1 n) + 1))
           (fun k : int =>
            BigBody k +%R true
              (match int.shift 1 (int.shift 1 n) with
               | Posz n1 =>
                   match k with
                   | Posz m1 => binomial_rec n1 m1 true true
                   | Negz m1 => binomial_rec n1 m1 true false
                   end
               | Negz n1 =>
                   match k with
                   | Posz m1 => binomial_rec n1 m1 false true
                   | Negz m1 => binomial_rec n1 m1 false false
                   end
               end%:~R ^ Posz 2 *
               match int.shift 1 (int.shift 1 n) + k with
               | Posz n1 =>
                   match k with
                   | Posz m1 => binomial_rec n1 m1 true true
                   | Negz m1 => binomial_rec n1 m1 true false
                   end
               | Negz n1 =>
                   match k with
                   | Posz m1 => binomial_rec n1 m1 false true
                   | Negz m1 => binomial_rec n1 m1 false false
                   end
               end%:~R ^ Posz 2 *
               (reducebig 0
                  (bigopz.index_iotaz 1 (int.shift 1 (int.shift 1 n) + 1))
                  (fun k0 : int => BigBody k0 +%R true (k0%:~R ^ Posz 3)^-1) +
                reducebig 0 (bigopz.index_iotaz 1 (k + 1))
                  (fun m : int =>
                   BigBody m +%R true
                     ((-1) ^ (m + 1) /
                      ((Posz 2)%:~R * m%:~R ^ Posz 3 *
                       match int.shift 1 (int.shift 1 n) with
                       | Posz n1 =>
                           match m with
                           | Posz m1 => binomial_rec n1 m1 true true
                           | Negz m1 => binomial_rec n1 m1 true false
                           end
                       | Negz n1 =>
                           match m with
                           | Posz m1 => binomial_rec n1 m1 false true
                           | Negz m1 => binomial_rec n1 m1 false false
                           end
                       end%:~R *
                       match int.shift 1 (int.shift 1 n) + m with
                       | Posz n1 =>
                           match m with
                           | Posz m1 => binomial_rec n1 m1 true true
                           | Negz m1 => binomial_rec n1 m1 true false
                           end
                       | Negz n1 =>
                           match m with
                           | Posz m1 => binomial_rec n1 m1 false true
                           | Negz m1 => binomial_rec n1 m1 false false
                           end
                       end%:~R)))))); annotated_recs_c.P_cf1 n;
         reducebig 0 (bigopz.index_iotaz 0 (int.shift 1 n + 1))
           (fun k : int =>
            BigBody k +%R true
              (match int.shift 1 n with
               | Posz n1 =>
                   match k with
                   | Posz m1 => binomial_rec n1 m1 true true
                   | Negz m1 => binomial_rec n1 m1 true false
                   end
               | Negz n1 =>
                   match k with
                   | Posz m1 => binomial_rec n1 m1 false true
                   | Negz m1 => binomial_rec n1 m1 false false
                   end
               end%:~R ^ Posz 2 *
               match int.shift 1 n + k with
               | Posz n1 =>
                   match k with
                   | Posz m1 => binomial_rec n1 m1 true true
                   | Negz m1 => binomial_rec n1 m1 true false
                   end
               | Negz n1 =>
                   match k with
                   | Posz m1 => binomial_rec n1 m1 false true
                   | Negz m1 => binomial_rec n1 m1 false false
                   end
               end%:~R ^ Posz 2 *
               (reducebig 0 (bigopz.index_iotaz 1 (int.shift 1 n + 1))
                  (fun k0 : int => BigBody k0 +%R true (k0%:~R ^ Posz 3)^-1) +
                reducebig 0 (bigopz.index_iotaz 1 (k + 1))
                  (fun m : int =>
                   BigBody m +%R true
                     ((-1) ^ (m + 1) /
                      ((Posz 2)%:~R * m%:~R ^ Posz 3 *
                       match int.shift 1 n with
                       | Posz n1 =>
                           match m with
                           | Posz m1 => binomial_rec n1 m1 true true
                           | Negz m1 => binomial_rec n1 m1 true false
                           end
                       | Negz n1 =>
                           match m with
                           | Posz m1 => binomial_rec n1 m1 false true
                           | Negz m1 => binomial_rec n1 m1 false false
                           end
                       end%:~R *
                       match int.shift 1 n + m with
                       | Posz n1 =>
                           match m with
                           | Posz m1 => binomial_rec n1 m1 true true
                           | Negz m1 => binomial_rec n1 m1 true false
                           end
                       | Negz n1 =>
                           match m with
                           | Posz m1 => binomial_rec n1 m1 false true
                           | Negz m1 => binomial_rec n1 m1 false false
                           end
                       end%:~R)))))); annotated_recs_c.P_cf0 n;
         reducebig 0 (bigopz.index_iotaz 0 (n + 1))
           (fun k : int =>
            BigBody k +%R true
              (match n with
               | Posz n1 =>
                   match k with
                   | Posz m1 => binomial_rec n1 m1 true true
                   | Negz m1 => binomial_rec n1 m1 true false
                   end
               | Negz n1 =>
                   match k with
                   | Posz m1 => binomial_rec n1 m1 false true
                   | Negz m1 => binomial_rec n1 m1 false false
                   end
               end%:~R ^ Posz 2 *
               match n + k with
               | Posz n1 =>
                   match k with
                   | Posz m1 => binomial_rec n1 m1 true true
                   | Negz m1 => binomial_rec n1 m1 true false
                   end
               | Negz n1 =>
                   match k with
                   | Posz m1 => binomial_rec n1 m1 false true
                   | Negz m1 => binomial_rec n1 m1 false false
                   end
               end%:~R ^ Posz 2 *
               (reducebig 0 (bigopz.index_iotaz 1 (n + 1))
                  (fun k0 : int => BigBody k0 +%R true (k0%:~R ^ Posz 3)^-1) +
                reducebig 0 (bigopz.index_iotaz 1 (k + 1))
                  (fun m : int =>
                   BigBody m +%R true
                     ((-1) ^ (m + 1) /
                      ((Posz 2)%:~R * m%:~R ^ Posz 3 *
                       match n with
                       | Posz n1 =>
                           match m with
                           | Posz m1 => binomial_rec n1 m1 true true
                           | Negz m1 => binomial_rec n1 m1 true false
                           end
                       | Negz n1 =>
                           match m with
                           | Posz m1 => binomial_rec n1 m1 false true
                           | Negz m1 => binomial_rec n1 m1 false false
                           end
                       end%:~R *
                       match n + m with
                       | Posz n1 =>
                           match m with
                           | Posz m1 => binomial_rec n1 m1 true true
                           | Negz m1 => binomial_rec n1 m1 true false
                           end
                       | Negz n1 =>
                           match m with
                           | Posz m1 => binomial_rec n1 m1 false true
                           | Negz m1 => binomial_rec n1 m1 false false
                           end
                       end%:~R))))))]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
eq_uv : is_true ((0 <= n) == true)
h' : is_true (0 <= n)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l =
     [:: annotated_recs_c.P_cf2 n; b (int.shift 1 (int.shift 1 n));
         annotated_recs_c.P_cf1 n; b (int.shift 1 n);
         annotated_recs_c.P_cf0 n; b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n : int
eq_uv : is_true ((0 <= n) == true)
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : GRing.Zmodule.sort
         (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
one : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
add : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
mul : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
sub : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
opp : GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType)) ->
      GRing.Zmodule.sort
        (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
Feqb : rel
         (Equality.sort
            (GRing.Zmodule.eqType
               (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))))
F_of_nat : nat ->
           GRing.Zmodule.sort
             (GRing.Ring.zmodType (Num.NumField.ringType rat_numFieldType))
exp : GRing.Ring.sort (Num.NumField.ringType rat_numFieldType) ->
      nat -> GRing.Ring.sort (Num.NumField.ringType rat_numFieldType)
l : seq (Num.NumField.sort rat_numFieldType)
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub =
       (fun
          x
           y : GRing.Zmodule.sort
                 (GRing.Ring.zmodType
                    (Num.NumField.ringType rat_numFieldType)) => 
        x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=Num.NumField.ringType rat_numFieldType)
lE : l = [:: n%:~R; b (int.shift 1 (int.shift 1 n)); b (int.shift 1 n); b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching:
((forall z : R, cond_positivity z = true <-> 0 <= z) ->
 match
   (fix pow (n m : nat) {struct m} : nat :=
      match m with
      | 0%nat => 1%nat
      | S m0 =>
          (fix mul (n0 m1 : nat) {struct n0} : nat :=
             match n0 with
             | 0%nat => 0%nat
             | S p =>
                 (fix add (n1 m2 : nat) {struct n1} : nat :=
                    match n1 with
                    | 0%nat => m2
                    | S p0 => S (add p0 m2)
                    end) m1 (mul p m1)
             end) n (pow n m0)
      end) 2%nat LE
 with
 | 0%nat =>
     (fix add (n m : nat) {struct n} : nat :=
        match n with
        | 0%nat => m
        | S p => S (add p m)
        end)
       ((fix mul (n m : nat) {struct n} : nat :=
           match n with
           | 0%nat => 0%nat
           | S p =>
               (fix add (n0 m0 : nat) {struct n0} : nat :=
                  match n0 with
                  | 0%nat => m0
                  | S p0 => S (add p0 m0)
                  end) m (mul p m)
           end) EQ
          ((fix pow (n m : nat) {struct m} : nat :=
              match m with
              | 0%nat => 1%nat
              | S m0 =>
                  (fix mul (n0 m1 : nat) {struct n0} : nat :=
                     match n0 with
                     | 0%nat => 0%nat
                     | S p =>
                         (fix add (n1 m2 : nat) {struct n1} : nat :=
                            match n1 with
                            | 0%nat => m2
                            | S p0 => S (add p0 m2)
                            end) m1 (mul p m1)
                     end) n (pow n m0)
              end) 2%nat LE)) a
 | S y' =>
     (fix sub (n m : nat) {struct n} : nat :=
        match n with
        | 0%nat => n
        | S k => match m with
                 | 0%nat => n
                 | S l => sub k l
                 end
        end) y'
       (let (_, y) :=
          (fix divmod (x y q u : nat) {struct x} : nat * nat :=
             match x with
             | 0%nat => (q, u)
             | S x' =>
                 match u with
                 | 0%nat => divmod x' y (S q) y
                 | S u' => divmod x' y q u'
                 end
             end)
            ((fix add (n m : nat) {struct n} : nat :=
                match n with
                | 0%nat => m
                | S p => S (add p m)
                end)
               ((fix mul (n m : nat) {struct n} : nat :=
                   match n with
                   | 0%nat => 0%nat
                   | S p =>
                       (fix add (n0 m0 : nat) {struct n0} : nat :=
                          match n0 with
                          | 0%nat => m0
                          | S p0 => S (add p0 m0)
                          end) m (mul p m)
                   end) EQ
                  ((fix pow (n m : nat) {struct m} : nat :=
                      match m with
                      | 0%nat => 1%nat
                      | S m0 =>
                          (fix mul (n0 m1 : nat) {struct n0} : nat :=
                             match n0 with
                             | 0%nat => 0%nat
                             | S p =>
                                 (fix add (n1 m2 : nat) {struct n1} : nat :=
                                    match n1 with
                                    | 0%nat => m2
                                    | S p0 => S (add p0 m2)
                                    end) m1 (mul p m1)
                             end) n (pow n m0)
                      end) 2%nat LE)) a) y' 0%nat y' in
        y)
 end = a)
Crunching: (Rabs (H0 - H) < Rmin H1 n -> H - H1 <= H0 <= H + n)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (snd h (H6 * 2 ^ h + H1) = H1)
Crunching:
((forall z : R, cond_positivity z = true <-> 0 <= z) ->
 match
   (fix pow (n m : nat) {struct m} : nat :=
      match m with
      | 0%nat => 1%nat
      | S m0 =>
          (fix mul (n0 m1 : nat) {struct n0} : nat :=
             match n0 with
             | 0%nat => 0%nat
             | S p =>
                 (fix add (n1 m2 : nat) {struct n1} : nat :=
                    match n1 with
                    | 0%nat => m2
                    | S p0 => S (add p0 m2)
                    end) m1 (mul p m1)
             end) n (pow n m0)
      end) 2%nat LE
 with
 | 0%nat =>
     (fix add (n m : nat) {struct n} : nat :=
        match n with
        | 0%nat => m
        | S p => S (add p m)
        end)
       ((fix mul (n m : nat) {struct n} : nat :=
           match n with
           | 0%nat => 0%nat
           | S p =>
               (fix add (n0 m0 : nat) {struct n0} : nat :=
                  match n0 with
                  | 0%nat => m0
                  | S p0 => S (add p0 m0)
                  end) m (mul p m)
           end) EQ
          ((fix pow (n m : nat) {struct m} : nat :=
              match m with
              | 0%nat => 1%nat
              | S m0 =>
                  (fix mul (n0 m1 : nat) {struct n0} : nat :=
                     match n0 with
                     | 0%nat => 0%nat
                     | S p =>
                         (fix add (n1 m2 : nat) {struct n1} : nat :=
                            match n1 with
                            | 0%nat => m2
                            | S p0 => S (add p0 m2)
                            end) m1 (mul p m1)
                     end) n (pow n m0)
              end) 2%nat LE)) a
 | S y' =>
     (fix sub (n m : nat) {struct n} : nat :=
        match n with
        | 0%nat => n
        | S k => match m with
                 | 0%nat => n
                 | S l => sub k l
                 end
        end) y'
       (let (_, y) :=
          (fix divmod (x y q u : nat) {struct x} : nat * nat :=
             match x with
             | 0%nat => (q, u)
             | S x' =>
                 match u with
                 | 0%nat => divmod x' y (S q) y
                 | S u' => divmod x' y q u'
                 end
             end)
            ((fix add (n m : nat) {struct n} : nat :=
                match n with
                | 0%nat => m
                | S p => S (add p m)
                end)
               ((fix mul (n m : nat) {struct n} : nat :=
                   match n with
                   | 0%nat => 0%nat
                   | S p =>
                       (fix add (n0 m0 : nat) {struct n0} : nat :=
                          match n0 with
                          | 0%nat => m0
                          | S p0 => S (add p0 m0)
                          end) m (mul p m)
                   end) EQ
                  ((fix pow (n m : nat) {struct m} : nat :=
                      match m with
                      | 0%nat => 1%nat
                      | S m0 =>
                          (fix mul (n0 m1 : nat) {struct n0} : nat :=
                             match n0 with
                             | 0%nat => 0%nat
                             | S p =>
                                 (fix add (n1 m2 : nat) {struct n1} : nat :=
                                    match n1 with
                                    | 0%nat => m2
                                    | S p0 => S (add p0 m2)
                                    end) m1 (mul p m1)
                             end) n (pow n m0)
                      end) 2%nat LE)) a) y' 0%nat y' in
        y)
 end = a)
Crunching: False
Crunching: (Rabs (H0 - H) < Rmin H1 n -> H - H1 <= H0 <= H + n)
Crunching: (Rabs (H0 - H) < Rmin H1 n -> H - H1 <= H0 <= H + n)
Crunching:
(forall y lb ub : nat,
 lb <= l <= ub /\ lb <= y <= ub -> lb <= (l + y) / 2 <= ub)
Crunching: False
Crunching:
((2 * big_sum (fun i : nat => nth i (scale x l) 0) (length (scale x l)))%R =
 (2 * (x * big_sum (fun i : nat => nth i l 0) (length l)))%R)
Crunching:
((2 * big_sum (fun i : nat => nth i (scale x l) 0) (length (scale x l)))%R =
 (2 * (x * big_sum (fun i : nat => nth i l 0) (length l)))%R)
Crunching: False
Crunching:
((forall n : nat, fact n + n * fact n = fact n + n * fact n) ->
 length (nat_to_binlist len n) = len)
Crunching:
((2 * big_sum (fun i : nat => nth i (scale x l) 0) (length (scale x l)))%R =
 (2 * (x * big_sum (fun i : nat => nth i l 0) (length l)))%R)
Crunching:
((2 * big_sum (fun i : nat => nth i (scale x l) 0) (length (scale x l)))%R =
 (2 * (x * big_sum (fun i : nat => nth i l 0) (length l)))%R)
Crunching:
((2 * big_sum (fun i : nat => nth i (scale x l) 0) (length (scale x l)))%R =
 (2 * (x * big_sum (fun i : nat => nth i l 0) (length l)))%R)
Crunching:
((2 * big_sum (fun i : nat => nth i (scale x l) 0) (length (scale x l)))%R =
 (2 * (x * big_sum (fun i : nat => nth i l 0) (length l)))%R)
Crunching:
((2 * big_sum (fun i : nat => nth i (scale x l) 0) (length (scale x l)))%R =
 (2 * (x * big_sum (fun i : nat => nth i l 0) (length l)))%R)
Crunching:
((2 * big_sum (fun i : nat => nth i (scale x l) 0) (length (scale x l)))%R =
 (2 * (x * big_sum (fun i : nat => nth i l 0) (length l)))%R)
Crunching:
((2 * big_sum (fun i : nat => nth i (scale x l) 0) (length (scale x l)))%R =
 (2 * (x * big_sum (fun i : nat => nth i l 0) (length l)))%R)
Crunching:
((2 * big_sum (fun i : nat => nth i (scale x l) 0) (length (scale x l)))%R =
 (2 * (x * big_sum (fun i : nat => nth i l 0) (length l)))%R)
Crunching:
((2 * big_sum (fun i : nat => nth i (scale x l) 0) (length (scale x l)))%R =
 (2 * (x * big_sum (fun i : nat => nth i l 0) (length l)))%R)
Crunching:
((2 * big_sum (fun i : nat => nth i (scale x l) 0) (length (scale x l)))%R =
 (2 * (x * big_sum (fun i : nat => nth i l 0) (length l)))%R)
Crunching:
((2 * big_sum (fun i : nat => nth i (scale x l) 0) (length (scale x l)))%R =
 (2 * (x * big_sum (fun i : nat => nth i l 0) (length l)))%R)
Crunching:
((2 * big_sum (fun i : nat => nth i (scale x l) 0) (length (scale x l)))%R =
 (2 * (x * big_sum (fun i : nat => nth i l 0) (length l)))%R)
Crunching: (continuity_pt atan 1)
Crunching: (length (nat_to_binlist k pk) = k)
Crunching:
(forall l : list R, sum_over_list (scale H6 l) = (H6 * sum_over_list l)%R)
Crunching:
(forall l : list R, sum_over_list (scale H6 l) = (H6 * sum_over_list l)%R)
Crunching:
(forall l : list R, sum_over_list (scale H6 l) = (H6 * sum_over_list l)%R)
Crunching: (sum_over_list (scale H6 Hn) = (H6 * sum_over_list Hn)%R)
Crunching:
(forall l : list R, sum_over_list (scale H6 l) = (H6 * sum_over_list l)%R)
Crunching:
(forall (f : nat -> bool) (dim : nat) (b : bool) (n : nat),
 dim <= n -> funbool_to_list dim (update f n b) = funbool_to_list dim f)
Crunching: (0 < 2)
Crunching:
(forall l : list R, sum_over_list (scale H6 l) = (H6 * sum_over_list l)%R)
Crunching:
(cos_in 0 (cos 0) ->
 funbool_to_list dim (update f n b) = funbool_to_list dim f)
Crunching:
(big_sum (fun i : nat => nth i (scale RS' n) 0) (length (scale RS' n)) <
 RS' * big_sum (fun i : nat => nth i n 0) (length n))
Crunching: (funbool_to_list r (update m n b) = funbool_to_list r m)
Crunching:
(forall (f : nat -> bool) (dim : nat) (b : bool) (n : nat),
 dim <= n -> funbool_to_list dim (update f n b) = funbool_to_list dim f)
Crunching:
(cos_in 0 (cos 0) ->
 funbool_to_list dim (update f n b) = funbool_to_list dim f)
Crunching: (funbool_to_list r (update q 0 b) = funbool_to_list r q)
Crunching: (funbool_to_list r (update m n b) = funbool_to_list r m)
Crunching:
(r <= c -> funbool_to_list r (update q c He) = funbool_to_list r q)
Crunching:
(forall (f : nat -> bool) (dim : nat) (b : bool) (n : nat),
 dim <= n -> funbool_to_list dim (update f n b) = funbool_to_list dim f)
Debug:
In environment
x : rat
le0i : 0 <= x
rhs := delta (x + 1) - delta x : rat_numDomainType
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: delta (x + 1); delta x; x]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             (add
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 2)) zero))
       (negb_
          (Feqb
             (add
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 3)) zero)))" (cannot unify 
"false" and "true").
Debug:
In environment
x : rat
le0i : 0 <= x
rhs := delta (x + 1) - delta x : rat_numDomainType
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: delta (x + 1); delta x; x]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type
 "false = true /\
  is_true_
    (andb_
       (negb_
          (Feqb
             (add
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 2)) zero))
       (negb_
          (Feqb
             (add
                match
                  match match l with
                        | [::] => [::]
                        | _ :: x0 => x0
                        end with
                  | [::] => [::]
                  | _ :: x0 => x0
                  end
                with
                | [::] => zero
                | x :: _ => x
                end (F_of_nat 3)) zero)))" (cannot unify 
"false" and "true").
Crunching:
((fix big_sum (G : Type) (H : Monoid G) (f : nat -> G) (n : nat) {struct n} :
      G :=
    match n with
    | 0%nat => let (Gzero, Gplus, _, _, _) := H in Gzero
    | S n' =>
        (let (Gzero, Gplus, _, _, _) := H in Gplus) (big_sum G H f n') (f n')
    end) R
   {|
     Gzero := R0;
     Gplus := Rplus;
     Gplus_0_l :=
       fun g : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEc (RMicromega.CZ 0)) (EnvRing.PEX 1);
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs := EnvRing.PEX 1
            |} ()) [] eq_refl (fun _ : positive => g);
     Gplus_0_r :=
       fun g : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEc (RMicromega.CZ 0));
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs := EnvRing.PEX 1
            |} ()) [] eq_refl (fun _ : positive => g);
     Gplus_assoc :=
       fun g h i : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEX 1)
                  (EnvRing.PEadd (EnvRing.PEX 2) (EnvRing.PEX 3));
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs :=
                EnvRing.PEadd (EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEX 2))
                  (EnvRing.PEX 3)
            |} ()) [] eq_refl
         (fun p : positive =>
          match p with
          | (_~1)%positive => i
          | (_~0)%positive => h
          | 1%positive => g
          end)
   |}
   (fun i : nat =>
    (fix nth (n : nat) (l : list R) (default : R) {struct l} : R :=
       match n with
       | 0%nat => match l with
                  | [] => default
                  | x :: _ => x
                  end
       | S m => match l with
                | [] => default
                | _ :: t => nth m t default
                end
       end) i
      match l with
      | [] => []
      | a :: l =>
          a
          :: (fix firstn (n : nat) (l0 : list R) {struct n} : list R :=
                match n with
                | 0%nat => []
                | S n0 =>
                    match l0 with
                    | [] => []
                    | a0 :: l1 => a0 :: firstn n0 l1
                    end
                end) n l
      end R0)
   ((fix length (l : list R) : nat :=
       match l with
       | [] => 0%nat
       | _ :: l' => S (length l')
       end)
      match l with
      | [] => []
      | a :: l =>
          a
          :: (fix firstn (n : nat) (l0 : list R) {struct n} : list R :=
                match n with
                | 0%nat => []
                | S n0 =>
                    match l0 with
                    | [] => []
                    | a0 :: l1 => a0 :: firstn n0 l1
                    end
                end) n l
      end) =
 ((fix big_sum
     (G : Type) (H : Monoid G) (f : nat -> G) (n : nat) {struct n} : G :=
     match n with
     | 0%nat => let (Gzero, Gplus, _, _, _) := H in Gzero
     | S n' =>
         (let (Gzero, Gplus, _, _, _) := H in Gplus) 
           (big_sum G H f n') (f n')
     end) R
    {|
      Gzero := R0;
      Gplus := Rplus;
      Gplus_0_l :=
        fun g : R =>
        RMicromega.RTautoChecker_sound
          (Tauto.A Tauto.isProp
             {|
               RingMicromega.Flhs :=
                 EnvRing.PEadd (EnvRing.PEc (RMicromega.CZ 0))
                   (EnvRing.PEX 1);
               RingMicromega.Fop := RingMicromega.OpEq;
               RingMicromega.Frhs := EnvRing.PEX 1
             |} ()) [] eq_refl (fun _ : positive => g);
      Gplus_0_r :=
        fun g : R =>
        RMicromega.RTautoChecker_sound
          (Tauto.A Tauto.isProp
             {|
               RingMicromega.Flhs :=
                 EnvRing.PEadd (EnvRing.PEX 1)
                   (EnvRing.PEc (RMicromega.CZ 0));
               RingMicromega.Fop := RingMicromega.OpEq;
               RingMicromega.Frhs := EnvRing.PEX 1
             |} ()) [] eq_refl (fun _ : positive => g);
      Gplus_assoc :=
        fun g h i : R =>
        RMicromega.RTautoChecker_sound
          (Tauto.A Tauto.isProp
             {|
               RingMicromega.Flhs :=
                 EnvRing.PEadd (EnvRing.PEX 1)
                   (EnvRing.PEadd (EnvRing.PEX 2) (EnvRing.PEX 3));
               RingMicromega.Fop := RingMicromega.OpEq;
               RingMicromega.Frhs :=
                 EnvRing.PEadd
                   (EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEX 2))
                   (EnvRing.PEX 3)
             |} ()) [] eq_refl
          (fun p : positive =>
           match p with
           | (_~1)%positive => i
           | (_~0)%positive => h
           | 1%positive => g
           end)
    |}
    (fun i : nat =>
     (fix nth (n : nat) (l : list R) (default : R) {struct l} : R :=
        match n with
        | 0%nat => match l with
                   | [] => default
                   | x :: _ => x
                   end
        | S m => match l with
                 | [] => default
                 | _ :: t => nth m t default
                 end
        end) i
       ((fix firstn (n : nat) (l : list R) {struct n} : list R :=
           match n with
           | 0%nat => []
           | S n0 =>
               match l with
               | [] => []
               | a :: l0 => a :: firstn n0 l0
               end
           end) n l) R0)
    ((fix length (l : list R) : nat :=
        match l with
        | [] => 0%nat
        | _ :: l' => S (length l')
        end)
       ((fix firstn (n : nat) (l : list R) {struct n} : list R :=
           match n with
           | 0%nat => []
           | S n0 =>
               match l with
               | [] => []
               | a :: l0 => a :: firstn n0 l0
               end
           end) n l)) +
  (fix nth (n : nat) (l : list R) (default : R) {struct l} : R :=
     match n with
     | 0%nat => match l with
                | [] => default
                | x :: _ => x
                end
     | S m => match l with
              | [] => default
              | _ :: t => nth m t default
              end
     end) n l R0)%R)
Crunching:
((fix big_sum (G : Type) (H : Monoid G) (f : nat -> G) (n : nat) {struct n} :
      G :=
    match n with
    | 0%nat => let (Gzero, Gplus, _, _, _) := H in Gzero
    | S n' =>
        (let (Gzero, Gplus, _, _, _) := H in Gplus) (big_sum G H f n') (f n')
    end) R
   {|
     Gzero := R0;
     Gplus := Rplus;
     Gplus_0_l :=
       fun g : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEc (RMicromega.CZ 0)) (EnvRing.PEX 1);
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs := EnvRing.PEX 1
            |} ()) [] eq_refl (fun _ : positive => g);
     Gplus_0_r :=
       fun g : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEc (RMicromega.CZ 0));
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs := EnvRing.PEX 1
            |} ()) [] eq_refl (fun _ : positive => g);
     Gplus_assoc :=
       fun g h i : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEX 1)
                  (EnvRing.PEadd (EnvRing.PEX 2) (EnvRing.PEX 3));
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs :=
                EnvRing.PEadd (EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEX 2))
                  (EnvRing.PEX 3)
            |} ()) [] eq_refl
         (fun p : positive =>
          match p with
          | (_~1)%positive => i
          | (_~0)%positive => h
          | 1%positive => g
          end)
   |}
   (fun i : nat =>
    (fix nth (n : nat) (l : list R) (default : R) {struct l} : R :=
       match n with
       | 0%nat => match l with
                  | [] => default
                  | x :: _ => x
                  end
       | S m => match l with
                | [] => default
                | _ :: t => nth m t default
                end
       end) i
      match l with
      | [] => []
      | a :: l =>
          a
          :: (fix firstn (n : nat) (l0 : list R) {struct n} : list R :=
                match n with
                | 0%nat => []
                | S n0 =>
                    match l0 with
                    | [] => []
                    | a0 :: l1 => a0 :: firstn n0 l1
                    end
                end) n l
      end R0)
   ((fix length (l : list R) : nat :=
       match l with
       | [] => 0%nat
       | _ :: l' => S (length l')
       end)
      match l with
      | [] => []
      | a :: l =>
          a
          :: (fix firstn (n : nat) (l0 : list R) {struct n} : list R :=
                match n with
                | 0%nat => []
                | S n0 =>
                    match l0 with
                    | [] => []
                    | a0 :: l1 => a0 :: firstn n0 l1
                    end
                end) n l
      end) =
 ((fix nth (n : nat) (l : list R) (default : R) {struct l} : R :=
     match n with
     | 0%nat => match l with
                | [] => default
                | x :: _ => x
                end
     | S m => match l with
              | [] => default
              | _ :: t => nth m t default
              end
     end) n l R0 +
  (fix big_sum
     (G : Type) (H : Monoid G) (f : nat -> G) (n : nat) {struct n} : G :=
     match n with
     | 0%nat => let (Gzero, Gplus, _, _, _) := H in Gzero
     | S n' =>
         (let (Gzero, Gplus, _, _, _) := H in Gplus) 
           (big_sum G H f n') (f n')
     end) R
    {|
      Gzero := R0;
      Gplus := Rplus;
      Gplus_0_l :=
        fun g : R =>
        RMicromega.RTautoChecker_sound
          (Tauto.A Tauto.isProp
             {|
               RingMicromega.Flhs :=
                 EnvRing.PEadd (EnvRing.PEc (RMicromega.CZ 0))
                   (EnvRing.PEX 1);
               RingMicromega.Fop := RingMicromega.OpEq;
               RingMicromega.Frhs := EnvRing.PEX 1
             |} ()) [] eq_refl (fun _ : positive => g);
      Gplus_0_r :=
        fun g : R =>
        RMicromega.RTautoChecker_sound
          (Tauto.A Tauto.isProp
             {|
               RingMicromega.Flhs :=
                 EnvRing.PEadd (EnvRing.PEX 1)
                   (EnvRing.PEc (RMicromega.CZ 0));
               RingMicromega.Fop := RingMicromega.OpEq;
               RingMicromega.Frhs := EnvRing.PEX 1
             |} ()) [] eq_refl (fun _ : positive => g);
      Gplus_assoc :=
        fun g h i : R =>
        RMicromega.RTautoChecker_sound
          (Tauto.A Tauto.isProp
             {|
               RingMicromega.Flhs :=
                 EnvRing.PEadd (EnvRing.PEX 1)
                   (EnvRing.PEadd (EnvRing.PEX 2) (EnvRing.PEX 3));
               RingMicromega.Fop := RingMicromega.OpEq;
               RingMicromega.Frhs :=
                 EnvRing.PEadd
                   (EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEX 2))
                   (EnvRing.PEX 3)
             |} ()) [] eq_refl
          (fun p : positive =>
           match p with
           | (_~1)%positive => i
           | (_~0)%positive => h
           | 1%positive => g
           end)
    |}
    (fun i : nat =>
     (fix nth (n : nat) (l : list R) (default : R) {struct l} : R :=
        match n with
        | 0%nat => match l with
                   | [] => default
                   | x :: _ => x
                   end
        | S m => match l with
                 | [] => default
                 | _ :: t => nth m t default
                 end
        end) i
       ((fix firstn (n : nat) (l : list R) {struct n} : list R :=
           match n with
           | 0%nat => []
           | S n0 =>
               match l with
               | [] => []
               | a :: l0 => a :: firstn n0 l0
               end
           end) n l) R0)
    ((fix length (l : list R) : nat :=
        match l with
        | [] => 0%nat
        | _ :: l' => S (length l')
        end)
       ((fix firstn (n : nat) (l : list R) {struct n} : list R :=
           match n with
           | 0%nat => []
           | S n0 =>
               match l with
               | [] => []
               | a :: l0 => a :: firstn n0 l0
               end
           end) n l)))%R)
Crunching: (funbool_to_list dim (update f 0 b) = funbool_to_list dim f)
Crunching:
((fix big_sum (G : Type) (H : Monoid G) (f : nat -> G) (n : nat) {struct n} :
      G :=
    match n with
    | 0%nat => let (Gzero, Gplus, _, _, _) := H in Gzero
    | S n' =>
        (let (Gzero, Gplus, _, _, _) := H in Gplus) (big_sum G H f n') (f n')
    end) R
   {|
     Gzero := R0;
     Gplus := Rplus;
     Gplus_0_l :=
       fun g : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEc (RMicromega.CZ 0)) (EnvRing.PEX 1);
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs := EnvRing.PEX 1
            |} ()) [] eq_refl (fun _ : positive => g);
     Gplus_0_r :=
       fun g : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEc (RMicromega.CZ 0));
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs := EnvRing.PEX 1
            |} ()) [] eq_refl (fun _ : positive => g);
     Gplus_assoc :=
       fun g h i : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEX 1)
                  (EnvRing.PEadd (EnvRing.PEX 2) (EnvRing.PEX 3));
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs :=
                EnvRing.PEadd (EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEX 2))
                  (EnvRing.PEX 3)
            |} ()) [] eq_refl
         (fun p : positive =>
          match p with
          | (_~1)%positive => i
          | (_~0)%positive => h
          | 1%positive => g
          end)
   |}
   (fun i : nat =>
    (fix nth (n : nat) (l : list R) (default : R) {struct l} : R :=
       match n with
       | 0%nat => match l with
                  | [] => default
                  | x :: _ => x
                  end
       | S m => match l with
                | [] => default
                | _ :: t => nth m t default
                end
       end) i
      match l with
      | [] => []
      | a :: l =>
          a
          :: (fix firstn (n : nat) (l0 : list R) {struct n} : list R :=
                match n with
                | 0%nat => []
                | S n0 =>
                    match l0 with
                    | [] => []
                    | a0 :: l1 => a0 :: firstn n0 l1
                    end
                end) n l
      end R0)
   ((fix length (l : list R) : nat :=
       match l with
       | [] => 0%nat
       | _ :: l' => S (length l')
       end)
      match l with
      | [] => []
      | a :: l =>
          a
          :: (fix firstn (n : nat) (l0 : list R) {struct n} : list R :=
                match n with
                | 0%nat => []
                | S n0 =>
                    match l0 with
                    | [] => []
                    | a0 :: l1 => a0 :: firstn n0 l1
                    end
                end) n l
      end) =
 ((fix big_sum
     (G : Type) (H : Monoid G) (f : nat -> G) (n : nat) {struct n} : G :=
     match n with
     | 0%nat => let (Gzero, Gplus, _, _, _) := H in Gzero
     | S n' =>
         (let (Gzero, Gplus, _, _, _) := H in Gplus) 
           (big_sum G H f n') (f n')
     end) R
    {|
      Gzero := R0;
      Gplus := Rplus;
      Gplus_0_l :=
        fun g : R =>
        RMicromega.RTautoChecker_sound
          (Tauto.A Tauto.isProp
             {|
               RingMicromega.Flhs :=
                 EnvRing.PEadd (EnvRing.PEc (RMicromega.CZ 0))
                   (EnvRing.PEX 1);
               RingMicromega.Fop := RingMicromega.OpEq;
               RingMicromega.Frhs := EnvRing.PEX 1
             |} ()) [] eq_refl (fun _ : positive => g);
      Gplus_0_r :=
        fun g : R =>
        RMicromega.RTautoChecker_sound
          (Tauto.A Tauto.isProp
             {|
               RingMicromega.Flhs :=
                 EnvRing.PEadd (EnvRing.PEX 1)
                   (EnvRing.PEc (RMicromega.CZ 0));
               RingMicromega.Fop := RingMicromega.OpEq;
               RingMicromega.Frhs := EnvRing.PEX 1
             |} ()) [] eq_refl (fun _ : positive => g);
      Gplus_assoc :=
        fun g h i : R =>
        RMicromega.RTautoChecker_sound
          (Tauto.A Tauto.isProp
             {|
               RingMicromega.Flhs :=
                 EnvRing.PEadd (EnvRing.PEX 1)
                   (EnvRing.PEadd (EnvRing.PEX 2) (EnvRing.PEX 3));
               RingMicromega.Fop := RingMicromega.OpEq;
               RingMicromega.Frhs :=
                 EnvRing.PEadd
                   (EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEX 2))
                   (EnvRing.PEX 3)
             |} ()) [] eq_refl
          (fun p : positive =>
           match p with
           | (_~1)%positive => i
           | (_~0)%positive => h
           | 1%positive => g
           end)
    |}
    (fun i : nat =>
     (fix nth (n : nat) (l : list R) (default : R) {struct l} : R :=
        match n with
        | 0%nat => match l with
                   | [] => default
                   | x :: _ => x
                   end
        | S m => match l with
                 | [] => default
                 | _ :: t => nth m t default
                 end
        end) i
       ((fix firstn (n : nat) (l : list R) {struct n} : list R :=
           match n with
           | 0%nat => []
           | S n0 =>
               match l with
               | [] => []
               | a :: l0 => a :: firstn n0 l0
               end
           end) n l) R0)
    ((fix length (l : list R) : nat :=
        match l with
        | [] => 0%nat
        | _ :: l' => S (length l')
        end)
       ((fix firstn (n : nat) (l : list R) {struct n} : list R :=
           match n with
           | 0%nat => []
           | S n0 =>
               match l with
               | [] => []
               | a :: l0 => a :: firstn n0 l0
               end
           end) n l)) +
  (fix nth (n : nat) (l : list R) (default : R) {struct l} : R :=
     match n with
     | 0%nat => match l with
                | [] => default
                | x :: _ => x
                end
     | S m => match l with
              | [] => default
              | _ :: t => nth m t default
              end
     end) n l R0)%R)
Crunching: (0 < 2)
Crunching: (0 < 2)
Crunching:
((fix big_sum (G : Type) (H : Monoid G) (f : nat -> G) (n : nat) {struct n} :
      G :=
    match n with
    | 0%nat => let (Gzero, Gplus, _, _, _) := H in Gzero
    | S n' =>
        (let (Gzero, Gplus, _, _, _) := H in Gplus) (big_sum G H f n') (f n')
    end) R
   {|
     Gzero := R0;
     Gplus := Rplus;
     Gplus_0_l :=
       fun g : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEc (RMicromega.CZ 0)) (EnvRing.PEX 1);
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs := EnvRing.PEX 1
            |} ()) [] eq_refl (fun _ : positive => g);
     Gplus_0_r :=
       fun g : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEc (RMicromega.CZ 0));
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs := EnvRing.PEX 1
            |} ()) [] eq_refl (fun _ : positive => g);
     Gplus_assoc :=
       fun g h i : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEX 1)
                  (EnvRing.PEadd (EnvRing.PEX 2) (EnvRing.PEX 3));
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs :=
                EnvRing.PEadd (EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEX 2))
                  (EnvRing.PEX 3)
            |} ()) [] eq_refl
         (fun p : positive =>
          match p with
          | (_~1)%positive => i
          | (_~0)%positive => h
          | 1%positive => g
          end)
   |}
   (fun i : nat =>
    (fix nth (n : nat) (l : list R) (default : R) {struct l} : R :=
       match n with
       | 0%nat => match l with
                  | [] => default
                  | x :: _ => x
                  end
       | S m => match l with
                | [] => default
                | _ :: t => nth m t default
                end
       end) i
      match l with
      | [] => []
      | a :: l =>
          a
          :: (fix firstn (n : nat) (l0 : list R) {struct n} : list R :=
                match n with
                | 0%nat => []
                | S n0 =>
                    match l0 with
                    | [] => []
                    | a0 :: l1 => a0 :: firstn n0 l1
                    end
                end) n l
      end R0)
   ((fix length (l : list R) : nat :=
       match l with
       | [] => 0%nat
       | _ :: l' => S (length l')
       end)
      match l with
      | [] => []
      | a :: l =>
          a
          :: (fix firstn (n : nat) (l0 : list R) {struct n} : list R :=
                match n with
                | 0%nat => []
                | S n0 =>
                    match l0 with
                    | [] => []
                    | a0 :: l1 => a0 :: firstn n0 l1
                    end
                end) n l
      end) =
 ((fix nth (n : nat) (l : list R) (default : R) {struct l} : R :=
     match n with
     | 0%nat => match l with
                | [] => default
                | x :: _ => x
                end
     | S m => match l with
              | [] => default
              | _ :: t => nth m t default
              end
     end) n l R0 +
  (fix big_sum
     (G : Type) (H : Monoid G) (f : nat -> G) (n : nat) {struct n} : G :=
     match n with
     | 0%nat => let (Gzero, Gplus, _, _, _) := H in Gzero
     | S n' =>
         (let (Gzero, Gplus, _, _, _) := H in Gplus) 
           (big_sum G H f n') (f n')
     end) R
    {|
      Gzero := R0;
      Gplus := Rplus;
      Gplus_0_l :=
        fun g : R =>
        RMicromega.RTautoChecker_sound
          (Tauto.A Tauto.isProp
             {|
               RingMicromega.Flhs :=
                 EnvRing.PEadd (EnvRing.PEc (RMicromega.CZ 0))
                   (EnvRing.PEX 1);
               RingMicromega.Fop := RingMicromega.OpEq;
               RingMicromega.Frhs := EnvRing.PEX 1
             |} ()) [] eq_refl (fun _ : positive => g);
      Gplus_0_r :=
        fun g : R =>
        RMicromega.RTautoChecker_sound
          (Tauto.A Tauto.isProp
             {|
               RingMicromega.Flhs :=
                 EnvRing.PEadd (EnvRing.PEX 1)
                   (EnvRing.PEc (RMicromega.CZ 0));
               RingMicromega.Fop := RingMicromega.OpEq;
               RingMicromega.Frhs := EnvRing.PEX 1
             |} ()) [] eq_refl (fun _ : positive => g);
      Gplus_assoc :=
        fun g h i : R =>
        RMicromega.RTautoChecker_sound
          (Tauto.A Tauto.isProp
             {|
               RingMicromega.Flhs :=
                 EnvRing.PEadd (EnvRing.PEX 1)
                   (EnvRing.PEadd (EnvRing.PEX 2) (EnvRing.PEX 3));
               RingMicromega.Fop := RingMicromega.OpEq;
               RingMicromega.Frhs :=
                 EnvRing.PEadd
                   (EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEX 2))
                   (EnvRing.PEX 3)
             |} ()) [] eq_refl
          (fun p : positive =>
           match p with
           | (_~1)%positive => i
           | (_~0)%positive => h
           | 1%positive => g
           end)
    |}
    (fun i : nat =>
     (fix nth (n : nat) (l : list R) (default : R) {struct l} : R :=
        match n with
        | 0%nat => match l with
                   | [] => default
                   | x :: _ => x
                   end
        | S m => match l with
                 | [] => default
                 | _ :: t => nth m t default
                 end
        end) i
       ((fix firstn (n : nat) (l : list R) {struct n} : list R :=
           match n with
           | 0%nat => []
           | S n0 =>
               match l with
               | [] => []
               | a :: l0 => a :: firstn n0 l0
               end
           end) n l) R0)
    ((fix length (l : list R) : nat :=
        match l with
        | [] => 0%nat
        | _ :: l' => S (length l')
        end)
       ((fix firstn (n : nat) (l : list R) {struct n} : list R :=
           match n with
           | 0%nat => []
           | S n0 =>
               match l with
               | [] => []
               | a :: l0 => a :: firstn n0 l0
               end
           end) n l)))%R)
Crunching:
(cos_in 0 (cos 0) ->
 funbool_to_list dim (update f n b) = funbool_to_list dim f)
Crunching:
((fix big_sum (G : Type) (H : Monoid G) (f : nat -> G) (n : nat) {struct n} :
      G :=
    match n with
    | 0%nat => let (Gzero, Gplus, _, _, _) := H in Gzero
    | S n' =>
        (let (Gzero, Gplus, _, _, _) := H in Gplus) (big_sum G H f n') (f n')
    end) R
   {|
     Gzero := R0;
     Gplus := Rplus;
     Gplus_0_l :=
       fun g : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEc (RMicromega.CZ 0)) (EnvRing.PEX 1);
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs := EnvRing.PEX 1
            |} ()) [] eq_refl (fun _ : positive => g);
     Gplus_0_r :=
       fun g : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEc (RMicromega.CZ 0));
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs := EnvRing.PEX 1
            |} ()) [] eq_refl (fun _ : positive => g);
     Gplus_assoc :=
       fun g h i : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEX 1)
                  (EnvRing.PEadd (EnvRing.PEX 2) (EnvRing.PEX 3));
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs :=
                EnvRing.PEadd (EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEX 2))
                  (EnvRing.PEX 3)
            |} ()) [] eq_refl
         (fun p : positive =>
          match p with
          | (_~1)%positive => i
          | (_~0)%positive => h
          | 1%positive => g
          end)
   |}
   (fun i : nat =>
    (fix nth (n : nat) (l : list R) (default : R) {struct l} : R :=
       match n with
       | 0%nat => match l with
                  | [] => default
                  | x :: _ => x
                  end
       | S m => match l with
                | [] => default
                | _ :: t => nth m t default
                end
       end) i
      match l with
      | [] => []
      | a :: l =>
          a
          :: (fix firstn (n : nat) (l0 : list R) {struct n} : list R :=
                match n with
                | 0%nat => []
                | S n0 =>
                    match l0 with
                    | [] => []
                    | a0 :: l1 => a0 :: firstn n0 l1
                    end
                end) n l
      end R0)
   ((fix length (l : list R) : nat :=
       match l with
       | [] => 0%nat
       | _ :: l' => S (length l')
       end)
      match l with
      | [] => []
      | a :: l =>
          a
          :: (fix firstn (n : nat) (l0 : list R) {struct n} : list R :=
                match n with
                | 0%nat => []
                | S n0 =>
                    match l0 with
                    | [] => []
                    | a0 :: l1 => a0 :: firstn n0 l1
                    end
                end) n l
      end) =
 ((fix big_sum
     (G : Type) (H : Monoid G) (f : nat -> G) (n : nat) {struct n} : G :=
     match n with
     | 0%nat => let (Gzero, Gplus, _, _, _) := H in Gzero
     | S n' =>
         (let (Gzero, Gplus, _, _, _) := H in Gplus) 
           (big_sum G H f n') (f n')
     end) R
    {|
      Gzero := R0;
      Gplus := Rplus;
      Gplus_0_l :=
        fun g : R =>
        RMicromega.RTautoChecker_sound
          (Tauto.A Tauto.isProp
             {|
               RingMicromega.Flhs :=
                 EnvRing.PEadd (EnvRing.PEc (RMicromega.CZ 0))
                   (EnvRing.PEX 1);
               RingMicromega.Fop := RingMicromega.OpEq;
               RingMicromega.Frhs := EnvRing.PEX 1
             |} ()) [] eq_refl (fun _ : positive => g);
      Gplus_0_r :=
        fun g : R =>
        RMicromega.RTautoChecker_sound
          (Tauto.A Tauto.isProp
             {|
               RingMicromega.Flhs :=
                 EnvRing.PEadd (EnvRing.PEX 1)
                   (EnvRing.PEc (RMicromega.CZ 0));
               RingMicromega.Fop := RingMicromega.OpEq;
               RingMicromega.Frhs := EnvRing.PEX 1
             |} ()) [] eq_refl (fun _ : positive => g);
      Gplus_assoc :=
        fun g h i : R =>
        RMicromega.RTautoChecker_sound
          (Tauto.A Tauto.isProp
             {|
               RingMicromega.Flhs :=
                 EnvRing.PEadd (EnvRing.PEX 1)
                   (EnvRing.PEadd (EnvRing.PEX 2) (EnvRing.PEX 3));
               RingMicromega.Fop := RingMicromega.OpEq;
               RingMicromega.Frhs :=
                 EnvRing.PEadd
                   (EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEX 2))
                   (EnvRing.PEX 3)
             |} ()) [] eq_refl
          (fun p : positive =>
           match p with
           | (_~1)%positive => i
           | (_~0)%positive => h
           | 1%positive => g
           end)
    |}
    (fun i : nat =>
     (fix nth (n : nat) (l : list R) (default : R) {struct l} : R :=
        match n with
        | 0%nat => match l with
                   | [] => default
                   | x :: _ => x
                   end
        | S m => match l with
                 | [] => default
                 | _ :: t => nth m t default
                 end
        end) i
       ((fix firstn (n : nat) (l : list R) {struct n} : list R :=
           match n with
           | 0%nat => []
           | S n0 =>
               match l with
               | [] => []
               | a :: l0 => a :: firstn n0 l0
               end
           end) n l) R0)
    ((fix length (l : list R) : nat :=
        match l with
        | [] => 0%nat
        | _ :: l' => S (length l')
        end)
       ((fix firstn (n : nat) (l : list R) {struct n} : list R :=
           match n with
           | 0%nat => []
           | S n0 =>
               match l with
               | [] => []
               | a :: l0 => a :: firstn n0 l0
               end
           end) n l)) +
  (fix nth (n : nat) (l : list R) (default : R) {struct l} : R :=
     match n with
     | 0%nat => match l with
                | [] => default
                | x :: _ => x
                end
     | S m => match l with
              | [] => default
              | _ :: t => nth m t default
              end
     end) n l R0)%R)
Crunching:
((fix big_sum (G : Type) (H : Monoid G) (f : nat -> G) (n : nat) {struct n} :
      G :=
    match n with
    | 0%nat => let (Gzero, Gplus, _, _, _) := H in Gzero
    | S n' =>
        (let (Gzero, Gplus, _, _, _) := H in Gplus) (big_sum G H f n') (f n')
    end) R
   {|
     Gzero := R0;
     Gplus := Rplus;
     Gplus_0_l :=
       fun g : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEc (RMicromega.CZ 0)) (EnvRing.PEX 1);
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs := EnvRing.PEX 1
            |} ()) [] eq_refl (fun _ : positive => g);
     Gplus_0_r :=
       fun g : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEc (RMicromega.CZ 0));
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs := EnvRing.PEX 1
            |} ()) [] eq_refl (fun _ : positive => g);
     Gplus_assoc :=
       fun g h i : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEX 1)
                  (EnvRing.PEadd (EnvRing.PEX 2) (EnvRing.PEX 3));
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs :=
                EnvRing.PEadd (EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEX 2))
                  (EnvRing.PEX 3)
            |} ()) [] eq_refl
         (fun p : positive =>
          match p with
          | (_~1)%positive => i
          | (_~0)%positive => h
          | 1%positive => g
          end)
   |}
   (fun i : nat =>
    (fix nth (n : nat) (l : list R) (default : R) {struct l} : R :=
       match n with
       | 0%nat => match l with
                  | [] => default
                  | x :: _ => x
                  end
       | S m => match l with
                | [] => default
                | _ :: t => nth m t default
                end
       end) i
      match l with
      | [] => []
      | a :: l =>
          a
          :: (fix firstn (n : nat) (l0 : list R) {struct n} : list R :=
                match n with
                | 0%nat => []
                | S n0 =>
                    match l0 with
                    | [] => []
                    | a0 :: l1 => a0 :: firstn n0 l1
                    end
                end) n l
      end R0)
   ((fix length (l : list R) : nat :=
       match l with
       | [] => 0%nat
       | _ :: l' => S (length l')
       end)
      match l with
      | [] => []
      | a :: l =>
          a
          :: (fix firstn (n : nat) (l0 : list R) {struct n} : list R :=
                match n with
                | 0%nat => []
                | S n0 =>
                    match l0 with
                    | [] => []
                    | a0 :: l1 => a0 :: firstn n0 l1
                    end
                end) n l
      end) =
 ((fix nth (n : nat) (l : list R) (default : R) {struct l} : R :=
     match n with
     | 0%nat => match l with
                | [] => default
                | x :: _ => x
                end
     | S m => match l with
              | [] => default
              | _ :: t => nth m t default
              end
     end) n l R0 +
  (fix big_sum
     (G : Type) (H : Monoid G) (f : nat -> G) (n : nat) {struct n} : G :=
     match n with
     | 0%nat => let (Gzero, Gplus, _, _, _) := H in Gzero
     | S n' =>
         (let (Gzero, Gplus, _, _, _) := H in Gplus) 
           (big_sum G H f n') (f n')
     end) R
    {|
      Gzero := R0;
      Gplus := Rplus;
      Gplus_0_l :=
        fun g : R =>
        RMicromega.RTautoChecker_sound
          (Tauto.A Tauto.isProp
             {|
               RingMicromega.Flhs :=
                 EnvRing.PEadd (EnvRing.PEc (RMicromega.CZ 0))
                   (EnvRing.PEX 1);
               RingMicromega.Fop := RingMicromega.OpEq;
               RingMicromega.Frhs := EnvRing.PEX 1
             |} ()) [] eq_refl (fun _ : positive => g);
      Gplus_0_r :=
        fun g : R =>
        RMicromega.RTautoChecker_sound
          (Tauto.A Tauto.isProp
             {|
               RingMicromega.Flhs :=
                 EnvRing.PEadd (EnvRing.PEX 1)
                   (EnvRing.PEc (RMicromega.CZ 0));
               RingMicromega.Fop := RingMicromega.OpEq;
               RingMicromega.Frhs := EnvRing.PEX 1
             |} ()) [] eq_refl (fun _ : positive => g);
      Gplus_assoc :=
        fun g h i : R =>
        RMicromega.RTautoChecker_sound
          (Tauto.A Tauto.isProp
             {|
               RingMicromega.Flhs :=
                 EnvRing.PEadd (EnvRing.PEX 1)
                   (EnvRing.PEadd (EnvRing.PEX 2) (EnvRing.PEX 3));
               RingMicromega.Fop := RingMicromega.OpEq;
               RingMicromega.Frhs :=
                 EnvRing.PEadd
                   (EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEX 2))
                   (EnvRing.PEX 3)
             |} ()) [] eq_refl
          (fun p : positive =>
           match p with
           | (_~1)%positive => i
           | (_~0)%positive => h
           | 1%positive => g
           end)
    |}
    (fun i : nat =>
     (fix nth (n : nat) (l : list R) (default : R) {struct l} : R :=
        match n with
        | 0%nat => match l with
                   | [] => default
                   | x :: _ => x
                   end
        | S m => match l with
                 | [] => default
                 | _ :: t => nth m t default
                 end
        end) i
       ((fix firstn (n : nat) (l : list R) {struct n} : list R :=
           match n with
           | 0%nat => []
           | S n0 =>
               match l with
               | [] => []
               | a :: l0 => a :: firstn n0 l0
               end
           end) n l) R0)
    ((fix length (l : list R) : nat :=
        match l with
        | [] => 0%nat
        | _ :: l' => S (length l')
        end)
       ((fix firstn (n : nat) (l : list R) {struct n} : list R :=
           match n with
           | 0%nat => []
           | S n0 =>
               match l with
               | [] => []
               | a :: l0 => a :: firstn n0 l0
               end
           end) n l)))%R)
Crunching: (n = 0)
Crunching:
((fix big_sum (G : Type) (H : Monoid G) (f : nat -> G) (n : nat) {struct n} :
      G :=
    match n with
    | 0%nat => let (Gzero, Gplus, _, _, _) := H in Gzero
    | S n' =>
        (let (Gzero, Gplus, _, _, _) := H in Gplus) (big_sum G H f n') (f n')
    end) R
   {|
     Gzero := R0;
     Gplus := Rplus;
     Gplus_0_l :=
       fun g : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEc (RMicromega.CZ 0)) (EnvRing.PEX 1);
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs := EnvRing.PEX 1
            |} ()) [] eq_refl (fun _ : positive => g);
     Gplus_0_r :=
       fun g : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEc (RMicromega.CZ 0));
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs := EnvRing.PEX 1
            |} ()) [] eq_refl (fun _ : positive => g);
     Gplus_assoc :=
       fun g h i : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEX 1)
                  (EnvRing.PEadd (EnvRing.PEX 2) (EnvRing.PEX 3));
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs :=
                EnvRing.PEadd (EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEX 2))
                  (EnvRing.PEX 3)
            |} ()) [] eq_refl
         (fun p : positive =>
          match p with
          | (_~1)%positive => i
          | (_~0)%positive => h
          | 1%positive => g
          end)
   |}
   (fun i : nat =>
    (fix nth (n : nat) (l : list R) (default : R) {struct l} : R :=
       match n with
       | 0%nat => match l with
                  | [] => default
                  | x :: _ => x
                  end
       | S m => match l with
                | [] => default
                | _ :: t => nth m t default
                end
       end) i
      match l with
      | [] => []
      | a :: l =>
          a
          :: (fix firstn (n : nat) (l0 : list R) {struct n} : list R :=
                match n with
                | 0%nat => []
                | S n0 =>
                    match l0 with
                    | [] => []
                    | a0 :: l1 => a0 :: firstn n0 l1
                    end
                end) n l
      end R0)
   ((fix length (l : list R) : nat :=
       match l with
       | [] => 0%nat
       | _ :: l' => S (length l')
       end)
      match l with
      | [] => []
      | a :: l =>
          a
          :: (fix firstn (n : nat) (l0 : list R) {struct n} : list R :=
                match n with
                | 0%nat => []
                | S n0 =>
                    match l0 with
                    | [] => []
                    | a0 :: l1 => a0 :: firstn n0 l1
                    end
                end) n l
      end) =
 ((fix big_sum
     (G : Type) (H : Monoid G) (f : nat -> G) (n : nat) {struct n} : G :=
     match n with
     | 0%nat => let (Gzero, Gplus, _, _, _) := H in Gzero
     | S n' =>
         (let (Gzero, Gplus, _, _, _) := H in Gplus) 
           (big_sum G H f n') (f n')
     end) R
    {|
      Gzero := R0;
      Gplus := Rplus;
      Gplus_0_l :=
        fun g : R =>
        RMicromega.RTautoChecker_sound
          (Tauto.A Tauto.isProp
             {|
               RingMicromega.Flhs :=
                 EnvRing.PEadd (EnvRing.PEc (RMicromega.CZ 0))
                   (EnvRing.PEX 1);
               RingMicromega.Fop := RingMicromega.OpEq;
               RingMicromega.Frhs := EnvRing.PEX 1
             |} ()) [] eq_refl (fun _ : positive => g);
      Gplus_0_r :=
        fun g : R =>
        RMicromega.RTautoChecker_sound
          (Tauto.A Tauto.isProp
             {|
               RingMicromega.Flhs :=
                 EnvRing.PEadd (EnvRing.PEX 1)
                   (EnvRing.PEc (RMicromega.CZ 0));
               RingMicromega.Fop := RingMicromega.OpEq;
               RingMicromega.Frhs := EnvRing.PEX 1
             |} ()) [] eq_refl (fun _ : positive => g);
      Gplus_assoc :=
        fun g h i : R =>
        RMicromega.RTautoChecker_sound
          (Tauto.A Tauto.isProp
             {|
               RingMicromega.Flhs :=
                 EnvRing.PEadd (EnvRing.PEX 1)
                   (EnvRing.PEadd (EnvRing.PEX 2) (EnvRing.PEX 3));
               RingMicromega.Fop := RingMicromega.OpEq;
               RingMicromega.Frhs :=
                 EnvRing.PEadd
                   (EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEX 2))
                   (EnvRing.PEX 3)
             |} ()) [] eq_refl
          (fun p : positive =>
           match p with
           | (_~1)%positive => i
           | (_~0)%positive => h
           | 1%positive => g
           end)
    |}
    (fun i : nat =>
     (fix nth (n : nat) (l : list R) (default : R) {struct l} : R :=
        match n with
        | 0%nat => match l with
                   | [] => default
                   | x :: _ => x
                   end
        | S m => match l with
                 | [] => default
                 | _ :: t => nth m t default
                 end
        end) i
       ((fix firstn (n : nat) (l : list R) {struct n} : list R :=
           match n with
           | 0%nat => []
           | S n0 =>
               match l with
               | [] => []
               | a :: l0 => a :: firstn n0 l0
               end
           end) n l) R0)
    ((fix length (l : list R) : nat :=
        match l with
        | [] => 0%nat
        | _ :: l' => S (length l')
        end)
       ((fix firstn (n : nat) (l : list R) {struct n} : list R :=
           match n with
           | 0%nat => []
           | S n0 =>
               match l with
               | [] => []
               | a :: l0 => a :: firstn n0 l0
               end
           end) n l)) +
  (fix nth (n : nat) (l : list R) (default : R) {struct l} : R :=
     match n with
     | 0%nat => match l with
                | [] => default
                | x :: _ => x
                end
     | S m => match l with
              | [] => default
              | _ :: t => nth m t default
              end
     end) n l R0)%R)
Crunching:
((fix big_sum (G : Type) (H : Monoid G) (f : nat -> G) (n : nat) {struct n} :
      G :=
    match n with
    | 0%nat => let (Gzero, Gplus, _, _, _) := H in Gzero
    | S n' =>
        (let (Gzero, Gplus, _, _, _) := H in Gplus) (big_sum G H f n') (f n')
    end) R
   {|
     Gzero := R0;
     Gplus := Rplus;
     Gplus_0_l :=
       fun g : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEc (RMicromega.CZ 0)) (EnvRing.PEX 1);
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs := EnvRing.PEX 1
            |} ()) [] eq_refl (fun _ : positive => g);
     Gplus_0_r :=
       fun g : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEc (RMicromega.CZ 0));
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs := EnvRing.PEX 1
            |} ()) [] eq_refl (fun _ : positive => g);
     Gplus_assoc :=
       fun g h i : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEX 1)
                  (EnvRing.PEadd (EnvRing.PEX 2) (EnvRing.PEX 3));
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs :=
                EnvRing.PEadd (EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEX 2))
                  (EnvRing.PEX 3)
            |} ()) [] eq_refl
         (fun p : positive =>
          match p with
          | (_~1)%positive => i
          | (_~0)%positive => h
          | 1%positive => g
          end)
   |}
   (fun i : nat =>
    (fix nth (n : nat) (l : list R) (default : R) {struct l} : R :=
       match n with
       | 0%nat => match l with
                  | [] => default
                  | x :: _ => x
                  end
       | S m => match l with
                | [] => default
                | _ :: t => nth m t default
                end
       end) i
      match l with
      | [] => []
      | a :: l =>
          a
          :: (fix firstn (n : nat) (l0 : list R) {struct n} : list R :=
                match n with
                | 0%nat => []
                | S n0 =>
                    match l0 with
                    | [] => []
                    | a0 :: l1 => a0 :: firstn n0 l1
                    end
                end) n l
      end R0)
   ((fix length (l : list R) : nat :=
       match l with
       | [] => 0%nat
       | _ :: l' => S (length l')
       end)
      match l with
      | [] => []
      | a :: l =>
          a
          :: (fix firstn (n : nat) (l0 : list R) {struct n} : list R :=
                match n with
                | 0%nat => []
                | S n0 =>
                    match l0 with
                    | [] => []
                    | a0 :: l1 => a0 :: firstn n0 l1
                    end
                end) n l
      end) =
 ((fix nth (n : nat) (l : list R) (default : R) {struct l} : R :=
     match n with
     | 0%nat => match l with
                | [] => default
                | x :: _ => x
                end
     | S m => match l with
              | [] => default
              | _ :: t => nth m t default
              end
     end) n l R0 +
  (fix big_sum
     (G : Type) (H : Monoid G) (f : nat -> G) (n : nat) {struct n} : G :=
     match n with
     | 0%nat => let (Gzero, Gplus, _, _, _) := H in Gzero
     | S n' =>
         (let (Gzero, Gplus, _, _, _) := H in Gplus) 
           (big_sum G H f n') (f n')
     end) R
    {|
      Gzero := R0;
      Gplus := Rplus;
      Gplus_0_l :=
        fun g : R =>
        RMicromega.RTautoChecker_sound
          (Tauto.A Tauto.isProp
             {|
               RingMicromega.Flhs :=
                 EnvRing.PEadd (EnvRing.PEc (RMicromega.CZ 0))
                   (EnvRing.PEX 1);
               RingMicromega.Fop := RingMicromega.OpEq;
               RingMicromega.Frhs := EnvRing.PEX 1
             |} ()) [] eq_refl (fun _ : positive => g);
      Gplus_0_r :=
        fun g : R =>
        RMicromega.RTautoChecker_sound
          (Tauto.A Tauto.isProp
             {|
               RingMicromega.Flhs :=
                 EnvRing.PEadd (EnvRing.PEX 1)
                   (EnvRing.PEc (RMicromega.CZ 0));
               RingMicromega.Fop := RingMicromega.OpEq;
               RingMicromega.Frhs := EnvRing.PEX 1
             |} ()) [] eq_refl (fun _ : positive => g);
      Gplus_assoc :=
        fun g h i : R =>
        RMicromega.RTautoChecker_sound
          (Tauto.A Tauto.isProp
             {|
               RingMicromega.Flhs :=
                 EnvRing.PEadd (EnvRing.PEX 1)
                   (EnvRing.PEadd (EnvRing.PEX 2) (EnvRing.PEX 3));
               RingMicromega.Fop := RingMicromega.OpEq;
               RingMicromega.Frhs :=
                 EnvRing.PEadd
                   (EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEX 2))
                   (EnvRing.PEX 3)
             |} ()) [] eq_refl
          (fun p : positive =>
           match p with
           | (_~1)%positive => i
           | (_~0)%positive => h
           | 1%positive => g
           end)
    |}
    (fun i : nat =>
     (fix nth (n : nat) (l : list R) (default : R) {struct l} : R :=
        match n with
        | 0%nat => match l with
                   | [] => default
                   | x :: _ => x
                   end
        | S m => match l with
                 | [] => default
                 | _ :: t => nth m t default
                 end
        end) i
       ((fix firstn (n : nat) (l : list R) {struct n} : list R :=
           match n with
           | 0%nat => []
           | S n0 =>
               match l with
               | [] => []
               | a :: l0 => a :: firstn n0 l0
               end
           end) n l) R0)
    ((fix length (l : list R) : nat :=
        match l with
        | [] => 0%nat
        | _ :: l' => S (length l')
        end)
       ((fix firstn (n : nat) (l : list R) {struct n} : list R :=
           match n with
           | 0%nat => []
           | S n0 =>
               match l with
               | [] => []
               | a :: l0 => a :: firstn n0 l0
               end
           end) n l)))%R)
Crunching: (n = 0)
Crunching:
((fix big_sum (G : Type) (H : Monoid G) (f : nat -> G) (n : nat) {struct n} :
      G :=
    match n with
    | 0%nat => let (Gzero, Gplus, _, _, _) := H in Gzero
    | S n' =>
        (let (Gzero, Gplus, _, _, _) := H in Gplus) (big_sum G H f n') (f n')
    end) R
   {|
     Gzero := R0;
     Gplus := Rplus;
     Gplus_0_l :=
       fun g : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEc (RMicromega.CZ 0)) (EnvRing.PEX 1);
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs := EnvRing.PEX 1
            |} ()) [] eq_refl (fun _ : positive => g);
     Gplus_0_r :=
       fun g : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEc (RMicromega.CZ 0));
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs := EnvRing.PEX 1
            |} ()) [] eq_refl (fun _ : positive => g);
     Gplus_assoc :=
       fun g h i : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEX 1)
                  (EnvRing.PEadd (EnvRing.PEX 2) (EnvRing.PEX 3));
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs :=
                EnvRing.PEadd (EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEX 2))
                  (EnvRing.PEX 3)
            |} ()) [] eq_refl
         (fun p : positive =>
          match p with
          | (_~1)%positive => i
          | (_~0)%positive => h
          | 1%positive => g
          end)
   |}
   (fun i : nat =>
    (fix nth (n : nat) (l : list R) (default : R) {struct l} : R :=
       match n with
       | 0%nat => match l with
                  | [] => default
                  | x :: _ => x
                  end
       | S m => match l with
                | [] => default
                | _ :: t => nth m t default
                end
       end) i
      match l with
      | [] => []
      | a :: l =>
          a
          :: (fix firstn (n : nat) (l0 : list R) {struct n} : list R :=
                match n with
                | 0%nat => []
                | S n0 =>
                    match l0 with
                    | [] => []
                    | a0 :: l1 => a0 :: firstn n0 l1
                    end
                end) n l
      end R0)
   ((fix length (l : list R) : nat :=
       match l with
       | [] => 0%nat
       | _ :: l' => S (length l')
       end)
      match l with
      | [] => []
      | a :: l =>
          a
          :: (fix firstn (n : nat) (l0 : list R) {struct n} : list R :=
                match n with
                | 0%nat => []
                | S n0 =>
                    match l0 with
                    | [] => []
                    | a0 :: l1 => a0 :: firstn n0 l1
                    end
                end) n l
      end) =
 ((fix big_sum
     (G : Type) (H : Monoid G) (f : nat -> G) (n : nat) {struct n} : G :=
     match n with
     | 0%nat => let (Gzero, Gplus, _, _, _) := H in Gzero
     | S n' =>
         (let (Gzero, Gplus, _, _, _) := H in Gplus) 
           (big_sum G H f n') (f n')
     end) R
    {|
      Gzero := R0;
      Gplus := Rplus;
      Gplus_0_l :=
        fun g : R =>
        RMicromega.RTautoChecker_sound
          (Tauto.A Tauto.isProp
             {|
               RingMicromega.Flhs :=
                 EnvRing.PEadd (EnvRing.PEc (RMicromega.CZ 0))
                   (EnvRing.PEX 1);
               RingMicromega.Fop := RingMicromega.OpEq;
               RingMicromega.Frhs := EnvRing.PEX 1
             |} ()) [] eq_refl (fun _ : positive => g);
      Gplus_0_r :=
        fun g : R =>
        RMicromega.RTautoChecker_sound
          (Tauto.A Tauto.isProp
             {|
               RingMicromega.Flhs :=
                 EnvRing.PEadd (EnvRing.PEX 1)
                   (EnvRing.PEc (RMicromega.CZ 0));
               RingMicromega.Fop := RingMicromega.OpEq;
               RingMicromega.Frhs := EnvRing.PEX 1
             |} ()) [] eq_refl (fun _ : positive => g);
      Gplus_assoc :=
        fun g h i : R =>
        RMicromega.RTautoChecker_sound
          (Tauto.A Tauto.isProp
             {|
               RingMicromega.Flhs :=
                 EnvRing.PEadd (EnvRing.PEX 1)
                   (EnvRing.PEadd (EnvRing.PEX 2) (EnvRing.PEX 3));
               RingMicromega.Fop := RingMicromega.OpEq;
               RingMicromega.Frhs :=
                 EnvRing.PEadd
                   (EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEX 2))
                   (EnvRing.PEX 3)
             |} ()) [] eq_refl
          (fun p : positive =>
           match p with
           | (_~1)%positive => i
           | (_~0)%positive => h
           | 1%positive => g
           end)
    |}
    (fun i : nat =>
     (fix nth (n : nat) (l : list R) (default : R) {struct l} : R :=
        match n with
        | 0%nat => match l with
                   | [] => default
                   | x :: _ => x
                   end
        | S m => match l with
                 | [] => default
                 | _ :: t => nth m t default
                 end
        end) i
       ((fix firstn (n : nat) (l : list R) {struct n} : list R :=
           match n with
           | 0%nat => []
           | S n0 =>
               match l with
               | [] => []
               | a :: l0 => a :: firstn n0 l0
               end
           end) n l) R0)
    ((fix length (l : list R) : nat :=
        match l with
        | [] => 0%nat
        | _ :: l' => S (length l')
        end)
       ((fix firstn (n : nat) (l : list R) {struct n} : list R :=
           match n with
           | 0%nat => []
           | S n0 =>
               match l with
               | [] => []
               | a :: l0 => a :: firstn n0 l0
               end
           end) n l)) +
  (fix nth (n : nat) (l : list R) (default : R) {struct l} : R :=
     match n with
     | 0%nat => match l with
                | [] => default
                | x :: _ => x
                end
     | S m => match l with
              | [] => default
              | _ :: t => nth m t default
              end
     end) n l R0)%R)
Crunching:
((fix big_sum (G : Type) (H : Monoid G) (f : nat -> G) (n : nat) {struct n} :
      G :=
    match n with
    | 0%nat => let (Gzero, Gplus, _, _, _) := H in Gzero
    | S n' =>
        (let (Gzero, Gplus, _, _, _) := H in Gplus) (big_sum G H f n') (f n')
    end) R
   {|
     Gzero := R0;
     Gplus := Rplus;
     Gplus_0_l :=
       fun g : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEc (RMicromega.CZ 0)) (EnvRing.PEX 1);
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs := EnvRing.PEX 1
            |} ()) [] eq_refl (fun _ : positive => g);
     Gplus_0_r :=
       fun g : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEc (RMicromega.CZ 0));
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs := EnvRing.PEX 1
            |} ()) [] eq_refl (fun _ : positive => g);
     Gplus_assoc :=
       fun g h i : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEX 1)
                  (EnvRing.PEadd (EnvRing.PEX 2) (EnvRing.PEX 3));
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs :=
                EnvRing.PEadd (EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEX 2))
                  (EnvRing.PEX 3)
            |} ()) [] eq_refl
         (fun p : positive =>
          match p with
          | (_~1)%positive => i
          | (_~0)%positive => h
          | 1%positive => g
          end)
   |}
   (fun i : nat =>
    (fix nth (n : nat) (l : list R) (default : R) {struct l} : R :=
       match n with
       | 0%nat => match l with
                  | [] => default
                  | x :: _ => x
                  end
       | S m => match l with
                | [] => default
                | _ :: t => nth m t default
                end
       end) i
      match l with
      | [] => []
      | a :: l =>
          a
          :: (fix firstn (n : nat) (l0 : list R) {struct n} : list R :=
                match n with
                | 0%nat => []
                | S n0 =>
                    match l0 with
                    | [] => []
                    | a0 :: l1 => a0 :: firstn n0 l1
                    end
                end) n l
      end R0)
   ((fix length (l : list R) : nat :=
       match l with
       | [] => 0%nat
       | _ :: l' => S (length l')
       end)
      match l with
      | [] => []
      | a :: l =>
          a
          :: (fix firstn (n : nat) (l0 : list R) {struct n} : list R :=
                match n with
                | 0%nat => []
                | S n0 =>
                    match l0 with
                    | [] => []
                    | a0 :: l1 => a0 :: firstn n0 l1
                    end
                end) n l
      end) =
 ((fix nth (n : nat) (l : list R) (default : R) {struct l} : R :=
     match n with
     | 0%nat => match l with
                | [] => default
                | x :: _ => x
                end
     | S m => match l with
              | [] => default
              | _ :: t => nth m t default
              end
     end) n l R0 +
  (fix big_sum
     (G : Type) (H : Monoid G) (f : nat -> G) (n : nat) {struct n} : G :=
     match n with
     | 0%nat => let (Gzero, Gplus, _, _, _) := H in Gzero
     | S n' =>
         (let (Gzero, Gplus, _, _, _) := H in Gplus) 
           (big_sum G H f n') (f n')
     end) R
    {|
      Gzero := R0;
      Gplus := Rplus;
      Gplus_0_l :=
        fun g : R =>
        RMicromega.RTautoChecker_sound
          (Tauto.A Tauto.isProp
             {|
               RingMicromega.Flhs :=
                 EnvRing.PEadd (EnvRing.PEc (RMicromega.CZ 0))
                   (EnvRing.PEX 1);
               RingMicromega.Fop := RingMicromega.OpEq;
               RingMicromega.Frhs := EnvRing.PEX 1
             |} ()) [] eq_refl (fun _ : positive => g);
      Gplus_0_r :=
        fun g : R =>
        RMicromega.RTautoChecker_sound
          (Tauto.A Tauto.isProp
             {|
               RingMicromega.Flhs :=
                 EnvRing.PEadd (EnvRing.PEX 1)
                   (EnvRing.PEc (RMicromega.CZ 0));
               RingMicromega.Fop := RingMicromega.OpEq;
               RingMicromega.Frhs := EnvRing.PEX 1
             |} ()) [] eq_refl (fun _ : positive => g);
      Gplus_assoc :=
        fun g h i : R =>
        RMicromega.RTautoChecker_sound
          (Tauto.A Tauto.isProp
             {|
               RingMicromega.Flhs :=
                 EnvRing.PEadd (EnvRing.PEX 1)
                   (EnvRing.PEadd (EnvRing.PEX 2) (EnvRing.PEX 3));
               RingMicromega.Fop := RingMicromega.OpEq;
               RingMicromega.Frhs :=
                 EnvRing.PEadd
                   (EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEX 2))
                   (EnvRing.PEX 3)
             |} ()) [] eq_refl
          (fun p : positive =>
           match p with
           | (_~1)%positive => i
           | (_~0)%positive => h
           | 1%positive => g
           end)
    |}
    (fun i : nat =>
     (fix nth (n : nat) (l : list R) (default : R) {struct l} : R :=
        match n with
        | 0%nat => match l with
                   | [] => default
                   | x :: _ => x
                   end
        | S m => match l with
                 | [] => default
                 | _ :: t => nth m t default
                 end
        end) i
       ((fix firstn (n : nat) (l : list R) {struct n} : list R :=
           match n with
           | 0%nat => []
           | S n0 =>
               match l with
               | [] => []
               | a :: l0 => a :: firstn n0 l0
               end
           end) n l) R0)
    ((fix length (l : list R) : nat :=
        match l with
        | [] => 0%nat
        | _ :: l' => S (length l')
        end)
       ((fix firstn (n : nat) (l : list R) {struct n} : list R :=
           match n with
           | 0%nat => []
           | S n0 =>
               match l with
               | [] => []
               | a :: l0 => a :: firstn n0 l0
               end
           end) n l)))%R)
Crunching:
((fix big_sum (G : Type) (H : Monoid G) (f : nat -> G) (n : nat) {struct n} :
      G :=
    match n with
    | 0%nat => let (Gzero, Gplus, _, _, _) := H in Gzero
    | S n' =>
        (let (Gzero, Gplus, _, _, _) := H in Gplus) (big_sum G H f n') (f n')
    end) R
   {|
     Gzero := R0;
     Gplus := Rplus;
     Gplus_0_l :=
       fun g : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEc (RMicromega.CZ 0)) (EnvRing.PEX 1);
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs := EnvRing.PEX 1
            |} ()) [] eq_refl (fun _ : positive => g);
     Gplus_0_r :=
       fun g : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEc (RMicromega.CZ 0));
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs := EnvRing.PEX 1
            |} ()) [] eq_refl (fun _ : positive => g);
     Gplus_assoc :=
       fun g h i : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEX 1)
                  (EnvRing.PEadd (EnvRing.PEX 2) (EnvRing.PEX 3));
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs :=
                EnvRing.PEadd (EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEX 2))
                  (EnvRing.PEX 3)
            |} ()) [] eq_refl
         (fun p : positive =>
          match p with
          | (_~1)%positive => i
          | (_~0)%positive => h
          | 1%positive => g
          end)
   |}
   (fun i : nat =>
    (fix nth (n : nat) (l : list R) (default : R) {struct l} : R :=
       match n with
       | 0%nat => match l with
                  | [] => default
                  | x :: _ => x
                  end
       | S m => match l with
                | [] => default
                | _ :: t => nth m t default
                end
       end) i
      match l with
      | [] => []
      | a :: l =>
          a
          :: (fix firstn (n : nat) (l0 : list R) {struct n} : list R :=
                match n with
                | 0%nat => []
                | S n0 =>
                    match l0 with
                    | [] => []
                    | a0 :: l1 => a0 :: firstn n0 l1
                    end
                end) n l
      end R0)
   ((fix length (l : list R) : nat :=
       match l with
       | [] => 0%nat
       | _ :: l' => S (length l')
       end)
      match l with
      | [] => []
      | a :: l =>
          a
          :: (fix firstn (n : nat) (l0 : list R) {struct n} : list R :=
                match n with
                | 0%nat => []
                | S n0 =>
                    match l0 with
                    | [] => []
                    | a0 :: l1 => a0 :: firstn n0 l1
                    end
                end) n l
      end) =
 ((fix big_sum
     (G : Type) (H : Monoid G) (f : nat -> G) (n : nat) {struct n} : G :=
     match n with
     | 0%nat => let (Gzero, Gplus, _, _, _) := H in Gzero
     | S n' =>
         (let (Gzero, Gplus, _, _, _) := H in Gplus) 
           (big_sum G H f n') (f n')
     end) R
    {|
      Gzero := R0;
      Gplus := Rplus;
      Gplus_0_l :=
        fun g : R =>
        RMicromega.RTautoChecker_sound
          (Tauto.A Tauto.isProp
             {|
               RingMicromega.Flhs :=
                 EnvRing.PEadd (EnvRing.PEc (RMicromega.CZ 0))
                   (EnvRing.PEX 1);
               RingMicromega.Fop := RingMicromega.OpEq;
               RingMicromega.Frhs := EnvRing.PEX 1
             |} ()) [] eq_refl (fun _ : positive => g);
      Gplus_0_r :=
        fun g : R =>
        RMicromega.RTautoChecker_sound
          (Tauto.A Tauto.isProp
             {|
               RingMicromega.Flhs :=
                 EnvRing.PEadd (EnvRing.PEX 1)
                   (EnvRing.PEc (RMicromega.CZ 0));
               RingMicromega.Fop := RingMicromega.OpEq;
               RingMicromega.Frhs := EnvRing.PEX 1
             |} ()) [] eq_refl (fun _ : positive => g);
      Gplus_assoc :=
        fun g h i : R =>
        RMicromega.RTautoChecker_sound
          (Tauto.A Tauto.isProp
             {|
               RingMicromega.Flhs :=
                 EnvRing.PEadd (EnvRing.PEX 1)
                   (EnvRing.PEadd (EnvRing.PEX 2) (EnvRing.PEX 3));
               RingMicromega.Fop := RingMicromega.OpEq;
               RingMicromega.Frhs :=
                 EnvRing.PEadd
                   (EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEX 2))
                   (EnvRing.PEX 3)
             |} ()) [] eq_refl
          (fun p : positive =>
           match p with
           | (_~1)%positive => i
           | (_~0)%positive => h
           | 1%positive => g
           end)
    |}
    (fun i : nat =>
     (fix nth (n : nat) (l : list R) (default : R) {struct l} : R :=
        match n with
        | 0%nat => match l with
                   | [] => default
                   | x :: _ => x
                   end
        | S m => match l with
                 | [] => default
                 | _ :: t => nth m t default
                 end
        end) i
       ((fix firstn (n : nat) (l : list R) {struct n} : list R :=
           match n with
           | 0%nat => []
           | S n0 =>
               match l with
               | [] => []
               | a :: l0 => a :: firstn n0 l0
               end
           end) n l) R0)
    ((fix length (l : list R) : nat :=
        match l with
        | [] => 0%nat
        | _ :: l' => S (length l')
        end)
       ((fix firstn (n : nat) (l : list R) {struct n} : list R :=
           match n with
           | 0%nat => []
           | S n0 =>
               match l with
               | [] => []
               | a :: l0 => a :: firstn n0 l0
               end
           end) n l)) +
  (fix nth (n : nat) (l : list R) (default : R) {struct l} : R :=
     match n with
     | 0%nat => match l with
                | [] => default
                | x :: _ => x
                end
     | S m => match l with
              | [] => default
              | _ :: t => nth m t default
              end
     end) n l R0)%R)
Crunching:
((fix big_sum (G : Type) (H : Monoid G) (f : nat -> G) (n : nat) {struct n} :
      G :=
    match n with
    | 0%nat => let (Gzero, Gplus, _, _, _) := H in Gzero
    | S n' =>
        (let (Gzero, Gplus, _, _, _) := H in Gplus) (big_sum G H f n') (f n')
    end) R
   {|
     Gzero := R0;
     Gplus := Rplus;
     Gplus_0_l :=
       fun g : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEc (RMicromega.CZ 0)) (EnvRing.PEX 1);
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs := EnvRing.PEX 1
            |} ()) [] eq_refl (fun _ : positive => g);
     Gplus_0_r :=
       fun g : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEc (RMicromega.CZ 0));
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs := EnvRing.PEX 1
            |} ()) [] eq_refl (fun _ : positive => g);
     Gplus_assoc :=
       fun g h i : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEX 1)
                  (EnvRing.PEadd (EnvRing.PEX 2) (EnvRing.PEX 3));
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs :=
                EnvRing.PEadd (EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEX 2))
                  (EnvRing.PEX 3)
            |} ()) [] eq_refl
         (fun p : positive =>
          match p with
          | (_~1)%positive => i
          | (_~0)%positive => h
          | 1%positive => g
          end)
   |}
   (fun i : nat =>
    (fix nth (n : nat) (l : list R) (default : R) {struct l} : R :=
       match n with
       | 0%nat => match l with
                  | [] => default
                  | x :: _ => x
                  end
       | S m => match l with
                | [] => default
                | _ :: t => nth m t default
                end
       end) i
      match l with
      | [] => []
      | a :: l =>
          a
          :: (fix firstn (n : nat) (l0 : list R) {struct n} : list R :=
                match n with
                | 0%nat => []
                | S n0 =>
                    match l0 with
                    | [] => []
                    | a0 :: l1 => a0 :: firstn n0 l1
                    end
                end) n l
      end R0)
   ((fix length (l : list R) : nat :=
       match l with
       | [] => 0%nat
       | _ :: l' => S (length l')
       end)
      match l with
      | [] => []
      | a :: l =>
          a
          :: (fix firstn (n : nat) (l0 : list R) {struct n} : list R :=
                match n with
                | 0%nat => []
                | S n0 =>
                    match l0 with
                    | [] => []
                    | a0 :: l1 => a0 :: firstn n0 l1
                    end
                end) n l
      end) =
 ((fix nth (n : nat) (l : list R) (default : R) {struct l} : R :=
     match n with
     | 0%nat => match l with
                | [] => default
                | x :: _ => x
                end
     | S m => match l with
              | [] => default
              | _ :: t => nth m t default
              end
     end) n l R0 +
  (fix big_sum
     (G : Type) (H : Monoid G) (f : nat -> G) (n : nat) {struct n} : G :=
     match n with
     | 0%nat => let (Gzero, Gplus, _, _, _) := H in Gzero
     | S n' =>
         (let (Gzero, Gplus, _, _, _) := H in Gplus) 
           (big_sum G H f n') (f n')
     end) R
    {|
      Gzero := R0;
      Gplus := Rplus;
      Gplus_0_l :=
        fun g : R =>
        RMicromega.RTautoChecker_sound
          (Tauto.A Tauto.isProp
             {|
               RingMicromega.Flhs :=
                 EnvRing.PEadd (EnvRing.PEc (RMicromega.CZ 0))
                   (EnvRing.PEX 1);
               RingMicromega.Fop := RingMicromega.OpEq;
               RingMicromega.Frhs := EnvRing.PEX 1
             |} ()) [] eq_refl (fun _ : positive => g);
      Gplus_0_r :=
        fun g : R =>
        RMicromega.RTautoChecker_sound
          (Tauto.A Tauto.isProp
             {|
               RingMicromega.Flhs :=
                 EnvRing.PEadd (EnvRing.PEX 1)
                   (EnvRing.PEc (RMicromega.CZ 0));
               RingMicromega.Fop := RingMicromega.OpEq;
               RingMicromega.Frhs := EnvRing.PEX 1
             |} ()) [] eq_refl (fun _ : positive => g);
      Gplus_assoc :=
        fun g h i : R =>
        RMicromega.RTautoChecker_sound
          (Tauto.A Tauto.isProp
             {|
               RingMicromega.Flhs :=
                 EnvRing.PEadd (EnvRing.PEX 1)
                   (EnvRing.PEadd (EnvRing.PEX 2) (EnvRing.PEX 3));
               RingMicromega.Fop := RingMicromega.OpEq;
               RingMicromega.Frhs :=
                 EnvRing.PEadd
                   (EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEX 2))
                   (EnvRing.PEX 3)
             |} ()) [] eq_refl
          (fun p : positive =>
           match p with
           | (_~1)%positive => i
           | (_~0)%positive => h
           | 1%positive => g
           end)
    |}
    (fun i : nat =>
     (fix nth (n : nat) (l : list R) (default : R) {struct l} : R :=
        match n with
        | 0%nat => match l with
                   | [] => default
                   | x :: _ => x
                   end
        | S m => match l with
                 | [] => default
                 | _ :: t => nth m t default
                 end
        end) i
       ((fix firstn (n : nat) (l : list R) {struct n} : list R :=
           match n with
           | 0%nat => []
           | S n0 =>
               match l with
               | [] => []
               | a :: l0 => a :: firstn n0 l0
               end
           end) n l) R0)
    ((fix length (l : list R) : nat :=
        match l with
        | [] => 0%nat
        | _ :: l' => S (length l')
        end)
       ((fix firstn (n : nat) (l : list R) {struct n} : list R :=
           match n with
           | 0%nat => []
           | S n0 =>
               match l with
               | [] => []
               | a :: l0 => a :: firstn n0 l0
               end
           end) n l)))%R)
Crunching:
((fix big_sum (G : Type) (H : Monoid G) (f : nat -> G) (n : nat) {struct n} :
      G :=
    match n with
    | 0%nat => let (Gzero, Gplus, _, _, _) := H in Gzero
    | S n' =>
        (let (Gzero, Gplus, _, _, _) := H in Gplus) (big_sum G H f n') (f n')
    end) R
   {|
     Gzero := R0;
     Gplus := Rplus;
     Gplus_0_l :=
       fun g : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEc (RMicromega.CZ 0)) (EnvRing.PEX 1);
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs := EnvRing.PEX 1
            |} ()) [] eq_refl (fun _ : positive => g);
     Gplus_0_r :=
       fun g : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEc (RMicromega.CZ 0));
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs := EnvRing.PEX 1
            |} ()) [] eq_refl (fun _ : positive => g);
     Gplus_assoc :=
       fun g h i : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEX 1)
                  (EnvRing.PEadd (EnvRing.PEX 2) (EnvRing.PEX 3));
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs :=
                EnvRing.PEadd (EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEX 2))
                  (EnvRing.PEX 3)
            |} ()) [] eq_refl
         (fun p : positive =>
          match p with
          | (_~1)%positive => i
          | (_~0)%positive => h
          | 1%positive => g
          end)
   |}
   (fun i : nat =>
    (fix nth (n : nat) (l : list R) (default : R) {struct l} : R :=
       match n with
       | 0%nat => match l with
                  | [] => default
                  | x :: _ => x
                  end
       | S m => match l with
                | [] => default
                | _ :: t => nth m t default
                end
       end) i
      match l with
      | [] => []
      | a :: l =>
          a
          :: (fix firstn (n : nat) (l0 : list R) {struct n} : list R :=
                match n with
                | 0%nat => []
                | S n0 =>
                    match l0 with
                    | [] => []
                    | a0 :: l1 => a0 :: firstn n0 l1
                    end
                end) n l
      end R0)
   ((fix length (l : list R) : nat :=
       match l with
       | [] => 0%nat
       | _ :: l' => S (length l')
       end)
      match l with
      | [] => []
      | a :: l =>
          a
          :: (fix firstn (n : nat) (l0 : list R) {struct n} : list R :=
                match n with
                | 0%nat => []
                | S n0 =>
                    match l0 with
                    | [] => []
                    | a0 :: l1 => a0 :: firstn n0 l1
                    end
                end) n l
      end) =
 ((fix big_sum
     (G : Type) (H : Monoid G) (f : nat -> G) (n : nat) {struct n} : G :=
     match n with
     | 0%nat => let (Gzero, Gplus, _, _, _) := H in Gzero
     | S n' =>
         (let (Gzero, Gplus, _, _, _) := H in Gplus) 
           (big_sum G H f n') (f n')
     end) R
    {|
      Gzero := R0;
      Gplus := Rplus;
      Gplus_0_l :=
        fun g : R =>
        RMicromega.RTautoChecker_sound
          (Tauto.A Tauto.isProp
             {|
               RingMicromega.Flhs :=
                 EnvRing.PEadd (EnvRing.PEc (RMicromega.CZ 0))
                   (EnvRing.PEX 1);
               RingMicromega.Fop := RingMicromega.OpEq;
               RingMicromega.Frhs := EnvRing.PEX 1
             |} ()) [] eq_refl (fun _ : positive => g);
      Gplus_0_r :=
        fun g : R =>
        RMicromega.RTautoChecker_sound
          (Tauto.A Tauto.isProp
             {|
               RingMicromega.Flhs :=
                 EnvRing.PEadd (EnvRing.PEX 1)
                   (EnvRing.PEc (RMicromega.CZ 0));
               RingMicromega.Fop := RingMicromega.OpEq;
               RingMicromega.Frhs := EnvRing.PEX 1
             |} ()) [] eq_refl (fun _ : positive => g);
      Gplus_assoc :=
        fun g h i : R =>
        RMicromega.RTautoChecker_sound
          (Tauto.A Tauto.isProp
             {|
               RingMicromega.Flhs :=
                 EnvRing.PEadd (EnvRing.PEX 1)
                   (EnvRing.PEadd (EnvRing.PEX 2) (EnvRing.PEX 3));
               RingMicromega.Fop := RingMicromega.OpEq;
               RingMicromega.Frhs :=
                 EnvRing.PEadd
                   (EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEX 2))
                   (EnvRing.PEX 3)
             |} ()) [] eq_refl
          (fun p : positive =>
           match p with
           | (_~1)%positive => i
           | (_~0)%positive => h
           | 1%positive => g
           end)
    |}
    (fun i : nat =>
     (fix nth (n : nat) (l : list R) (default : R) {struct l} : R :=
        match n with
        | 0%nat => match l with
                   | [] => default
                   | x :: _ => x
                   end
        | S m => match l with
                 | [] => default
                 | _ :: t => nth m t default
                 end
        end) i
       ((fix firstn (n : nat) (l : list R) {struct n} : list R :=
           match n with
           | 0%nat => []
           | S n0 =>
               match l with
               | [] => []
               | a :: l0 => a :: firstn n0 l0
               end
           end) n l) R0)
    ((fix length (l : list R) : nat :=
        match l with
        | [] => 0%nat
        | _ :: l' => S (length l')
        end)
       ((fix firstn (n : nat) (l : list R) {struct n} : list R :=
           match n with
           | 0%nat => []
           | S n0 =>
               match l with
               | [] => []
               | a :: l0 => a :: firstn n0 l0
               end
           end) n l)) +
  (fix nth (n : nat) (l : list R) (default : R) {struct l} : R :=
     match n with
     | 0%nat => match l with
                | [] => default
                | x :: _ => x
                end
     | S m => match l with
              | [] => default
              | _ :: t => nth m t default
              end
     end) n l R0)%R)
Crunching:
((fix big_sum (G : Type) (H : Monoid G) (f : nat -> G) (n : nat) {struct n} :
      G :=
    match n with
    | 0%nat => let (Gzero, Gplus, _, _, _) := H in Gzero
    | S n' =>
        (let (Gzero, Gplus, _, _, _) := H in Gplus) (big_sum G H f n') (f n')
    end) R
   {|
     Gzero := R0;
     Gplus := Rplus;
     Gplus_0_l :=
       fun g : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEc (RMicromega.CZ 0)) (EnvRing.PEX 1);
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs := EnvRing.PEX 1
            |} ()) [] eq_refl (fun _ : positive => g);
     Gplus_0_r :=
       fun g : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEc (RMicromega.CZ 0));
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs := EnvRing.PEX 1
            |} ()) [] eq_refl (fun _ : positive => g);
     Gplus_assoc :=
       fun g h i : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEX 1)
                  (EnvRing.PEadd (EnvRing.PEX 2) (EnvRing.PEX 3));
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs :=
                EnvRing.PEadd (EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEX 2))
                  (EnvRing.PEX 3)
            |} ()) [] eq_refl
         (fun p : positive =>
          match p with
          | (_~1)%positive => i
          | (_~0)%positive => h
          | 1%positive => g
          end)
   |}
   (fun i : nat =>
    (fix nth (n : nat) (l : list R) (default : R) {struct l} : R :=
       match n with
       | 0%nat => match l with
                  | [] => default
                  | x :: _ => x
                  end
       | S m => match l with
                | [] => default
                | _ :: t => nth m t default
                end
       end) i
      match l with
      | [] => []
      | a :: l =>
          a
          :: (fix firstn (n : nat) (l0 : list R) {struct n} : list R :=
                match n with
                | 0%nat => []
                | S n0 =>
                    match l0 with
                    | [] => []
                    | a0 :: l1 => a0 :: firstn n0 l1
                    end
                end) n l
      end R0)
   ((fix length (l : list R) : nat :=
       match l with
       | [] => 0%nat
       | _ :: l' => S (length l')
       end)
      match l with
      | [] => []
      | a :: l =>
          a
          :: (fix firstn (n : nat) (l0 : list R) {struct n} : list R :=
                match n with
                | 0%nat => []
                | S n0 =>
                    match l0 with
                    | [] => []
                    | a0 :: l1 => a0 :: firstn n0 l1
                    end
                end) n l
      end) =
 ((fix nth (n : nat) (l : list R) (default : R) {struct l} : R :=
     match n with
     | 0%nat => match l with
                | [] => default
                | x :: _ => x
                end
     | S m => match l with
              | [] => default
              | _ :: t => nth m t default
              end
     end) n l R0 +
  (fix big_sum
     (G : Type) (H : Monoid G) (f : nat -> G) (n : nat) {struct n} : G :=
     match n with
     | 0%nat => let (Gzero, Gplus, _, _, _) := H in Gzero
     | S n' =>
         (let (Gzero, Gplus, _, _, _) := H in Gplus) 
           (big_sum G H f n') (f n')
     end) R
    {|
      Gzero := R0;
      Gplus := Rplus;
      Gplus_0_l :=
        fun g : R =>
        RMicromega.RTautoChecker_sound
          (Tauto.A Tauto.isProp
             {|
               RingMicromega.Flhs :=
                 EnvRing.PEadd (EnvRing.PEc (RMicromega.CZ 0))
                   (EnvRing.PEX 1);
               RingMicromega.Fop := RingMicromega.OpEq;
               RingMicromega.Frhs := EnvRing.PEX 1
             |} ()) [] eq_refl (fun _ : positive => g);
      Gplus_0_r :=
        fun g : R =>
        RMicromega.RTautoChecker_sound
          (Tauto.A Tauto.isProp
             {|
               RingMicromega.Flhs :=
                 EnvRing.PEadd (EnvRing.PEX 1)
                   (EnvRing.PEc (RMicromega.CZ 0));
               RingMicromega.Fop := RingMicromega.OpEq;
               RingMicromega.Frhs := EnvRing.PEX 1
             |} ()) [] eq_refl (fun _ : positive => g);
      Gplus_assoc :=
        fun g h i : R =>
        RMicromega.RTautoChecker_sound
          (Tauto.A Tauto.isProp
             {|
               RingMicromega.Flhs :=
                 EnvRing.PEadd (EnvRing.PEX 1)
                   (EnvRing.PEadd (EnvRing.PEX 2) (EnvRing.PEX 3));
               RingMicromega.Fop := RingMicromega.OpEq;
               RingMicromega.Frhs :=
                 EnvRing.PEadd
                   (EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEX 2))
                   (EnvRing.PEX 3)
             |} ()) [] eq_refl
          (fun p : positive =>
           match p with
           | (_~1)%positive => i
           | (_~0)%positive => h
           | 1%positive => g
           end)
    |}
    (fun i : nat =>
     (fix nth (n : nat) (l : list R) (default : R) {struct l} : R :=
        match n with
        | 0%nat => match l with
                   | [] => default
                   | x :: _ => x
                   end
        | S m => match l with
                 | [] => default
                 | _ :: t => nth m t default
                 end
        end) i
       ((fix firstn (n : nat) (l : list R) {struct n} : list R :=
           match n with
           | 0%nat => []
           | S n0 =>
               match l with
               | [] => []
               | a :: l0 => a :: firstn n0 l0
               end
           end) n l) R0)
    ((fix length (l : list R) : nat :=
        match l with
        | [] => 0%nat
        | _ :: l' => S (length l')
        end)
       ((fix firstn (n : nat) (l : list R) {struct n} : list R :=
           match n with
           | 0%nat => []
           | S n0 =>
               match l with
               | [] => []
               | a :: l0 => a :: firstn n0 l0
               end
           end) n l)))%R)
Crunching:
((fix big_sum (G : Type) (H : Monoid G) (f : nat -> G) (n : nat) {struct n} :
      G :=
    match n with
    | 0%nat => let (Gzero, Gplus, _, _, _) := H in Gzero
    | S n' =>
        (let (Gzero, Gplus, _, _, _) := H in Gplus) (big_sum G H f n') (f n')
    end) R
   {|
     Gzero := R0;
     Gplus := Rplus;
     Gplus_0_l :=
       fun g : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEc (RMicromega.CZ 0)) (EnvRing.PEX 1);
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs := EnvRing.PEX 1
            |} ()) [] eq_refl (fun _ : positive => g);
     Gplus_0_r :=
       fun g : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEc (RMicromega.CZ 0));
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs := EnvRing.PEX 1
            |} ()) [] eq_refl (fun _ : positive => g);
     Gplus_assoc :=
       fun g h i : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEX 1)
                  (EnvRing.PEadd (EnvRing.PEX 2) (EnvRing.PEX 3));
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs :=
                EnvRing.PEadd (EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEX 2))
                  (EnvRing.PEX 3)
            |} ()) [] eq_refl
         (fun p : positive =>
          match p with
          | (_~1)%positive => i
          | (_~0)%positive => h
          | 1%positive => g
          end)
   |}
   (fun i : nat =>
    (fix nth (n : nat) (l : list R) (default : R) {struct l} : R :=
       match n with
       | 0%nat => match l with
                  | [] => default
                  | x :: _ => x
                  end
       | S m => match l with
                | [] => default
                | _ :: t => nth m t default
                end
       end) i
      match l with
      | [] => []
      | a :: l =>
          a
          :: (fix firstn (n : nat) (l0 : list R) {struct n} : list R :=
                match n with
                | 0%nat => []
                | S n0 =>
                    match l0 with
                    | [] => []
                    | a0 :: l1 => a0 :: firstn n0 l1
                    end
                end) n l
      end R0)
   ((fix length (l : list R) : nat :=
       match l with
       | [] => 0%nat
       | _ :: l' => S (length l')
       end)
      match l with
      | [] => []
      | a :: l =>
          a
          :: (fix firstn (n : nat) (l0 : list R) {struct n} : list R :=
                match n with
                | 0%nat => []
                | S n0 =>
                    match l0 with
                    | [] => []
                    | a0 :: l1 => a0 :: firstn n0 l1
                    end
                end) n l
      end) =
 ((fix big_sum
     (G : Type) (H : Monoid G) (f : nat -> G) (n : nat) {struct n} : G :=
     match n with
     | 0%nat => let (Gzero, Gplus, _, _, _) := H in Gzero
     | S n' =>
         (let (Gzero, Gplus, _, _, _) := H in Gplus) 
           (big_sum G H f n') (f n')
     end) R
    {|
      Gzero := R0;
      Gplus := Rplus;
      Gplus_0_l :=
        fun g : R =>
        RMicromega.RTautoChecker_sound
          (Tauto.A Tauto.isProp
             {|
               RingMicromega.Flhs :=
                 EnvRing.PEadd (EnvRing.PEc (RMicromega.CZ 0))
                   (EnvRing.PEX 1);
               RingMicromega.Fop := RingMicromega.OpEq;
               RingMicromega.Frhs := EnvRing.PEX 1
             |} ()) [] eq_refl (fun _ : positive => g);
      Gplus_0_r :=
        fun g : R =>
        RMicromega.RTautoChecker_sound
          (Tauto.A Tauto.isProp
             {|
               RingMicromega.Flhs :=
                 EnvRing.PEadd (EnvRing.PEX 1)
                   (EnvRing.PEc (RMicromega.CZ 0));
               RingMicromega.Fop := RingMicromega.OpEq;
               RingMicromega.Frhs := EnvRing.PEX 1
             |} ()) [] eq_refl (fun _ : positive => g);
      Gplus_assoc :=
        fun g h i : R =>
        RMicromega.RTautoChecker_sound
          (Tauto.A Tauto.isProp
             {|
               RingMicromega.Flhs :=
                 EnvRing.PEadd (EnvRing.PEX 1)
                   (EnvRing.PEadd (EnvRing.PEX 2) (EnvRing.PEX 3));
               RingMicromega.Fop := RingMicromega.OpEq;
               RingMicromega.Frhs :=
                 EnvRing.PEadd
                   (EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEX 2))
                   (EnvRing.PEX 3)
             |} ()) [] eq_refl
          (fun p : positive =>
           match p with
           | (_~1)%positive => i
           | (_~0)%positive => h
           | 1%positive => g
           end)
    |}
    (fun i : nat =>
     (fix nth (n : nat) (l : list R) (default : R) {struct l} : R :=
        match n with
        | 0%nat => match l with
                   | [] => default
                   | x :: _ => x
                   end
        | S m => match l with
                 | [] => default
                 | _ :: t => nth m t default
                 end
        end) i
       ((fix firstn (n : nat) (l : list R) {struct n} : list R :=
           match n with
           | 0%nat => []
           | S n0 =>
               match l with
               | [] => []
               | a :: l0 => a :: firstn n0 l0
               end
           end) n l) R0)
    ((fix length (l : list R) : nat :=
        match l with
        | [] => 0%nat
        | _ :: l' => S (length l')
        end)
       ((fix firstn (n : nat) (l : list R) {struct n} : list R :=
           match n with
           | 0%nat => []
           | S n0 =>
               match l with
               | [] => []
               | a :: l0 => a :: firstn n0 l0
               end
           end) n l)) +
  (fix nth (n : nat) (l : list R) (default : R) {struct l} : R :=
     match n with
     | 0%nat => match l with
                | [] => default
                | x :: _ => x
                end
     | S m => match l with
              | [] => default
              | _ :: t => nth m t default
              end
     end) n l R0)%R)
Crunching:
((fix big_sum (G : Type) (H : Monoid G) (f : nat -> G) (n : nat) {struct n} :
      G :=
    match n with
    | 0%nat => let (Gzero, Gplus, _, _, _) := H in Gzero
    | S n' =>
        (let (Gzero, Gplus, _, _, _) := H in Gplus) (big_sum G H f n') (f n')
    end) R
   {|
     Gzero := R0;
     Gplus := Rplus;
     Gplus_0_l :=
       fun g : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEc (RMicromega.CZ 0)) (EnvRing.PEX 1);
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs := EnvRing.PEX 1
            |} ()) [] eq_refl (fun _ : positive => g);
     Gplus_0_r :=
       fun g : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEc (RMicromega.CZ 0));
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs := EnvRing.PEX 1
            |} ()) [] eq_refl (fun _ : positive => g);
     Gplus_assoc :=
       fun g h i : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEX 1)
                  (EnvRing.PEadd (EnvRing.PEX 2) (EnvRing.PEX 3));
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs :=
                EnvRing.PEadd (EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEX 2))
                  (EnvRing.PEX 3)
            |} ()) [] eq_refl
         (fun p : positive =>
          match p with
          | (_~1)%positive => i
          | (_~0)%positive => h
          | 1%positive => g
          end)
   |}
   (fun i : nat =>
    (fix nth (n : nat) (l : list R) (default : R) {struct l} : R :=
       match n with
       | 0%nat => match l with
                  | [] => default
                  | x :: _ => x
                  end
       | S m => match l with
                | [] => default
                | _ :: t => nth m t default
                end
       end) i
      match l with
      | [] => []
      | a :: l =>
          a
          :: (fix firstn (n : nat) (l0 : list R) {struct n} : list R :=
                match n with
                | 0%nat => []
                | S n0 =>
                    match l0 with
                    | [] => []
                    | a0 :: l1 => a0 :: firstn n0 l1
                    end
                end) n l
      end R0)
   ((fix length (l : list R) : nat :=
       match l with
       | [] => 0%nat
       | _ :: l' => S (length l')
       end)
      match l with
      | [] => []
      | a :: l =>
          a
          :: (fix firstn (n : nat) (l0 : list R) {struct n} : list R :=
                match n with
                | 0%nat => []
                | S n0 =>
                    match l0 with
                    | [] => []
                    | a0 :: l1 => a0 :: firstn n0 l1
                    end
                end) n l
      end) =
 ((fix nth (n : nat) (l : list R) (default : R) {struct l} : R :=
     match n with
     | 0%nat => match l with
                | [] => default
                | x :: _ => x
                end
     | S m => match l with
              | [] => default
              | _ :: t => nth m t default
              end
     end) n l R0 +
  (fix big_sum
     (G : Type) (H : Monoid G) (f : nat -> G) (n : nat) {struct n} : G :=
     match n with
     | 0%nat => let (Gzero, Gplus, _, _, _) := H in Gzero
     | S n' =>
         (let (Gzero, Gplus, _, _, _) := H in Gplus) 
           (big_sum G H f n') (f n')
     end) R
    {|
      Gzero := R0;
      Gplus := Rplus;
      Gplus_0_l :=
        fun g : R =>
        RMicromega.RTautoChecker_sound
          (Tauto.A Tauto.isProp
             {|
               RingMicromega.Flhs :=
                 EnvRing.PEadd (EnvRing.PEc (RMicromega.CZ 0))
                   (EnvRing.PEX 1);
               RingMicromega.Fop := RingMicromega.OpEq;
               RingMicromega.Frhs := EnvRing.PEX 1
             |} ()) [] eq_refl (fun _ : positive => g);
      Gplus_0_r :=
        fun g : R =>
        RMicromega.RTautoChecker_sound
          (Tauto.A Tauto.isProp
             {|
               RingMicromega.Flhs :=
                 EnvRing.PEadd (EnvRing.PEX 1)
                   (EnvRing.PEc (RMicromega.CZ 0));
               RingMicromega.Fop := RingMicromega.OpEq;
               RingMicromega.Frhs := EnvRing.PEX 1
             |} ()) [] eq_refl (fun _ : positive => g);
      Gplus_assoc :=
        fun g h i : R =>
        RMicromega.RTautoChecker_sound
          (Tauto.A Tauto.isProp
             {|
               RingMicromega.Flhs :=
                 EnvRing.PEadd (EnvRing.PEX 1)
                   (EnvRing.PEadd (EnvRing.PEX 2) (EnvRing.PEX 3));
               RingMicromega.Fop := RingMicromega.OpEq;
               RingMicromega.Frhs :=
                 EnvRing.PEadd
                   (EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEX 2))
                   (EnvRing.PEX 3)
             |} ()) [] eq_refl
          (fun p : positive =>
           match p with
           | (_~1)%positive => i
           | (_~0)%positive => h
           | 1%positive => g
           end)
    |}
    (fun i : nat =>
     (fix nth (n : nat) (l : list R) (default : R) {struct l} : R :=
        match n with
        | 0%nat => match l with
                   | [] => default
                   | x :: _ => x
                   end
        | S m => match l with
                 | [] => default
                 | _ :: t => nth m t default
                 end
        end) i
       ((fix firstn (n : nat) (l : list R) {struct n} : list R :=
           match n with
           | 0%nat => []
           | S n0 =>
               match l with
               | [] => []
               | a :: l0 => a :: firstn n0 l0
               end
           end) n l) R0)
    ((fix length (l : list R) : nat :=
        match l with
        | [] => 0%nat
        | _ :: l' => S (length l')
        end)
       ((fix firstn (n : nat) (l : list R) {struct n} : list R :=
           match n with
           | 0%nat => []
           | S n0 =>
               match l with
               | [] => []
               | a :: l0 => a :: firstn n0 l0
               end
           end) n l)))%R)
Crunching: False
Crunching: (Forall (fun x : R => 0 <= x) (scale a l))
Crunching: (Forall (fun x : R => 0 <= x) (scale a l))
Crunching: (0 < 2 ^ p -> funbool_to_nat p (nat_to_funbool p 0) = 0)
Crunching: (Forall (fun x : R => 0 <= x) (scale a l))
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (H < 2 ^ n -> funbool_to_nat n (nat_to_funbool n H) = H)
Crunching: (0 < 2 ^ len -> funbool_to_nat len (nat_to_funbool len 0) = 0)
Crunching:
(0 < 2 ^ p -> binlist_to_nat (funbool_to_list p (nat_to_funbool p 0)) = 0)
Crunching: (0 < 2 ^ p -> funbool_to_nat p (nat_to_funbool p 0) = 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (0 < 2 ^ len -> funbool_to_nat len (nat_to_funbool len 0) = 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Debug:
In environment
i : int
cps : ?Goal2 *m ?Goal4 = const_mx 0
e : eqb match i with
        | Posz n' => eqn (2 - n')%Nrec 0
        | Negz _ => false
        end true
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: (a (intZmod.addz (intZmod.addz i 1) 1) *
          ((a (intZmod.addz i 1))^-1)%Q)%Q;
         ((((((cast 17%Z *
               (match i with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                 1%Q + loop elpi_ctx_entry_7_
                             end) n)%Q
                     end)%Q
                end *
                match i with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                 1%Q + loop elpi_ctx_entry_7_
                             end) n)%Q
                     end)%Q
                end)%Q)%Q +
              (cast 51%Z *
               match i with
               | Posz n => iterop n addq 1 0
               | Negz n =>
                   (-
                    match n with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                1%Q + loop elpi_ctx_entry_7_
                            end) n)%Q
                    end)%Q
               end)%Q)%Q + cast 39%Z)%Q *
            ((cast 2%Z *
              match i with
              | Posz n => iterop n addq 1 0
              | Negz n =>
                  (-
                   match n with
                   | 0 => 1%Q
                   | _.+1 =>
                       (1%Q +
                        (fix loop (m : nat) : rat :=
                           match m with
                           | 0 => 0
                           | 1 => 1
                           | (_.+1 as elpi_ctx_entry_7_).+1 =>
                               1%Q + loop elpi_ctx_entry_7_
                           end) n)%Q
                   end)%Q
              end)%Q + cast 3%Z)%Q)%Q *
           (((match i with
              | Posz n => iterop n addq 1 0
              | Negz n =>
                  (-
                   match n with
                   | 0 => 1%Q
                   | _.+1 =>
                       (1%Q +
                        (fix loop (m : nat) : rat :=
                           match m with
                           | 0 => 0
                           | 1 => 1
                           | (_.+1 as elpi_ctx_entry_7_).+1 =>
                               1%Q + loop elpi_ctx_entry_7_
                           end) n)%Q
                   end)%Q
              end + cast 2%Z)%Q *
             ((match i with
               | Posz n => iterop n addq 1 0
               | Negz n =>
                   (-
                    match n with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                1%Q + loop elpi_ctx_entry_7_
                            end) n)%Q
                    end)%Q
               end + cast 2%Z)%Q *
              (match i with
               | Posz n => iterop n addq 1 0
               | Negz n =>
                   (-
                    match n with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                1%Q + loop elpi_ctx_entry_7_
                            end) n)%Q
                    end)%Q
               end + cast 2%Z)%Q)%Q)%Q^-1)%Q)%Q +
          (-
           ((((match i with
               | Posz n => iterop n addq 1 0
               | Negz n =>
                   (-
                    match n with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                1%Q + loop elpi_ctx_entry_7_
                            end) n)%Q
                    end)%Q
               end + cast 1%Z)%Q *
              ((match i with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                 1%Q + loop elpi_ctx_entry_7_
                             end) n)%Q
                     end)%Q
                end + cast 2%Z)%Q^-1)%Q)%Q *
             (((match i with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                 1%Q + loop elpi_ctx_entry_7_
                             end) n)%Q
                     end)%Q
                end + cast 1%Z)%Q *
               ((match i with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                  1%Q + loop elpi_ctx_entry_7_
                              end) n)%Q
                      end)%Q
                 end + cast 2%Z)%Q^-1)%Q)%Q *
              ((match i with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                 1%Q + loop elpi_ctx_entry_7_
                             end) n)%Q
                     end)%Q
                end + cast 1%Z)%Q *
               ((match i with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                  1%Q + loop elpi_ctx_entry_7_
                              end) n)%Q
                      end)%Q
                 end + cast 2%Z)%Q^-1)%Q)%Q)%Q)%Q *
            ((a (intZmod.addz i 1) * ((a i)^-1)%Q)%Q^-1)%Q)%Q)%Q)%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching: (funbool_to_nat len (nat_to_funbool len n) = n)
Debug:
In environment
i : int
cps : ?Goal2 *m ?Goal4 = const_mx 0
e : eqb match i with
        | Posz n' => eqn (2 - n')%Nrec 0
        | Negz _ => false
        end true
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: (a (intZmod.addz (intZmod.addz i 1) 1) *
          ((a (intZmod.addz i 1))^-1)%Q)%Q;
         ((((((cast 17%Z *
               (match i with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                 1%Q + loop elpi_ctx_entry_7_
                             end) n)%Q
                     end)%Q
                end *
                match i with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                 1%Q + loop elpi_ctx_entry_7_
                             end) n)%Q
                     end)%Q
                end)%Q)%Q +
              (cast 51%Z *
               match i with
               | Posz n => iterop n addq 1 0
               | Negz n =>
                   (-
                    match n with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                1%Q + loop elpi_ctx_entry_7_
                            end) n)%Q
                    end)%Q
               end)%Q)%Q + cast 39%Z)%Q *
            ((cast 2%Z *
              match i with
              | Posz n => iterop n addq 1 0
              | Negz n =>
                  (-
                   match n with
                   | 0 => 1%Q
                   | _.+1 =>
                       (1%Q +
                        (fix loop (m : nat) : rat :=
                           match m with
                           | 0 => 0
                           | 1 => 1
                           | (_.+1 as elpi_ctx_entry_7_).+1 =>
                               1%Q + loop elpi_ctx_entry_7_
                           end) n)%Q
                   end)%Q
              end)%Q + cast 3%Z)%Q)%Q *
           (((match i with
              | Posz n => iterop n addq 1 0
              | Negz n =>
                  (-
                   match n with
                   | 0 => 1%Q
                   | _.+1 =>
                       (1%Q +
                        (fix loop (m : nat) : rat :=
                           match m with
                           | 0 => 0
                           | 1 => 1
                           | (_.+1 as elpi_ctx_entry_7_).+1 =>
                               1%Q + loop elpi_ctx_entry_7_
                           end) n)%Q
                   end)%Q
              end + cast 2%Z)%Q *
             ((match i with
               | Posz n => iterop n addq 1 0
               | Negz n =>
                   (-
                    match n with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                1%Q + loop elpi_ctx_entry_7_
                            end) n)%Q
                    end)%Q
               end + cast 2%Z)%Q *
              (match i with
               | Posz n => iterop n addq 1 0
               | Negz n =>
                   (-
                    match n with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                1%Q + loop elpi_ctx_entry_7_
                            end) n)%Q
                    end)%Q
               end + cast 2%Z)%Q)%Q)%Q^-1)%Q)%Q +
          (-
           ((((match i with
               | Posz n => iterop n addq 1 0
               | Negz n =>
                   (-
                    match n with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                1%Q + loop elpi_ctx_entry_7_
                            end) n)%Q
                    end)%Q
               end + cast 1%Z)%Q *
              ((match i with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                 1%Q + loop elpi_ctx_entry_7_
                             end) n)%Q
                     end)%Q
                end + cast 2%Z)%Q^-1)%Q)%Q *
             (((match i with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                 1%Q + loop elpi_ctx_entry_7_
                             end) n)%Q
                     end)%Q
                end + cast 1%Z)%Q *
               ((match i with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                  1%Q + loop elpi_ctx_entry_7_
                              end) n)%Q
                      end)%Q
                 end + cast 2%Z)%Q^-1)%Q)%Q *
              ((match i with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                 1%Q + loop elpi_ctx_entry_7_
                             end) n)%Q
                     end)%Q
                end + cast 1%Z)%Q *
               ((match i with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                  1%Q + loop elpi_ctx_entry_7_
                              end) n)%Q
                      end)%Q
                 end + cast 2%Z)%Q^-1)%Q)%Q)%Q)%Q *
            ((a (intZmod.addz i 1) * ((a i)^-1)%Q)%Q^-1)%Q)%Q)%Q)%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
i : int
a : ?Goal2 *m ?Goal4 = const_mx 0
id_x : eqb
         match i with
         | Posz n' => eqn (2 - n')%Nrec 0
         | Negz _ => false
         end true
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: (seq_defs.a (intZmod.addz (intZmod.addz i 1) 1) *
          ((seq_defs.a (intZmod.addz i 1))^-1)%Q)%Q;
         ((((((cast 17%Z *
               (match i with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                 1%Q + loop elpi_ctx_entry_7_
                             end) n)%Q
                     end)%Q
                end *
                match i with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                 1%Q + loop elpi_ctx_entry_7_
                             end) n)%Q
                     end)%Q
                end)%Q)%Q +
              (cast 51%Z *
               match i with
               | Posz n => iterop n addq 1 0
               | Negz n =>
                   (-
                    match n with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                1%Q + loop elpi_ctx_entry_7_
                            end) n)%Q
                    end)%Q
               end)%Q)%Q + cast 39%Z)%Q *
            ((cast 2%Z *
              match i with
              | Posz n => iterop n addq 1 0
              | Negz n =>
                  (-
                   match n with
                   | 0 => 1%Q
                   | _.+1 =>
                       (1%Q +
                        (fix loop (m : nat) : rat :=
                           match m with
                           | 0 => 0
                           | 1 => 1
                           | (_.+1 as elpi_ctx_entry_7_).+1 =>
                               1%Q + loop elpi_ctx_entry_7_
                           end) n)%Q
                   end)%Q
              end)%Q + cast 3%Z)%Q)%Q *
           (((match i with
              | Posz n => iterop n addq 1 0
              | Negz n =>
                  (-
                   match n with
                   | 0 => 1%Q
                   | _.+1 =>
                       (1%Q +
                        (fix loop (m : nat) : rat :=
                           match m with
                           | 0 => 0
                           | 1 => 1
                           | (_.+1 as elpi_ctx_entry_7_).+1 =>
                               1%Q + loop elpi_ctx_entry_7_
                           end) n)%Q
                   end)%Q
              end + cast 2%Z)%Q *
             ((match i with
               | Posz n => iterop n addq 1 0
               | Negz n =>
                   (-
                    match n with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                1%Q + loop elpi_ctx_entry_7_
                            end) n)%Q
                    end)%Q
               end + cast 2%Z)%Q *
              (match i with
               | Posz n => iterop n addq 1 0
               | Negz n =>
                   (-
                    match n with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                1%Q + loop elpi_ctx_entry_7_
                            end) n)%Q
                    end)%Q
               end + cast 2%Z)%Q)%Q)%Q^-1)%Q)%Q +
          (-
           ((((match i with
               | Posz n => iterop n addq 1 0
               | Negz n =>
                   (-
                    match n with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                1%Q + loop elpi_ctx_entry_7_
                            end) n)%Q
                    end)%Q
               end + cast 1%Z)%Q *
              ((match i with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                 1%Q + loop elpi_ctx_entry_7_
                             end) n)%Q
                     end)%Q
                end + cast 2%Z)%Q^-1)%Q)%Q *
             (((match i with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                 1%Q + loop elpi_ctx_entry_7_
                             end) n)%Q
                     end)%Q
                end + cast 1%Z)%Q *
               ((match i with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                  1%Q + loop elpi_ctx_entry_7_
                              end) n)%Q
                      end)%Q
                 end + cast 2%Z)%Q^-1)%Q)%Q *
              ((match i with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                 1%Q + loop elpi_ctx_entry_7_
                             end) n)%Q
                     end)%Q
                end + cast 1%Z)%Q *
               ((match i with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                  1%Q + loop elpi_ctx_entry_7_
                              end) n)%Q
                      end)%Q
                 end + cast 2%Z)%Q^-1)%Q)%Q)%Q)%Q *
            ((seq_defs.a (intZmod.addz i 1) * ((seq_defs.a i)^-1)%Q)%Q^-1)%Q)%Q)%Q)%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
i : int
a : ?Goal2 *m ?Goal4 = const_mx 0
n_gt0 : eqb
          match i with
          | Posz n' => eqn (2 - n')%Nrec 0
          | Negz _ => false
          end true
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: (seq_defs.a (intZmod.addz (intZmod.addz i 1) 1) *
          ((seq_defs.a (intZmod.addz i 1))^-1)%Q)%Q;
         ((((((cast 17%Z *
               (match i with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                 1%Q + loop elpi_ctx_entry_7_
                             end) n)%Q
                     end)%Q
                end *
                match i with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                 1%Q + loop elpi_ctx_entry_7_
                             end) n)%Q
                     end)%Q
                end)%Q)%Q +
              (cast 51%Z *
               match i with
               | Posz n => iterop n addq 1 0
               | Negz n =>
                   (-
                    match n with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                1%Q + loop elpi_ctx_entry_7_
                            end) n)%Q
                    end)%Q
               end)%Q)%Q + cast 39%Z)%Q *
            ((cast 2%Z *
              match i with
              | Posz n => iterop n addq 1 0
              | Negz n =>
                  (-
                   match n with
                   | 0 => 1%Q
                   | _.+1 =>
                       (1%Q +
                        (fix loop (m : nat) : rat :=
                           match m with
                           | 0 => 0
                           | 1 => 1
                           | (_.+1 as elpi_ctx_entry_7_).+1 =>
                               1%Q + loop elpi_ctx_entry_7_
                           end) n)%Q
                   end)%Q
              end)%Q + cast 3%Z)%Q)%Q *
           (((match i with
              | Posz n => iterop n addq 1 0
              | Negz n =>
                  (-
                   match n with
                   | 0 => 1%Q
                   | _.+1 =>
                       (1%Q +
                        (fix loop (m : nat) : rat :=
                           match m with
                           | 0 => 0
                           | 1 => 1
                           | (_.+1 as elpi_ctx_entry_7_).+1 =>
                               1%Q + loop elpi_ctx_entry_7_
                           end) n)%Q
                   end)%Q
              end + cast 2%Z)%Q *
             ((match i with
               | Posz n => iterop n addq 1 0
               | Negz n =>
                   (-
                    match n with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                1%Q + loop elpi_ctx_entry_7_
                            end) n)%Q
                    end)%Q
               end + cast 2%Z)%Q *
              (match i with
               | Posz n => iterop n addq 1 0
               | Negz n =>
                   (-
                    match n with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                1%Q + loop elpi_ctx_entry_7_
                            end) n)%Q
                    end)%Q
               end + cast 2%Z)%Q)%Q)%Q^-1)%Q)%Q +
          (-
           ((((match i with
               | Posz n => iterop n addq 1 0
               | Negz n =>
                   (-
                    match n with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                1%Q + loop elpi_ctx_entry_7_
                            end) n)%Q
                    end)%Q
               end + cast 1%Z)%Q *
              ((match i with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                 1%Q + loop elpi_ctx_entry_7_
                             end) n)%Q
                     end)%Q
                end + cast 2%Z)%Q^-1)%Q)%Q *
             (((match i with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                 1%Q + loop elpi_ctx_entry_7_
                             end) n)%Q
                     end)%Q
                end + cast 1%Z)%Q *
               ((match i with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                  1%Q + loop elpi_ctx_entry_7_
                              end) n)%Q
                      end)%Q
                 end + cast 2%Z)%Q^-1)%Q)%Q *
              ((match i with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                 1%Q + loop elpi_ctx_entry_7_
                             end) n)%Q
                     end)%Q
                end + cast 1%Z)%Q *
               ((match i with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                  1%Q + loop elpi_ctx_entry_7_
                              end) n)%Q
                      end)%Q
                 end + cast 2%Z)%Q^-1)%Q)%Q)%Q)%Q *
            ((seq_defs.a (intZmod.addz i 1) * ((seq_defs.a i)^-1)%Q)%Q^-1)%Q)%Q)%Q)%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
i : int
a : ?Goal2 *m ?Goal4 = const_mx 0
n_gt0 : eqb
          match i with
          | Posz n' => eqn (2 - n')%Nrec 0
          | Negz _ => false
          end true
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: (seq_defs.a (intZmod.addz (intZmod.addz i 1) 1) *
          ((seq_defs.a (intZmod.addz i 1))^-1)%Q)%Q;
         ((((((cast 17%Z *
               (match i with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                 1%Q + loop elpi_ctx_entry_7_
                             end) n)%Q
                     end)%Q
                end *
                match i with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                 1%Q + loop elpi_ctx_entry_7_
                             end) n)%Q
                     end)%Q
                end)%Q)%Q +
              (cast 51%Z *
               match i with
               | Posz n => iterop n addq 1 0
               | Negz n =>
                   (-
                    match n with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                1%Q + loop elpi_ctx_entry_7_
                            end) n)%Q
                    end)%Q
               end)%Q)%Q + cast 39%Z)%Q *
            ((cast 2%Z *
              match i with
              | Posz n => iterop n addq 1 0
              | Negz n =>
                  (-
                   match n with
                   | 0 => 1%Q
                   | _.+1 =>
                       (1%Q +
                        (fix loop (m : nat) : rat :=
                           match m with
                           | 0 => 0
                           | 1 => 1
                           | (_.+1 as elpi_ctx_entry_7_).+1 =>
                               1%Q + loop elpi_ctx_entry_7_
                           end) n)%Q
                   end)%Q
              end)%Q + cast 3%Z)%Q)%Q *
           (((match i with
              | Posz n => iterop n addq 1 0
              | Negz n =>
                  (-
                   match n with
                   | 0 => 1%Q
                   | _.+1 =>
                       (1%Q +
                        (fix loop (m : nat) : rat :=
                           match m with
                           | 0 => 0
                           | 1 => 1
                           | (_.+1 as elpi_ctx_entry_7_).+1 =>
                               1%Q + loop elpi_ctx_entry_7_
                           end) n)%Q
                   end)%Q
              end + cast 2%Z)%Q *
             ((match i with
               | Posz n => iterop n addq 1 0
               | Negz n =>
                   (-
                    match n with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                1%Q + loop elpi_ctx_entry_7_
                            end) n)%Q
                    end)%Q
               end + cast 2%Z)%Q *
              (match i with
               | Posz n => iterop n addq 1 0
               | Negz n =>
                   (-
                    match n with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                1%Q + loop elpi_ctx_entry_7_
                            end) n)%Q
                    end)%Q
               end + cast 2%Z)%Q)%Q)%Q^-1)%Q)%Q +
          (-
           ((((match i with
               | Posz n => iterop n addq 1 0
               | Negz n =>
                   (-
                    match n with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                1%Q + loop elpi_ctx_entry_7_
                            end) n)%Q
                    end)%Q
               end + cast 1%Z)%Q *
              ((match i with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                 1%Q + loop elpi_ctx_entry_7_
                             end) n)%Q
                     end)%Q
                end + cast 2%Z)%Q^-1)%Q)%Q *
             (((match i with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                 1%Q + loop elpi_ctx_entry_7_
                             end) n)%Q
                     end)%Q
                end + cast 1%Z)%Q *
               ((match i with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                  1%Q + loop elpi_ctx_entry_7_
                              end) n)%Q
                      end)%Q
                 end + cast 2%Z)%Q^-1)%Q)%Q *
              ((match i with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                 1%Q + loop elpi_ctx_entry_7_
                             end) n)%Q
                     end)%Q
                end + cast 1%Z)%Q *
               ((match i with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as elpi_ctx_entry_7_).+1 =>
                                  1%Q + loop elpi_ctx_entry_7_
                              end) n)%Q
                      end)%Q
                 end + cast 2%Z)%Q^-1)%Q)%Q)%Q)%Q *
            ((seq_defs.a (intZmod.addz i 1) * ((seq_defs.a i)^-1)%Q)%Q^-1)%Q)%Q)%Q)%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching:
(0 < x ->
 Forall (fun x : R => 0 <= x) H -> Forall (fun x : R => 0 <= x) (scale x H))
Debug:
In environment
n_gt0 : int
l : annotated_recs_z.precond.Sn2 n_gt0
n : int * int
H : (0 < n.2) && coprime `|n.1| `|n.2|
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l0 : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l0 =
     [:: ghn3 (int.shift 2 n_gt0); annotated_recs_z.Sn2_cf0 n_gt0;
         ghn3 n_gt0; annotated_recs_z.Sn2_cf1 n_gt0; 
        ghn3 (int.shift 1 n_gt0)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n_gt0 : int
l : annotated_recs_z.precond.Sn2 n_gt0
n : int * int
H : (0 < n.2) && coprime `|n.1| `|n.2|
Unable to unify "true" with "false".
Debug:
In environment
n_gt0 : int
l : annotated_recs_z.precond.Sn2 n_gt0
n : int * int
H : (0 < n.2) && coprime `|n.1| `|n.2|
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l0 : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l0 =
     [:: ghn3 (int.shift 2 n_gt0); annotated_recs_z.Sn2_cf0 n_gt0;
         ghn3 n_gt0; annotated_recs_z.Sn2_cf1 n_gt0; 
        ghn3 (int.shift 1 n_gt0)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n_gt0 : int
l : annotated_recs_z.precond.Sn2 n_gt0
n : int * int
H : (0 < n.2) && coprime `|n.1| `|n.2|
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l0 : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l0 =
     [:: ghn3 (int.shift 2 n_gt0); annotated_recs_z.Sn2_cf0 n_gt0;
         ghn3 n_gt0; annotated_recs_z.Sn2_cf1 n_gt0; 
        ghn3 (int.shift 1 n_gt0)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n_gt0 : int
l : annotated_recs_z.precond.Sn2 n_gt0
n : int * int
e_xy : (0 < n.2) && coprime `|n.1| `|n.2|
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l0 : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l0 =
     [:: ghn3 (int.shift 2 n_gt0); annotated_recs_z.Sn2_cf0 n_gt0;
         ghn3 n_gt0; annotated_recs_z.Sn2_cf1 n_gt0; 
        ghn3 (int.shift 1 n_gt0)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n_gt0 : int
l : annotated_recs_z.precond.Sn2 n_gt0
n : int * int
e_xy : (0 < n.2) && coprime `|n.1| `|n.2|
Unable to unify "true" with "false".
Debug:
In environment
n_gt0 : int
l : annotated_recs_z.precond.Sn2 n_gt0
n : int * int
e_xy : (0 < n.2) && coprime `|n.1| `|n.2|
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l0 : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l0 =
     [:: ghn3 (int.shift 2 n_gt0); annotated_recs_z.Sn2_cf0 n_gt0;
         ghn3 n_gt0; annotated_recs_z.Sn2_cf1 n_gt0; 
        ghn3 (int.shift 1 n_gt0)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
n_gt0 : int
l : annotated_recs_z.precond.Sn2 n_gt0
n : int * int
e_xy : (0 < n.2) && coprime `|n.1| `|n.2|
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l0 : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l0 =
     [:: ghn3 (int.shift 2 n_gt0); annotated_recs_z.Sn2_cf0 n_gt0;
         ghn3 n_gt0; annotated_recs_z.Sn2_cf1 n_gt0; 
        ghn3 (int.shift 1 n_gt0)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
v : int -> int -> rat
v_ann : v.Ann v
v_Sn2 := v.Sn2_ v_ann : v.Sn2 v
v_SnSk := v.SnSk_ v_ann : v.SnSk v
v_Sk2 := v.Sk2_ v_ann : v.Sk2 v
b := fun n : int => \sum_(0 <= k < n + 1 :> int) v n k : int -> rat
n : int
lin_xy : (2 : int) <= n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: v.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
v : int -> int -> rat
v_ann : v.Ann v
v_Sn2 := v.Sn2_ v_ann : v.Sn2 v
v_SnSk := v.SnSk_ v_ann : v.SnSk v
v_Sk2 := v.Sk2_ v_ann : v.Sk2 v
b := fun n : int => \sum_(0 <= k < n + 1 :> int) v n k : int -> rat
n : int
Hb' : (2 : int) <= n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: v.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
v : int -> int -> rat
v_ann : v.Ann v
v_Sn2 := v.Sn2_ v_ann : v.Sn2 v
v_SnSk := v.SnSk_ v_ann : v.SnSk v
v_Sk2 := v.Sk2_ v_ann : v.Sk2 v
b := fun n : int => \sum_(0 <= k < n + 1 :> int) v n k : int -> rat
n : int
l : (2 : int) <= n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l0 : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l0 = [:: v.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
v : int -> int -> rat
v_ann : v.Ann v
v_Sn2 := v.Sn2_ v_ann : v.Sn2 v
v_SnSk := v.SnSk_ v_ann : v.SnSk v
v_Sk2 := v.Sk2_ v_ann : v.Sk2 v
b := fun n : int => \sum_(0 <= k < n + 1 :> int) v n k : int -> rat
n : int
lin_xy : (2 : int) <= n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: v.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
v : int -> int -> rat
v_ann : v.Ann v
v_Sn2 := v.Sn2_ v_ann : v.Sn2 v
v_SnSk := v.SnSk_ v_ann : v.SnSk v
v_Sk2 := v.Sk2_ v_ann : v.Sk2 v
b := fun n : int => \sum_(0 <= k < n + 1 :> int) v n k : int -> rat
n : int
Hb' : (2 : int) <= n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: v.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
v : int -> int -> rat
v_ann : v.Ann v
v_Sn2 := v.Sn2_ v_ann : v.Sn2 v
v_SnSk := v.SnSk_ v_ann : v.SnSk v
v_Sk2 := v.Sk2_ v_ann : v.Sk2 v
b := fun n : int => \sum_(0 <= k < n + 1 :> int) v n k : int -> rat
n : int
l : (2 : int) <= n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l0 : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l0 = [:: v.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
v : int -> int -> rat
v_ann : v.Ann v
v_Sn2 := v.Sn2_ v_ann : v.Sn2 v
v_SnSk := v.SnSk_ v_ann : v.SnSk v
v_Sk2 := v.Sk2_ v_ann : v.Sk2 v
b := fun n : int => \sum_(0 <= k < n + 1 :> int) v n k : int -> rat
n : int
lin_xy : (2 : int) <= n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: v.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
v : int -> int -> rat
v_ann : v.Ann v
v_Sn2 := v.Sn2_ v_ann : v.Sn2 v
v_SnSk := v.SnSk_ v_ann : v.SnSk v
v_Sk2 := v.Sk2_ v_ann : v.Sk2 v
b := fun n : int => \sum_(0 <= k < n + 1 :> int) v n k : int -> rat
n : int
Hb' : (2 : int) <= n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: v.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
v : int -> int -> rat
v_ann : v.Ann v
v_Sn2 := v.Sn2_ v_ann : v.Sn2 v
v_SnSk := v.SnSk_ v_ann : v.SnSk v
v_Sk2 := v.Sk2_ v_ann : v.Sk2 v
b := fun n : int => \sum_(0 <= k < n + 1 :> int) v n k : int -> rat
n : int
q : (2 : int) <= n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: v.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
v : int -> int -> rat
v_ann : v.Ann v
v_Sn2 := v.Sn2_ v_ann : v.Sn2 v
v_SnSk := v.SnSk_ v_ann : v.SnSk v
v_Sk2 := v.Sk2_ v_ann : v.Sk2 v
b := fun n : int => \sum_(0 <= k < n + 1 :> int) v n k : int -> rat
n : int
l : (2 : int) <= n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l0 : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l0 = [:: v.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
v : int -> int -> rat
v_ann : v.Ann v
v_Sn2 := v.Sn2_ v_ann : v.Sn2 v
v_SnSk := v.SnSk_ v_ann : v.SnSk v
v_Sk2 := v.Sk2_ v_ann : v.Sk2 v
b := fun n : int => \sum_(0 <= k < n + 1 :> int) v n k : int -> rat
n : int
lin_xy : (2 : int) <= n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: v.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
v : int -> int -> rat
v_ann : v.Ann v
v_Sn2 := v.Sn2_ v_ann : v.Sn2 v
v_SnSk := v.SnSk_ v_ann : v.SnSk v
v_Sk2 := v.Sk2_ v_ann : v.Sk2 v
b := fun n : int => \sum_(0 <= k < n + 1 :> int) v n k : int -> rat
n : int
Hb' : (2 : int) <= n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: v.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
v : int -> int -> rat
v_ann : v.Ann v
v_Sn2 := v.Sn2_ v_ann : v.Sn2 v
v_SnSk := v.SnSk_ v_ann : v.SnSk v
v_Sk2 := v.Sk2_ v_ann : v.Sk2 v
b := fun n : int => \sum_(0 <= k < n + 1 :> int) v n k : int -> rat
n : int
q : (2 : int) <= n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: v.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
v : int -> int -> rat
v_ann : v.Ann v
v_Sn2 := v.Sn2_ v_ann : v.Sn2 v
v_SnSk := v.SnSk_ v_ann : v.SnSk v
v_Sk2 := v.Sk2_ v_ann : v.Sk2 v
b := fun n : int => \sum_(0 <= k < n + 1 :> int) v n k : int -> rat
n : int
l : (2 : int) <= n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l0 : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l0 = [:: v.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
v : int -> int -> rat
v_ann : v.Ann v
v_Sn2 := v.Sn2_ v_ann : v.Sn2 v
v_SnSk := v.SnSk_ v_ann : v.SnSk v
v_Sk2 := v.Sk2_ v_ann : v.Sk2 v
b := fun n : int => \sum_(0 <= k < n + 1 :> int) v n k : int -> rat
n : int
lin_xy : (2 : int) <= n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: v.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
v : int -> int -> rat
v_ann : v.Ann v
v_Sn2 := v.Sn2_ v_ann : v.Sn2 v
v_SnSk := v.SnSk_ v_ann : v.SnSk v
v_Sk2 := v.Sk2_ v_ann : v.Sk2 v
b := fun n : int => \sum_(0 <= k < n + 1 :> int) v n k : int -> rat
n : int
Hb' : (2 : int) <= n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: v.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
v : int -> int -> rat
v_ann : v.Ann v
v_Sn2 := v.Sn2_ v_ann : v.Sn2 v
v_SnSk := v.SnSk_ v_ann : v.SnSk v
v_Sk2 := v.Sk2_ v_ann : v.Sk2 v
b := fun n : int => \sum_(0 <= k < n + 1 :> int) v n k : int -> rat
n : int
q : (2 : int) <= n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: v.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
v : int -> int -> rat
v_ann : v.Ann v
v_Sn2 := v.Sn2_ v_ann : v.Sn2 v
v_SnSk := v.SnSk_ v_ann : v.SnSk v
v_Sk2 := v.Sk2_ v_ann : v.Sk2 v
b := fun n : int => \sum_(0 <= k < n + 1 :> int) v n k : int -> rat
n : int
l : (2 : int) <= n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l0 : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l0 = [:: v.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
v : int -> int -> rat
v_ann : v.Ann v
v_Sn2 := v.Sn2_ v_ann : v.Sn2 v
v_SnSk := v.SnSk_ v_ann : v.SnSk v
v_Sk2 := v.Sk2_ v_ann : v.Sk2 v
b := fun n : int => \sum_(0 <= k < n + 1 :> int) v n k : int -> rat
n : int
abelG : (2 : int) <= n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: v.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
v : int -> int -> rat
v_ann : v.Ann v
v_Sn2 := v.Sn2_ v_ann : v.Sn2 v
v_SnSk := v.SnSk_ v_ann : v.SnSk v
v_Sk2 := v.Sk2_ v_ann : v.Sk2 v
b := fun n : int => \sum_(0 <= k < n + 1 :> int) v n k : int -> rat
n : int
lin_xy : (2 : int) <= n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: v.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
v : int -> int -> rat
v_ann : v.Ann v
v_Sn2 := v.Sn2_ v_ann : v.Sn2 v
v_SnSk := v.SnSk_ v_ann : v.SnSk v
v_Sk2 := v.Sk2_ v_ann : v.Sk2 v
b := fun n : int => \sum_(0 <= k < n + 1 :> int) v n k : int -> rat
n : int
Hb' : (2 : int) <= n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: v.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
v : int -> int -> rat
v_ann : v.Ann v
v_Sn2 := v.Sn2_ v_ann : v.Sn2 v
v_SnSk := v.SnSk_ v_ann : v.SnSk v
v_Sk2 := v.Sk2_ v_ann : v.Sk2 v
b := fun n : int => \sum_(0 <= k < n + 1 :> int) v n k : int -> rat
n : int
q : (2 : int) <= n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: v.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
v : int -> int -> rat
v_ann : v.Ann v
v_Sn2 := v.Sn2_ v_ann : v.Sn2 v
v_SnSk := v.SnSk_ v_ann : v.SnSk v
v_Sk2 := v.Sk2_ v_ann : v.Sk2 v
b := fun n : int => \sum_(0 <= k < n + 1 :> int) v n k : int -> rat
n : int
l : (2 : int) <= n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l0 : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l0 = [:: v.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
v : int -> int -> rat
v_ann : v.Ann v
v_Sn2 := v.Sn2_ v_ann : v.Sn2 v
v_SnSk := v.SnSk_ v_ann : v.SnSk v
v_Sk2 := v.Sk2_ v_ann : v.Sk2 v
b := fun n : int => \sum_(0 <= k < n + 1 :> int) v n k : int -> rat
n : int
abelG : (2 : int) <= n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: v.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
v : int -> int -> rat
v_ann : v.Ann v
v_Sn2 := v.Sn2_ v_ann : v.Sn2 v
v_SnSk := v.SnSk_ v_ann : v.SnSk v
v_Sk2 := v.Sk2_ v_ann : v.Sk2 v
b := fun n : int => \sum_(0 <= k < n + 1 :> int) v n k : int -> rat
n : int
lin_xy : (2 : int) <= n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: v.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching:
(Forall (fun x : R => 0 <= x) (x :: l) ->
 (forall i : nat,
  (i < length (x :: l))%nat -> Forall (fun x : R => 0 <= x) (l2 i)) -> 
 0 < 0)
Debug:
In environment
v : int -> int -> rat
v_ann : v.Ann v
v_Sn2 := v.Sn2_ v_ann : v.Sn2 v
v_SnSk := v.SnSk_ v_ann : v.SnSk v
v_Sk2 := v.Sk2_ v_ann : v.Sk2 v
b := fun n : int => \sum_(0 <= k < n + 1 :> int) v n k : int -> rat
n : int
Pj : (2 : int) <= n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: v.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
v : int -> int -> rat
v_ann : v.Ann v
v_Sn2 := v.Sn2_ v_ann : v.Sn2 v
v_SnSk := v.SnSk_ v_ann : v.SnSk v
v_Sk2 := v.Sk2_ v_ann : v.Sk2 v
b := fun n : int => \sum_(0 <= k < n + 1 :> int) v n k : int -> rat
n : int
Hb' : (2 : int) <= n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: v.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (H11 < 0 -> √ (H11 + m) <= √ H11 + √ m)
Crunching: (√ (H40 + b) < √ H40 + √ b)
Debug:
In environment
v : int -> int -> rat
v_ann : v.Ann v
v_Sn2 := v.Sn2_ v_ann : v.Sn2 v
v_SnSk := v.SnSk_ v_ann : v.SnSk v
v_Sk2 := v.Sk2_ v_ann : v.Sk2 v
b := fun n : int => \sum_(0 <= k < n + 1 :> int) v n k : int -> rat
n : int
q : (2 : int) <= n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: v.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching: (H40 < 0 -> √ (H40 + Hfalse) <= √ H40 + √ Hfalse)
Debug:
In environment
v : int -> int -> rat
v_ann : v.Ann v
v_Sn2 := v.Sn2_ v_ann : v.Sn2 v
v_SnSk := v.SnSk_ v_ann : v.SnSk v
v_Sk2 := v.Sk2_ v_ann : v.Sk2 v
b := fun n : int => \sum_(0 <= k < n + 1 :> int) v n k : int -> rat
n : int
l' : (2 : int) <= n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: v.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
v : int -> int -> rat
v_ann : v.Ann v
v_Sn2 := v.Sn2_ v_ann : v.Sn2 v
v_SnSk := v.SnSk_ v_ann : v.SnSk v
v_Sk2 := v.Sk2_ v_ann : v.Sk2 v
b := fun n : int => \sum_(0 <= k < n + 1 :> int) v n k : int -> rat
n : int
l : (2 : int) <= n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l0 : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l0 = [:: v.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
v : int -> int -> rat
v_ann : v.Ann v
v_Sn2 := v.Sn2_ v_ann : v.Sn2 v
v_SnSk := v.SnSk_ v_ann : v.SnSk v
v_Sk2 := v.Sk2_ v_ann : v.Sk2 v
b := fun n : int => \sum_(0 <= k < n + 1 :> int) v n k : int -> rat
n : int
abelG : (2 : int) <= n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: v.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
v : int -> int -> rat
v_ann : v.Ann v
v_Sn2 := v.Sn2_ v_ann : v.Sn2 v
v_SnSk := v.SnSk_ v_ann : v.SnSk v
v_Sk2 := v.Sk2_ v_ann : v.Sk2 v
b := fun n : int => \sum_(0 <= k < n + 1 :> int) v n k : int -> rat
n : int
lin_xy : (2 : int) <= n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: v.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching: (forall b : R, Hz < 0 -> √ (Hz + b) <= √ Hz + √ b)
Debug:
In environment
v : int -> int -> rat
v_ann : v.Ann v
v_Sn2 := v.Sn2_ v_ann : v.Sn2 v
v_SnSk := v.SnSk_ v_ann : v.SnSk v
v_Sk2 := v.Sk2_ v_ann : v.Sk2 v
b := fun n : int => \sum_(0 <= k < n + 1 :> int) v n k : int -> rat
n : int
Pj : (2 : int) <= n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: v.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching: (Hz < 0 -> √ (Hz + H4) <= √ Hz + √ H4)
Debug:
In environment
v : int -> int -> rat
v_ann : v.Ann v
v_Sn2 := v.Sn2_ v_ann : v.Sn2 v
v_SnSk := v.SnSk_ v_ann : v.SnSk v
v_Sk2 := v.Sk2_ v_ann : v.Sk2 v
b := fun n : int => \sum_(0 <= k < n + 1 :> int) v n k : int -> rat
n : int
sAD : (2 : int) <= n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: v.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
v : int -> int -> rat
v_ann : v.Ann v
v_Sn2 := v.Sn2_ v_ann : v.Sn2 v
v_SnSk := v.SnSk_ v_ann : v.SnSk v
v_Sk2 := v.Sk2_ v_ann : v.Sk2 v
b := fun n : int => \sum_(0 <= k < n + 1 :> int) v n k : int -> rat
n : int
Hb' : (2 : int) <= n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: v.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching: (Forall (fun x : R => 0 <= x) (join H5 Hincl))
Crunching: (nat_to_binlist' (2 * Hx) = false :: nat_to_binlist' Hx)
Debug:
In environment
v : int -> int -> rat
v_ann : v.Ann v
v_Sn2 := v.Sn2_ v_ann : v.Sn2 v
v_SnSk := v.SnSk_ v_ann : v.SnSk v
v_Sk2 := v.Sk2_ v_ann : v.Sk2 v
b := fun n : int => \sum_(0 <= k < n + 1 :> int) v n k : int -> rat
n : int
q : (2 : int) <= n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: v.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
v : int -> int -> rat
v_ann : v.Ann v
v_Sn2 := v.Sn2_ v_ann : v.Sn2 v
v_SnSk := v.SnSk_ v_ann : v.SnSk v
v_Sk2 := v.Sk2_ v_ann : v.Sk2 v
b := fun n : int => \sum_(0 <= k < n + 1 :> int) v n k : int -> rat
n : int
Hb' : (2 : int) <= n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: v.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
v : int -> int -> rat
v_ann : v.Ann v
v_Sn2 := v.Sn2_ v_ann : v.Sn2 v
v_SnSk := v.SnSk_ v_ann : v.SnSk v
v_Sk2 := v.Sk2_ v_ann : v.Sk2 v
b := fun n : int => \sum_(0 <= k < n + 1 :> int) v n k : int -> rat
n : int
l' : (2 : int) <= n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: v.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
v : int -> int -> rat
v_ann : v.Ann v
v_Sn2 := v.Sn2_ v_ann : v.Sn2 v
v_SnSk := v.SnSk_ v_ann : v.SnSk v
v_Sk2 := v.Sk2_ v_ann : v.Sk2 v
b := fun n : int => \sum_(0 <= k < n + 1 :> int) v n k : int -> rat
n : int
l : (2 : int) <= n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l0 : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l0 = [:: v.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
v : int -> int -> rat
v_ann : v.Ann v
v_Sn2 := v.Sn2_ v_ann : v.Sn2 v
v_SnSk := v.SnSk_ v_ann : v.SnSk v
v_Sk2 := v.Sk2_ v_ann : v.Sk2 v
b := fun n : int => \sum_(0 <= k < n + 1 :> int) v n k : int -> rat
n : int
abelG : (2 : int) <= n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: v.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
v : int -> int -> rat
v_ann : v.Ann v
v_Sn2 := v.Sn2_ v_ann : v.Sn2 v
v_SnSk := v.SnSk_ v_ann : v.SnSk v
v_Sk2 := v.Sk2_ v_ann : v.Sk2 v
b := fun n : int => \sum_(0 <= k < n + 1 :> int) v n k : int -> rat
n : int
PQxQ : (2 : int) <= n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: v.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
v : int -> int -> rat
v_ann : v.Ann v
v_Sn2 := v.Sn2_ v_ann : v.Sn2 v
v_SnSk := v.SnSk_ v_ann : v.SnSk v
v_Sk2 := v.Sk2_ v_ann : v.Sk2 v
b := fun n : int => \sum_(0 <= k < n + 1 :> int) v n k : int -> rat
n : int
lin_xy : (2 : int) <= n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: v.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
v : int -> int -> rat
v_ann : v.Ann v
v_Sn2 := v.Sn2_ v_ann : v.Sn2 v
v_SnSk := v.SnSk_ v_ann : v.SnSk v
v_Sk2 := v.Sk2_ v_ann : v.Sk2 v
b := fun n : int => \sum_(0 <= k < n + 1 :> int) v n k : int -> rat
n : int
Pj : (2 : int) <= n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: v.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
v : int -> int -> rat
v_ann : v.Ann v
v_Sn2 := v.Sn2_ v_ann : v.Sn2 v
v_SnSk := v.SnSk_ v_ann : v.SnSk v
v_Sk2 := v.Sk2_ v_ann : v.Sk2 v
b := fun n : int => \sum_(0 <= k < n + 1 :> int) v n k : int -> rat
n : int
sAD : (2 : int) <= n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: v.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
v : int -> int -> rat
v_ann : v.Ann v
v_Sn2 := v.Sn2_ v_ann : v.Sn2 v
v_SnSk := v.SnSk_ v_ann : v.SnSk v
v_Sk2 := v.Sk2_ v_ann : v.Sk2 v
b := fun n : int => \sum_(0 <= k < n + 1 :> int) v n k : int -> rat
n : int
Hb' : (2 : int) <= n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: v.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
v : int -> int -> rat
v_ann : v.Ann v
v_Sn2 := v.Sn2_ v_ann : v.Sn2 v
v_SnSk := v.SnSk_ v_ann : v.SnSk v
v_Sk2 := v.Sk2_ v_ann : v.Sk2 v
b := fun n : int => \sum_(0 <= k < n + 1 :> int) v n k : int -> rat
n : int
Hb' : (2 : int) <= n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: v.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
Hy, a : int
n : annotated_recs_s.precond.Sn2 Hy a
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: u (int.shift 2 Hy) a; annotated_recs_s.Sn2_cf0_0 Hy a; 
        u Hy a; annotated_recs_s.Sn2_cf1_0 Hy a; u (int.shift 1 Hy) a;
         annotated_recs_s.Sn2_cf0_1 Hy a; u Hy (int.shift 1 a)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching:
(forall n : nat, nat_to_binlist' (2 * n + 1) = true :: nat_to_binlist' n)
Crunching:
(forall n : nat, nat_to_binlist' (2 * n + 1) = true :: nat_to_binlist' n)
Crunching:
(forall n : nat, nat_to_binlist' (2 * n + 1) = true :: nat_to_binlist' n)
Crunching:
(forall n : nat, nat_to_binlist' (2 * n + 1) = true :: nat_to_binlist' n)
Debug:
In environment
v : int -> int -> rat
v_ann : v.Ann v
v_Sn2 := v.Sn2_ v_ann : v.Sn2 v
v_SnSk := v.SnSk_ v_ann : v.SnSk v
v_Sk2 := v.Sk2_ v_ann : v.Sk2 v
b := fun n : int => \sum_(0 <= k < n + 1 :> int) v n k : int -> rat
n : int
q : (2 : int) <= n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: v.P_horner b n]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching:
(forall n : nat, nat_to_binlist' (2 * n + 1) = true :: nat_to_binlist' n)
Crunching:
(forall n : nat, nat_to_binlist' (2 * n + 1) = true :: nat_to_binlist' n)
Crunching:
((forall i : nat, (i < length H)%nat -> distribution (f i)) ->
 distribution (join H f))
Crunching:
((1 + 0)%R = 1 ->
 (0 + 1)%R = 1 ->
 (forall i : nat, (i < length H)%nat -> distribution (x i)) ->
 distribution (join H x))
Crunching:
(forall n : nat, nat_to_binlist' (2 * n + 1) = true :: nat_to_binlist' n)
Debug:
In environment
n, Hn : int
IHn : annotated_recs_s.precond.SnSk n Hn
u2 := u (int.shift 1 n) (int.shift 1 Hn) : rat
Unable to unify "true" with "false".
Debug:
In environment
n, Hn : int
IHn : annotated_recs_s.precond.SnSk n Hn
u2 := u (int.shift 1 n) (int.shift 1 Hn) : rat
Unable to unify "true" with "false".
Crunching: (√ (a + b) <= √ a + √ b)
Crunching: ((0 + 1)%R = 1%R -> False)
Crunching: (0 < q / 2)
Debug:
In environment
a, Ea : int
H : annotated_recs_s.precond.SnSk a Ea
q : 0 <= Ea
H0 : intOrdered.ltz Ea a
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: (ghn3 (intZmod.addz a 1) + s (intZmod.addz a 1) (intZmod.addz Ea 1))%Q;
         ((((((-
               match a with
               | Posz n => iterop n addq 1 0
               | Negz n =>
                   (-
                    match n with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 => 1%Q + loop i
                            end) n)%Q
                    end)%Q
               end)%Q +
              match Ea with
              | Posz n => iterop n addq 1 0
              | Negz n =>
                  (-
                   match n with
                   | 0 => 1%Q
                   | _.+1 =>
                       (1%Q +
                        (fix loop (m : nat) : rat :=
                           match m with
                           | 0 => 0
                           | 1 => 1
                           | (_.+1 as i).+1 => 1%Q + loop i
                           end) n)%Q
                   end)%Q
              end)%Q *
             (((match a with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 => 1%Q + loop i
                             end) n)%Q
                     end)%Q
                end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q +
               match Ea with
               | Posz n => iterop n addq 1 0
               | Negz n =>
                   (-
                    match n with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 => 1%Q + loop i
                            end) n)%Q
                    end)%Q
               end)%Q^-1)%Q)%Q * (ghn3 a + s a Ea)%Q)%Q +
           (rat_of_Z (BinNums.Zpos 1%AC) *
            (ghn3 (intZmod.addz a 1) + s (intZmod.addz a 1) Ea)%Q)%Q)%Q +
          (((match a with
             | Posz n => iterop n addq 1 0
             | Negz n =>
                 (-
                  match n with
                  | 0 => 1%Q
                  | _.+1 =>
                      (1%Q +
                       (fix loop (m : nat) : rat :=
                          match m with
                          | 0 => 0
                          | 1 => 1
                          | (_.+1 as i).+1 => 1%Q + loop i
                          end) n)%Q
                  end)%Q
             end +
             (-
              match Ea with
              | Posz n => iterop n addq 1 0
              | Negz n =>
                  (-
                   match n with
                   | 0 => 1%Q
                   | _.+1 =>
                       (1%Q +
                        (fix loop (m : nat) : rat :=
                           match m with
                           | 0 => 0
                           | 1 => 1
                           | (_.+1 as i).+1 => 1%Q + loop i
                           end) n)%Q
                   end)%Q
              end)%Q)%Q *
            (((match a with
               | Posz n => iterop n addq 1 0
               | Negz n =>
                   (-
                    match n with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 => 1%Q + loop i
                            end) n)%Q
                    end)%Q
               end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q +
              match Ea with
              | Posz n => iterop n addq 1 0
              | Negz n =>
                  (-
                   match n with
                   | 0 => 1%Q
                   | _.+1 =>
                       (1%Q +
                        (fix loop (m : nat) : rat :=
                           match m with
                           | 0 => 0
                           | 1 => 1
                           | (_.+1 as i).+1 => 1%Q + loop i
                           end) n)%Q
                   end)%Q
              end)%Q^-1)%Q)%Q * (ghn3 a + s a (intZmod.addz Ea 1))%Q)%Q)%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
a, Ea : int
H : annotated_recs_s.precond.SnSk a Ea
q : 0 <= Ea
H0 : intOrdered.ltz Ea a
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: (ghn3 (intZmod.addz a 1) + s (intZmod.addz a 1) (intZmod.addz Ea 1))%Q;
         ((((((-
               match a with
               | Posz n => iterop n addq 1 0
               | Negz n =>
                   (-
                    match n with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 => 1%Q + loop i
                            end) n)%Q
                    end)%Q
               end)%Q +
              match Ea with
              | Posz n => iterop n addq 1 0
              | Negz n =>
                  (-
                   match n with
                   | 0 => 1%Q
                   | _.+1 =>
                       (1%Q +
                        (fix loop (m : nat) : rat :=
                           match m with
                           | 0 => 0
                           | 1 => 1
                           | (_.+1 as i).+1 => 1%Q + loop i
                           end) n)%Q
                   end)%Q
              end)%Q *
             (((match a with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 => 1%Q + loop i
                             end) n)%Q
                     end)%Q
                end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q +
               match Ea with
               | Posz n => iterop n addq 1 0
               | Negz n =>
                   (-
                    match n with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 => 1%Q + loop i
                            end) n)%Q
                    end)%Q
               end)%Q^-1)%Q)%Q * (ghn3 a + s a Ea)%Q)%Q +
           (annotated_recs_s.SnSk_cf1_0 a Ea *
            (ghn3 (intZmod.addz a 1) + s (intZmod.addz a 1) Ea)%Q)%Q)%Q +
          (((match a with
             | Posz n => iterop n addq 1 0
             | Negz n =>
                 (-
                  match n with
                  | 0 => 1%Q
                  | _.+1 =>
                      (1%Q +
                       (fix loop (m : nat) : rat :=
                          match m with
                          | 0 => 0
                          | 1 => 1
                          | (_.+1 as i).+1 => 1%Q + loop i
                          end) n)%Q
                  end)%Q
             end +
             (-
              match Ea with
              | Posz n => iterop n addq 1 0
              | Negz n =>
                  (-
                   match n with
                   | 0 => 1%Q
                   | _.+1 =>
                       (1%Q +
                        (fix loop (m : nat) : rat :=
                           match m with
                           | 0 => 0
                           | 1 => 1
                           | (_.+1 as i).+1 => 1%Q + loop i
                           end) n)%Q
                   end)%Q
              end)%Q)%Q *
            (((match a with
               | Posz n => iterop n addq 1 0
               | Negz n =>
                   (-
                    match n with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 => 1%Q + loop i
                            end) n)%Q
                    end)%Q
               end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q +
              match Ea with
              | Posz n => iterop n addq 1 0
              | Negz n =>
                  (-
                   match n with
                   | 0 => 1%Q
                   | _.+1 =>
                       (1%Q +
                        (fix loop (m : nat) : rat :=
                           match m with
                           | 0 => 0
                           | 1 => 1
                           | (_.+1 as i).+1 => 1%Q + loop i
                           end) n)%Q
                   end)%Q
              end)%Q^-1)%Q)%Q * (ghn3 a + s a (intZmod.addz Ea 1))%Q)%Q)%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching: ((0 + 1)%R = 1%R -> False)
Crunching:
((forall k : nat, (k < length Hab)%nat -> distribution (abs k)) ->
 fst n (sample (join Hab abs) l) = sample Hab l)
Crunching:
((forall k : nat, (k < length Hab)%nat -> distribution (abs k)) ->
 fst n (sample (join Hab abs) l) = sample Hab l)
Crunching:
((forall k : nat, (k < length Hab)%nat -> distribution (abs k)) ->
 fst n (sample (join Hab abs) l) = sample Hab l)
Crunching: positive
Crunching: positive
Crunching:
((forall k : nat, (k < length Hab)%nat -> distribution (abs k)) ->
 fst 0 (sample (join' Hab abs (length Hab)) rnd) = sample Hab rnd)
Crunching: positive
Crunching: (list_to_funbool 1 (repeat false 1) m = false)
Crunching:
((forall k : nat, (k < length Hab)%nat -> distribution (abs k)) ->
 fst 0 (sample (join' Hab abs (length Hab)) rnd) = sample Hab rnd)
Crunching: positive
Crunching:
((forall k : nat, (k < length Hab)%nat -> distribution (abs k)) ->
 fst 0 (sample (join' Hab abs (length Hab)) rnd) = sample Hab rnd)
Crunching:
(update (list_to_funbool (S a - 0) (repeat false (S a))) (S a - 0) false H =
 false)
Crunching:
(update (list_to_funbool (S a - 0) (repeat false (S a))) (S a - 0) false H =
 false)
Crunching: False
Crunching:
(update (list_to_funbool (S a - 0) (repeat false (S a))) (S a - 0) false H =
 false)
Crunching:
(update (list_to_funbool (S a - 0) (repeat false (S a))) (S a - 0) false H =
 false)
Crunching: (fst 0 (sample (join' Hab abs (length Hab)) rnd) = sample Hab rnd)
Crunching:
(update (list_to_funbool (n - 0) (repeat false n)) (n - 0) false H8 = false)
Crunching: positive
Crunching:
(update (list_to_funbool (S a - 0) (repeat false (S a))) (S a - 0) false H =
 false)
Crunching: False
Crunching:
(update (list_to_funbool (S a - 0) (repeat false (S a))) (S a - 0) false H =
 false)
Crunching: (0 < ?r1)
Crunching:
(update (list_to_funbool (n - 0) (repeat false n)) (n - 0) false H8 = false)
Crunching: positive
Crunching:
(update (list_to_funbool (S a - 0) (repeat false (S a))) (S a - 0) false H =
 false)
Crunching: False
Crunching:
(update (list_to_funbool (S a - 0) (repeat false (S a))) (S a - 0) false H =
 false)
Crunching: (l n = false)
Debug:
In environment
Hab, H : int
hkn : annotated_recs_v.precond.Sn2 Hab H
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: v (int.shift 2 Hab) H; annotated_recs_v.Sn2_cf0_0 Hab H; 
        v Hab H; annotated_recs_v.Sn2_cf1_0 Hab H; 
        v (int.shift 1 Hab) H; annotated_recs_v.Sn2_cf0_1 Hab H;
         v Hab (int.shift 1 H)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
Hab, H : int
nz_a : annotated_recs_v.precond.Sn2 Hab H
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: v (int.shift 2 Hab) H; annotated_recs_v.Sn2_cf0_0 Hab H; 
        v Hab H; annotated_recs_v.Sn2_cf1_0 Hab H; 
        v (int.shift 1 Hab) H; annotated_recs_v.Sn2_cf0_1 Hab H;
         v Hab (int.shift 1 H)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching: (l n = false)
Debug:
In environment
Hab, n_gt0 : int
l : annotated_recs_v.precond.Sn2 Hab n_gt0
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l0 : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l0 =
     [:: (((match binomialz (intZmod.addz (intZmod.addz Hab 1) 1) n_gt0 with
            | Posz n => iterop n addq 1 0
            | Negz n =>
                (-
                 match n with
                 | 0 => 1%Q
                 | _.+1 =>
                     (1%Q +
                      (fix loop (m : nat) : rat :=
                         match m with
                         | 0 => 0
                         | 1 => 1
                         | (_.+1 as i).+1 => 1%Q + loop i
                         end) n)%Q
                 end)%Q
            end *
            match binomialz (intZmod.addz (intZmod.addz Hab 1) 1) n_gt0 with
            | Posz n => iterop n addq 1 0
            | Negz n =>
                (-
                 match n with
                 | 0 => 1%Q
                 | _.+1 =>
                     (1%Q +
                      (fix loop (m : nat) : rat :=
                         match m with
                         | 0 => 0
                         | 1 => 1
                         | (_.+1 as i).+1 => 1%Q + loop i
                         end) n)%Q
                 end)%Q
            end)%Q *
           (match
              binomialz
                (intZmod.addz (intZmod.addz (intZmod.addz Hab 1) 1) n_gt0)
                n_gt0
            with
            | Posz n => iterop n addq 1 0
            | Negz n =>
                (-
                 match n with
                 | 0 => 1%Q
                 | _.+1 =>
                     (1%Q +
                      (fix loop (m : nat) : rat :=
                         match m with
                         | 0 => 0
                         | 1 => 1
                         | (_.+1 as i).+1 => 1%Q + loop i
                         end) n)%Q
                 end)%Q
            end *
            match
              binomialz
                (intZmod.addz (intZmod.addz (intZmod.addz Hab 1) 1) n_gt0)
                n_gt0
            with
            | Posz n => iterop n addq 1 0
            | Negz n =>
                (-
                 match n with
                 | 0 => 1%Q
                 | _.+1 =>
                     (1%Q +
                      (fix loop (m : nat) : rat :=
                         match m with
                         | 0 => 0
                         | 1 => 1
                         | (_.+1 as i).+1 => 1%Q + loop i
                         end) n)%Q
                 end)%Q
            end)%Q)%Q *
          (ghn3 (intZmod.addz (intZmod.addz Hab 1) 1) +
           s (intZmod.addz (intZmod.addz Hab 1) 1) n_gt0)%Q)%Q;
         ((((((((- rat_of_Z (BinNums.Zpos 1%AC))%Q *
                ((match Hab with
                  | Posz n => iterop n addq 1 0
                  | Negz n =>
                      (-
                       match n with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as i).+1 => 1%Q + loop i
                               end) n)%Q
                       end)%Q
                  end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q +
                 match n_gt0 with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end)%Q)%Q *
               (((((((((((((rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)) +
                            (rat_of_Z (BinNums.Zpos (...)) *
                             (match ... with
                              | ... ...
                              | ... ...%Q
                              end * match ... with
                                    | ... ...
                                    | ... ...%Q
                                    end)%Q)%Q)%Q +
                           (((- rat_of_Z (...))%Q *
                             match n_gt0 with
                             | Posz n => iterop n addq 1 0
                             | Negz n => (- ...)%Q
                             end)%Q *
                            match Hab with
                            | Posz n => iterop n addq 1 0
                            | Negz n =>
                                (- match ... with
                                   | ... 1%Q
                                   | ... ...%Q
                                   end)%Q
                            end)%Q)%Q +
                          (rat_of_Z
                             (BinNums.Zpos (BinNums.xO (BinNums.xI 1%AC))) *
                           (match n_gt0 with
                            | Posz n => iterop n addq 1 0
                            | Negz n =>
                                (- match ... with
                                   | ... 1%Q
                                   | ... ...%Q
                                   end)%Q
                            end *
                            match n_gt0 with
                            | Posz n => iterop n addq 1 0
                            | Negz n =>
                                (- match ... with
                                   | ... 1%Q
                                   | ... ...%Q
                                   end)%Q
                            end)%Q)%Q)%Q +
                         (match Hab with
                          | Posz n => iterop n addq 1 0
                          | Negz n =>
                              (-
                               match n with
                               | 0 => 1%Q
                               | _.+1 => (1%Q + (...) n)%Q
                               end)%Q
                          end *
                          (match Hab with
                           | Posz n => iterop n addq 1 0
                           | Negz n =>
                               (-
                                match n with
                                | 0 => 1%Q
                                | _.+1 => (1%Q + ...)%Q
                                end)%Q
                           end *
                           (match Hab with
                            | Posz n => iterop n addq 1 0
                            | Negz n =>
                                (- match ... with
                                   | ... 1%Q
                                   | ... ...%Q
                                   end)%Q
                            end *
                            match Hab with
                            | Posz n => iterop n addq 1 0
                            | Negz n =>
                                (- match ... with
                                   | ... 1%Q
                                   | ... ...%Q
                                   end)%Q
                            end)%Q)%Q)%Q)%Q +
                        (rat_of_Z
                           (BinNums.Zpos (BinNums.xI (BinNums.xO 1%AC))) *
                         (match Hab with
                          | Posz n => iterop n addq 1 0
                          | Negz n =>
                              (-
                               match n with
                               | 0 => 1%Q
                               | _.+1 => (1%Q + (...) n)%Q
                               end)%Q
                          end *
                          (match Hab with
                           | Posz n => iterop n addq 1 0
                           | Negz n =>
                               (-
                                match n with
                                | 0 => 1%Q
                                | _.+1 => (1%Q + ...)%Q
                                end)%Q
                           end *
                           match Hab with
                           | Posz n => iterop n addq 1 0
                           | Negz n =>
                               (-
                                match n with
                                | 0 => 1%Q
                                | _.+1 => (1%Q + ...)%Q
                                end)%Q
                           end)%Q)%Q)%Q)%Q +
                       (rat_of_Z
                          (BinNums.Zpos (BinNums.xO (BinNums.xI 1%AC))) *
                        (match n_gt0 with
                         | Posz n => iterop n addq 1 0
                         | Negz n =>
                             (-
                              match n with
                              | 0 => 1%Q
                              | _.+1 =>
                                  (1%Q +
                                   (fix loop ... : rat := ...
                                                 ...
                                                 ...
                                                 ...
                                                 end) n)%Q
                              end)%Q
                         end *
                         (match n_gt0 with
                          | Posz n => iterop n addq 1 0
                          | Negz n =>
                              (-
                               match n with
                               | 0 => 1%Q
                               | _.+1 => (1%Q + (...) n)%Q
                               end)%Q
                          end *
                          match n_gt0 with
                          | Posz n => iterop n addq 1 0
                          | Negz n =>
                              (-
                               match n with
                               | 0 => 1%Q
                               | _.+1 => (1%Q + (...) n)%Q
                               end)%Q
                          end)%Q)%Q)%Q)%Q +
                      (match n_gt0 with
                       | Posz n => iterop n addq 1 0
                       | Negz n =>
                           (-
                            match n with
                            | 0 => 1%Q
                            | _.+1 =>
                                (1%Q +
                                 (fix loop (m : nat) : rat :=
                                    match m with
                                    | 0 => 0
                                    | 1 => 1
                                    | (_.+1 as i).+1 => 1%Q + loop i
                                    end) n)%Q
                            end)%Q
                       end *
                       (match Hab with
                        | Posz n => iterop n addq 1 0
                        | Negz n =>
                            (-
                             match n with
                             | 0 => 1%Q
                             | _.+1 =>
                                 (1%Q +
                                  (fix loop (m : nat) : rat :=
                                     match ... with
                                     | ... => 0
                                     | ... => 1
                                     | ... => 1%Q + ...
                                     end) n)%Q
                             end)%Q
                        end *
                        (match Hab with
                         | Posz n => iterop n addq 1 0
                         | Negz n =>
                             (-
                              match n with
                              | 0 => 1%Q
                              | _.+1 =>
                                  (1%Q +
                                   (fix loop ... : rat := ...
                                                 ...
                                                 ...
                                                 ...
                                                 end) n)%Q
                              end)%Q
                         end *
                         match Hab with
                         | Posz n => iterop n addq 1 0
                         | Negz n =>
                             (-
                              match n with
                              | 0 => 1%Q
                              | _.+1 =>
                                  (1%Q +
                                   (fix loop ... : rat := ...
                                                 ...
                                                 ...
                                                 ...
                                                 end) n)%Q
                              end)%Q
                         end)%Q)%Q)%Q)%Q +
                     ((-
                       match n_gt0 with
                       | Posz n => iterop n addq 1 0
                       | Negz n =>
                           (-
                            match n with
                            | 0 => 1%Q
                            | _.+1 =>
                                (1%Q +
                                 (fix loop (m : nat) : rat :=
                                    match m with
                                    | 0 => 0
                                    | 1 => 1
                                    | (_.+1 as i).+1 => 1%Q + loop i
                                    end) n)%Q
                            end)%Q
                       end)%Q *
                      (match Hab with
                       | Posz n => iterop n addq 1 0
                       | Negz n =>
                           (-
                            match n with
                            | 0 => 1%Q
                            | _.+1 =>
                                (1%Q +
                                 (fix loop (m : nat) : rat :=
                                    match m with
                                    | 0 => 0
                                    | 1 => 1
                                    | (_.+1 as i).+1 => 1%Q + loop i
                                    end) n)%Q
                            end)%Q
                       end *
                       match Hab with
                       | Posz n => iterop n addq 1 0
                       | Negz n =>
                           (-
                            match n with
                            | 0 => 1%Q
                            | _.+1 =>
                                (1%Q +
                                 (fix loop (m : nat) : rat :=
                                    match m with
                                    | 0 => 0
                                    | 1 => 1
                                    | (_.+1 as i).+1 => 1%Q + loop i
                                    end) n)%Q
                            end)%Q
                       end)%Q)%Q)%Q +
                    (((-
                       rat_of_Z (BinNums.Zpos (BinNums.xO (BinNums.xO 1%AC))))%Q *
                      (match n_gt0 with
                       | Posz n => iterop n addq 1 0
                       | Negz n =>
                           (-
                            match n with
                            | 0 => 1%Q
                            | _.+1 =>
                                (1%Q +
                                 (fix loop (m : nat) : rat :=
                                    match m with
                                    | 0 => 0
                                    | 1 => 1
                                    | (_.+1 as i).+1 => 1%Q + loop i
                                    end) n)%Q
                            end)%Q
                       end *
                       match n_gt0 with
                       | Posz n => iterop n addq 1 0
                       | Negz n =>
                           (-
                            match n with
                            | 0 => 1%Q
                            | _.+1 =>
                                (1%Q +
                                 (fix loop (m : nat) : rat :=
                                    match m with
                                    | 0 => 0
                                    | 1 => 1
                                    | (_.+1 as i).+1 => 1%Q + loop i
                                    end) n)%Q
                            end)%Q
                       end)%Q)%Q *
                     (match Hab with
                      | Posz n => iterop n addq 1 0
                      | Negz n =>
                          (-
                           match n with
                           | 0 => 1%Q
                           | _.+1 =>
                               (1%Q +
                                (fix loop (m : nat) : rat :=
                                   match m with
                                   | 0 => 0
                                   | 1 => 1
                                   | (_.+1 as i).+1 => 1%Q + loop i
                                   end) n)%Q
                           end)%Q
                      end *
                      match Hab with
                      | Posz n => iterop n addq 1 0
                      | Negz n =>
                          (-
                           match n with
                           | 0 => 1%Q
                           | _.+1 =>
                               (1%Q +
                                (fix loop (m : nat) : rat :=
                                   match m with
                                   | 0 => 0
                                   | 1 => 1
                                   | (_.+1 as i).+1 => 1%Q + loop i
                                   end) n)%Q
                           end)%Q
                      end)%Q)%Q)%Q +
                   (((- rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q *
                     (match n_gt0 with
                      | Posz n => iterop n addq 1 0
                      | Negz n =>
                          (-
                           match n with
                           | 0 => 1%Q
                           | _.+1 =>
                               (1%Q +
                                (fix loop (m : nat) : rat :=
                                   match m with
                                   | 0 => 0
                                   | 1 => 1
                                   | (_.+1 as i).+1 => 1%Q + loop i
                                   end) n)%Q
                           end)%Q
                      end *
                      match n_gt0 with
                      | Posz n => iterop n addq 1 0
                      | Negz n =>
                          (-
                           match n with
                           | 0 => 1%Q
                           | _.+1 =>
                               (1%Q +
                                (fix loop (m : nat) : rat :=
                                   match m with
                                   | 0 => 0
                                   | 1 => 1
                                   | (_.+1 as i).+1 => 1%Q + loop i
                                   end) n)%Q
                           end)%Q
                      end)%Q)%Q *
                    match Hab with
                    | Posz n => iterop n addq 1 0
                    | Negz n =>
                        (-
                         match n with
                         | 0 => 1%Q
                         | _.+1 =>
                             (1%Q +
                              (fix loop (m : nat) : rat :=
                                 match m with
                                 | 0 => 0
                                 | 1 => 1
                                 | (_.+1 as i).+1 => 1%Q + loop i
                                 end) n)%Q
                         end)%Q
                    end)%Q)%Q +
                  ((rat_of_Z (BinNums.Zpos (BinNums.xO (BinNums.xO 1%AC))) *
                    (match n_gt0 with
                     | Posz n => iterop n addq 1 0
                     | Negz n =>
                         (-
                          match n with
                          | 0 => 1%Q
                          | _.+1 =>
                              (1%Q +
                               (fix loop (m : nat) : rat :=
                                  match m with
                                  | 0 => 0
                                  | 1 => 1
                                  | (_.+1 as i).+1 => 1%Q + loop i
                                  end) n)%Q
                          end)%Q
                     end *
                     (match n_gt0 with
                      | Posz n => iterop n addq 1 0
                      | Negz n =>
                          (-
                           match n with
                           | 0 => 1%Q
                           | _.+1 =>
                               (1%Q +
                                (fix loop (m : nat) : rat :=
                                   match m with
                                   | 0 => 0
                                   | 1 => 1
                                   | (_.+1 as i).+1 => 1%Q + loop i
                                   end) n)%Q
                           end)%Q
                      end *
                      match n_gt0 with
                      | Posz n => iterop n addq 1 0
                      | Negz n =>
                          (-
                           match n with
                           | 0 => 1%Q
                           | _.+1 =>
                               (1%Q +
                                (fix loop (m : nat) : rat :=
                                   match m with
                                   | 0 => 0
                                   | 1 => 1
                                   | (_.+1 as i).+1 => 1%Q + loop i
                                   end) n)%Q
                           end)%Q
                      end)%Q)%Q)%Q *
                   match Hab with
                   | Posz n => iterop n addq 1 0
                   | Negz n =>
                       (-
                        match n with
                        | 0 => 1%Q
                        | _.+1 =>
                            (1%Q +
                             (fix loop (m : nat) : rat :=
                                match m with
                                | 0 => 0
                                | 1 => 1
                                | (_.+1 as i).+1 => 1%Q + loop i
                                end) n)%Q
                        end)%Q
                   end)%Q)%Q +
                 match n_gt0 with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end)%Q +
                (rat_of_Z (BinNums.Zpos (BinNums.xI (BinNums.xI 1%AC))) *
                 match Hab with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end)%Q)%Q)%Q *
              (((match Hab with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end + rat_of_Z (BinNums.Zpos 1%AC))%Q +
                match n_gt0 with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 => 1%Q + loop i
                             end) n)%Q
                     end)%Q
                end)%Q *
               ((match Hab with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end + rat_of_Z (BinNums.Zpos 1%AC))%Q +
                match n_gt0 with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 => 1%Q + loop i
                             end) n)%Q
                     end)%Q
                end)%Q)%Q)%Q *
             (((((match Hab with
                  | Posz n => iterop n addq 1 0
                  | Negz n =>
                      (-
                       match n with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as i).+1 => 1%Q + loop i
                               end) n)%Q
                       end)%Q
                  end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q *
                 ((match Hab with
                   | Posz n => iterop n addq 1 0
                   | Negz n =>
                       (-
                        match n with
                        | 0 => 1%Q
                        | _.+1 =>
                            (1%Q +
                             (fix loop (m : nat) : rat :=
                                match m with
                                | 0 => 0
                                | 1 => 1
                                | (_.+1 as i).+1 => 1%Q + loop i
                                end) n)%Q
                        end)%Q
                   end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q *
                  (match Hab with
                   | Posz n => iterop n addq 1 0
                   | Negz n =>
                       (-
                        match n with
                        | 0 => 1%Q
                        | _.+1 =>
                            (1%Q +
                             (fix loop (m : nat) : rat :=
                                match m with
                                | 0 => 0
                                | 1 => 1
                                | (_.+1 as i).+1 => 1%Q + loop i
                                end) n)%Q
                        end)%Q
                   end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q)%Q)%Q *
                ((((-
                    match Hab with
                    | Posz n => iterop n addq 1 0
                    | Negz n =>
                        (-
                         match n with
                         | 0 => 1%Q
                         | _.+1 =>
                             (1%Q +
                              (fix loop (m : nat) : rat :=
                                 match m with
                                 | 0 => 0
                                 | 1 => 1
                                 | (_.+1 as i).+1 => 1%Q + loop i
                                 end) n)%Q
                         end)%Q
                    end)%Q + (- rat_of_Z (BinNums.Zpos 1%AC))%Q)%Q +
                  match n_gt0 with
                  | Posz n => iterop n addq 1 0
                  | Negz n =>
                      (-
                       match n with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as i).+1 => 1%Q + loop i
                               end) n)%Q
                       end)%Q
                  end)%Q *
                 (((-
                    match Hab with
                    | Posz n => iterop n addq 1 0
                    | Negz n =>
                        (-
                         match n with
                         | 0 => 1%Q
                         | _.+1 =>
                             (1%Q +
                              (fix loop (m : nat) : rat :=
                                 match m with
                                 | 0 => 0
                                 | 1 => 1
                                 | (_.+1 as i).+1 => 1%Q + loop i
                                 end) n)%Q
                         end)%Q
                    end)%Q + (- rat_of_Z (BinNums.Zpos 1%AC))%Q)%Q +
                  match n_gt0 with
                  | Posz n => iterop n addq 1 0
                  | Negz n =>
                      (-
                       match n with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as i).+1 => 1%Q + loop i
                               end) n)%Q
                       end)%Q
                  end)%Q)%Q)%Q *
               (((match n_gt0 with
                  | Posz n => iterop n addq 1 0
                  | Negz n =>
                      (-
                       match n with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as i).+1 => 1%Q + loop i
                               end) n)%Q
                       end)%Q
                  end +
                  (-
                   match Hab with
                   | Posz n => iterop n addq 1 0
                   | Negz n =>
                       (-
                        match n with
                        | 0 => 1%Q
                        | _.+1 =>
                            (1%Q +
                             (fix loop (m : nat) : rat :=
                                match m with
                                | 0 => 0
                                | 1 => 1
                                | (_.+1 as i).+1 => 1%Q + loop i
                                end) n)%Q
                        end)%Q
                   end)%Q)%Q +
                 (- rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q)%Q *
                ((match n_gt0 with
                  | Posz n => iterop n addq 1 0
                  | Negz n =>
                      (-
                       match n with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as i).+1 => 1%Q + loop i
                               end) n)%Q
                       end)%Q
                  end +
                  (-
                   match Hab with
                   | Posz n => iterop n addq 1 0
                   | Negz n =>
                       (-
                        match n with
                        | 0 => 1%Q
                        | _.+1 =>
                            (1%Q +
                             (fix loop (m : nat) : rat :=
                                match m with
                                | 0 => 0
                                | 1 => 1
                                | (_.+1 as i).+1 => 1%Q + loop i
                                end) n)%Q
                        end)%Q
                   end)%Q)%Q +
                 (- rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q)%Q)%Q)%Q^-1)%Q)%Q *
            (((match binomialz Hab n_gt0 with
               | Posz n => iterop n addq 1 0
               | Negz n =>
                   (-
                    match n with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 => 1%Q + loop i
                            end) n)%Q
                    end)%Q
               end *
               match binomialz Hab n_gt0 with
               | Posz n => iterop n addq 1 0
               | Negz n =>
                   (-
                    match n with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 => 1%Q + loop i
                            end) n)%Q
                    end)%Q
               end)%Q *
              (match binomialz (intZmod.addz Hab n_gt0) n_gt0 with
               | Posz n => iterop n addq 1 0
               | Negz n =>
                   (-
                    match n with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 => 1%Q + loop i
                            end) n)%Q
                    end)%Q
               end *
               match binomialz (intZmod.addz Hab n_gt0) n_gt0 with
               | Posz n => iterop n addq 1 0
               | Negz n =>
                   (-
                    match n with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 => 1%Q + loop i
                            end) n)%Q
                    end)%Q
               end)%Q)%Q * (ghn3 Hab + s Hab n_gt0)%Q)%Q)%Q +
           ((((((rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)) *
                 match Hab with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end)%Q + rat_of_Z (BinNums.Zpos (BinNums.xI 1%AC)))%Q *
               (((match Hab with
                  | Posz n => iterop n addq 1 0
                  | Negz n =>
                      (-
                       match n with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as i).+1 => 1%Q + loop i
                               end) n)%Q
                       end)%Q
                  end *
                  match Hab with
                  | Posz n => iterop n addq 1 0
                  | Negz n =>
                      (-
                       match n with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as i).+1 => 1%Q + loop i
                               end) n)%Q
                       end)%Q
                  end)%Q +
                 (rat_of_Z (BinNums.Zpos (BinNums.xI 1%AC)) *
                  match Hab with
                  | Posz n => iterop n addq 1 0
                  | Negz n =>
                      (-
                       match n with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as i).+1 => 1%Q + loop i
                               end) n)%Q
                       end)%Q
                  end)%Q)%Q + rat_of_Z (BinNums.Zpos (BinNums.xI 1%AC)))%Q)%Q *
              (((match Hab with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q +
                match n_gt0 with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 => 1%Q + loop i
                             end) n)%Q
                     end)%Q
                end)%Q *
               ((match Hab with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q +
                match n_gt0 with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 => 1%Q + loop i
                             end) n)%Q
                     end)%Q
                end)%Q)%Q)%Q *
             ((((match Hab with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q *
                ((match Hab with
                  | Posz n => iterop n addq 1 0
                  | Negz n =>
                      (-
                       match n with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as i).+1 => 1%Q + loop i
                               end) n)%Q
                       end)%Q
                  end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q *
                 (match Hab with
                  | Posz n => iterop n addq 1 0
                  | Negz n =>
                      (-
                       match n with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as i).+1 => 1%Q + loop i
                               end) n)%Q
                       end)%Q
                  end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q)%Q)%Q *
               (((match n_gt0 with
                  | Posz n => iterop n addq 1 0
                  | Negz n =>
                      (-
                       match n with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as i).+1 => 1%Q + loop i
                               end) n)%Q
                       end)%Q
                  end +
                  (-
                   match Hab with
                   | Posz n => iterop n addq 1 0
                   | Negz n =>
                       (-
                        match n with
                        | 0 => 1%Q
                        | _.+1 =>
                            (1%Q +
                             (fix loop (m : nat) : rat :=
                                match m with
                                | 0 => 0
                                | 1 => 1
                                | (_.+1 as i).+1 => 1%Q + loop i
                                end) n)%Q
                        end)%Q
                   end)%Q)%Q +
                 (- rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q)%Q *
                ((match n_gt0 with
                  | Posz n => iterop n addq 1 0
                  | Negz n =>
                      (-
                       match n with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as i).+1 => 1%Q + loop i
                               end) n)%Q
                       end)%Q
                  end +
                  (-
                   match Hab with
                   | Posz n => iterop n addq 1 0
                   | Negz n =>
                       (-
                        match n with
                        | 0 => 1%Q
                        | _.+1 =>
                            (1%Q +
                             (fix loop (m : nat) : rat :=
                                match m with
                                | 0 => 0
                                | 1 => 1
                                | (_.+1 as i).+1 => 1%Q + loop i
                                end) n)%Q
                        end)%Q
                   end)%Q)%Q +
                 (- rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q)%Q)%Q)%Q^-1)%Q)%Q *
            (((match binomialz (intZmod.addz Hab 1) n_gt0 with
               | Posz n => iterop n addq 1 0
               | Negz n =>
                   (-
                    match n with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 => 1%Q + loop i
                            end) n)%Q
                    end)%Q
               end *
               match binomialz (intZmod.addz Hab 1) n_gt0 with
               | Posz n => iterop n addq 1 0
               | Negz n =>
                   (-
                    match n with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 => 1%Q + loop i
                            end) n)%Q
                    end)%Q
               end)%Q *
              (match
                 binomialz (intZmod.addz (intZmod.addz Hab 1) n_gt0) n_gt0
               with
               | Posz n => iterop n addq 1 0
               | Negz n =>
                   (-
                    match n with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 => 1%Q + loop i
                            end) n)%Q
                    end)%Q
               end *
               match
                 binomialz (intZmod.addz (intZmod.addz Hab 1) n_gt0) n_gt0
               with
               | Posz n => iterop n addq 1 0
               | Negz n =>
                   (-
                    match n with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 => 1%Q + loop i
                            end) n)%Q
                    end)%Q
               end)%Q)%Q *
             (ghn3 (intZmod.addz Hab 1) + s (intZmod.addz Hab 1) n_gt0)%Q)%Q)%Q)%Q +
          ((((((rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)) *
                match n_gt0 with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 => 1%Q + loop i
                             end) n)%Q
                     end)%Q
                end)%Q *
               ((rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)) *
                 match Hab with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end)%Q + rat_of_Z (BinNums.Zpos (BinNums.xI 1%AC)))%Q)%Q *
              ((match n_gt0 with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 => 1%Q + loop i
                             end) n)%Q
                     end)%Q
                end + rat_of_Z (BinNums.Zpos 1%AC))%Q *
               ((match n_gt0 with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end + rat_of_Z (BinNums.Zpos 1%AC))%Q *
                ((match n_gt0 with
                  | Posz n => iterop n addq 1 0
                  | Negz n =>
                      (-
                       match n with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as i).+1 => 1%Q + loop i
                               end) n)%Q
                       end)%Q
                  end + rat_of_Z (BinNums.Zpos 1%AC))%Q *
                 ((match n_gt0 with
                   | Posz n => iterop n addq 1 0
                   | Negz n =>
                       (-
                        match n with
                        | 0 => 1%Q
                        | _.+1 =>
                            (1%Q +
                             (fix loop (m : nat) : rat :=
                                match m with
                                | 0 => 0
                                | 1 => 1
                                | (_.+1 as i).+1 => 1%Q + loop i
                                end) n)%Q
                        end)%Q
                   end + rat_of_Z (BinNums.Zpos 1%AC))%Q *
                  (match n_gt0 with
                   | Posz n => iterop n addq 1 0
                   | Negz n =>
                       (-
                        match n with
                        | 0 => 1%Q
                        | _.+1 =>
                            (1%Q +
                             (fix loop (m : nat) : rat :=
                                match m with
                                | 0 => 0
                                | 1 => 1
                                | (_.+1 as i).+1 => 1%Q + loop i
                                end) n)%Q
                        end)%Q
                   end + rat_of_Z (BinNums.Zpos 1%AC))%Q)%Q)%Q)%Q)%Q)%Q *
             ((match Hab with
               | Posz n => iterop n addq 1 0
               | Negz n =>
                   (-
                    match n with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 => 1%Q + loop i
                            end) n)%Q
                    end)%Q
               end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q +
              match n_gt0 with
              | Posz n => iterop n addq 1 0
              | Negz n =>
                  (-
                   match n with
                   | 0 => 1%Q
                   | _.+1 =>
                       (1%Q +
                        (fix loop (m : nat) : rat :=
                           match m with
                           | 0 => 0
                           | 1 => 1
                           | (_.+1 as i).+1 => 1%Q + loop i
                           end) n)%Q
                   end)%Q
              end)%Q)%Q *
            ((((((match Hab with
                  | Posz n => iterop n addq 1 0
                  | Negz n =>
                      (-
                       match n with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as i).+1 => 1%Q + loop i
                               end) n)%Q
                       end)%Q
                  end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q *
                 ((match Hab with
                   | Posz n => iterop n addq 1 0
                   | Negz n =>
                       (-
                        match n with
                        | 0 => 1%Q
                        | _.+1 =>
                            (1%Q +
                             (fix loop (m : nat) : rat :=
                                match m with
                                | 0 => 0
                                | 1 => 1
                                | (_.+1 as i).+1 => 1%Q + loop i
                                end) n)%Q
                        end)%Q
                   end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q *
                  (match Hab with
                   | Posz n => iterop n addq 1 0
                   | Negz n =>
                       (-
                        match n with
                        | 0 => 1%Q
                        | _.+1 =>
                            (1%Q +
                             (fix loop (m : nat) : rat :=
                                match m with
                                | 0 => 0
                                | 1 => 1
                                | (_.+1 as i).+1 => 1%Q + loop i
                                end) n)%Q
                        end)%Q
                   end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q)%Q)%Q *
                ((-
                  match Hab with
                  | Posz n => iterop n addq 1 0
                  | Negz n =>
                      (-
                       match n with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as i).+1 => 1%Q + loop i
                               end) n)%Q
                       end)%Q
                  end)%Q +
                 match n_gt0 with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end)%Q)%Q *
               ((((-
                   match Hab with
                   | Posz n => iterop n addq 1 0
                   | Negz n =>
                       (-
                        match n with
                        | 0 => 1%Q
                        | _.+1 =>
                            (1%Q +
                             (fix loop (m : nat) : rat :=
                                match m with
                                | 0 => 0
                                | 1 => 1
                                | (_.+1 as i).+1 => 1%Q + loop i
                                end) n)%Q
                        end)%Q
                   end)%Q + (- rat_of_Z (BinNums.Zpos 1%AC))%Q)%Q +
                 match n_gt0 with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end)%Q *
                (((-
                   match Hab with
                   | Posz n => iterop n addq 1 0
                   | Negz n =>
                       (-
                        match n with
                        | 0 => 1%Q
                        | _.+1 =>
                            (1%Q +
                             (fix loop (m : nat) : rat :=
                                match m with
                                | 0 => 0
                                | 1 => 1
                                | (_.+1 as i).+1 => 1%Q + loop i
                                end) n)%Q
                        end)%Q
                   end)%Q + (- rat_of_Z (BinNums.Zpos 1%AC))%Q)%Q +
                 match n_gt0 with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end)%Q)%Q)%Q *
              (((match n_gt0 with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end +
                 (-
                  match Hab with
                  | Posz n => iterop n addq 1 0
                  | Negz n =>
                      (-
                       match n with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as i).+1 => 1%Q + loop i
                               end) n)%Q
                       end)%Q
                  end)%Q)%Q + (- rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q)%Q *
               ((match n_gt0 with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end +
                 (-
                  match Hab with
                  | Posz n => iterop n addq 1 0
                  | Negz n =>
                      (-
                       match n with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as i).+1 => 1%Q + loop i
                               end) n)%Q
                       end)%Q
                  end)%Q)%Q + (- rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q)%Q)%Q)%Q^-1)%Q)%Q *
           (((match binomialz Hab (intZmod.addz n_gt0 1) with
              | Posz n => iterop n addq 1 0
              | Negz n =>
                  (-
                   match n with
                   | 0 => 1%Q
                   | _.+1 =>
                       (1%Q +
                        (fix loop (m : nat) : rat :=
                           match m with
                           | 0 => 0
                           | 1 => 1
                           | (_.+1 as i).+1 => 1%Q + loop i
                           end) n)%Q
                   end)%Q
              end *
              match binomialz Hab (intZmod.addz n_gt0 1) with
              | Posz n => iterop n addq 1 0
              | Negz n =>
                  (-
                   match n with
                   | 0 => 1%Q
                   | _.+1 =>
                       (1%Q +
                        (fix loop (m : nat) : rat :=
                           match m with
                           | 0 => 0
                           | 1 => 1
                           | (_.+1 as i).+1 => 1%Q + loop i
                           end) n)%Q
                   end)%Q
              end)%Q *
             (match
                binomialz (intZmod.addz Hab (intZmod.addz n_gt0 1))
                  (intZmod.addz n_gt0 1)
              with
              | Posz n => iterop n addq 1 0
              | Negz n =>
                  (-
                   match n with
                   | 0 => 1%Q
                   | _.+1 =>
                       (1%Q +
                        (fix loop (m : nat) : rat :=
                           match m with
                           | 0 => 0
                           | 1 => 1
                           | (_.+1 as i).+1 => 1%Q + loop i
                           end) n)%Q
                   end)%Q
              end *
              match
                binomialz (intZmod.addz Hab (intZmod.addz n_gt0 1))
                  (intZmod.addz n_gt0 1)
              with
              | Posz n => iterop n addq 1 0
              | Negz n =>
                  (-
                   match n with
                   | 0 => 1%Q
                   | _.+1 =>
                       (1%Q +
                        (fix loop (m : nat) : rat :=
                           match m with
                           | 0 => 0
                           | 1 => 1
                           | (_.+1 as i).+1 => 1%Q + loop i
                           end) n)%Q
                   end)%Q
              end)%Q)%Q * (ghn3 Hab + s Hab (intZmod.addz n_gt0 1))%Q)%Q)%Q)%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
Hab, k_ : int
H : annotated_recs_v.precond.Sn2 Hab k_
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: (((match binomialz (intZmod.addz (intZmod.addz Hab 1) 1) k_ with
            | Posz n => iterop n addq 1 0
            | Negz n =>
                (-
                 match n with
                 | 0 => 1%Q
                 | _.+1 =>
                     (1%Q +
                      (fix loop (m : nat) : rat :=
                         match m with
                         | 0 => 0
                         | 1 => 1
                         | (_.+1 as i).+1 => 1%Q + loop i
                         end) n)%Q
                 end)%Q
            end *
            match binomialz (intZmod.addz (intZmod.addz Hab 1) 1) k_ with
            | Posz n => iterop n addq 1 0
            | Negz n =>
                (-
                 match n with
                 | 0 => 1%Q
                 | _.+1 =>
                     (1%Q +
                      (fix loop (m : nat) : rat :=
                         match m with
                         | 0 => 0
                         | 1 => 1
                         | (_.+1 as i).+1 => 1%Q + loop i
                         end) n)%Q
                 end)%Q
            end)%Q *
           (match
              binomialz
                (intZmod.addz (intZmod.addz (intZmod.addz Hab 1) 1) k_) k_
            with
            | Posz n => iterop n addq 1 0
            | Negz n =>
                (-
                 match n with
                 | 0 => 1%Q
                 | _.+1 =>
                     (1%Q +
                      (fix loop (m : nat) : rat :=
                         match m with
                         | 0 => 0
                         | 1 => 1
                         | (_.+1 as i).+1 => 1%Q + loop i
                         end) n)%Q
                 end)%Q
            end *
            match
              binomialz
                (intZmod.addz (intZmod.addz (intZmod.addz Hab 1) 1) k_) k_
            with
            | Posz n => iterop n addq 1 0
            | Negz n =>
                (-
                 match n with
                 | 0 => 1%Q
                 | _.+1 =>
                     (1%Q +
                      (fix loop (m : nat) : rat :=
                         match m with
                         | 0 => 0
                         | 1 => 1
                         | (_.+1 as i).+1 => 1%Q + loop i
                         end) n)%Q
                 end)%Q
            end)%Q)%Q *
          (ghn3 (intZmod.addz (intZmod.addz Hab 1) 1) +
           s (intZmod.addz (intZmod.addz Hab 1) 1) k_)%Q)%Q;
         ((((((((- rat_of_Z (BinNums.Zpos 1%AC))%Q *
                ((match Hab with
                  | Posz n => iterop n addq 1 0
                  | Negz n =>
                      (-
                       match n with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as i).+1 => 1%Q + loop i
                               end) n)%Q
                       end)%Q
                  end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q +
                 match k_ with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end)%Q)%Q *
               (((((((((((((rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)) +
                            (rat_of_Z (BinNums.Zpos (...)) *
                             (match ... with
                              | ... ...
                              | ... ...%Q
                              end * match ... with
                                    | ... ...
                                    | ... ...%Q
                                    end)%Q)%Q)%Q +
                           (((- rat_of_Z (...))%Q *
                             match k_ with
                             | Posz n => iterop n addq 1 0
                             | Negz n => (- ...)%Q
                             end)%Q *
                            match Hab with
                            | Posz n => iterop n addq 1 0
                            | Negz n =>
                                (- match ... with
                                   | ... 1%Q
                                   | ... ...%Q
                                   end)%Q
                            end)%Q)%Q +
                          (rat_of_Z
                             (BinNums.Zpos (BinNums.xO (BinNums.xI 1%AC))) *
                           (match k_ with
                            | Posz n => iterop n addq 1 0
                            | Negz n =>
                                (- match ... with
                                   | ... 1%Q
                                   | ... ...%Q
                                   end)%Q
                            end *
                            match k_ with
                            | Posz n => iterop n addq 1 0
                            | Negz n =>
                                (- match ... with
                                   | ... 1%Q
                                   | ... ...%Q
                                   end)%Q
                            end)%Q)%Q)%Q +
                         (match Hab with
                          | Posz n => iterop n addq 1 0
                          | Negz n =>
                              (-
                               match n with
                               | 0 => 1%Q
                               | _.+1 => (1%Q + (...) n)%Q
                               end)%Q
                          end *
                          (match Hab with
                           | Posz n => iterop n addq 1 0
                           | Negz n =>
                               (-
                                match n with
                                | 0 => 1%Q
                                | _.+1 => (1%Q + ...)%Q
                                end)%Q
                           end *
                           (match Hab with
                            | Posz n => iterop n addq 1 0
                            | Negz n =>
                                (- match ... with
                                   | ... 1%Q
                                   | ... ...%Q
                                   end)%Q
                            end *
                            match Hab with
                            | Posz n => iterop n addq 1 0
                            | Negz n =>
                                (- match ... with
                                   | ... 1%Q
                                   | ... ...%Q
                                   end)%Q
                            end)%Q)%Q)%Q)%Q +
                        (rat_of_Z
                           (BinNums.Zpos (BinNums.xI (BinNums.xO 1%AC))) *
                         (match Hab with
                          | Posz n => iterop n addq 1 0
                          | Negz n =>
                              (-
                               match n with
                               | 0 => 1%Q
                               | _.+1 => (1%Q + (...) n)%Q
                               end)%Q
                          end *
                          (match Hab with
                           | Posz n => iterop n addq 1 0
                           | Negz n =>
                               (-
                                match n with
                                | 0 => 1%Q
                                | _.+1 => (1%Q + ...)%Q
                                end)%Q
                           end *
                           match Hab with
                           | Posz n => iterop n addq 1 0
                           | Negz n =>
                               (-
                                match n with
                                | 0 => 1%Q
                                | _.+1 => (1%Q + ...)%Q
                                end)%Q
                           end)%Q)%Q)%Q)%Q +
                       (rat_of_Z
                          (BinNums.Zpos (BinNums.xO (BinNums.xI 1%AC))) *
                        (match k_ with
                         | Posz n => iterop n addq 1 0
                         | Negz n =>
                             (-
                              match n with
                              | 0 => 1%Q
                              | _.+1 =>
                                  (1%Q +
                                   (fix loop ... : rat := ...
                                                 ...
                                                 ...
                                                 ...
                                                 end) n)%Q
                              end)%Q
                         end *
                         (match k_ with
                          | Posz n => iterop n addq 1 0
                          | Negz n =>
                              (-
                               match n with
                               | 0 => 1%Q
                               | _.+1 => (1%Q + (...) n)%Q
                               end)%Q
                          end *
                          match k_ with
                          | Posz n => iterop n addq 1 0
                          | Negz n =>
                              (-
                               match n with
                               | 0 => 1%Q
                               | _.+1 => (1%Q + (...) n)%Q
                               end)%Q
                          end)%Q)%Q)%Q)%Q +
                      (match k_ with
                       | Posz n => iterop n addq 1 0
                       | Negz n =>
                           (-
                            match n with
                            | 0 => 1%Q
                            | _.+1 =>
                                (1%Q +
                                 (fix loop (m : nat) : rat :=
                                    match m with
                                    | 0 => 0
                                    | 1 => 1
                                    | (_.+1 as i).+1 => 1%Q + loop i
                                    end) n)%Q
                            end)%Q
                       end *
                       (match Hab with
                        | Posz n => iterop n addq 1 0
                        | Negz n =>
                            (-
                             match n with
                             | 0 => 1%Q
                             | _.+1 =>
                                 (1%Q +
                                  (fix loop (m : nat) : rat :=
                                     match ... with
                                     | ... => 0
                                     | ... => 1
                                     | ... => 1%Q + ...
                                     end) n)%Q
                             end)%Q
                        end *
                        (match Hab with
                         | Posz n => iterop n addq 1 0
                         | Negz n =>
                             (-
                              match n with
                              | 0 => 1%Q
                              | _.+1 =>
                                  (1%Q +
                                   (fix loop ... : rat := ...
                                                 ...
                                                 ...
                                                 ...
                                                 end) n)%Q
                              end)%Q
                         end *
                         match Hab with
                         | Posz n => iterop n addq 1 0
                         | Negz n =>
                             (-
                              match n with
                              | 0 => 1%Q
                              | _.+1 =>
                                  (1%Q +
                                   (fix loop ... : rat := ...
                                                 ...
                                                 ...
                                                 ...
                                                 end) n)%Q
                              end)%Q
                         end)%Q)%Q)%Q)%Q +
                     ((-
                       match k_ with
                       | Posz n => iterop n addq 1 0
                       | Negz n =>
                           (-
                            match n with
                            | 0 => 1%Q
                            | _.+1 =>
                                (1%Q +
                                 (fix loop (m : nat) : rat :=
                                    match m with
                                    | 0 => 0
                                    | 1 => 1
                                    | (_.+1 as i).+1 => 1%Q + loop i
                                    end) n)%Q
                            end)%Q
                       end)%Q *
                      (match Hab with
                       | Posz n => iterop n addq 1 0
                       | Negz n =>
                           (-
                            match n with
                            | 0 => 1%Q
                            | _.+1 =>
                                (1%Q +
                                 (fix loop (m : nat) : rat :=
                                    match m with
                                    | 0 => 0
                                    | 1 => 1
                                    | (_.+1 as i).+1 => 1%Q + loop i
                                    end) n)%Q
                            end)%Q
                       end *
                       match Hab with
                       | Posz n => iterop n addq 1 0
                       | Negz n =>
                           (-
                            match n with
                            | 0 => 1%Q
                            | _.+1 =>
                                (1%Q +
                                 (fix loop (m : nat) : rat :=
                                    match m with
                                    | 0 => 0
                                    | 1 => 1
                                    | (_.+1 as i).+1 => 1%Q + loop i
                                    end) n)%Q
                            end)%Q
                       end)%Q)%Q)%Q +
                    (((-
                       rat_of_Z (BinNums.Zpos (BinNums.xO (BinNums.xO 1%AC))))%Q *
                      (match k_ with
                       | Posz n => iterop n addq 1 0
                       | Negz n =>
                           (-
                            match n with
                            | 0 => 1%Q
                            | _.+1 =>
                                (1%Q +
                                 (fix loop (m : nat) : rat :=
                                    match m with
                                    | 0 => 0
                                    | 1 => 1
                                    | (_.+1 as i).+1 => 1%Q + loop i
                                    end) n)%Q
                            end)%Q
                       end *
                       match k_ with
                       | Posz n => iterop n addq 1 0
                       | Negz n =>
                           (-
                            match n with
                            | 0 => 1%Q
                            | _.+1 =>
                                (1%Q +
                                 (fix loop (m : nat) : rat :=
                                    match m with
                                    | 0 => 0
                                    | 1 => 1
                                    | (_.+1 as i).+1 => 1%Q + loop i
                                    end) n)%Q
                            end)%Q
                       end)%Q)%Q *
                     (match Hab with
                      | Posz n => iterop n addq 1 0
                      | Negz n =>
                          (-
                           match n with
                           | 0 => 1%Q
                           | _.+1 =>
                               (1%Q +
                                (fix loop (m : nat) : rat :=
                                   match m with
                                   | 0 => 0
                                   | 1 => 1
                                   | (_.+1 as i).+1 => 1%Q + loop i
                                   end) n)%Q
                           end)%Q
                      end *
                      match Hab with
                      | Posz n => iterop n addq 1 0
                      | Negz n =>
                          (-
                           match n with
                           | 0 => 1%Q
                           | _.+1 =>
                               (1%Q +
                                (fix loop (m : nat) : rat :=
                                   match m with
                                   | 0 => 0
                                   | 1 => 1
                                   | (_.+1 as i).+1 => 1%Q + loop i
                                   end) n)%Q
                           end)%Q
                      end)%Q)%Q)%Q +
                   (((- rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q *
                     (match k_ with
                      | Posz n => iterop n addq 1 0
                      | Negz n =>
                          (-
                           match n with
                           | 0 => 1%Q
                           | _.+1 =>
                               (1%Q +
                                (fix loop (m : nat) : rat :=
                                   match m with
                                   | 0 => 0
                                   | 1 => 1
                                   | (_.+1 as i).+1 => 1%Q + loop i
                                   end) n)%Q
                           end)%Q
                      end *
                      match k_ with
                      | Posz n => iterop n addq 1 0
                      | Negz n =>
                          (-
                           match n with
                           | 0 => 1%Q
                           | _.+1 =>
                               (1%Q +
                                (fix loop (m : nat) : rat :=
                                   match m with
                                   | 0 => 0
                                   | 1 => 1
                                   | (_.+1 as i).+1 => 1%Q + loop i
                                   end) n)%Q
                           end)%Q
                      end)%Q)%Q *
                    match Hab with
                    | Posz n => iterop n addq 1 0
                    | Negz n =>
                        (-
                         match n with
                         | 0 => 1%Q
                         | _.+1 =>
                             (1%Q +
                              (fix loop (m : nat) : rat :=
                                 match m with
                                 | 0 => 0
                                 | 1 => 1
                                 | (_.+1 as i).+1 => 1%Q + loop i
                                 end) n)%Q
                         end)%Q
                    end)%Q)%Q +
                  ((rat_of_Z (BinNums.Zpos (BinNums.xO (BinNums.xO 1%AC))) *
                    (match k_ with
                     | Posz n => iterop n addq 1 0
                     | Negz n =>
                         (-
                          match n with
                          | 0 => 1%Q
                          | _.+1 =>
                              (1%Q +
                               (fix loop (m : nat) : rat :=
                                  match m with
                                  | 0 => 0
                                  | 1 => 1
                                  | (_.+1 as i).+1 => 1%Q + loop i
                                  end) n)%Q
                          end)%Q
                     end *
                     (match k_ with
                      | Posz n => iterop n addq 1 0
                      | Negz n =>
                          (-
                           match n with
                           | 0 => 1%Q
                           | _.+1 =>
                               (1%Q +
                                (fix loop (m : nat) : rat :=
                                   match m with
                                   | 0 => 0
                                   | 1 => 1
                                   | (_.+1 as i).+1 => 1%Q + loop i
                                   end) n)%Q
                           end)%Q
                      end *
                      match k_ with
                      | Posz n => iterop n addq 1 0
                      | Negz n =>
                          (-
                           match n with
                           | 0 => 1%Q
                           | _.+1 =>
                               (1%Q +
                                (fix loop (m : nat) : rat :=
                                   match m with
                                   | 0 => 0
                                   | 1 => 1
                                   | (_.+1 as i).+1 => 1%Q + loop i
                                   end) n)%Q
                           end)%Q
                      end)%Q)%Q)%Q *
                   match Hab with
                   | Posz n => iterop n addq 1 0
                   | Negz n =>
                       (-
                        match n with
                        | 0 => 1%Q
                        | _.+1 =>
                            (1%Q +
                             (fix loop (m : nat) : rat :=
                                match m with
                                | 0 => 0
                                | 1 => 1
                                | (_.+1 as i).+1 => 1%Q + loop i
                                end) n)%Q
                        end)%Q
                   end)%Q)%Q +
                 match k_ with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end)%Q +
                (rat_of_Z (BinNums.Zpos (BinNums.xI (BinNums.xI 1%AC))) *
                 match Hab with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end)%Q)%Q)%Q *
              (((match Hab with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end + rat_of_Z (BinNums.Zpos 1%AC))%Q +
                match k_ with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 => 1%Q + loop i
                             end) n)%Q
                     end)%Q
                end)%Q *
               ((match Hab with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end + rat_of_Z (BinNums.Zpos 1%AC))%Q +
                match k_ with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 => 1%Q + loop i
                             end) n)%Q
                     end)%Q
                end)%Q)%Q)%Q *
             (((((match Hab with
                  | Posz n => iterop n addq 1 0
                  | Negz n =>
                      (-
                       match n with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as i).+1 => 1%Q + loop i
                               end) n)%Q
                       end)%Q
                  end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q *
                 ((match Hab with
                   | Posz n => iterop n addq 1 0
                   | Negz n =>
                       (-
                        match n with
                        | 0 => 1%Q
                        | _.+1 =>
                            (1%Q +
                             (fix loop (m : nat) : rat :=
                                match m with
                                | 0 => 0
                                | 1 => 1
                                | (_.+1 as i).+1 => 1%Q + loop i
                                end) n)%Q
                        end)%Q
                   end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q *
                  (match Hab with
                   | Posz n => iterop n addq 1 0
                   | Negz n =>
                       (-
                        match n with
                        | 0 => 1%Q
                        | _.+1 =>
                            (1%Q +
                             (fix loop (m : nat) : rat :=
                                match m with
                                | 0 => 0
                                | 1 => 1
                                | (_.+1 as i).+1 => 1%Q + loop i
                                end) n)%Q
                        end)%Q
                   end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q)%Q)%Q *
                ((((-
                    match Hab with
                    | Posz n => iterop n addq 1 0
                    | Negz n =>
                        (-
                         match n with
                         | 0 => 1%Q
                         | _.+1 =>
                             (1%Q +
                              (fix loop (m : nat) : rat :=
                                 match m with
                                 | 0 => 0
                                 | 1 => 1
                                 | (_.+1 as i).+1 => 1%Q + loop i
                                 end) n)%Q
                         end)%Q
                    end)%Q + (- rat_of_Z (BinNums.Zpos 1%AC))%Q)%Q +
                  match k_ with
                  | Posz n => iterop n addq 1 0
                  | Negz n =>
                      (-
                       match n with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as i).+1 => 1%Q + loop i
                               end) n)%Q
                       end)%Q
                  end)%Q *
                 (((-
                    match Hab with
                    | Posz n => iterop n addq 1 0
                    | Negz n =>
                        (-
                         match n with
                         | 0 => 1%Q
                         | _.+1 =>
                             (1%Q +
                              (fix loop (m : nat) : rat :=
                                 match m with
                                 | 0 => 0
                                 | 1 => 1
                                 | (_.+1 as i).+1 => 1%Q + loop i
                                 end) n)%Q
                         end)%Q
                    end)%Q + (- rat_of_Z (BinNums.Zpos 1%AC))%Q)%Q +
                  match k_ with
                  | Posz n => iterop n addq 1 0
                  | Negz n =>
                      (-
                       match n with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as i).+1 => 1%Q + loop i
                               end) n)%Q
                       end)%Q
                  end)%Q)%Q)%Q *
               (((match k_ with
                  | Posz n => iterop n addq 1 0
                  | Negz n =>
                      (-
                       match n with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as i).+1 => 1%Q + loop i
                               end) n)%Q
                       end)%Q
                  end +
                  (-
                   match Hab with
                   | Posz n => iterop n addq 1 0
                   | Negz n =>
                       (-
                        match n with
                        | 0 => 1%Q
                        | _.+1 =>
                            (1%Q +
                             (fix loop (m : nat) : rat :=
                                match m with
                                | 0 => 0
                                | 1 => 1
                                | (_.+1 as i).+1 => 1%Q + loop i
                                end) n)%Q
                        end)%Q
                   end)%Q)%Q +
                 (- rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q)%Q *
                ((match k_ with
                  | Posz n => iterop n addq 1 0
                  | Negz n =>
                      (-
                       match n with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as i).+1 => 1%Q + loop i
                               end) n)%Q
                       end)%Q
                  end +
                  (-
                   match Hab with
                   | Posz n => iterop n addq 1 0
                   | Negz n =>
                       (-
                        match n with
                        | 0 => 1%Q
                        | _.+1 =>
                            (1%Q +
                             (fix loop (m : nat) : rat :=
                                match m with
                                | 0 => 0
                                | 1 => 1
                                | (_.+1 as i).+1 => 1%Q + loop i
                                end) n)%Q
                        end)%Q
                   end)%Q)%Q +
                 (- rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q)%Q)%Q)%Q^-1)%Q)%Q *
            (((match binomialz Hab k_ with
               | Posz n => iterop n addq 1 0
               | Negz n =>
                   (-
                    match n with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 => 1%Q + loop i
                            end) n)%Q
                    end)%Q
               end *
               match binomialz Hab k_ with
               | Posz n => iterop n addq 1 0
               | Negz n =>
                   (-
                    match n with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 => 1%Q + loop i
                            end) n)%Q
                    end)%Q
               end)%Q *
              (match binomialz (intZmod.addz Hab k_) k_ with
               | Posz n => iterop n addq 1 0
               | Negz n =>
                   (-
                    match n with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 => 1%Q + loop i
                            end) n)%Q
                    end)%Q
               end *
               match binomialz (intZmod.addz Hab k_) k_ with
               | Posz n => iterop n addq 1 0
               | Negz n =>
                   (-
                    match n with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 => 1%Q + loop i
                            end) n)%Q
                    end)%Q
               end)%Q)%Q * (ghn3 Hab + s Hab k_)%Q)%Q)%Q +
           ((((((rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)) *
                 match Hab with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end)%Q + rat_of_Z (BinNums.Zpos (BinNums.xI 1%AC)))%Q *
               (((match Hab with
                  | Posz n => iterop n addq 1 0
                  | Negz n =>
                      (-
                       match n with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as i).+1 => 1%Q + loop i
                               end) n)%Q
                       end)%Q
                  end *
                  match Hab with
                  | Posz n => iterop n addq 1 0
                  | Negz n =>
                      (-
                       match n with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as i).+1 => 1%Q + loop i
                               end) n)%Q
                       end)%Q
                  end)%Q +
                 (rat_of_Z (BinNums.Zpos (BinNums.xI 1%AC)) *
                  match Hab with
                  | Posz n => iterop n addq 1 0
                  | Negz n =>
                      (-
                       match n with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as i).+1 => 1%Q + loop i
                               end) n)%Q
                       end)%Q
                  end)%Q)%Q + rat_of_Z (BinNums.Zpos (BinNums.xI 1%AC)))%Q)%Q *
              (((match Hab with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q +
                match k_ with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 => 1%Q + loop i
                             end) n)%Q
                     end)%Q
                end)%Q *
               ((match Hab with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q +
                match k_ with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 => 1%Q + loop i
                             end) n)%Q
                     end)%Q
                end)%Q)%Q)%Q *
             ((((match Hab with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q *
                ((match Hab with
                  | Posz n => iterop n addq 1 0
                  | Negz n =>
                      (-
                       match n with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as i).+1 => 1%Q + loop i
                               end) n)%Q
                       end)%Q
                  end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q *
                 (match Hab with
                  | Posz n => iterop n addq 1 0
                  | Negz n =>
                      (-
                       match n with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as i).+1 => 1%Q + loop i
                               end) n)%Q
                       end)%Q
                  end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q)%Q)%Q *
               (((match k_ with
                  | Posz n => iterop n addq 1 0
                  | Negz n =>
                      (-
                       match n with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as i).+1 => 1%Q + loop i
                               end) n)%Q
                       end)%Q
                  end +
                  (-
                   match Hab with
                   | Posz n => iterop n addq 1 0
                   | Negz n =>
                       (-
                        match n with
                        | 0 => 1%Q
                        | _.+1 =>
                            (1%Q +
                             (fix loop (m : nat) : rat :=
                                match m with
                                | 0 => 0
                                | 1 => 1
                                | (_.+1 as i).+1 => 1%Q + loop i
                                end) n)%Q
                        end)%Q
                   end)%Q)%Q +
                 (- rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q)%Q *
                ((match k_ with
                  | Posz n => iterop n addq 1 0
                  | Negz n =>
                      (-
                       match n with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as i).+1 => 1%Q + loop i
                               end) n)%Q
                       end)%Q
                  end +
                  (-
                   match Hab with
                   | Posz n => iterop n addq 1 0
                   | Negz n =>
                       (-
                        match n with
                        | 0 => 1%Q
                        | _.+1 =>
                            (1%Q +
                             (fix loop (m : nat) : rat :=
                                match m with
                                | 0 => 0
                                | 1 => 1
                                | (_.+1 as i).+1 => 1%Q + loop i
                                end) n)%Q
                        end)%Q
                   end)%Q)%Q +
                 (- rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q)%Q)%Q)%Q^-1)%Q)%Q *
            (((match binomialz (intZmod.addz Hab 1) k_ with
               | Posz n => iterop n addq 1 0
               | Negz n =>
                   (-
                    match n with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 => 1%Q + loop i
                            end) n)%Q
                    end)%Q
               end *
               match binomialz (intZmod.addz Hab 1) k_ with
               | Posz n => iterop n addq 1 0
               | Negz n =>
                   (-
                    match n with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 => 1%Q + loop i
                            end) n)%Q
                    end)%Q
               end)%Q *
              (match binomialz (intZmod.addz (intZmod.addz Hab 1) k_) k_ with
               | Posz n => iterop n addq 1 0
               | Negz n =>
                   (-
                    match n with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 => 1%Q + loop i
                            end) n)%Q
                    end)%Q
               end *
               match binomialz (intZmod.addz (intZmod.addz Hab 1) k_) k_ with
               | Posz n => iterop n addq 1 0
               | Negz n =>
                   (-
                    match n with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 => 1%Q + loop i
                            end) n)%Q
                    end)%Q
               end)%Q)%Q *
             (ghn3 (intZmod.addz Hab 1) + s (intZmod.addz Hab 1) k_)%Q)%Q)%Q)%Q +
          ((((((rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)) *
                match k_ with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 => 1%Q + loop i
                             end) n)%Q
                     end)%Q
                end)%Q *
               ((rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)) *
                 match Hab with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end)%Q + rat_of_Z (BinNums.Zpos (BinNums.xI 1%AC)))%Q)%Q *
              ((match k_ with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 => 1%Q + loop i
                             end) n)%Q
                     end)%Q
                end + rat_of_Z (BinNums.Zpos 1%AC))%Q *
               ((match k_ with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end + rat_of_Z (BinNums.Zpos 1%AC))%Q *
                ((match k_ with
                  | Posz n => iterop n addq 1 0
                  | Negz n =>
                      (-
                       match n with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as i).+1 => 1%Q + loop i
                               end) n)%Q
                       end)%Q
                  end + rat_of_Z (BinNums.Zpos 1%AC))%Q *
                 ((match k_ with
                   | Posz n => iterop n addq 1 0
                   | Negz n =>
                       (-
                        match n with
                        | 0 => 1%Q
                        | _.+1 =>
                            (1%Q +
                             (fix loop (m : nat) : rat :=
                                match m with
                                | 0 => 0
                                | 1 => 1
                                | (_.+1 as i).+1 => 1%Q + loop i
                                end) n)%Q
                        end)%Q
                   end + rat_of_Z (BinNums.Zpos 1%AC))%Q *
                  (match k_ with
                   | Posz n => iterop n addq 1 0
                   | Negz n =>
                       (-
                        match n with
                        | 0 => 1%Q
                        | _.+1 =>
                            (1%Q +
                             (fix loop (m : nat) : rat :=
                                match m with
                                | 0 => 0
                                | 1 => 1
                                | (_.+1 as i).+1 => 1%Q + loop i
                                end) n)%Q
                        end)%Q
                   end + rat_of_Z (BinNums.Zpos 1%AC))%Q)%Q)%Q)%Q)%Q)%Q *
             ((match Hab with
               | Posz n => iterop n addq 1 0
               | Negz n =>
                   (-
                    match n with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 => 1%Q + loop i
                            end) n)%Q
                    end)%Q
               end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q +
              match k_ with
              | Posz n => iterop n addq 1 0
              | Negz n =>
                  (-
                   match n with
                   | 0 => 1%Q
                   | _.+1 =>
                       (1%Q +
                        (fix loop (m : nat) : rat :=
                           match m with
                           | 0 => 0
                           | 1 => 1
                           | (_.+1 as i).+1 => 1%Q + loop i
                           end) n)%Q
                   end)%Q
              end)%Q)%Q *
            ((((((match Hab with
                  | Posz n => iterop n addq 1 0
                  | Negz n =>
                      (-
                       match n with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as i).+1 => 1%Q + loop i
                               end) n)%Q
                       end)%Q
                  end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q *
                 ((match Hab with
                   | Posz n => iterop n addq 1 0
                   | Negz n =>
                       (-
                        match n with
                        | 0 => 1%Q
                        | _.+1 =>
                            (1%Q +
                             (fix loop (m : nat) : rat :=
                                match m with
                                | 0 => 0
                                | 1 => 1
                                | (_.+1 as i).+1 => 1%Q + loop i
                                end) n)%Q
                        end)%Q
                   end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q *
                  (match Hab with
                   | Posz n => iterop n addq 1 0
                   | Negz n =>
                       (-
                        match n with
                        | 0 => 1%Q
                        | _.+1 =>
                            (1%Q +
                             (fix loop (m : nat) : rat :=
                                match m with
                                | 0 => 0
                                | 1 => 1
                                | (_.+1 as i).+1 => 1%Q + loop i
                                end) n)%Q
                        end)%Q
                   end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q)%Q)%Q *
                ((-
                  match Hab with
                  | Posz n => iterop n addq 1 0
                  | Negz n =>
                      (-
                       match n with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as i).+1 => 1%Q + loop i
                               end) n)%Q
                       end)%Q
                  end)%Q +
                 match k_ with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end)%Q)%Q *
               ((((-
                   match Hab with
                   | Posz n => iterop n addq 1 0
                   | Negz n =>
                       (-
                        match n with
                        | 0 => 1%Q
                        | _.+1 =>
                            (1%Q +
                             (fix loop (m : nat) : rat :=
                                match m with
                                | 0 => 0
                                | 1 => 1
                                | (_.+1 as i).+1 => 1%Q + loop i
                                end) n)%Q
                        end)%Q
                   end)%Q + (- rat_of_Z (BinNums.Zpos 1%AC))%Q)%Q +
                 match k_ with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end)%Q *
                (((-
                   match Hab with
                   | Posz n => iterop n addq 1 0
                   | Negz n =>
                       (-
                        match n with
                        | 0 => 1%Q
                        | _.+1 =>
                            (1%Q +
                             (fix loop (m : nat) : rat :=
                                match m with
                                | 0 => 0
                                | 1 => 1
                                | (_.+1 as i).+1 => 1%Q + loop i
                                end) n)%Q
                        end)%Q
                   end)%Q + (- rat_of_Z (BinNums.Zpos 1%AC))%Q)%Q +
                 match k_ with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end)%Q)%Q)%Q *
              (((match k_ with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end +
                 (-
                  match Hab with
                  | Posz n => iterop n addq 1 0
                  | Negz n =>
                      (-
                       match n with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as i).+1 => 1%Q + loop i
                               end) n)%Q
                       end)%Q
                  end)%Q)%Q + (- rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q)%Q *
               ((match k_ with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end +
                 (-
                  match Hab with
                  | Posz n => iterop n addq 1 0
                  | Negz n =>
                      (-
                       match n with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as i).+1 => 1%Q + loop i
                               end) n)%Q
                       end)%Q
                  end)%Q)%Q + (- rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q)%Q)%Q)%Q^-1)%Q)%Q *
           (((match binomialz Hab (intZmod.addz k_ 1) with
              | Posz n => iterop n addq 1 0
              | Negz n =>
                  (-
                   match n with
                   | 0 => 1%Q
                   | _.+1 =>
                       (1%Q +
                        (fix loop (m : nat) : rat :=
                           match m with
                           | 0 => 0
                           | 1 => 1
                           | (_.+1 as i).+1 => 1%Q + loop i
                           end) n)%Q
                   end)%Q
              end *
              match binomialz Hab (intZmod.addz k_ 1) with
              | Posz n => iterop n addq 1 0
              | Negz n =>
                  (-
                   match n with
                   | 0 => 1%Q
                   | _.+1 =>
                       (1%Q +
                        (fix loop (m : nat) : rat :=
                           match m with
                           | 0 => 0
                           | 1 => 1
                           | (_.+1 as i).+1 => 1%Q + loop i
                           end) n)%Q
                   end)%Q
              end)%Q *
             (match
                binomialz (intZmod.addz Hab (intZmod.addz k_ 1))
                  (intZmod.addz k_ 1)
              with
              | Posz n => iterop n addq 1 0
              | Negz n =>
                  (-
                   match n with
                   | 0 => 1%Q
                   | _.+1 =>
                       (1%Q +
                        (fix loop (m : nat) : rat :=
                           match m with
                           | 0 => 0
                           | 1 => 1
                           | (_.+1 as i).+1 => 1%Q + loop i
                           end) n)%Q
                   end)%Q
              end *
              match
                binomialz (intZmod.addz Hab (intZmod.addz k_ 1))
                  (intZmod.addz k_ 1)
              with
              | Posz n => iterop n addq 1 0
              | Negz n =>
                  (-
                   match n with
                   | 0 => 1%Q
                   | _.+1 =>
                       (1%Q +
                        (fix loop (m : nat) : rat :=
                           match m with
                           | 0 => 0
                           | 1 => 1
                           | (_.+1 as i).+1 => 1%Q + loop i
                           end) n)%Q
                   end)%Q
              end)%Q)%Q * (ghn3 Hab + s Hab (intZmod.addz k_ 1))%Q)%Q)%Q)%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching: (nat_to_funbool w2 (funbool_to_nat w2 H) H4 = H H4)
Crunching:
((fun i j : nat => if (i =? n) && (j =? 0) then C1 else 0%R) =
 f_to_vec len (nat_to_funbool len n))
Crunching:
((forall k : nat, length (Ha k) = (2 ^ IHf1)%nat) ->
 (forall k : nat, (k < length a)%nat -> distribution (Ha k)) ->
 snd IHf1 (sample (join a Ha) n) =
 sample (Ha (sample a n)) (compute_new_rnd n a (sample a n)))
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching:
((if true && true then C1 else 0%R) =
 f_to_vec len (list_to_funbool len (nat_to_binlist len x)) x y)
Crunching:
((fun i j : nat => if (i =? n) && (j =? 0) then C1 else 0%R) =
 f_to_vec len (nat_to_funbool len n))
Crunching: False
Crunching: False
Debug:
In environment
sR13, sR24 : int
defH : annotated_recs_v.precond.Sn2 sR13 sR24
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: v (int.shift 2 sR13) sR24; annotated_recs_v.Sn2_cf0_0 sR13 sR24;
         v sR13 sR24; annotated_recs_v.Sn2_cf1_0 sR13 sR24;
         v (int.shift 1 sR13) sR24; annotated_recs_v.Sn2_cf0_1 sR13 sR24;
         v sR13 (int.shift 1 sR24)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
Hab, H : int
hkn : annotated_recs_v.precond.Sn2 Hab H
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: v (int.shift 2 Hab) H; annotated_recs_v.Sn2_cf0_0 Hab H; 
        v Hab H; annotated_recs_v.Sn2_cf1_0 Hab H; 
        v (int.shift 1 Hab) H; annotated_recs_v.Sn2_cf0_1 Hab H;
         v Hab (int.shift 1 H)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
Hab, H : int
nz_a : annotated_recs_v.precond.Sn2 Hab H
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: v (int.shift 2 Hab) H; annotated_recs_v.Sn2_cf0_0 Hab H; 
        v Hab H; annotated_recs_v.Sn2_cf1_0 Hab H; 
        v (int.shift 1 Hab) H; annotated_recs_v.Sn2_cf0_1 Hab H;
         v Hab (int.shift 1 H)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
Hab, n_gt0 : int
l : annotated_recs_v.precond.Sn2 Hab n_gt0
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l0 : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l0 =
     [:: (((match binomialz (intZmod.addz (intZmod.addz Hab 1) 1) n_gt0 with
            | Posz n => iterop n addq 1 0
            | Negz n =>
                (-
                 match n with
                 | 0 => 1%Q
                 | _.+1 =>
                     (1%Q +
                      (fix loop (m : nat) : rat :=
                         match m with
                         | 0 => 0
                         | 1 => 1
                         | (_.+1 as i).+1 => 1%Q + loop i
                         end) n)%Q
                 end)%Q
            end *
            match binomialz (intZmod.addz (intZmod.addz Hab 1) 1) n_gt0 with
            | Posz n => iterop n addq 1 0
            | Negz n =>
                (-
                 match n with
                 | 0 => 1%Q
                 | _.+1 =>
                     (1%Q +
                      (fix loop (m : nat) : rat :=
                         match m with
                         | 0 => 0
                         | 1 => 1
                         | (_.+1 as i).+1 => 1%Q + loop i
                         end) n)%Q
                 end)%Q
            end)%Q *
           (match
              binomialz
                (intZmod.addz (intZmod.addz (intZmod.addz Hab 1) 1) n_gt0)
                n_gt0
            with
            | Posz n => iterop n addq 1 0
            | Negz n =>
                (-
                 match n with
                 | 0 => 1%Q
                 | _.+1 =>
                     (1%Q +
                      (fix loop (m : nat) : rat :=
                         match m with
                         | 0 => 0
                         | 1 => 1
                         | (_.+1 as i).+1 => 1%Q + loop i
                         end) n)%Q
                 end)%Q
            end *
            match
              binomialz
                (intZmod.addz (intZmod.addz (intZmod.addz Hab 1) 1) n_gt0)
                n_gt0
            with
            | Posz n => iterop n addq 1 0
            | Negz n =>
                (-
                 match n with
                 | 0 => 1%Q
                 | _.+1 =>
                     (1%Q +
                      (fix loop (m : nat) : rat :=
                         match m with
                         | 0 => 0
                         | 1 => 1
                         | (_.+1 as i).+1 => 1%Q + loop i
                         end) n)%Q
                 end)%Q
            end)%Q)%Q *
          (ghn3 (intZmod.addz (intZmod.addz Hab 1) 1) +
           s (intZmod.addz (intZmod.addz Hab 1) 1) n_gt0)%Q)%Q;
         ((((((((- rat_of_Z (BinNums.Zpos 1%AC))%Q *
                ((match Hab with
                  | Posz n => iterop n addq 1 0
                  | Negz n =>
                      (-
                       match n with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as i).+1 => 1%Q + loop i
                               end) n)%Q
                       end)%Q
                  end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q +
                 match n_gt0 with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end)%Q)%Q *
               (((((((((((((rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)) +
                            (rat_of_Z (BinNums.Zpos (...)) *
                             (match ... with
                              | ... ...
                              | ... ...%Q
                              end * match ... with
                                    | ... ...
                                    | ... ...%Q
                                    end)%Q)%Q)%Q +
                           (((- rat_of_Z (...))%Q *
                             match n_gt0 with
                             | Posz n => iterop n addq 1 0
                             | Negz n => (- ...)%Q
                             end)%Q *
                            match Hab with
                            | Posz n => iterop n addq 1 0
                            | Negz n =>
                                (- match ... with
                                   | ... 1%Q
                                   | ... ...%Q
                                   end)%Q
                            end)%Q)%Q +
                          (rat_of_Z
                             (BinNums.Zpos (BinNums.xO (BinNums.xI 1%AC))) *
                           (match n_gt0 with
                            | Posz n => iterop n addq 1 0
                            | Negz n =>
                                (- match ... with
                                   | ... 1%Q
                                   | ... ...%Q
                                   end)%Q
                            end *
                            match n_gt0 with
                            | Posz n => iterop n addq 1 0
                            | Negz n =>
                                (- match ... with
                                   | ... 1%Q
                                   | ... ...%Q
                                   end)%Q
                            end)%Q)%Q)%Q +
                         (match Hab with
                          | Posz n => iterop n addq 1 0
                          | Negz n =>
                              (-
                               match n with
                               | 0 => 1%Q
                               | _.+1 => (1%Q + (...) n)%Q
                               end)%Q
                          end *
                          (match Hab with
                           | Posz n => iterop n addq 1 0
                           | Negz n =>
                               (-
                                match n with
                                | 0 => 1%Q
                                | _.+1 => (1%Q + ...)%Q
                                end)%Q
                           end *
                           (match Hab with
                            | Posz n => iterop n addq 1 0
                            | Negz n =>
                                (- match ... with
                                   | ... 1%Q
                                   | ... ...%Q
                                   end)%Q
                            end *
                            match Hab with
                            | Posz n => iterop n addq 1 0
                            | Negz n =>
                                (- match ... with
                                   | ... 1%Q
                                   | ... ...%Q
                                   end)%Q
                            end)%Q)%Q)%Q)%Q +
                        (rat_of_Z
                           (BinNums.Zpos (BinNums.xI (BinNums.xO 1%AC))) *
                         (match Hab with
                          | Posz n => iterop n addq 1 0
                          | Negz n =>
                              (-
                               match n with
                               | 0 => 1%Q
                               | _.+1 => (1%Q + (...) n)%Q
                               end)%Q
                          end *
                          (match Hab with
                           | Posz n => iterop n addq 1 0
                           | Negz n =>
                               (-
                                match n with
                                | 0 => 1%Q
                                | _.+1 => (1%Q + ...)%Q
                                end)%Q
                           end *
                           match Hab with
                           | Posz n => iterop n addq 1 0
                           | Negz n =>
                               (-
                                match n with
                                | 0 => 1%Q
                                | _.+1 => (1%Q + ...)%Q
                                end)%Q
                           end)%Q)%Q)%Q)%Q +
                       (rat_of_Z
                          (BinNums.Zpos (BinNums.xO (BinNums.xI 1%AC))) *
                        (match n_gt0 with
                         | Posz n => iterop n addq 1 0
                         | Negz n =>
                             (-
                              match n with
                              | 0 => 1%Q
                              | _.+1 =>
                                  (1%Q +
                                   (fix loop ... : rat := ...
                                                 ...
                                                 ...
                                                 ...
                                                 end) n)%Q
                              end)%Q
                         end *
                         (match n_gt0 with
                          | Posz n => iterop n addq 1 0
                          | Negz n =>
                              (-
                               match n with
                               | 0 => 1%Q
                               | _.+1 => (1%Q + (...) n)%Q
                               end)%Q
                          end *
                          match n_gt0 with
                          | Posz n => iterop n addq 1 0
                          | Negz n =>
                              (-
                               match n with
                               | 0 => 1%Q
                               | _.+1 => (1%Q + (...) n)%Q
                               end)%Q
                          end)%Q)%Q)%Q)%Q +
                      (match n_gt0 with
                       | Posz n => iterop n addq 1 0
                       | Negz n =>
                           (-
                            match n with
                            | 0 => 1%Q
                            | _.+1 =>
                                (1%Q +
                                 (fix loop (m : nat) : rat :=
                                    match m with
                                    | 0 => 0
                                    | 1 => 1
                                    | (_.+1 as i).+1 => 1%Q + loop i
                                    end) n)%Q
                            end)%Q
                       end *
                       (match Hab with
                        | Posz n => iterop n addq 1 0
                        | Negz n =>
                            (-
                             match n with
                             | 0 => 1%Q
                             | _.+1 =>
                                 (1%Q +
                                  (fix loop (m : nat) : rat :=
                                     match ... with
                                     | ... => 0
                                     | ... => 1
                                     | ... => 1%Q + ...
                                     end) n)%Q
                             end)%Q
                        end *
                        (match Hab with
                         | Posz n => iterop n addq 1 0
                         | Negz n =>
                             (-
                              match n with
                              | 0 => 1%Q
                              | _.+1 =>
                                  (1%Q +
                                   (fix loop ... : rat := ...
                                                 ...
                                                 ...
                                                 ...
                                                 end) n)%Q
                              end)%Q
                         end *
                         match Hab with
                         | Posz n => iterop n addq 1 0
                         | Negz n =>
                             (-
                              match n with
                              | 0 => 1%Q
                              | _.+1 =>
                                  (1%Q +
                                   (fix loop ... : rat := ...
                                                 ...
                                                 ...
                                                 ...
                                                 end) n)%Q
                              end)%Q
                         end)%Q)%Q)%Q)%Q +
                     ((-
                       match n_gt0 with
                       | Posz n => iterop n addq 1 0
                       | Negz n =>
                           (-
                            match n with
                            | 0 => 1%Q
                            | _.+1 =>
                                (1%Q +
                                 (fix loop (m : nat) : rat :=
                                    match m with
                                    | 0 => 0
                                    | 1 => 1
                                    | (_.+1 as i).+1 => 1%Q + loop i
                                    end) n)%Q
                            end)%Q
                       end)%Q *
                      (match Hab with
                       | Posz n => iterop n addq 1 0
                       | Negz n =>
                           (-
                            match n with
                            | 0 => 1%Q
                            | _.+1 =>
                                (1%Q +
                                 (fix loop (m : nat) : rat :=
                                    match m with
                                    | 0 => 0
                                    | 1 => 1
                                    | (_.+1 as i).+1 => 1%Q + loop i
                                    end) n)%Q
                            end)%Q
                       end *
                       match Hab with
                       | Posz n => iterop n addq 1 0
                       | Negz n =>
                           (-
                            match n with
                            | 0 => 1%Q
                            | _.+1 =>
                                (1%Q +
                                 (fix loop (m : nat) : rat :=
                                    match m with
                                    | 0 => 0
                                    | 1 => 1
                                    | (_.+1 as i).+1 => 1%Q + loop i
                                    end) n)%Q
                            end)%Q
                       end)%Q)%Q)%Q +
                    (((-
                       rat_of_Z (BinNums.Zpos (BinNums.xO (BinNums.xO 1%AC))))%Q *
                      (match n_gt0 with
                       | Posz n => iterop n addq 1 0
                       | Negz n =>
                           (-
                            match n with
                            | 0 => 1%Q
                            | _.+1 =>
                                (1%Q +
                                 (fix loop (m : nat) : rat :=
                                    match m with
                                    | 0 => 0
                                    | 1 => 1
                                    | (_.+1 as i).+1 => 1%Q + loop i
                                    end) n)%Q
                            end)%Q
                       end *
                       match n_gt0 with
                       | Posz n => iterop n addq 1 0
                       | Negz n =>
                           (-
                            match n with
                            | 0 => 1%Q
                            | _.+1 =>
                                (1%Q +
                                 (fix loop (m : nat) : rat :=
                                    match m with
                                    | 0 => 0
                                    | 1 => 1
                                    | (_.+1 as i).+1 => 1%Q + loop i
                                    end) n)%Q
                            end)%Q
                       end)%Q)%Q *
                     (match Hab with
                      | Posz n => iterop n addq 1 0
                      | Negz n =>
                          (-
                           match n with
                           | 0 => 1%Q
                           | _.+1 =>
                               (1%Q +
                                (fix loop (m : nat) : rat :=
                                   match m with
                                   | 0 => 0
                                   | 1 => 1
                                   | (_.+1 as i).+1 => 1%Q + loop i
                                   end) n)%Q
                           end)%Q
                      end *
                      match Hab with
                      | Posz n => iterop n addq 1 0
                      | Negz n =>
                          (-
                           match n with
                           | 0 => 1%Q
                           | _.+1 =>
                               (1%Q +
                                (fix loop (m : nat) : rat :=
                                   match m with
                                   | 0 => 0
                                   | 1 => 1
                                   | (_.+1 as i).+1 => 1%Q + loop i
                                   end) n)%Q
                           end)%Q
                      end)%Q)%Q)%Q +
                   (((- rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q *
                     (match n_gt0 with
                      | Posz n => iterop n addq 1 0
                      | Negz n =>
                          (-
                           match n with
                           | 0 => 1%Q
                           | _.+1 =>
                               (1%Q +
                                (fix loop (m : nat) : rat :=
                                   match m with
                                   | 0 => 0
                                   | 1 => 1
                                   | (_.+1 as i).+1 => 1%Q + loop i
                                   end) n)%Q
                           end)%Q
                      end *
                      match n_gt0 with
                      | Posz n => iterop n addq 1 0
                      | Negz n =>
                          (-
                           match n with
                           | 0 => 1%Q
                           | _.+1 =>
                               (1%Q +
                                (fix loop (m : nat) : rat :=
                                   match m with
                                   | 0 => 0
                                   | 1 => 1
                                   | (_.+1 as i).+1 => 1%Q + loop i
                                   end) n)%Q
                           end)%Q
                      end)%Q)%Q *
                    match Hab with
                    | Posz n => iterop n addq 1 0
                    | Negz n =>
                        (-
                         match n with
                         | 0 => 1%Q
                         | _.+1 =>
                             (1%Q +
                              (fix loop (m : nat) : rat :=
                                 match m with
                                 | 0 => 0
                                 | 1 => 1
                                 | (_.+1 as i).+1 => 1%Q + loop i
                                 end) n)%Q
                         end)%Q
                    end)%Q)%Q +
                  ((rat_of_Z (BinNums.Zpos (BinNums.xO (BinNums.xO 1%AC))) *
                    (match n_gt0 with
                     | Posz n => iterop n addq 1 0
                     | Negz n =>
                         (-
                          match n with
                          | 0 => 1%Q
                          | _.+1 =>
                              (1%Q +
                               (fix loop (m : nat) : rat :=
                                  match m with
                                  | 0 => 0
                                  | 1 => 1
                                  | (_.+1 as i).+1 => 1%Q + loop i
                                  end) n)%Q
                          end)%Q
                     end *
                     (match n_gt0 with
                      | Posz n => iterop n addq 1 0
                      | Negz n =>
                          (-
                           match n with
                           | 0 => 1%Q
                           | _.+1 =>
                               (1%Q +
                                (fix loop (m : nat) : rat :=
                                   match m with
                                   | 0 => 0
                                   | 1 => 1
                                   | (_.+1 as i).+1 => 1%Q + loop i
                                   end) n)%Q
                           end)%Q
                      end *
                      match n_gt0 with
                      | Posz n => iterop n addq 1 0
                      | Negz n =>
                          (-
                           match n with
                           | 0 => 1%Q
                           | _.+1 =>
                               (1%Q +
                                (fix loop (m : nat) : rat :=
                                   match m with
                                   | 0 => 0
                                   | 1 => 1
                                   | (_.+1 as i).+1 => 1%Q + loop i
                                   end) n)%Q
                           end)%Q
                      end)%Q)%Q)%Q *
                   match Hab with
                   | Posz n => iterop n addq 1 0
                   | Negz n =>
                       (-
                        match n with
                        | 0 => 1%Q
                        | _.+1 =>
                            (1%Q +
                             (fix loop (m : nat) : rat :=
                                match m with
                                | 0 => 0
                                | 1 => 1
                                | (_.+1 as i).+1 => 1%Q + loop i
                                end) n)%Q
                        end)%Q
                   end)%Q)%Q +
                 match n_gt0 with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end)%Q +
                (rat_of_Z (BinNums.Zpos (BinNums.xI (BinNums.xI 1%AC))) *
                 match Hab with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end)%Q)%Q)%Q *
              (((match Hab with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end + rat_of_Z (BinNums.Zpos 1%AC))%Q +
                match n_gt0 with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 => 1%Q + loop i
                             end) n)%Q
                     end)%Q
                end)%Q *
               ((match Hab with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end + rat_of_Z (BinNums.Zpos 1%AC))%Q +
                match n_gt0 with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 => 1%Q + loop i
                             end) n)%Q
                     end)%Q
                end)%Q)%Q)%Q *
             (((((match Hab with
                  | Posz n => iterop n addq 1 0
                  | Negz n =>
                      (-
                       match n with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as i).+1 => 1%Q + loop i
                               end) n)%Q
                       end)%Q
                  end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q *
                 ((match Hab with
                   | Posz n => iterop n addq 1 0
                   | Negz n =>
                       (-
                        match n with
                        | 0 => 1%Q
                        | _.+1 =>
                            (1%Q +
                             (fix loop (m : nat) : rat :=
                                match m with
                                | 0 => 0
                                | 1 => 1
                                | (_.+1 as i).+1 => 1%Q + loop i
                                end) n)%Q
                        end)%Q
                   end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q *
                  (match Hab with
                   | Posz n => iterop n addq 1 0
                   | Negz n =>
                       (-
                        match n with
                        | 0 => 1%Q
                        | _.+1 =>
                            (1%Q +
                             (fix loop (m : nat) : rat :=
                                match m with
                                | 0 => 0
                                | 1 => 1
                                | (_.+1 as i).+1 => 1%Q + loop i
                                end) n)%Q
                        end)%Q
                   end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q)%Q)%Q *
                ((((-
                    match Hab with
                    | Posz n => iterop n addq 1 0
                    | Negz n =>
                        (-
                         match n with
                         | 0 => 1%Q
                         | _.+1 =>
                             (1%Q +
                              (fix loop (m : nat) : rat :=
                                 match m with
                                 | 0 => 0
                                 | 1 => 1
                                 | (_.+1 as i).+1 => 1%Q + loop i
                                 end) n)%Q
                         end)%Q
                    end)%Q + (- rat_of_Z (BinNums.Zpos 1%AC))%Q)%Q +
                  match n_gt0 with
                  | Posz n => iterop n addq 1 0
                  | Negz n =>
                      (-
                       match n with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as i).+1 => 1%Q + loop i
                               end) n)%Q
                       end)%Q
                  end)%Q *
                 (((-
                    match Hab with
                    | Posz n => iterop n addq 1 0
                    | Negz n =>
                        (-
                         match n with
                         | 0 => 1%Q
                         | _.+1 =>
                             (1%Q +
                              (fix loop (m : nat) : rat :=
                                 match m with
                                 | 0 => 0
                                 | 1 => 1
                                 | (_.+1 as i).+1 => 1%Q + loop i
                                 end) n)%Q
                         end)%Q
                    end)%Q + (- rat_of_Z (BinNums.Zpos 1%AC))%Q)%Q +
                  match n_gt0 with
                  | Posz n => iterop n addq 1 0
                  | Negz n =>
                      (-
                       match n with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as i).+1 => 1%Q + loop i
                               end) n)%Q
                       end)%Q
                  end)%Q)%Q)%Q *
               (((match n_gt0 with
                  | Posz n => iterop n addq 1 0
                  | Negz n =>
                      (-
                       match n with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as i).+1 => 1%Q + loop i
                               end) n)%Q
                       end)%Q
                  end +
                  (-
                   match Hab with
                   | Posz n => iterop n addq 1 0
                   | Negz n =>
                       (-
                        match n with
                        | 0 => 1%Q
                        | _.+1 =>
                            (1%Q +
                             (fix loop (m : nat) : rat :=
                                match m with
                                | 0 => 0
                                | 1 => 1
                                | (_.+1 as i).+1 => 1%Q + loop i
                                end) n)%Q
                        end)%Q
                   end)%Q)%Q +
                 (- rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q)%Q *
                ((match n_gt0 with
                  | Posz n => iterop n addq 1 0
                  | Negz n =>
                      (-
                       match n with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as i).+1 => 1%Q + loop i
                               end) n)%Q
                       end)%Q
                  end +
                  (-
                   match Hab with
                   | Posz n => iterop n addq 1 0
                   | Negz n =>
                       (-
                        match n with
                        | 0 => 1%Q
                        | _.+1 =>
                            (1%Q +
                             (fix loop (m : nat) : rat :=
                                match m with
                                | 0 => 0
                                | 1 => 1
                                | (_.+1 as i).+1 => 1%Q + loop i
                                end) n)%Q
                        end)%Q
                   end)%Q)%Q +
                 (- rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q)%Q)%Q)%Q^-1)%Q)%Q *
            (((match binomialz Hab n_gt0 with
               | Posz n => iterop n addq 1 0
               | Negz n =>
                   (-
                    match n with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 => 1%Q + loop i
                            end) n)%Q
                    end)%Q
               end *
               match binomialz Hab n_gt0 with
               | Posz n => iterop n addq 1 0
               | Negz n =>
                   (-
                    match n with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 => 1%Q + loop i
                            end) n)%Q
                    end)%Q
               end)%Q *
              (match binomialz (intZmod.addz Hab n_gt0) n_gt0 with
               | Posz n => iterop n addq 1 0
               | Negz n =>
                   (-
                    match n with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 => 1%Q + loop i
                            end) n)%Q
                    end)%Q
               end *
               match binomialz (intZmod.addz Hab n_gt0) n_gt0 with
               | Posz n => iterop n addq 1 0
               | Negz n =>
                   (-
                    match n with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 => 1%Q + loop i
                            end) n)%Q
                    end)%Q
               end)%Q)%Q * (ghn3 Hab + s Hab n_gt0)%Q)%Q)%Q +
           ((((((rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)) *
                 match Hab with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end)%Q + rat_of_Z (BinNums.Zpos (BinNums.xI 1%AC)))%Q *
               (((match Hab with
                  | Posz n => iterop n addq 1 0
                  | Negz n =>
                      (-
                       match n with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as i).+1 => 1%Q + loop i
                               end) n)%Q
                       end)%Q
                  end *
                  match Hab with
                  | Posz n => iterop n addq 1 0
                  | Negz n =>
                      (-
                       match n with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as i).+1 => 1%Q + loop i
                               end) n)%Q
                       end)%Q
                  end)%Q +
                 (rat_of_Z (BinNums.Zpos (BinNums.xI 1%AC)) *
                  match Hab with
                  | Posz n => iterop n addq 1 0
                  | Negz n =>
                      (-
                       match n with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as i).+1 => 1%Q + loop i
                               end) n)%Q
                       end)%Q
                  end)%Q)%Q + rat_of_Z (BinNums.Zpos (BinNums.xI 1%AC)))%Q)%Q *
              (((match Hab with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q +
                match n_gt0 with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 => 1%Q + loop i
                             end) n)%Q
                     end)%Q
                end)%Q *
               ((match Hab with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q +
                match n_gt0 with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 => 1%Q + loop i
                             end) n)%Q
                     end)%Q
                end)%Q)%Q)%Q *
             ((((match Hab with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q *
                ((match Hab with
                  | Posz n => iterop n addq 1 0
                  | Negz n =>
                      (-
                       match n with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as i).+1 => 1%Q + loop i
                               end) n)%Q
                       end)%Q
                  end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q *
                 (match Hab with
                  | Posz n => iterop n addq 1 0
                  | Negz n =>
                      (-
                       match n with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as i).+1 => 1%Q + loop i
                               end) n)%Q
                       end)%Q
                  end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q)%Q)%Q *
               (((match n_gt0 with
                  | Posz n => iterop n addq 1 0
                  | Negz n =>
                      (-
                       match n with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as i).+1 => 1%Q + loop i
                               end) n)%Q
                       end)%Q
                  end +
                  (-
                   match Hab with
                   | Posz n => iterop n addq 1 0
                   | Negz n =>
                       (-
                        match n with
                        | 0 => 1%Q
                        | _.+1 =>
                            (1%Q +
                             (fix loop (m : nat) : rat :=
                                match m with
                                | 0 => 0
                                | 1 => 1
                                | (_.+1 as i).+1 => 1%Q + loop i
                                end) n)%Q
                        end)%Q
                   end)%Q)%Q +
                 (- rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q)%Q *
                ((match n_gt0 with
                  | Posz n => iterop n addq 1 0
                  | Negz n =>
                      (-
                       match n with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as i).+1 => 1%Q + loop i
                               end) n)%Q
                       end)%Q
                  end +
                  (-
                   match Hab with
                   | Posz n => iterop n addq 1 0
                   | Negz n =>
                       (-
                        match n with
                        | 0 => 1%Q
                        | _.+1 =>
                            (1%Q +
                             (fix loop (m : nat) : rat :=
                                match m with
                                | 0 => 0
                                | 1 => 1
                                | (_.+1 as i).+1 => 1%Q + loop i
                                end) n)%Q
                        end)%Q
                   end)%Q)%Q +
                 (- rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q)%Q)%Q)%Q^-1)%Q)%Q *
            (((match binomialz (intZmod.addz Hab 1) n_gt0 with
               | Posz n => iterop n addq 1 0
               | Negz n =>
                   (-
                    match n with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 => 1%Q + loop i
                            end) n)%Q
                    end)%Q
               end *
               match binomialz (intZmod.addz Hab 1) n_gt0 with
               | Posz n => iterop n addq 1 0
               | Negz n =>
                   (-
                    match n with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 => 1%Q + loop i
                            end) n)%Q
                    end)%Q
               end)%Q *
              (match
                 binomialz (intZmod.addz (intZmod.addz Hab 1) n_gt0) n_gt0
               with
               | Posz n => iterop n addq 1 0
               | Negz n =>
                   (-
                    match n with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 => 1%Q + loop i
                            end) n)%Q
                    end)%Q
               end *
               match
                 binomialz (intZmod.addz (intZmod.addz Hab 1) n_gt0) n_gt0
               with
               | Posz n => iterop n addq 1 0
               | Negz n =>
                   (-
                    match n with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 => 1%Q + loop i
                            end) n)%Q
                    end)%Q
               end)%Q)%Q *
             (ghn3 (intZmod.addz Hab 1) + s (intZmod.addz Hab 1) n_gt0)%Q)%Q)%Q)%Q +
          ((((((rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)) *
                match n_gt0 with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 => 1%Q + loop i
                             end) n)%Q
                     end)%Q
                end)%Q *
               ((rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)) *
                 match Hab with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end)%Q + rat_of_Z (BinNums.Zpos (BinNums.xI 1%AC)))%Q)%Q *
              ((match n_gt0 with
                | Posz n => iterop n addq 1 0
                | Negz n =>
                    (-
                     match n with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 => 1%Q + loop i
                             end) n)%Q
                     end)%Q
                end + rat_of_Z (BinNums.Zpos 1%AC))%Q *
               ((match n_gt0 with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end + rat_of_Z (BinNums.Zpos 1%AC))%Q *
                ((match n_gt0 with
                  | Posz n => iterop n addq 1 0
                  | Negz n =>
                      (-
                       match n with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as i).+1 => 1%Q + loop i
                               end) n)%Q
                       end)%Q
                  end + rat_of_Z (BinNums.Zpos 1%AC))%Q *
                 ((match n_gt0 with
                   | Posz n => iterop n addq 1 0
                   | Negz n =>
                       (-
                        match n with
                        | 0 => 1%Q
                        | _.+1 =>
                            (1%Q +
                             (fix loop (m : nat) : rat :=
                                match m with
                                | 0 => 0
                                | 1 => 1
                                | (_.+1 as i).+1 => 1%Q + loop i
                                end) n)%Q
                        end)%Q
                   end + rat_of_Z (BinNums.Zpos 1%AC))%Q *
                  (match n_gt0 with
                   | Posz n => iterop n addq 1 0
                   | Negz n =>
                       (-
                        match n with
                        | 0 => 1%Q
                        | _.+1 =>
                            (1%Q +
                             (fix loop (m : nat) : rat :=
                                match m with
                                | 0 => 0
                                | 1 => 1
                                | (_.+1 as i).+1 => 1%Q + loop i
                                end) n)%Q
                        end)%Q
                   end + rat_of_Z (BinNums.Zpos 1%AC))%Q)%Q)%Q)%Q)%Q)%Q *
             ((match Hab with
               | Posz n => iterop n addq 1 0
               | Negz n =>
                   (-
                    match n with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 => 1%Q + loop i
                            end) n)%Q
                    end)%Q
               end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q +
              match n_gt0 with
              | Posz n => iterop n addq 1 0
              | Negz n =>
                  (-
                   match n with
                   | 0 => 1%Q
                   | _.+1 =>
                       (1%Q +
                        (fix loop (m : nat) : rat :=
                           match m with
                           | 0 => 0
                           | 1 => 1
                           | (_.+1 as i).+1 => 1%Q + loop i
                           end) n)%Q
                   end)%Q
              end)%Q)%Q *
            ((((((match Hab with
                  | Posz n => iterop n addq 1 0
                  | Negz n =>
                      (-
                       match n with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as i).+1 => 1%Q + loop i
                               end) n)%Q
                       end)%Q
                  end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q *
                 ((match Hab with
                   | Posz n => iterop n addq 1 0
                   | Negz n =>
                       (-
                        match n with
                        | 0 => 1%Q
                        | _.+1 =>
                            (1%Q +
                             (fix loop (m : nat) : rat :=
                                match m with
                                | 0 => 0
                                | 1 => 1
                                | (_.+1 as i).+1 => 1%Q + loop i
                                end) n)%Q
                        end)%Q
                   end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q *
                  (match Hab with
                   | Posz n => iterop n addq 1 0
                   | Negz n =>
                       (-
                        match n with
                        | 0 => 1%Q
                        | _.+1 =>
                            (1%Q +
                             (fix loop (m : nat) : rat :=
                                match m with
                                | 0 => 0
                                | 1 => 1
                                | (_.+1 as i).+1 => 1%Q + loop i
                                end) n)%Q
                        end)%Q
                   end + rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q)%Q)%Q *
                ((-
                  match Hab with
                  | Posz n => iterop n addq 1 0
                  | Negz n =>
                      (-
                       match n with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as i).+1 => 1%Q + loop i
                               end) n)%Q
                       end)%Q
                  end)%Q +
                 match n_gt0 with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end)%Q)%Q *
               ((((-
                   match Hab with
                   | Posz n => iterop n addq 1 0
                   | Negz n =>
                       (-
                        match n with
                        | 0 => 1%Q
                        | _.+1 =>
                            (1%Q +
                             (fix loop (m : nat) : rat :=
                                match m with
                                | 0 => 0
                                | 1 => 1
                                | (_.+1 as i).+1 => 1%Q + loop i
                                end) n)%Q
                        end)%Q
                   end)%Q + (- rat_of_Z (BinNums.Zpos 1%AC))%Q)%Q +
                 match n_gt0 with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end)%Q *
                (((-
                   match Hab with
                   | Posz n => iterop n addq 1 0
                   | Negz n =>
                       (-
                        match n with
                        | 0 => 1%Q
                        | _.+1 =>
                            (1%Q +
                             (fix loop (m : nat) : rat :=
                                match m with
                                | 0 => 0
                                | 1 => 1
                                | (_.+1 as i).+1 => 1%Q + loop i
                                end) n)%Q
                        end)%Q
                   end)%Q + (- rat_of_Z (BinNums.Zpos 1%AC))%Q)%Q +
                 match n_gt0 with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end)%Q)%Q)%Q *
              (((match n_gt0 with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end +
                 (-
                  match Hab with
                  | Posz n => iterop n addq 1 0
                  | Negz n =>
                      (-
                       match n with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as i).+1 => 1%Q + loop i
                               end) n)%Q
                       end)%Q
                  end)%Q)%Q + (- rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q)%Q *
               ((match n_gt0 with
                 | Posz n => iterop n addq 1 0
                 | Negz n =>
                     (-
                      match n with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) n)%Q
                      end)%Q
                 end +
                 (-
                  match Hab with
                  | Posz n => iterop n addq 1 0
                  | Negz n =>
                      (-
                       match n with
                       | 0 => 1%Q
                       | _.+1 =>
                           (1%Q +
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as i).+1 => 1%Q + loop i
                               end) n)%Q
                       end)%Q
                  end)%Q)%Q + (- rat_of_Z (BinNums.Zpos (BinNums.xO 1%AC)))%Q)%Q)%Q)%Q^-1)%Q)%Q *
           (((match binomialz Hab (intZmod.addz n_gt0 1) with
              | Posz n => iterop n addq 1 0
              | Negz n =>
                  (-
                   match n with
                   | 0 => 1%Q
                   | _.+1 =>
                       (1%Q +
                        (fix loop (m : nat) : rat :=
                           match m with
                           | 0 => 0
                           | 1 => 1
                           | (_.+1 as i).+1 => 1%Q + loop i
                           end) n)%Q
                   end)%Q
              end *
              match binomialz Hab (intZmod.addz n_gt0 1) with
              | Posz n => iterop n addq 1 0
              | Negz n =>
                  (-
                   match n with
                   | 0 => 1%Q
                   | _.+1 =>
                       (1%Q +
                        (fix loop (m : nat) : rat :=
                           match m with
                           | 0 => 0
                           | 1 => 1
                           | (_.+1 as i).+1 => 1%Q + loop i
                           end) n)%Q
                   end)%Q
              end)%Q *
             (match
                binomialz (intZmod.addz Hab (intZmod.addz n_gt0 1))
                  (intZmod.addz n_gt0 1)
              with
              | Posz n => iterop n addq 1 0
              | Negz n =>
                  (-
                   match n with
                   | 0 => 1%Q
                   | _.+1 =>
                       (1%Q +
                        (fix loop (m : nat) : rat :=
                           match m with
                           | 0 => 0
                           | 1 => 1
                           | (_.+1 as i).+1 => 1%Q + loop i
                           end) n)%Q
                   end)%Q
              end *
              match
                binomialz (intZmod.addz Hab (intZmod.addz n_gt0 1))
                  (intZmod.addz n_gt0 1)
              with
              | Posz n => iterop n addq 1 0
              | Negz n =>
                  (-
                   match n with
                   | 0 => 1%Q
                   | _.+1 =>
                       (1%Q +
                        (fix loop (m : nat) : rat :=
                           match m with
                           | 0 => 0
                           | 1 => 1
                           | (_.+1 as i).+1 => 1%Q + loop i
                           end) n)%Q
                   end)%Q
              end)%Q)%Q * (ghn3 Hab + s Hab (intZmod.addz n_gt0 1))%Q)%Q)%Q)%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
env, f : int
H2 : 0 <= f
H3 : f < env
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: c (int.shift 1 env) (int.shift 1 f);
         annotated_recs_s.SnSk_cf0_0 env f; u env f; 
        u (int.shift 1 env) f; annotated_recs_s.SnSk_cf0_1 env f;
         u env (int.shift 1 f); annotated_recs_v.SnSk_cf0_0 env f; 
        c env f; annotated_recs_v.SnSk_cf1_0 env f; 
        c (int.shift 1 env) f; annotated_recs_v.SnSk_cf0_1 env f;
         c env (int.shift 1 f)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching:
((if true && true then C1 else 0%R) =
 f_to_vec len (list_to_funbool len (nat_to_binlist len x)) x y)
Crunching:
((if true && true then C1 else 0%R) =
 f_to_vec len (list_to_funbool len (nat_to_binlist len x)) x y)
Crunching:
((if true && true then C1 else 0%R) =
 f_to_vec len (list_to_funbool len (nat_to_binlist len x)) x y)
Crunching: (forall x y z : R, y <= z - x -> x + y <= z)
Crunching:
(forall (rnd : R) (m : nat),
 0 <= rnd < sum_over_list X_enc ->
 Forall (fun x : R => 0 <= x) X_enc ->
 (forall k : nat, length (Hyp k) = (2 ^ m)%nat) ->
 (forall k : nat, (k < length X_enc)%nat -> distribution (Hyp k)) ->
 sample (join X_enc Hyp) rnd mod 2 ^ m =
 sample (Hyp (sample X_enc rnd))
   (compute_new_rnd rnd X_enc (sample X_enc rnd)))
Debug:
In environment
env, f : int
H2 : 0 <= f
H3 : f < env
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: c (int.shift 1 env) (int.shift 1 f);
         annotated_recs_s.SnSk_cf0_0 env f; u env f; 
        u (int.shift 1 env) f; annotated_recs_s.SnSk_cf0_1 env f;
         u env (int.shift 1 f); annotated_recs_v.SnSk_cf0_0 env f; 
        c env f; annotated_recs_v.SnSk_cf1_0 env f; 
        c (int.shift 1 env) f; annotated_recs_v.SnSk_cf0_1 env f;
         c env (int.shift 1 f)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Crunching:
(WF_Matrix WF ->
 (forall f : nat -> bool, q' × f_to_vec q f = WF × f_to_vec q f) -> q' = WF)
Crunching:
(f_to_vec n (update f 0 b) ⊗ ∣ update f 0 b n ⟩ = f_to_vec n f ⊗ ∣ f n ⟩)
Crunching:
(f_to_vec n (update f 0 b) ⊗ ∣ update f 0 b n ⟩ = f_to_vec n f ⊗ ∣ f n ⟩)
Crunching:
(0 < 0 ->
 (fix Ffix
    (x : Type) (x0 : Monoid x) (x1 : nat -> x) (x2 : nat) {struct x2} : x :=
    match x2 with
    | 0%nat => match x0 with
               | {| Gzero := Gzero |} => Gzero
               end
    | S x3 =>
        match x0 with
        | {| Gplus := Gplus |} => Gplus
        end (Ffix x x0 x1 x3) (x1 x3)
    end) R
   {|
     Gzero := R0;
     Gplus := Rplus;
     Gplus_0_l :=
       fun g : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEc (RMicromega.CZ 0)) (EnvRing.PEX 1);
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs := EnvRing.PEX 1
            |} ()) [] eq_refl (fun _ : positive => g);
     Gplus_0_r :=
       fun g : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEc (RMicromega.CZ 0));
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs := EnvRing.PEX 1
            |} ()) [] eq_refl (fun _ : positive => g);
     Gplus_assoc :=
       fun g h i : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEX 1)
                  (EnvRing.PEadd (EnvRing.PEX 2) (EnvRing.PEX 3));
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs :=
                EnvRing.PEadd (EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEX 2))
                  (EnvRing.PEX 3)
            |} ()) [] eq_refl
         (fun x : positive =>
          match x with
          | (_~1)%positive => i
          | (_~0)%positive => h
          | 1%positive => g
          end)
   |}
   (fun x2 : nat =>
    if x1 x2
    then
     (fix Ffix (x : nat) (x0 : list R) (x1 : R) {struct x0} : R :=
        match x with
        | 0%nat => match x0 with
                   | [] => x1
                   | x3 :: _ => x3
                   end
        | S x3 => match x0 with
                  | [] => x1
                  | _ :: x5 => Ffix x3 x5 x1
                  end
        end) x2
       ((fix Ffix (x : R) (x0 : list R) {struct x0} : list R :=
           match x0 with
           | [] => []
           | x1 :: x3 => (x * x1)%R :: Ffix x x3
           end) x x0) R0
    else R0)
   ((fix Ffix (x : list R) : nat :=
       match x with
       | [] => 0%nat
       | _ :: x1 => S (Ffix x1)
       end)
      ((fix Ffix (x : R) (x0 : list R) {struct x0} : list R :=
          match x0 with
          | [] => []
          | x1 :: x2 => (x * x1)%R :: Ffix x x2
          end) x x0)) =
 (x *
  (fix Ffix
     (x : Type) (x0 : Monoid x) (x1 : nat -> x) (x2 : nat) {struct x2} : x :=
     match x2 with
     | 0%nat => match x0 with
                | {| Gzero := Gzero |} => Gzero
                end
     | S x3 =>
         match x0 with
         | {| Gplus := Gplus |} => Gplus
         end (Ffix x x0 x1 x3) (x1 x3)
     end) R
    {|
      Gzero := R0;
      Gplus := Rplus;
      Gplus_0_l :=
        fun g : R =>
        RMicromega.RTautoChecker_sound
          (Tauto.A Tauto.isProp
             {|
               RingMicromega.Flhs :=
                 EnvRing.PEadd (EnvRing.PEc (RMicromega.CZ 0))
                   (EnvRing.PEX 1);
               RingMicromega.Fop := RingMicromega.OpEq;
               RingMicromega.Frhs := EnvRing.PEX 1
             |} ()) [] eq_refl (fun _ : positive => g);
      Gplus_0_r :=
        fun g : R =>
        RMicromega.RTautoChecker_sound
          (Tauto.A Tauto.isProp
             {|
               RingMicromega.Flhs :=
                 EnvRing.PEadd (EnvRing.PEX 1)
                   (EnvRing.PEc (RMicromega.CZ 0));
               RingMicromega.Fop := RingMicromega.OpEq;
               RingMicromega.Frhs := EnvRing.PEX 1
             |} ()) [] eq_refl (fun _ : positive => g);
      Gplus_assoc :=
        fun g h i : R =>
        RMicromega.RTautoChecker_sound
          (Tauto.A Tauto.isProp
             {|
               RingMicromega.Flhs :=
                 EnvRing.PEadd (EnvRing.PEX 1)
                   (EnvRing.PEadd (EnvRing.PEX 2) (EnvRing.PEX 3));
               RingMicromega.Fop := RingMicromega.OpEq;
               RingMicromega.Frhs :=
                 EnvRing.PEadd
                   (EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEX 2))
                   (EnvRing.PEX 3)
             |} ()) [] eq_refl
          (fun x : positive =>
           match x with
           | (_~1)%positive => i
           | (_~0)%positive => h
           | 1%positive => g
           end)
    |}
    (fun x : nat =>
     if x1 x
     then
      (fix Ffix (x0 : nat) (x1 : list R) (x2 : R) {struct x1} : R :=
         match x0 with
         | 0%nat => match x1 with
                    | [] => x2
                    | x3 :: _ => x3
                    end
         | S x3 => match x1 with
                   | [] => x2
                   | _ :: x5 => Ffix x3 x5 x2
                   end
         end) x x0 R0
     else R0)
    ((fix Ffix (x : list R) : nat :=
        match x with
        | [] => 0%nat
        | _ :: x1 => S (Ffix x1)
        end) x0))%R)
Crunching:
(f_to_vec n (update f 0 b) ⊗ ∣ update f 0 b n ⟩ = f_to_vec n f ⊗ ∣ f n ⟩)
Crunching:
(0 < 2 -> forall b : bool, H <= y -> f_to_vec H (update x y b) = f_to_vec H x)
Crunching:
(0 < 2 -> forall b : bool, H <= y -> f_to_vec H (update x y b) = f_to_vec H x)
Crunching:
(0 < 2 -> forall b : bool, H <= y -> f_to_vec H (update x y b) = f_to_vec H x)
Crunching:
(0 < 2 -> forall b : bool, H <= y -> f_to_vec H (update x y b) = f_to_vec H x)
Crunching: (f_to_vec H (update f H true) = f_to_vec H f)
Crunching: (f_to_vec H (update f H true) = f_to_vec H f)
Crunching: Z
Crunching:
(0 < 0 ->
 (fix Ffix
    (x : Type) (x0 : Monoid x) (x1 : nat -> x) (x2 : nat) {struct x2} : x :=
    match x2 with
    | 0%nat => match x0 with
               | {| Gzero := Gzero |} => Gzero
               end
    | S x3 =>
        match x0 with
        | {| Gplus := Gplus |} => Gplus
        end (Ffix x x0 x1 x3) (x1 x3)
    end) R
   {|
     Gzero := R0;
     Gplus := Rplus;
     Gplus_0_l :=
       fun g : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEc (RMicromega.CZ 0)) (EnvRing.PEX 1);
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs := EnvRing.PEX 1
            |} ()) [] eq_refl (fun _ : positive => g);
     Gplus_0_r :=
       fun g : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEc (RMicromega.CZ 0));
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs := EnvRing.PEX 1
            |} ()) [] eq_refl (fun _ : positive => g);
     Gplus_assoc :=
       fun g h i : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEX 1)
                  (EnvRing.PEadd (EnvRing.PEX 2) (EnvRing.PEX 3));
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs :=
                EnvRing.PEadd (EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEX 2))
                  (EnvRing.PEX 3)
            |} ()) [] eq_refl
         (fun x : positive =>
          match x with
          | (_~1)%positive => i
          | (_~0)%positive => h
          | 1%positive => g
          end)
   |}
   (fun x2 : nat =>
    if x1 x2
    then
     (fix Ffix (x : nat) (x0 : list R) (x1 : R) {struct x0} : R :=
        match x with
        | 0%nat => match x0 with
                   | [] => x1
                   | x3 :: _ => x3
                   end
        | S x3 => match x0 with
                  | [] => x1
                  | _ :: x5 => Ffix x3 x5 x1
                  end
        end) x2
       ((fix Ffix (x : R) (x0 : list R) {struct x0} : list R :=
           match x0 with
           | [] => []
           | x1 :: x3 => (x * x1)%R :: Ffix x x3
           end) x x0) R0
    else R0)
   ((fix Ffix (x : list R) : nat :=
       match x with
       | [] => 0%nat
       | _ :: x1 => S (Ffix x1)
       end)
      ((fix Ffix (x : R) (x0 : list R) {struct x0} : list R :=
          match x0 with
          | [] => []
          | x1 :: x2 => (x * x1)%R :: Ffix x x2
          end) x x0)) =
 (x *
  (fix Ffix
     (x : Type) (x0 : Monoid x) (x1 : nat -> x) (x2 : nat) {struct x2} : x :=
     match x2 with
     | 0%nat => match x0 with
                | {| Gzero := Gzero |} => Gzero
                end
     | S x3 =>
         match x0 with
         | {| Gplus := Gplus |} => Gplus
         end (Ffix x x0 x1 x3) (x1 x3)
     end) R
    {|
      Gzero := R0;
      Gplus := Rplus;
      Gplus_0_l :=
        fun g : R =>
        RMicromega.RTautoChecker_sound
          (Tauto.A Tauto.isProp
             {|
               RingMicromega.Flhs :=
                 EnvRing.PEadd (EnvRing.PEc (RMicromega.CZ 0))
                   (EnvRing.PEX 1);
               RingMicromega.Fop := RingMicromega.OpEq;
               RingMicromega.Frhs := EnvRing.PEX 1
             |} ()) [] eq_refl (fun _ : positive => g);
      Gplus_0_r :=
        fun g : R =>
        RMicromega.RTautoChecker_sound
          (Tauto.A Tauto.isProp
             {|
               RingMicromega.Flhs :=
                 EnvRing.PEadd (EnvRing.PEX 1)
                   (EnvRing.PEc (RMicromega.CZ 0));
               RingMicromega.Fop := RingMicromega.OpEq;
               RingMicromega.Frhs := EnvRing.PEX 1
             |} ()) [] eq_refl (fun _ : positive => g);
      Gplus_assoc :=
        fun g h i : R =>
        RMicromega.RTautoChecker_sound
          (Tauto.A Tauto.isProp
             {|
               RingMicromega.Flhs :=
                 EnvRing.PEadd (EnvRing.PEX 1)
                   (EnvRing.PEadd (EnvRing.PEX 2) (EnvRing.PEX 3));
               RingMicromega.Fop := RingMicromega.OpEq;
               RingMicromega.Frhs :=
                 EnvRing.PEadd
                   (EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEX 2))
                   (EnvRing.PEX 3)
             |} ()) [] eq_refl
          (fun x : positive =>
           match x with
           | (_~1)%positive => i
           | (_~0)%positive => h
           | 1%positive => g
           end)
    |}
    (fun x : nat =>
     if x1 x
     then
      (fix Ffix (x0 : nat) (x1 : list R) (x2 : R) {struct x1} : R :=
         match x0 with
         | 0%nat => match x1 with
                    | [] => x2
                    | x3 :: _ => x3
                    end
         | S x3 => match x1 with
                   | [] => x2
                   | _ :: x5 => Ffix x3 x5 x2
                   end
         end) x x0 R0
     else R0)
    ((fix Ffix (x : list R) : nat :=
        match x with
        | [] => 0%nat
        | _ :: x1 => S (Ffix x1)
        end) x0))%R)
Crunching:
(f_to_vec ReprFunChoice (update D' H4 x) ⊗ ∣ update D' H4 x ReprFunChoice ⟩ =
 f_to_vec ReprFunChoice D' ⊗ ∣ D' ReprFunChoice ⟩)
Crunching:
(f_to_vec ReprFunChoice (update D' H4 x) ⊗ ∣ update D' H4 x ReprFunChoice ⟩ =
 f_to_vec ReprFunChoice D' ⊗ ∣ D' ReprFunChoice ⟩)
Crunching:
(forall x : nat -> bool,
 (fix Ffix
    (x0 : Type) (x1 : Monoid x0) (x2 : nat -> x0) (x3 : nat) {struct x3} :
      x0 :=
    match x3 with
    | 0%nat => match x1 with
               | {| Gzero := Gzero |} => Gzero
               end
    | S x4 =>
        match x1 with
        | {| Gplus := Gplus |} => Gplus
        end (Ffix x0 x1 x2 x4) (x2 x4)
    end) R
   {|
     Gzero := R0;
     Gplus := Rplus;
     Gplus_0_l :=
       fun g : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEc (RMicromega.CZ 0)) (EnvRing.PEX 1);
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs := EnvRing.PEX 1
            |} ()) [] eq_refl (fun _ : positive => g);
     Gplus_0_r :=
       fun g : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEc (RMicromega.CZ 0));
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs := EnvRing.PEX 1
            |} ()) [] eq_refl (fun _ : positive => g);
     Gplus_assoc :=
       fun g h i : R =>
       RMicromega.RTautoChecker_sound
         (Tauto.A Tauto.isProp
            {|
              RingMicromega.Flhs :=
                EnvRing.PEadd (EnvRing.PEX 1)
                  (EnvRing.PEadd (EnvRing.PEX 2) (EnvRing.PEX 3));
              RingMicromega.Fop := RingMicromega.OpEq;
              RingMicromega.Frhs :=
                EnvRing.PEadd (EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEX 2))
                  (EnvRing.PEX 3)
            |} ()) [] eq_refl
         (fun x0 : positive =>
          match x0 with
          | (_~1)%positive => i
          | (_~0)%positive => h
          | 1%positive => g
          end)
   |}
   (fun x0 : nat =>
    if x x0
    then
     (fix Ffix (x1 : nat) (x2 : list R) (x3 : R) {struct x2} : R :=
        match x1 with
        | 0%nat => match x2 with
                   | [] => x3
                   | x4 :: _ => x4
                   end
        | S x4 => match x2 with
                  | [] => x3
                  | _ :: x6 => Ffix x4 x6 x3
                  end
        end) x0
       ((fix Ffix (x1 : R) (x2 : list R) {struct x2} : list R :=
           match x2 with
           | [] => []
           | x3 :: x4 => (x1 * x3)%R :: Ffix x1 x4
           end) Hnin l2) R0
    else R0)
   ((fix Ffix (x0 : list R) : nat :=
       match x0 with
       | [] => 0%nat
       | _ :: x2 => S (Ffix x2)
       end)
      ((fix Ffix (x0 : R) (x1 : list R) {struct x1} : list R :=
          match x1 with
          | [] => []
          | x2 :: x3 => (x0 * x2)%R :: Ffix x0 x3
          end) Hnin l2)) =
 (Hnin *
  (fix Ffix
     (x0 : Type) (x1 : Monoid x0) (x2 : nat -> x0) (x3 : nat) {struct x3} :
       x0 :=
     match x3 with
     | 0%nat => match x1 with
                | {| Gzero := Gzero |} => Gzero
                end
     | S x4 =>
         match x1 with
         | {| Gplus := Gplus |} => Gplus
         end (Ffix x0 x1 x2 x4) (x2 x4)
     end) R
    {|
      Gzero := R0;
      Gplus := Rplus;
      Gplus_0_l :=
        fun g : R =>
        RMicromega.RTautoChecker_sound
          (Tauto.A Tauto.isProp
             {|
               RingMicromega.Flhs :=
                 EnvRing.PEadd (EnvRing.PEc (RMicromega.CZ 0))
                   (EnvRing.PEX 1);
               RingMicromega.Fop := RingMicromega.OpEq;
               RingMicromega.Frhs := EnvRing.PEX 1
             |} ()) [] eq_refl (fun _ : positive => g);
      Gplus_0_r :=
        fun g : R =>
        RMicromega.RTautoChecker_sound
          (Tauto.A Tauto.isProp
             {|
               RingMicromega.Flhs :=
                 EnvRing.PEadd (EnvRing.PEX 1)
                   (EnvRing.PEc (RMicromega.CZ 0));
               RingMicromega.Fop := RingMicromega.OpEq;
               RingMicromega.Frhs := EnvRing.PEX 1
             |} ()) [] eq_refl (fun _ : positive => g);
      Gplus_assoc :=
        fun g h i : R =>
        RMicromega.RTautoChecker_sound
          (Tauto.A Tauto.isProp
             {|
               RingMicromega.Flhs :=
                 EnvRing.PEadd (EnvRing.PEX 1)
                   (EnvRing.PEadd (EnvRing.PEX 2) (EnvRing.PEX 3));
               RingMicromega.Fop := RingMicromega.OpEq;
               RingMicromega.Frhs :=
                 EnvRing.PEadd
                   (EnvRing.PEadd (EnvRing.PEX 1) (EnvRing.PEX 2))
                   (EnvRing.PEX 3)
             |} ()) [] eq_refl
          (fun x0 : positive =>
           match x0 with
           | (_~1)%positive => i
           | (_~0)%positive => h
           | 1%positive => g
           end)
    |}
    (fun x0 : nat =>
     if x x0
     then
      (fix Ffix (x1 : nat) (x2 : list R) (x3 : R) {struct x2} : R :=
         match x1 with
         | 0%nat => match x2 with
                    | [] => x3
                    | x4 :: _ => x4
                    end
         | S x4 => match x2 with
                   | [] => x3
                   | _ :: x6 => Ffix x4 x6 x3
                   end
         end) x0 l2 R0
     else R0)
    ((fix Ffix (x0 : list R) : nat :=
        match x0 with
        | [] => 0%nat
        | _ :: x2 => S (Ffix x2)
        end) l2))%R)
Crunching:
(S H2 <= H4 ->
 f_to_vec H2 (update D' H4 x) ⊗ ∣ update D' H4 x H2 ⟩ =
 f_to_vec H2 D' ⊗ ∣ D' H2 ⟩)
"paths has been translated as pathsᵗ"
Crunching:
((forall k : nat, (k < n)%nat -> length (q k) = Hm) ->
 length (join' H q n) = (n * Hm)%nat)
"idpath has been translated as idpathᵗ"
Crunching: (f_to_vec r (shift (update f i b) j) = f_to_vec r (shift f j))
Crunching: (f_to_vec r (shift (update f i b) j) = f_to_vec r (shift f j))
Crunching: (f_to_vec r (shift (update f i b) j) = f_to_vec r (shift f j))
Crunching: (f_to_vec r (shift (update f i b) j) = f_to_vec r (shift f j))
Crunching: (f_to_vec r (shift (update f i b) j) = f_to_vec r (shift f j))
"paths_ind has been translated as paths_indᵗ"
"transport has been translated as transportᵗ"
"sigT has been translated as sigTᵗ"
"projT1 has been translated as projT1ᵗ"
"projT2 has been translated as projT2ᵗ"
"existT has been translated as existTᵗ"
Crunching:
((forall k : nat, (k < n)%nat -> length (q k) = Hm) ->
 length (join' H q n) = (n * Hm)%nat)
Crunching: (a < p * c -> a * / p < c)
Crunching: (forall a b c : R, 0 < b -> a < b * c -> a * / b < c)
Crunching:
((forall k : nat, (k < n)%nat -> length (q k) = Eq2) ->
 length (join' H q n) = (n * Eq2)%nat)
Crunching:
((forall k : nat, (k < n)%nat -> length (q k) = Eq2) ->
 length (join' H q n) = (n * Eq2)%nat)
Crunching: (f_to_vec r (shift (update f i b) j) = f_to_vec r (shift f j))
Crunching: (- (PI / 2) <= pr_outcome_sum (firstn 1 H') l <= PI / 2)
Crunching:
(f_to_vec H1 p1 ⊗ f_to_vec l p2 =
 f_to_vec (H1 + l) (fun x : nat => if x <? H1 then p1 x else p2 (x - H1)))
Crunching:
(f_to_vec 0 p1 ⊗ f_to_vec l p2 =
 f_to_vec (0 + l) (fun x : nat => if x <? 0 then p1 x else p2 (x - 0)))
Crunching:
((Ha < length Hb)%nat ->
 pr_outcome_sum (firstn (S Ha) Hb) LT =
 ((if LT Ha then nth Ha Hb 0 else 0) + pr_outcome_sum (firstn Ha Hb) LT)%R)
Crunching:
(f_to_vec p n ⊗ f_to_vec 0 m =
 f_to_vec (p + 0) (fun x : nat => if x <? p then n x else m (x - p)))
Crunching:
(f_to_vec p n ⊗ f_to_vec 0 m =
 f_to_vec (p + 0) (fun x : nat => if x <? p then n x else m (x - p)))
Crunching:
((Ha < length Hb)%nat ->
 pr_outcome_sum (firstn (S Ha) Hb) LT =
 ((if LT Ha then nth Ha Hb 0 else 0) + pr_outcome_sum (firstn Ha Hb) LT)%R)
Crunching:
(f_to_vec p n ⊗ f_to_vec 0 m =
 f_to_vec (p + 0) (fun x : nat => if x <? p then n x else m (x - p)))
"isequiv has been translated as isequivᵗ"
"equiv has been translated as equivᵗ"
"eq has been translated as eqᵗ"
"inverse has been translated as inverseᵗ"
"contr has been translated as contrᵗ"
"weakFunext has been translated as weakFunextᵗ"
Crunching: (- (PI / 2) <= pr_outcome_sum (firstn (S n) H7) env <= PI / 2)
Crunching:
(f_to_vec p n ⊗ f_to_vec n0 m =
 f_to_vec (p + n0) (fun x : nat => if x <? p then n x else m (x - p)))
Crunching:
(0 < 0 ->
 (2 * pr_outcome_sum (firstn 1 H7) env)%R =
 (2 *
  ((if env 0%nat then nth 0 H7 0 else 0) + pr_outcome_sum (firstn 0 H7) env))%R)
Crunching:
(0 < 0 ->
 (2 * pr_outcome_sum (firstn 1 H7) env)%R =
 (2 *
  ((if env 0%nat then nth 0 H7 0 else 0) + pr_outcome_sum (firstn 0 H7) env))%R)
Crunching:
(0 < 0 ->
 (2 * pr_outcome_sum (firstn 1 H7) env)%R =
 (2 *
  ((if env 0%nat then nth 0 H7 0 else 0) + pr_outcome_sum (firstn 0 H7) env))%R)
Crunching: (- (PI / 2) <= pr_outcome_sum (firstn 1 H') l <= PI / 2)
Crunching:
(pr_outcome_sum (firstn 1 H') H = (0 + pr_outcome_sum (firstn 0 H') H)%R)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (pad_u n i σx × f_to_vec n f = f_to_vec n (update f i (¬ f i)))
Crunching:
(pr_outcome_sum (apply_u u) (fun x : nat => f (fst k x)) =
 big_sum
   (fun x : nat =>
    ((if f x then 1 else 0) *
     prob_partial_meas (basis_vector (2 ^ P') x)
       (u × basis_vector (2 ^ (P' + k)) 0))%R) (2 ^ P'))
Crunching:
(forall (k : nat) (u : Square (2 ^ (P' + k))) (f : nat -> bool),
 WF_Matrix u ->
 pr_outcome_sum (apply_u u) (fun x : nat => f (fst k x)) =
 big_sum
   (fun x : nat =>
    ((if f x then 1 else 0) *
     prob_partial_meas (basis_vector (2 ^ P') x)
       (u × basis_vector (2 ^ (P' + k)) 0))%R) (2 ^ P'))
Crunching: (pad_u n m σx × f_to_vec n H3 = f_to_vec n (update H3 m (¬ H3 m)))
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (pad_u n i σx × f_to_vec n f = f_to_vec n (update f i (¬ f i)))
Crunching:
(Forall (fun r : R => 0 <= r < 1) x0 ->
 (forall r : R, 0 <= r < 1 -> x0_encad r = y_encad1 r) ->
 iterate x0 x0_encad = iterate x0 y_encad1)
Crunching:
(Forall (fun r : R => 0 <= r < 1) x0 ->
 (forall r : R, 0 <= r < 1 -> x0_encad r = H3 r) ->
 iterate x0 x0_encad = iterate x0 H3)
Crunching: (pad_u n i σx × f_to_vec n f = f_to_vec n (update f i (¬ f i)))
Crunching:
(forall (Ps2 : list R -> Prop) (r : R),
 (forall rnds : list R,
  Forall (fun r0 : R => 0 <= r0 < 1) rnds -> Hcase rnds <-> Ps2 rnds) ->
 pr_Ps Hcase n r -> pr_Ps Ps2 n r)
Crunching: (pr_Ps Ps2 He r)
Crunching:
(forall r : R,
 (forall rnds : list R,
  Forall (fun r0 : R => 0 <= r0 < 1) rnds -> Hbeq rnds <-> l' rnds) ->
 pr_Ps Hbeq He r -> pr_Ps l' He r)
Crunching:
((forall rnds : list R,
  Forall (fun r : R => 0 <= r < 1) rnds -> Ha rnds <-> xy rnds) ->
 pr_Ps Ha H3 yz -> pr_Ps xy H3 yz)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (∣0⟩ = basis_vector 2 0)
"Ty has been translated as Tyᵗ"
Tyᵗ : El Tyᵗ
     : El Tyᵗ
Crunching:
((forall rnds : list R,
  Forall (fun r : R => 0 <= r < 1) rnds -> Hcase rnds <-> z' rnds) ->
 pr_Ps Hcase n x_pos -> pr_Ps z' n x_pos)
Crunching:
(forall (Ps2 : list R -> Prop) (r : R),
 (forall rnds : list R,
  Forall (fun r0 : R => 0 <= r0 < 1) rnds -> Hcase rnds <-> Ps2 rnds) ->
 pr_Ps Hcase n r -> pr_Ps Ps2 n r)
Crunching: (pr_Ps Ps2 He r)
Crunching: (pr_Ps Ps2 He r)
Crunching:
(forall r : R,
 (forall rnds : list R,
  Forall (fun r0 : R => 0 <= r0 < 1) rnds -> Hbeq rnds <-> l' rnds) ->
 pr_Ps Hbeq He r -> pr_Ps l' He r)
Crunching: (pad_u X i σx × f_to_vec X H8 = f_to_vec X (update H8 i (¬ H8 i)))
"sigT has been translated as sigTᵗ"
Crunching: (pr_Ps H1 0 1)
Crunching:
((forall z : R, cond_positivity z = false <-> z < 0) -> pr_Ps H1 He a)
Crunching: (pad_u n m σx × f_to_vec n H3 = f_to_vec n (update H3 m (¬ H3 m)))
Crunching: (pad_u n 0 σx × f_to_vec n H3 = f_to_vec n (update H3 0 (¬ H3 0)))
Crunching:
(forall r : R,
 (forall rnds : list R,
  Forall (fun r0 : R => 0 <= r0 < 1) rnds -> alp rnds <-> H2 rnds) ->
 pr_Ps alp H3 r -> pr_Ps H2 H3 r)
Crunching:
((forall rnds : list R,
  Forall (fun r : R => 0 <= r < 1) rnds -> Ha rnds <-> xy rnds) ->
 pr_Ps Ha H3 yz -> pr_Ps xy H3 yz)
Crunching:
(pad_ctrl Hyp' i j σx × f_to_vec Hyp' f =
 f_to_vec Hyp' (update f j (f j ⊕ f i)))
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching:
(pad_ctrl n i j σx × f_to_vec n f = f_to_vec n (update f j (f j ⊕ f i)))
Crunching:
(pad_ctrl n i j σx × f_to_vec n f = f_to_vec n (update f j (f j ⊕ f i)))
Crunching: Type
Crunching:
(Hsep < x ->
 0 <> Hsep ->
 pad_ctrl x 0 Hsep σx × f_to_vec x delta2 =
 f_to_vec x (update delta2 Hsep (delta2 Hsep ⊕ delta2 0)))
Crunching:
(forall a b : R, a < 0 -> √ (a + b) < √ a + √ b \/ √ (a + b) = (√ a + √ b)%R)
Crunching:
(Hsep < x ->
 S y <> Hsep ->
 pad_ctrl x (S y) Hsep σx × f_to_vec x H =
 f_to_vec x (update H Hsep (true ⊕ true)))
Crunching: (m [])
Crunching:
(Hsep < x ->
 S y <> Hsep ->
 pad_ctrl x (S y) Hsep σx × f_to_vec x H =
 f_to_vec x (update H Hsep (H Hsep ⊕ H (S y))))
Crunching: (forall (Ps : list R -> Prop) (r : R), pr_Ps Ps v r -> Ps [])
Crunching: (forall (Ps : list R -> Prop) (r : R), pr_Ps Ps v r -> Ps [])
Crunching: (x0 - x1 <= y0)
Crunching: (√ (n + b) < √ n + √ b \/ √ (n + b) = (√ n + √ b)%R)
"existT has been translated as existTᵗ"
Finished transaction in 0.326 secs (0.265u,0.06s) (successful)
Crunching:
(forall b : R, n < 0 -> √ (n + b) < √ n + √ b \/ √ (n + b) = (√ n + √ b)%R)
Crunching:
(H < S q ->
 q <> H ->
 pad_ctrl (S q) q H σx × f_to_vec (S q) f =
 f_to_vec (S q) (update f H (f H ⊕ f q)))
Crunching:
(forall a b : R, a < 0 -> √ (a + b) < √ a + √ b \/ √ (a + b) = (√ a + √ b)%R)
Crunching:
(pad_ctrl Hyp' i j σx × f_to_vec Hyp' f =
 f_to_vec Hyp' (update f j (f j ⊕ f i)))
Crunching: (m [])
Crunching: (m [])
Crunching: (m [])
Crunching: False
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching:
(forall y : nat,
 H3 >= 2 ^ H + (2 ^ H + 0) \/ y >= 1 ->
 (pad_swap (S H) H j × (f_to_vec H f ⊗ ∣ f H ⟩)) H3 y = 0%R)
Crunching: False
Crunching: False
Crunching: False
Crunching: False
Crunching: False
Crunching: False
Crunching: False
Crunching: False
Crunching: False
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (p = n)
Crunching:
(forall (j : nat) (f : nat -> bool),
 H10 < alp_f2t2 ->
 j < alp_f2t2 ->
 H10 <> j ->
 pad_swap alp_f2t2 H10 j × f_to_vec alp_f2t2 f =
 f_to_vec alp_f2t2 (fswap f H10 j))
"sigT_ind has been translated as sigT_indᵗ"
Crunching: (~ 0 < 0)
"paths has been translated as pathsᵗ"
Crunching: (forall a b : R, a < 0 -> √ (a + b) <= √ a + √ b)
Crunching: (forall a b : R, a < 0 -> √ (a + b) <= √ a + √ b)
Crunching: (forall a b : R, a < 0 -> √ (a + b) <= √ a + √ b)
Crunching:
(a <> b -> pad_swap LE a b × f_to_vec LE n = f_to_vec LE (fswap n a b))
Crunching: (forall a b : R, a < 0 -> √ (a + b) <= √ a + √ b)
Crunching: (forall a b : R, a < 0 -> √ (a + b) <= √ a + √ b)
Coq.Init.Datatypes.nat has been translated.
Coq.Init.Datatypes.list has been translated.
listᵗ : forall A : TYPE, list A.1 -> Type
     : forall A : TYPE, list A.1 -> Type
nilᵗ : forall A : TYPE, listᵗ A []
     : forall A : TYPE, listᵗ A []
consᵗ
:
forall (A : TYPE) (x : El A) (lH : ∃ l : list A.1, listᵗ A l),
listᵗ A (x.1 :: lH.1)
     : forall (A : TYPE) (x : El A) (lH : ∃ l : list A.1, listᵗ A l),
       listᵗ A (x.1 :: lH.1)
Crunching: (forall a b : R, a < 0 -> √ (a + b) <= √ a + √ b)
Crunching: (forall a b : R, a < 0 -> √ (a + b) <= √ a + √ b)
Crunching: (forall a b : R, a < 0 -> √ (a + b) <= √ a + √ b)
Crunching:
(forall (n i : nat) (θ : R) (f : nat -> bool),
 i < n ->
 pad_u n i (phase_shift θ) × f_to_vec n f = Cexp (f i * θ) .* f_to_vec n f)
Crunching: (forall a b : R, a < 0 -> √ (a + b) <= √ a + √ b)
Crunching: (forall a b : R, a < 0 -> √ (a + b) <= √ a + √ b)
Crunching:
(n < a ->
 pad_u a n (phase_shift θ) × f_to_vec a H = Cexp (H n * θ) .* f_to_vec a H)
Crunching:
(n < a ->
 pad_u a n (phase_shift del2) × f_to_vec a H0 =
 Cexp (H0 n * del2) .* f_to_vec a H0)
Crunching:
(n < a ->
 pad_u a n (phase_shift x) × f_to_vec a x_cond =
 Cexp (x_cond n * x) .* f_to_vec a x_cond)
Crunching:
(0 < a ->
 pad_u a 0 (phase_shift x) × f_to_vec a x_cond =
 Cexp (x_cond 0 * x) .* f_to_vec a x_cond)
Crunching:
(0 < a ->
 pad_u a 0 (phase_shift x) × f_to_vec a x_cond =
 Cexp
   (Rabst
      (ConstructiveCauchyRealsMult.CReal_mult (Rrepr (x_cond 0)) (Rrepr x)))
 .* f_to_vec a x_cond)
Crunching:
((pad_u (S n) n (phase_shift Hyp_eq) × (f_to_vec n f ⊗ ∣ f n ⟩)) i 0 =
 (Cexp (f n * Hyp_eq) .* (f_to_vec n f ⊗ ∣ f n ⟩)) i 0)
Crunching:
(pad_u 0 0 (phase_shift Hyp_eq) × f_to_vec 0 f =
 Cexp (f 0 * Hyp_eq) .* f_to_vec 0 f)
Crunching:
(Cexp (f 0 * Hyp_eq) .* f_to_vec 0 f =
 pad_u 0 0 (phase_shift Hyp_eq) × f_to_vec 0 f)
Crunching:
(n < a ->
 pad_u a n (phase_shift Hyp_eq) × f_to_vec a H' =
 (cos (H' n * Hyp_eq), sin (H' n * Hyp_eq)) .* f_to_vec a H')
Crunching:
(n < a ->
 pad_u a n (phase_shift p) × f_to_vec a a1 = Cexp (a1 n * p) .* f_to_vec a a1)
Crunching:
(0 < a ->
 pad_u a 0 (phase_shift p) × f_to_vec a a1 = Cexp (a1 0 * p) .* f_to_vec a a1)
Crunching:
(b < a ->
 pad_u a b (phase_shift Hb) × f_to_vec a H0 =
 Cexp (H0 b * Hb) .* f_to_vec a H0)
Crunching:
(pr_P (fun rnd : R => isNone (l rnd) = true) t ->
 pr_Ps (fun rnds : list R => isNone (iterate rnds l) = true) p (t ^ p))
Crunching:
(pad_u x xdz hadamard × f_to_vec x a0 =
 / √ 2
 .* (f_to_vec x (update a0 xdz false)
     .+ Cexp (a0 xdz * PI) .* f_to_vec x (update a0 xdz true)))
Crunching:
(pad_u x xdz hadamard × f_to_vec x htemp =
 / √ 2
 .* (f_to_vec x (update htemp xdz false)
     .+ Cexp (htemp xdz * PI) .* f_to_vec x (update htemp xdz true)))
Crunching:
(pad_u H1 i hadamard × f_to_vec H1 f =
 / √ 2
 .* (f_to_vec H1 (update f i false)
     .+ (cos (f i * PI), sin (f i * PI)) .* f_to_vec H1 (update f i true)))
Crunching:
(pad_u H1 i hadamard × f_to_vec H1 f =
 / √ 2
 .* (f_to_vec H1 (update f i false)
     .+ (cos (f i * PI), sin (f i * PI)) .* f_to_vec H1 (update f i true)))
Crunching:
((fun r : R =>
  0%nat <> 2%nat ->
  pad_u H1 i hadamard × f_to_vec H1 f =
  / √ r
  .* (f_to_vec H1 (update f i false)
      .+ Cexp (f i * PI) .* f_to_vec H1 (update f i true))) 2)
Crunching:
(pad_u H1 i hadamard × f_to_vec H1 f =
 / √ 2
 .* (f_to_vec H1 (update f i false)
     .+ (cos (f i * PI), sin (f i * PI)) .* f_to_vec H1 (update f i true)))
Crunching:
(pad_u H1 i hadamard × f_to_vec H1 f =
 / √ 2
 .* (f_to_vec H1 (update f i false)
     .+ (cos (f i * PI), sin (f i * PI)) .* f_to_vec H1 (update f i true)))
Crunching:
((fun r : R =>
  0%nat <> 2%nat ->
  pad_u H1 i hadamard × f_to_vec H1 f =
  / √ r
  .* (f_to_vec H1 (update f i false)
      .+ Cexp (f i * PI) .* f_to_vec H1 (update f i true))) 2)
Crunching:
(pad_u H1 a hadamard × f_to_vec H1 b =
 / √ 2
 .* (f_to_vec H1 (update b a false)
     .+ Cexp (b a * PI) .* f_to_vec H1 (update b a true)))
"idpath has been translated as idpathᵗ"
Crunching: (x <= y + z)
Crunching: (x <= y + z)
Crunching:
((z1 < H1)%nat ->
 pad_u H1 z1 hadamard × f_to_vec H1 z2 =
 / √ 2
 .* (f_to_vec H1 (update z2 z1 false)
     .+ Cexp (z2 z1 * PI) .* f_to_vec H1 (update z2 z1 true)))
Coq.Init.Datatypes.nat has been translated.
Coq.Init.Datatypes.bool has been translated.
Coq.Init.Datatypes.list has been translated.
"HD has been translated as HDᵗ"
"MAP has been translated as MAPᵗ"
Crunching:
(pad_u x xdz hadamard × f_to_vec x a0 =
 / √ 2
 .* (f_to_vec x (update a0 xdz false)
     .+ Cexp (a0 xdz * PI) .* f_to_vec x (update a0 xdz true)))
Crunching:
(pad_u x xdz hadamard × f_to_vec x htemp =
 / √ 2
 .* (f_to_vec x (update htemp xdz false)
     .+ Cexp (htemp xdz * PI) .* f_to_vec x (update htemp xdz true)))
Crunching:
(pad_u x xdz hadamard × f_to_vec x N0 =
 / √ 2
 .* (f_to_vec x (update N0 xdz false)
     .+ Cexp (N0 xdz * PI) .* f_to_vec x (update N0 xdz true)))
Crunching:
(~ 0 < 0 ->
 forall (i : nat) (f : nat -> bool),
 (i < abs)%nat ->
 pad_u abs i hadamard × f_to_vec abs f =
 / √ 2
 .* (f_to_vec abs (update f i false)
     .+ Cexp (f i * PI) .* f_to_vec abs (update f i true)))
Crunching:
((fun _ : Set =>
  (0 < h)%nat ->
  pad_u h 0 hadamard × f_to_vec h H2 =
  / √ 2
  .* (f_to_vec h (update H2 0 false)
      .+ Cexp (H2 0%nat * PI) .* f_to_vec h (update H2 0 true))) N)
Crunching:
(pad_u H1 i hadamard × f_to_vec H1 f =
 / √ 2
 .* (f_to_vec H1 (update f i false)
     .+ (cos (f i * PI), sin (f i * PI)) .* f_to_vec H1 (update f i true)))
Crunching:
(pad_u H1 i hadamard × f_to_vec H1 f =
 / √ 2
 .* (f_to_vec H1 (update f i false)
     .+ (cos (f i * PI), sin (f i * PI)) .* f_to_vec H1 (update f i true)))
Crunching:
((fun r : R =>
  0%nat <> 2%nat ->
  pad_u H1 i hadamard × f_to_vec H1 f =
  / √ r
  .* (f_to_vec H1 (update f i false)
      .+ Cexp (f i * PI) .* f_to_vec H1 (update f i true))) 2)
Crunching:
(pad_u H1 i hadamard × f_to_vec H1 f =
 / √ 2
 .* (f_to_vec H1 (update f i false)
     .+ (cos (f i * PI), sin (f i * PI)) .* f_to_vec H1 (update f i true)))
Crunching:
(pad_u H1 i hadamard × f_to_vec H1 f =
 / √ 2
 .* (f_to_vec H1 (update f i false)
     .+ (cos (f i * PI), sin (f i * PI)) .* f_to_vec H1 (update f i true)))
Crunching:
((fun r : R =>
  0%nat <> 2%nat ->
  pad_u H1 i hadamard × f_to_vec H1 f =
  / √ r
  .* (f_to_vec H1 (update f i false)
      .+ Cexp (f i * PI) .* f_to_vec H1 (update f i true))) 2)
Crunching: (A = big_sum (fun i : nat => A i 0 .* basis_vector n i) n)
Crunching:
(forall ψ : Vector H12,
 WF_Matrix ψ -> ψ = big_sum (fun i : nat => ψ i 0 .* basis_vector H12 i) H12)
Crunching: (A = big_sum (fun i : nat => A i 0 .* basis_vector n i) n)
"T has been translated as Tᵗ"
"tm has been translated as tmᵗ"
Coq.Init.Datatypes.nat has been translated.
Coq.Init.Datatypes.bool has been translated.
Crunching:
(forall ψ : Vector H12,
 WF_Matrix ψ -> ψ = big_sum (fun i : nat => ψ i 0 .* basis_vector H12 i) H12)
Crunching: (A = big_sum (fun i : nat => A i 0 .* basis_vector n i) n)
"paths_ind has been translated as paths_indᵗ"
"Funext has been translated as Funextᵗ"
Crunching: (0 <> 0)
Crunching:
(WF_Matrix Hm ->
 Hm = big_sum (fun i x y : nat => (Hm i 0 * basis_vector m i x y)%C) m)
Crunching:
(forall ψ : Vector H12,
 WF_Matrix ψ -> ψ = big_sum (fun i : nat => ψ i 0 .* basis_vector H12 i) H12)
Crunching: (A = big_sum (fun i : nat => A i 0 .* basis_vector n i) n)
Crunching:
(forall ψ : Vector p,
 WF_Matrix ψ ->
 ψ = big_sum (fun i x y : nat => (ψ i 0 * basis_vector p i x y)%C) p)
Crunching:
(forall (d : nat) (ψ : Vector d),
 WF_Matrix ψ -> ψ = big_sum (fun i : nat => ψ i 0 .* basis_vector d i) d)
check_guarded: true
check_positive: true
check_universes: true
cumulative sprop: false
definitional uip: false
"toto has been translated as totoᵗ"
totoᵗ : unit -> (forall A : Type, A -> A) -> Type -> Type
     : unit -> (forall A : Type, A -> A) -> Type -> Type
"FALSE has been translated as FALSEᵗ"
"toto"
"a has been translated as aᵗ"
"T has been translated as Tᵗ"
"tm has been translated as tmᵗ"
Crunching:
(forall f : nat -> Vector n,
 big_sum f (2 * c) =
 big_sum (fun i : nat => f (2 * i)) c
 .+ big_sum (fun i : nat => f (2 * i + 1)) c)
Crunching:
(forall f : nat -> Vector n,
 big_sum f (2 * c) =
 big_sum (fun i : nat => f (2 * i)) c
 .+ big_sum (fun i : nat => f (2 * i + 1)) c)
"FALSE has been translated as FALSEᵗ"
Crunching:
(forall f : nat -> Vector n,
 big_sum f (2 * c) =
 big_sum (fun i : nat => f (2 * i)) c
 .+ big_sum (fun i : nat => f (2 * i + 1)) c)
"UIP has been translated as UIPᵗ"
Crunching: (WF_Matrix (big_sum v (S i)))
"False has been translated as Falseᵗ"
"equiv has been translated as equivᵗ"
Crunching:
(p < H2 ->
 q < H2 ->
 big_sum (fun i : nat => m (n i)) H2 =
 big_sum (fun i : nat => m (fswap n p q i)) H2)
Crunching: (forall x0 : nat, x0 < H -> v (H1 x0) = v (fswap H1 x y x0))
Crunching: False
Crunching:
(l < r ->
 H3 < r ->
 big_sum (fun i : nat => H (m i)) r =
 big_sum (fun i : nat => H (fswap m l H3 i)) r)
Crunching:
(p < H2 ->
 q < H2 ->
 big_sum (fun i : nat => m (n i)) H2 =
 big_sum (fun i : nat => m (fswap n p q i)) H2)
Crunching: (a >= 2 ^ n \/ m >= 1 -> vkron n f a m = 0%R)
Crunching: (a >= 2 ^ n \/ m >= 1 -> vkron n f a m = 0%R)
Crunching:
(fst
   ((fix vkron (n : nat) (f : nat -> nat -> nat -> R * R) {struct n} :
         nat -> nat -> R * R :=
       match n with
       | 0 =>
           fun x y : nat =>
           if
            if
             (fix eqb (n0 m : nat) {struct n0} : bool :=
                match n0 with
                | 0 => match m with
                       | 0 => true
                       | S _ => false
                       end
                | S n' => match m with
                          | 0 => false
                          | S m' => eqb n' m'
                          end
                end) x y
            then
             (fix leb (n0 m : nat) {struct n0} : bool :=
                match n0 with
                | 0 => true
                | S n' => match m with
                          | 0 => false
                          | S m' => leb n' m'
                          end
                end) x 0
            else false
           then (R1, R0)
           else (R0, R0)
       | S n' =>
           fun x y : nat =>
           (((let (x0, _) :=
                vkron n' f
                  (let (x0, _) :=
                     (fix divmod (x0 y0 q u : nat) {struct x0} : nat * nat :=
                        match x0 with
                        | 0%nat => (q, u)
                        | S x' =>
                            match u with
                            | 0%nat => divmod x' y0 (S q) y0
                            | S u' => divmod x' y0 q u'
                            end
                        end) x 1%nat 0%nat 1%nat in
                   x0)
                  (let (x0, _) :=
                     (fix divmod (x0 y0 q u : nat) {struct x0} : nat * nat :=
                        match x0 with
                        | 0%nat => (q, u)
                        | S x' =>
                            match u with
                            | 0%nat => divmod x' y0 (S q) y0
                            | S u' => divmod x' y0 q u'
                            end
                        end) y 0%nat 0%nat 0%nat in
                   x0) in
              x0) *
             (let (x0, _) :=
                f n'
                  match
                    (let (_, y0) :=
                       (fix divmod (x0 y0 q u : nat) {struct x0} :
                            nat * nat :=
                          match x0 with
                          | 0%nat => (q, u)
                          | S x' =>
                              match u with
                              | 0%nat => divmod x' y0 (S q) y0
                              | S u' => divmod x' y0 q u'
                              end
                          end) x 1%nat 0%nat 1%nat in
                     y0)
                  with
                  | 0%nat => 1%nat
                  | S _ => 0%nat
                  end 0%nat in
              x0) +
             -
             ((let (_, y0) :=
                 vkron n' f
                   (let (x0, _) :=
                      (fix divmod (x0 y0 q u : nat) {struct x0} :
                           nat * nat :=
                         match x0 with
                         | 0%nat => (q, u)
                         | S x' =>
                             match u with
                             | 0%nat => divmod x' y0 (S q) y0
                             | S u' => divmod x' y0 q u'
                             end
                         end) x 1%nat 0%nat 1%nat in
                    x0)
                   (let (x0, _) :=
                      (fix divmod (x0 y0 q u : nat) {struct x0} :
                           nat * nat :=
                         match x0 with
                         | 0%nat => (q, u)
                         | S x' =>
                             match u with
                             | 0%nat => divmod x' y0 (S q) y0
                             | S u' => divmod x' y0 q u'
                             end
                         end) y 0%nat 0%nat 0%nat in
                    x0) in
               y0) *
              (let (_, y0) :=
                 f n'
                   match
                     (let (_, y0) :=
                        (fix divmod (x0 y0 q u : nat) {struct x0} :
                             nat * nat :=
                           match x0 with
                           | 0%nat => (q, u)
                           | S x' =>
                               match u with
                               | 0%nat => divmod x' y0 (S q) y0
                               | S u' => divmod x' y0 q u'
                               end
                           end) x 1%nat 0%nat 1%nat in
                      y0)
                   with
                   | 0%nat => 1%nat
                   | S _ => 0%nat
                   end 0%nat in
               y0)))%R,
           ((let (x0, _) :=
               vkron n' f
                 (let (x0, _) :=
                    (fix divmod (x0 y0 q u : nat) {struct x0} : nat * nat :=
                       match x0 with
                       | 0%nat => (q, u)
                       | S x' =>
                           match u with
                           | 0%nat => divmod x' y0 (S q) y0
                           | S u' => divmod x' y0 q u'
                           end
                       end) x 1%nat 0%nat 1%nat in
                  x0)
                 (let (x0, _) :=
                    (fix divmod (x0 y0 q u : nat) {struct x0} : nat * nat :=
                       match x0 with
                       | 0%nat => (q, u)
                       | S x' =>
                           match u with
                           | 0%nat => divmod x' y0 (S q) y0
                           | S u' => divmod x' y0 q u'
                           end
                       end) y 0%nat 0%nat 0%nat in
                  x0) in
             x0) *
            (let (_, y0) :=
               f n'
                 match
                   (let (_, y0) :=
                      (fix divmod (x0 y0 q u : nat) {struct x0} :
                           nat * nat :=
                         match x0 with
                         | 0%nat => (q, u)
                         | S x' =>
                             match u with
                             | 0%nat => divmod x' y0 (S q) y0
                             | S u' => divmod x' y0 q u'
                             end
                         end) x 1%nat 0%nat 1%nat in
                    y0)
                 with
                 | 0%nat => 1%nat
                 | S _ => 0%nat
                 end 0%nat in
             y0) +
            (let (_, y0) :=
               vkron n' f
                 (let (x0, _) :=
                    (fix divmod (x0 y0 q u : nat) {struct x0} : nat * nat :=
                       match x0 with
                       | 0%nat => (q, u)
                       | S x' =>
                           match u with
                           | 0%nat => divmod x' y0 (S q) y0
                           | S u' => divmod x' y0 q u'
                           end
                       end) x 1%nat 0%nat 1%nat in
                  x0)
                 (let (x0, _) :=
                    (fix divmod (x0 y0 q u : nat) {struct x0} : nat * nat :=
                       match x0 with
                       | 0%nat => (q, u)
                       | S x' =>
                           match u with
                           | 0%nat => divmod x' y0 (S q) y0
                           | S u' => divmod x' y0 q u'
                           end
                       end) y 0%nat 0%nat 0%nat in
                  x0) in
             y0) *
            (let (x0, _) :=
               f n'
                 match
                   (let (_, y0) :=
                      (fix divmod (x0 y0 q u : nat) {struct x0} :
                           nat * nat :=
                         match x0 with
                         | 0%nat => (q, u)
                         | S x' =>
                             match u with
                             | 0%nat => divmod x' y0 (S q) y0
                             | S u' => divmod x' y0 q u'
                             end
                         end) x 1%nat 0%nat 1%nat in
                    y0)
                 with
                 | 0%nat => 1%nat
                 | S _ => 0%nat
                 end 0%nat in
             x0))%R)
       end) y Ey a b) = fst (Ey ?Goal ?Goal1 ?Goal2))
Crunching: (vkron y Ey a b = Ey ?Goal ?Goal1 ?Goal2)
Crunching: (vkron y Ey a b = Ey ?Goal ?Goal1 ?Goal2)
Crunching:
(fst
   ((fix vkron (n : nat) (f : nat -> nat -> nat -> R * R) {struct n} :
         nat -> nat -> R * R :=
       match n with
       | 0 =>
           fun x y : nat =>
           if
            if
             (fix eqb (n0 m : nat) {struct n0} : bool :=
                match n0 with
                | 0 => match m with
                       | 0 => true
                       | S _ => false
                       end
                | S n' => match m with
                          | 0 => false
                          | S m' => eqb n' m'
                          end
                end) x y
            then
             (fix leb (n0 m : nat) {struct n0} : bool :=
                match n0 with
                | 0 => true
                | S n' => match m with
                          | 0 => false
                          | S m' => leb n' m'
                          end
                end) x 0
            else false
           then (R1, R0)
           else (R0, R0)
       | S n' =>
           fun x y : nat =>
           (((let (x0, _) :=
                vkron n' f
                  (let (x0, _) :=
                     (fix divmod (x0 y0 q u : nat) {struct x0} : nat * nat :=
                        match x0 with
                        | 0%nat => (q, u)
                        | S x' =>
                            match u with
                            | 0%nat => divmod x' y0 (S q) y0
                            | S u' => divmod x' y0 q u'
                            end
                        end) x 1%nat 0%nat 1%nat in
                   x0)
                  (let (x0, _) :=
                     (fix divmod (x0 y0 q u : nat) {struct x0} : nat * nat :=
                        match x0 with
                        | 0%nat => (q, u)
                        | S x' =>
                            match u with
                            | 0%nat => divmod x' y0 (S q) y0
                            | S u' => divmod x' y0 q u'
                            end
                        end) y 0%nat 0%nat 0%nat in
                   x0) in
              x0) *
             (let (x0, _) :=
                f n'
                  match
                    (let (_, y0) :=
                       (fix divmod (x0 y0 q u : nat) {struct x0} :
                            nat * nat :=
                          match x0 with
                          | 0%nat => (q, u)
                          | S x' =>
                              match u with
                              | 0%nat => divmod x' y0 (S q) y0
                              | S u' => divmod x' y0 q u'
                              end
                          end) x 1%nat 0%nat 1%nat in
                     y0)
                  with
                  | 0%nat => 1%nat
                  | S _ => 0%nat
                  end 0%nat in
              x0) +
             -
             ((let (_, y0) :=
                 vkron n' f
                   (let (x0, _) :=
                      (fix divmod (x0 y0 q u : nat) {struct x0} :
                           nat * nat :=
                         match x0 with
                         | 0%nat => (q, u)
                         | S x' =>
                             match u with
                             | 0%nat => divmod x' y0 (S q) y0
                             | S u' => divmod x' y0 q u'
                             end
                         end) x 1%nat 0%nat 1%nat in
                    x0)
                   (let (x0, _) :=
                      (fix divmod (x0 y0 q u : nat) {struct x0} :
                           nat * nat :=
                         match x0 with
                         | 0%nat => (q, u)
                         | S x' =>
                             match u with
                             | 0%nat => divmod x' y0 (S q) y0
                             | S u' => divmod x' y0 q u'
                             end
                         end) y 0%nat 0%nat 0%nat in
                    x0) in
               y0) *
              (let (_, y0) :=
                 f n'
                   match
                     (let (_, y0) :=
                        (fix divmod (x0 y0 q u : nat) {struct x0} :
                             nat * nat :=
                           match x0 with
                           | 0%nat => (q, u)
                           | S x' =>
                               match u with
                               | 0%nat => divmod x' y0 (S q) y0
                               | S u' => divmod x' y0 q u'
                               end
                           end) x 1%nat 0%nat 1%nat in
                      y0)
                   with
                   | 0%nat => 1%nat
                   | S _ => 0%nat
                   end 0%nat in
               y0)))%R,
           ((let (x0, _) :=
               vkron n' f
                 (let (x0, _) :=
                    (fix divmod (x0 y0 q u : nat) {struct x0} : nat * nat :=
                       match x0 with
                       | 0%nat => (q, u)
                       | S x' =>
                           match u with
                           | 0%nat => divmod x' y0 (S q) y0
                           | S u' => divmod x' y0 q u'
                           end
                       end) x 1%nat 0%nat 1%nat in
                  x0)
                 (let (x0, _) :=
                    (fix divmod (x0 y0 q u : nat) {struct x0} : nat * nat :=
                       match x0 with
                       | 0%nat => (q, u)
                       | S x' =>
                           match u with
                           | 0%nat => divmod x' y0 (S q) y0
                           | S u' => divmod x' y0 q u'
                           end
                       end) y 0%nat 0%nat 0%nat in
                  x0) in
             x0) *
            (let (_, y0) :=
               f n'
                 match
                   (let (_, y0) :=
                      (fix divmod (x0 y0 q u : nat) {struct x0} :
                           nat * nat :=
                         match x0 with
                         | 0%nat => (q, u)
                         | S x' =>
                             match u with
                             | 0%nat => divmod x' y0 (S q) y0
                             | S u' => divmod x' y0 q u'
                             end
                         end) x 1%nat 0%nat 1%nat in
                    y0)
                 with
                 | 0%nat => 1%nat
                 | S _ => 0%nat
                 end 0%nat in
             y0) +
            (let (_, y0) :=
               vkron n' f
                 (let (x0, _) :=
                    (fix divmod (x0 y0 q u : nat) {struct x0} : nat * nat :=
                       match x0 with
                       | 0%nat => (q, u)
                       | S x' =>
                           match u with
                           | 0%nat => divmod x' y0 (S q) y0
                           | S u' => divmod x' y0 q u'
                           end
                       end) x 1%nat 0%nat 1%nat in
                  x0)
                 (let (x0, _) :=
                    (fix divmod (x0 y0 q u : nat) {struct x0} : nat * nat :=
                       match x0 with
                       | 0%nat => (q, u)
                       | S x' =>
                           match u with
                           | 0%nat => divmod x' y0 (S q) y0
                           | S u' => divmod x' y0 q u'
                           end
                       end) y 0%nat 0%nat 0%nat in
                  x0) in
             y0) *
            (let (x0, _) :=
               f n'
                 match
                   (let (_, y0) :=
                      (fix divmod (x0 y0 q u : nat) {struct x0} :
                           nat * nat :=
                         match x0 with
                         | 0%nat => (q, u)
                         | S x' =>
                             match u with
                             | 0%nat => divmod x' y0 (S q) y0
                             | S u' => divmod x' y0 q u'
                             end
                         end) x 1%nat 0%nat 1%nat in
                    y0)
                 with
                 | 0%nat => 1%nat
                 | S _ => 0%nat
                 end 0%nat in
             x0))%R)
       end) y Ey a b) = fst (Ey ?Goal ?Goal1 ?Goal2))
Crunching: (vkron y Ey a b = Ey ?Goal ?Goal1 ?Goal2)
Crunching: (vkron y Ey a b = Ey ?Goal ?Goal1 ?Goal2)
Crunching: (vkron n Hn Lo Hi = 0%R)
Crunching: (vkron n Hn Lo Hi = 0%R)
Crunching: (vkron n Hn Lo Hi = 0%R)
Crunching: (a >= 2 ^ n \/ m >= 1 -> vkron n f a m = 0%R)
Crunching: (f 0 ⊗ vkron n (fun i : nat => f (i + 1)) = vkron (S n) f)
Crunching:
((fun x0 y : nat =>
  (x 0 (x0 / 2 ^ s1)%nat (y / 1)%nat *
   vkron s1 (shift x 1) (x0 mod 2 ^ s1) (y mod 1))%C) = 
 vkron (S s1) x)
Crunching: (f 0 ⊗ vkron n (fun i : nat => f (i + 1)) = vkron (S n) f)
Crunching: (f 0 ⊗ vkron n (fun i : nat => f (i + 1)) = vkron (S n) f)
Crunching:
((fun x0 y : nat =>
  (x 0 (x0 / 2 ^ s1)%nat (y / 1)%nat *
   vkron s1 (shift x 1) (x0 mod 2 ^ s1) (y mod 1))%C) = 
 vkron (S s1) x)
Crunching: (f 0 ⊗ vkron n (fun i : nat => f (i + 1)) = vkron (S n) f)
Crunching: (H0 0 ⊗ I 1 = I 1 ⊗ H0 0)
Crunching: (S (a + b) < n)
Crunching: (forall n : nat, 2 * 2 ^ n * 2 = 2 ^ (1 + n + 1))
Crunching:
(vkron x n = vkron x' n ⊗ n x' ⊗ vkron (x - 1 - x') (shift n (x' + 1)))
Crunching: (∣0⟩ ⊗ basis_vector (S Hb) Hb = basis_vector (S (S (Hb + Hb))) Hb)
Crunching:
(∣0⟩ ⊗ (fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) =
 (fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R))
Crunching:
(∣1⟩ ⊗ (fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) =
 (fun i j : nat => if (i =? k + n) && (j =? 0) then C1 else 0%R))
Crunching: (∣1⟩ ⊗ basis_vector n k = basis_vector (2 * n) (k + n))
Crunching:
(∣1⟩ ⊗ (fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) =
 (fun i j : nat => if (i =? k + n) && (j =? 0) then C1 else 0%R))
Crunching:
(∣1⟩ ⊗ (fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) =
 (fun i j : nat => if (i =? k + n) && (j =? 0) then C1 else 0%R))
Crunching:
(∣1⟩ ⊗ (fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) =
 (fun i j : nat => if (i =? k + 0) && (j =? 0) then C1 else 0%R))
Crunching: ((∣1⟩ ⊗ basis_vector n k) x y = basis_vector (2 * n) (k + n) x y)
Crunching: ((∣1⟩ ⊗ basis_vector n k) x = basis_vector (2 * n) (k + n) x)
Crunching:
((∣1⟩ ⊗ basis_vector x Hx) x0 y = basis_vector (x + (x + 0)) (Hx + x) x0 y)
Crunching:
((fun x0 y : nat =>
  (∣1⟩ (x0 / x)%nat (y / 1)%nat *
   (if (x0 mod x =? Hx) && (y mod 1 =? 0) then C1 else 0%R))%C) =
 (fun i j : nat => if (i =? Hx + x) && (j =? 0) then C1 else 0%R))
Crunching:
((fun x0 y : nat =>
  (∣1⟩ (x0 / x)%nat (y / 1)%nat *
   (if (x0 mod x =? Hx) && (y mod 1 =? 0) then C1 else 0%R))%C) =
 (fun i j : nat => if (i =? Hx + x) && (j =? 0) then C1 else 0%R))
Crunching:
((∣1⟩ ⊗ basis_vector x Hx) x0 y = basis_vector (x + x) (Hx + x) x0 y)
Crunching:
((∣1⟩ ⊗ basis_vector x Hx) x0 y = basis_vector (x + x) (Hx + x) x0 y)
Crunching:
((fun x0 y : nat =>
  (∣1⟩ (x0 / x)%nat (y / 1)%nat *
   (if (x0 mod x =? Hx) && (y mod 1 =? 0) then C1 else 0%R))%C) =
 (fun i j : nat => if (i =? Hx + x) && (j =? 0) then C1 else 0%R))
Crunching:
((fun x0 y : nat =>
  (∣1⟩ (x0 / x)%nat (y / 1)%nat *
   (if (x0 mod x =? Hx) && (y mod 1 =? 0) then C1 else 0%R))%C) =
 (fun i j : nat => if (i =? Hx + x) && (j =? 0) then C1 else 0%R))
Crunching:
((fun x0 y : nat =>
  (∣1⟩ (x0 / x)%nat (y / 1)%nat *
   (if (x0 mod x =? Hx) && (y mod 1 =? 0) then C1 else 0%R))%C) =
 (fun i j : nat => if (i =? Hx + x) && (j =? 0) then C1 else 0%R))
Crunching:
((fun x0 y : nat =>
  (∣1⟩ (x0 / x)%nat (y / 1)%nat *
   (if (x0 mod x =? Hx) && (y mod 1 =? 0) then C1 else 0%R))%C) =
 (fun i j : nat => if (i =? Hx + x) && (j =? 0) then C1 else 0%R))
Crunching:
((fun x0 y : nat =>
  (∣1⟩ (x0 / x)%nat (y / 1)%nat *
   (if (x0 mod x =? Hx) && (y mod 1 =? 0) then C1 else 0%R))%C) =
 (fun i j : nat => if (i =? Hx + x) && (j =? 0) then C1 else 0%R))
Crunching:
((∣1⟩ ⊗ basis_vector x Hx) x0 y = basis_vector (2 * x) (Hx + x) x0 y)
Crunching:
((∣1⟩ ⊗ basis_vector x Hx) x0 y = basis_vector (x + (x + 0)) (Hx + x) x0 y)
Crunching:
(∣1⟩ ⊗ (fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) =
 (fun i j : nat => if (i =? k + n) && (j =? 0) then C1 else 0%R))
Crunching:
((0%R * (if x mod n =? k then C1 else 0%R))%C =
 (if x =? k + n then C1 else 0%R))
Crunching:
((0%R * (if x mod S k =? k then C1 else 0%R))%C =
 (if x =? k + S k then C1 else 0%R))
Crunching:
((0%R * (if x mod S k =? k then C1 else 0%R))%C =
 (if x =? k + S k then C1 else 0%R))
Crunching:
((0%R * (if x mod S k =? k then C1 else 0%R))%C =
 (if x =? k + S k then C1 else 0%R))
Crunching: ((match (x / n)%nat with
             | 1 => C1
             | _ => 0%R
             end * C1)%C = C1)
Crunching: ((match (x / n)%nat with
             | 1 => C1
             | _ => 0%R
             end * C1)%C = C1)
Crunching: ((match (x / n)%nat with
             | 1 => C1
             | _ => 0%R
             end * C1)%C = C1)
Crunching:
((0%R * (if x mod S k =? k then C1 else 0%R))%C =
 (if x =? k + S k then C1 else 0%R))
Crunching:
((0%R * (if x mod n =? k then C1 else 0%R))%C =
 (if x =? k + n then C1 else 0%R))
Crunching: Z
Crunching:
((0%R * (if x mod S k =? k then C1 else 0%R))%C =
 (if x =? k + S k then C1 else 0%R))
Crunching:
((0%R * (if x mod n =? k then C1 else 0%R))%C =
 (if x =? k + n then C1 else 0%R))
Crunching: Z
Crunching:
((forall n : nat, fact (S n) = S n * fact n) ->
 (0%R * (if (x mod n =? k) && true then C1 else 0%R))%C =
 (if (x =? k + n) && true then C1 else 0%R))
Crunching: nat
Crunching:
(∣1⟩ ⊗ (fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) =
 (fun i j : nat => if (i =? k + n) && (j =? 0) then C1 else 0%R))
Crunching:
((fun i j : nat => if (i =? b) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩ =
 (fun i j : nat => if (i =? 2 * b) && (j =? 0) then C1 else 0%R))
Crunching:
((fun i j : nat => if (i =? b) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩ =
 (fun i j : nat => if (i =? 2 * b) && (j =? 0) then C1 else 0%R))
Crunching: (basis_vector a b ⊗ ∣0⟩ = basis_vector (2 * a) (2 * b))
Crunching:
((fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩ =
 (fun i j : nat => if (i =? 2 * k) && (j =? 0) then C1 else 0%R))
Crunching: (basis_vector n k ⊗ ∣0⟩ = basis_vector (2 * n) (2 * k))
Crunching: (m < n -> basis_vector n m ⊗ ∣0⟩ = basis_vector (2 * n) (2 * m))
Crunching:
(forall k : nat,
 0 <> 0 ->
 k < 0 ->
 (fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩ =
 (fun i j : nat => if (i =? 2 * k) && (j =? 0) then C1 else 0%R))
Crunching:
((fun i j : nat => if (i =? 2 * N) && (j =? 0) then C1 else 0%R) =
 (fun i j : nat => if (i =? N) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩)
Crunching: (basis_vector (2 * y) (2 * N) = basis_vector y N ⊗ ∣0⟩)
Crunching:
((fun i j : nat => if (i =? N) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩ =
 (fun i j : nat => if (i =? 2 * N) && (j =? 0) then C1 else 0%R))
Crunching: (basis_vector y N ⊗ ∣0⟩ = basis_vector (2 * y) (2 * N))
Crunching:
((fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩ =
 (fun i j : nat => if (i =? 2 * k) && (j =? 0) then C1 else 0%R))
Crunching: (basis_vector n k ⊗ ∣0⟩ = basis_vector (2 * n) (2 * k))
Crunching:
((fun i j : nat => if (i =? b) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩ =
 (fun i j : nat => if (i =? 2 * b) && (j =? 0) then C1 else 0%R))
Crunching:
(((fun i j : nat => if (i =? b) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩) x y =
 (if (x =? 2 * b) && (y =? 0) then C1 else 0%R))
Crunching:
(((fun i j : nat => if (i =? b) && (j =? 0) then R1 else R0) ⊗ ∣0⟩) x y =
 (if (x =? 2 * b) && (y =? 0) then R1 else R0))
Crunching:
((fun i j : nat => if (i =? b) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩ =
 (fun i j : nat => if (i =? 2 * b) && (j =? 0) then C1 else 0%R))
Crunching:
(((fun i j : nat => if (i =? b) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩) x y =
 (if (x =? 2 * b) && (y =? 0) then C1 else 0%R))
Crunching:
(((fun i j : nat => if (i =? b) && (j =? 0) then R1 else R0) ⊗ ∣0⟩) x y =
 (if (x =? 2 * b) && (y =? 0) then R1 else R0))
Crunching:
((fun i j : nat => if (i =? b) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩ =
 (fun i j : nat => if (i =? 2 * b) && (j =? 0) then C1 else 0%R))
Crunching: (basis_vector a b ⊗ ∣0⟩ = basis_vector (2 * a) (2 * b))
Crunching:
((fun i j : nat => if (i =? b) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩ =
 (fun i j : nat => if (i =? 2 * b) && (j =? 0) then C1 else 0%R))
Crunching: (basis_vector a b ⊗ ∣0⟩ = basis_vector (2 * a) (2 * b))
Crunching:
((fun i j : nat => if (i =? m) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩ =
 (fun i j : nat => if (i =? 2 * m) && (j =? 0) then C1 else 0%R))
Crunching: (m < n -> basis_vector n m ⊗ ∣0⟩ = basis_vector (2 * n) (2 * m))
Crunching:
((fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩ =
 (fun i j : nat => if (i =? 2 * k) && (j =? 0) then C1 else 0%R))
Crunching:
((fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩ =
 (fun i j : nat => if (i =? 2 * k) && (j =? 0) then C1 else 0%R))
Crunching: (basis_vector n k ⊗ ∣0⟩ = basis_vector (2 * n) (2 * k))
Crunching:
((fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩ =
 (fun i j : nat => if (i =? 2 * k) && (j =? 0) then C1 else 0%R))
Crunching: (basis_vector n k ⊗ ∣0⟩ = basis_vector (2 * n) (2 * k))
Crunching:
(forall k : nat,
 0 <> 0 ->
 k < 0 ->
 (fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩ =
 (fun i j : nat => if (i =? 2 * k) && (j =? 0) then C1 else 0%R))
Crunching: (n < 0 -> basis_vector 0 n ⊗ ∣0⟩ = basis_vector (2 * 0) (2 * n))
Crunching:
((fun i j : nat => if (i =? a) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩ =
 (fun i j : nat => if (i =? 2 * a) && (j =? 0) then C1 else 0%R))
Crunching: (basis_vector n a ⊗ ∣0⟩ = basis_vector (2 * n) (2 * a))
Crunching:
((fun i j : nat => if (i =? a) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩ =
 (fun i j : nat => if (i =? 2 * a) && (j =? 0) then C1 else 0%R))
Crunching:
((fun i j : nat => if (i =? a) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩ =
 (fun i j : nat => if (i =? 2 * a) && (j =? 0) then C1 else 0%R))
Crunching: (basis_vector n a ⊗ ∣0⟩ = basis_vector (2 * n) (2 * a))
Crunching:
((fun i j : nat => if (i =? m) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩ =
 (fun i j : nat => if (i =? 2 * m) && (j =? 0) then C1 else 0%R))
Crunching:
((fun i j : nat => if (i =? m) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩ =
 (fun i j : nat => if (i =? 2 * m) && (j =? 0) then C1 else 0%R))
Crunching:
((fun i j : nat => if (i =? 0) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩ =
 (fun i j : nat => if (i =? 2 * 0) && (j =? 0) then C1 else 0%R))
Crunching:
((fun i j : nat => if (i =? m) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩ =
 (fun i j : nat => if (i =? 2 * m) && (j =? 0) then C1 else 0%R))
Crunching:
((fun i j : nat => if (i =? m) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩ =
 (fun i j : nat => if (i =? 2 * m) && (j =? 0) then C1 else 0%R))
Crunching:
((fun i j : nat => if (i =? m) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩ =
 (fun i j : nat => if (i =? 2 * m) && (j =? 0) then C1 else 0%R))
Crunching:
((fun i j : nat => if (i =? m) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩ =
 (fun i j : nat => if (i =? 2 * m) && (j =? 0) then C1 else 0%R))
Crunching:
((fun i j : nat => if (i =? 0) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩ =
 (fun i j : nat => if (i =? 2 * 0) && (j =? 0) then C1 else 0%R))
Crunching:
((fun i j : nat => if (i =? m) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩ =
 (fun i j : nat => if (i =? 2 * m) && (j =? 0) then C1 else 0%R))
Crunching:
((fun i j : nat => if (i =? m) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩ =
 (fun i j : nat => if (i =? 2 * m) && (j =? 0) then C1 else 0%R))
Crunching:
((fun i j : nat => if (i =? m) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩ =
 (fun i j : nat => if (i =? 2 * m) && (j =? 0) then C1 else 0%R))
Crunching:
((fun i j : nat => if (i =? m) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩ =
 (fun i j : nat => if (i =? 2 * m) && (j =? 0) then C1 else 0%R))
Crunching:
((fun i j : nat => if (i =? m) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩ =
 (fun i j : nat => if (i =? 2 * m) && (j =? 0) then C1 else 0%R))
Crunching: (m < n -> basis_vector n m ⊗ ∣0⟩ = basis_vector (2 * n) (2 * m))
Crunching: (c < n -> basis_vector n c ⊗ ∣0⟩ = basis_vector (n + n) (2 * c))
Crunching:
((fun i j : nat => if (i =? H6) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩ =
 (fun i j : nat => if (i =? 2 * H6) && (j =? 0) then C1 else 0%R))
Crunching:
(forall k : nat,
 0 <> 0 ->
 k < 0 ->
 (fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩ =
 (fun i j : nat => if (i =? 2 * k) && (j =? 0) then C1 else 0%R))
Crunching:
((fun i j : nat => if (i =? H) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩ =
 (fun i j : nat => if (i =? 2 * H) && (j =? 0) then C1 else 0%R))
Crunching:
((fun i j : nat => if (i =? 2 * N) && (j =? 0) then C1 else 0%R) =
 (fun i j : nat => if (i =? N) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩)
Crunching:
((fun i j : nat => if (i =? N) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩ =
 (fun i j : nat => if (i =? 2 * N) && (j =? 0) then C1 else 0%R))
Crunching: (basis_vector (2 * y) (2 * N) = basis_vector y N ⊗ ∣0⟩)
Crunching:
((fun i j : nat => if (i =? N) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩ =
 (fun i j : nat => if (i =? 2 * N) && (j =? 0) then C1 else 0%R))
Crunching:
((fun i j : nat => if (i =? 2 * N) && (j =? 0) then C1 else 0%R) =
 (fun i j : nat => if (i =? N) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩)
Crunching: (basis_vector y N ⊗ ∣0⟩ = basis_vector (2 * y) (2 * N))
Crunching:
((fun i j : nat => if (i =? 2 * N) && (j =? 0) then C1 else 0%R) =
 (fun i j : nat => if (i =? N) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩)
Crunching: (basis_vector (2 * y) (2 * N) = basis_vector y N ⊗ ∣0⟩)
Crunching:
((fun i j : nat => if (i =? N) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩ =
 (fun i j : nat => if (i =? 2 * N) && (j =? 0) then C1 else 0%R))
Crunching: (basis_vector y N ⊗ ∣0⟩ = basis_vector (2 * y) (2 * N))
Crunching:
((fun i j : nat => if (i =? 2 * N) && (j =? 0) then C1 else 0%R) =
 (fun i j : nat => if (i =? N) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩)
Crunching: (basis_vector (2 * y) (2 * N) = basis_vector y N ⊗ ∣0⟩)
Crunching:
((fun i j : nat => if (i =? N) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩ =
 (fun i j : nat => if (i =? 2 * N) && (j =? 0) then C1 else 0%R))
Crunching:
((fun i j : nat => if (i =? 2 * N) && (j =? 0) then C1 else 0%R) =
 (fun i j : nat => if (i =? N) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩)
Crunching: (basis_vector y N ⊗ ∣0⟩ = basis_vector (2 * y) (2 * N))
Crunching:
((fun i j : nat => if (i =? 2 * N) && (j =? 0) then C1 else 0%R) =
 (fun i j : nat => if (i =? N) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩)
Crunching:
((fun i j : nat => if (i =? N) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩ =
 (fun i j : nat => if (i =? 2 * N) && (j =? 0) then C1 else 0%R))
Crunching: (basis_vector (2 * y) (2 * N) = basis_vector y N ⊗ ∣0⟩)
Crunching:
((fun i j : nat => if (i =? N) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩ =
 (fun i j : nat => if (i =? 2 * N) && (j =? 0) then C1 else 0%R))
Crunching: (basis_vector y N ⊗ ∣0⟩ = basis_vector (2 * y) (2 * N))
Crunching:
((fun i j : nat => if (i =? 2 * N) && (j =? 0) then C1 else 0%R) =
 (fun i j : nat => if (i =? N) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩)
Crunching: (basis_vector (2 * y) (2 * N) = basis_vector y N ⊗ ∣0⟩)
Crunching:
((fun i j : nat => if (i =? N) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩ =
 (fun i j : nat => if (i =? 2 * N) && (j =? 0) then C1 else 0%R))
Crunching: (basis_vector y N ⊗ ∣0⟩ = basis_vector (2 * y) (2 * N))
Crunching:
((fun i j : nat => if (i =? N) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩ =
 (fun i j : nat => if (i =? 2 * N) && (j =? 0) then C1 else 0%R))
Crunching: (basis_vector y N ⊗ ∣0⟩ = basis_vector (2 * y) (2 * N))
Crunching:
((fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩ =
 (fun i j : nat => if (i =? 2 * k) && (j =? 0) then C1 else 0%R))
Crunching: (basis_vector LT k ⊗ ∣0⟩ = basis_vector (2 * LT) (2 * k))
Crunching:
((fun x y : nat =>
  (((let (x0, _) :=
       if
        if
         (fix eqb (n m : nat) {struct n} : bool :=
            match n with
            | 0%nat => match m with
                       | 0%nat => true
                       | S _ => false
                       end
            | S n' => match m with
                      | 0%nat => false
                      | S m' => eqb n' m'
                      end
            end) (x / 2)%nat k
        then
         (fix eqb (n m : nat) {struct n} : bool :=
            match n with
            | 0%nat => match m with
                       | 0%nat => true
                       | S _ => false
                       end
            | S n' => match m with
                      | 0%nat => false
                      | S m' => eqb n' m'
                      end
            end) (y / 1)%nat 0%nat
        else false
       then (R1, R0)
       else (R0, R0) in
     x0) *
    (let (x0, _) :=
       match x mod 2 with
       | 0%nat =>
           match y mod 1 with
           | 0%nat => (R1, R0)
           | S _ => (R0, R0)
           end
       | 1%nat => match y mod 1 with
                  | 0%nat | _ => (R0, R0)
                  end
       | S (S _) => (R0, R0)
       end in
     x0) +
    -
    ((let (_, y0) :=
        if
         if
          (fix eqb (n m : nat) {struct n} : bool :=
             match n with
             | 0%nat => match m with
                        | 0%nat => true
                        | S _ => false
                        end
             | S n' => match m with
                       | 0%nat => false
                       | S m' => eqb n' m'
                       end
             end) (x / 2)%nat k
         then
          (fix eqb (n m : nat) {struct n} : bool :=
             match n with
             | 0%nat => match m with
                        | 0%nat => true
                        | S _ => false
                        end
             | S n' => match m with
                       | 0%nat => false
                       | S m' => eqb n' m'
                       end
             end) (y / 1)%nat 0%nat
         else false
        then (R1, R0)
        else (R0, R0) in
      y0) *
     (let (_, y0) :=
        match x mod 2 with
        | 0%nat =>
            match y mod 1 with
            | 0%nat => (R1, R0)
            | S _ => (R0, R0)
            end
        | 1%nat => match y mod 1 with
                   | 0%nat | _ => (R0, R0)
                   end
        | S (S _) => (R0, R0)
        end in
      y0)))%R,
  ((let (x0, _) :=
      if
       if
        (fix eqb (n m : nat) {struct n} : bool :=
           match n with
           | 0%nat => match m with
                      | 0%nat => true
                      | S _ => false
                      end
           | S n' => match m with
                     | 0%nat => false
                     | S m' => eqb n' m'
                     end
           end) (x / 2)%nat k
       then
        (fix eqb (n m : nat) {struct n} : bool :=
           match n with
           | 0%nat => match m with
                      | 0%nat => true
                      | S _ => false
                      end
           | S n' => match m with
                     | 0%nat => false
                     | S m' => eqb n' m'
                     end
           end) (y / 1)%nat 0%nat
       else false
      then (R1, R0)
      else (R0, R0) in
    x0) *
   (let (_, y0) :=
      match x mod 2 with
      | 0%nat => match y mod 1 with
                 | 0%nat => (R1, R0)
                 | S _ => (R0, R0)
                 end
      | 1%nat => match y mod 1 with
                 | 0%nat | _ => (R0, R0)
                 end
      | S (S _) => (R0, R0)
      end in
    y0) +
   (let (_, y0) :=
      if
       if
        (fix eqb (n m : nat) {struct n} : bool :=
           match n with
           | 0%nat => match m with
                      | 0%nat => true
                      | S _ => false
                      end
           | S n' => match m with
                     | 0%nat => false
                     | S m' => eqb n' m'
                     end
           end) (x / 2)%nat k
       then
        (fix eqb (n m : nat) {struct n} : bool :=
           match n with
           | 0%nat => match m with
                      | 0%nat => true
                      | S _ => false
                      end
           | S n' => match m with
                     | 0%nat => false
                     | S m' => eqb n' m'
                     end
           end) (y / 1)%nat 0%nat
       else false
      then (R1, R0)
      else (R0, R0) in
    y0) *
   (let (x0, _) :=
      match x mod 2 with
      | 0%nat => match y mod 1 with
                 | 0%nat => (R1, R0)
                 | S _ => (R0, R0)
                 end
      | 1%nat => match y mod 1 with
                 | 0%nat | _ => (R0, R0)
                 end
      | S (S _) => (R0, R0)
      end in
    x0))%R)) =
 (fun i j : nat =>
  if
   if
    (fix eqb (n m : nat) {struct n} : bool :=
       match n with
       | 0 => match m with
              | 0 => true
              | S _ => false
              end
       | S n' => match m with
                 | 0 => false
                 | S m' => eqb n' m'
                 end
       end) i (2 * k)
   then
    (fix eqb (n m : nat) {struct n} : bool :=
       match n with
       | 0 => match m with
              | 0 => true
              | S _ => false
              end
       | S n' => match m with
                 | 0 => false
                 | S m' => eqb n' m'
                 end
       end) j 0
   else false
  then (R1, R0)
  else (R0, R0)))
Crunching:
((fun x y : nat =>
  (((let (x0, _) :=
       if
        if
         (fix eqb (n m : nat) {struct n} : bool :=
            match n with
            | 0%nat => match m with
                       | 0%nat => true
                       | S _ => false
                       end
            | S n' => match m with
                      | 0%nat => false
                      | S m' => eqb n' m'
                      end
            end) (x / 2)%nat k
        then
         (fix eqb (n m : nat) {struct n} : bool :=
            match n with
            | 0%nat => match m with
                       | 0%nat => true
                       | S _ => false
                       end
            | S n' => match m with
                      | 0%nat => false
                      | S m' => eqb n' m'
                      end
            end) (y / 1)%nat 0%nat
        else false
       then (R1, R0)
       else (R0, R0) in
     x0) *
    (let (x0, _) :=
       match x mod 2 with
       | 0%nat =>
           match y mod 1 with
           | 0%nat => (R1, R0)
           | S _ => (R0, R0)
           end
       | 1%nat => match y mod 1 with
                  | 0%nat | _ => (R0, R0)
                  end
       | S (S _) => (R0, R0)
       end in
     x0) +
    -
    ((let (_, y0) :=
        if
         if
          (fix eqb (n m : nat) {struct n} : bool :=
             match n with
             | 0%nat => match m with
                        | 0%nat => true
                        | S _ => false
                        end
             | S n' => match m with
                       | 0%nat => false
                       | S m' => eqb n' m'
                       end
             end) (x / 2)%nat k
         then
          (fix eqb (n m : nat) {struct n} : bool :=
             match n with
             | 0%nat => match m with
                        | 0%nat => true
                        | S _ => false
                        end
             | S n' => match m with
                       | 0%nat => false
                       | S m' => eqb n' m'
                       end
             end) (y / 1)%nat 0%nat
         else false
        then (R1, R0)
        else (R0, R0) in
      y0) *
     (let (_, y0) :=
        match x mod 2 with
        | 0%nat =>
            match y mod 1 with
            | 0%nat => (R1, R0)
            | S _ => (R0, R0)
            end
        | 1%nat => match y mod 1 with
                   | 0%nat | _ => (R0, R0)
                   end
        | S (S _) => (R0, R0)
        end in
      y0)))%R,
  ((let (x0, _) :=
      if
       if
        (fix eqb (n m : nat) {struct n} : bool :=
           match n with
           | 0%nat => match m with
                      | 0%nat => true
                      | S _ => false
                      end
           | S n' => match m with
                     | 0%nat => false
                     | S m' => eqb n' m'
                     end
           end) (x / 2)%nat k
       then
        (fix eqb (n m : nat) {struct n} : bool :=
           match n with
           | 0%nat => match m with
                      | 0%nat => true
                      | S _ => false
                      end
           | S n' => match m with
                     | 0%nat => false
                     | S m' => eqb n' m'
                     end
           end) (y / 1)%nat 0%nat
       else false
      then (R1, R0)
      else (R0, R0) in
    x0) *
   (let (_, y0) :=
      match x mod 2 with
      | 0%nat => match y mod 1 with
                 | 0%nat => (R1, R0)
                 | S _ => (R0, R0)
                 end
      | 1%nat => match y mod 1 with
                 | 0%nat | _ => (R0, R0)
                 end
      | S (S _) => (R0, R0)
      end in
    y0) +
   (let (_, y0) :=
      if
       if
        (fix eqb (n m : nat) {struct n} : bool :=
           match n with
           | 0%nat => match m with
                      | 0%nat => true
                      | S _ => false
                      end
           | S n' => match m with
                     | 0%nat => false
                     | S m' => eqb n' m'
                     end
           end) (x / 2)%nat k
       then
        (fix eqb (n m : nat) {struct n} : bool :=
           match n with
           | 0%nat => match m with
                      | 0%nat => true
                      | S _ => false
                      end
           | S n' => match m with
                     | 0%nat => false
                     | S m' => eqb n' m'
                     end
           end) (y / 1)%nat 0%nat
       else false
      then (R1, R0)
      else (R0, R0) in
    y0) *
   (let (x0, _) :=
      match x mod 2 with
      | 0%nat => match y mod 1 with
                 | 0%nat => (R1, R0)
                 | S _ => (R0, R0)
                 end
      | 1%nat => match y mod 1 with
                 | 0%nat | _ => (R0, R0)
                 end
      | S (S _) => (R0, R0)
      end in
    x0))%R)) =
 (fun i j : nat =>
  if
   if
    (fix eqb (n m : nat) {struct n} : bool :=
       match n with
       | 0 => match m with
              | 0 => true
              | S _ => false
              end
       | S n' => match m with
                 | 0 => false
                 | S m' => eqb n' m'
                 end
       end) i (k + k)
   then
    (fix eqb (n m : nat) {struct n} : bool :=
       match n with
       | 0 => match m with
              | 0 => true
              | S _ => false
              end
       | S n' => match m with
                 | 0 => false
                 | S m' => eqb n' m'
                 end
       end) j 0
   else false
  then (R1, R0)
  else (R0, R0)))
Crunching:
((fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩ =
 (fun i j : nat => if (i =? 2 * k) && (j =? 0) then C1 else 0%R))
Crunching:
((fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩ =
 (fun i j : nat => if (i =? 2 * k) && (j =? 0) then C1 else 0%R))
Crunching:
((fun x y : nat =>
  ((if (x / 2 =? k) && (y / 1 =? 0) then C1 else 0%R) *
   match x mod 2 with
   | 0 => match y mod 1 with
          | 0 => C1
          | S _ => 0%R
          end
   | 1 => match y mod 1 with
          | 0 | _ => 0%R
          end
   | S (S _) => 0%R
   end)%C) = (fun i j : nat => if (i =? 2 * k) && (j =? 0) then C1 else 0%R))
Crunching:
((fun x y : nat =>
  ((if (x / 2 =? k) && (y / 1 =? 0) then C1 else 0%R) *
   ∣0⟩ (x mod 2) (y mod 1))%C) =
 (fun i j : nat => if (i =? 2 * k) && (j =? 0) then C1 else 0%R))
Crunching:
(forall x : nat,
 (fun y : nat =>
  ((if (x / 2 =? k) && (y / 1 =? 0) then C1 else 0%R) *
   ∣0⟩ (x mod 2) (y mod 1))%C) =
 (fun j : nat => if (x =? 2 * k) && (j =? 0) then C1 else 0%R))
Crunching:
((fun x y : nat =>
  ((if (x / 2 =? k) && (y / 1 =? 0) then C1 else 0%R) *
   ∣0⟩ (x mod 2) (y mod 1))%C) =
 (fun i j : nat => if (i =? 2 * k) && (j =? 0) then C1 else 0%R))
Crunching:
((fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩ =
 (fun i j : nat => if (i =? 2 * k) && (j =? 0) then C1 else 0%R))
Crunching: (basis_vector n k ⊗ ∣0⟩ = basis_vector (2 * n) (2 * k))
Crunching: (basis_vector f1 f2 ⊗ ∣0⟩ = basis_vector (2 * f1) (2 * f2))
Crunching:
((fun i j : nat => if (i =? EQ) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩ =
 (fun i j : nat => if (i =? 2 * EQ) && (j =? 0) then C1 else 0%R))
Crunching:
((fun i j : nat => if (i =? EQ) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩ =
 (fun i j : nat => if (i =? 2 * EQ) && (j =? 0) then C1 else 0%R))
Crunching: (basis_vector LE EQ ⊗ ∣0⟩ = basis_vector (2 * LE) (2 * EQ))
Crunching:
(basis_vector (EQ + 1 + x) EQ ⊗ ∣0⟩ =
 basis_vector (2 * (EQ + 1 + x)) (2 * EQ))
Crunching:
(EQ < LE -> basis_vector LE EQ ⊗ ∣0⟩ = basis_vector (2 * LE) (2 * EQ))
Crunching:
((fun i j : nat => if (i =? EQ) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩ =
 (fun i j : nat => if (i =? 2 * EQ) && (j =? 0) then C1 else 0%R))
Crunching: (basis_vector LE EQ ⊗ ∣0⟩ = basis_vector (2 * LE) (2 * EQ))
Crunching:
(basis_vector (EQ + 1 + x) EQ ⊗ ∣0⟩ =
 basis_vector (2 * (EQ + 1 + x)) (2 * EQ))
Crunching:
((fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) ⊗ ∣0⟩ =
 (fun i j : nat => if (i =? 2 * k) && (j =? 0) then C1 else 0%R))
Crunching:
((fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) ⊗ ∣1⟩ =
 (fun i j : nat => if (i =? 2 * k + 1) && (j =? 0) then C1 else 0%R))
Crunching:
((fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) ⊗ ∣1⟩ =
 (fun i j : nat => if (i =? 2 * k + 1) && (j =? 0) then C1 else 0%R))
Crunching:
((fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) ⊗ ∣1⟩ =
 (fun i j : nat => if (i =? 2 * k + 1) && (j =? 0) then C1 else 0%R))
Crunching:
((fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) ⊗ ∣1⟩ =
 (fun i j : nat => if (i =? 2 * k + 1) && (j =? 0) then C1 else 0%R))
Crunching:
(((if (x / 2 =? k) && (y / 1 =? 0) then C1 else 0%R) *
  match x mod 2 with
  | 0 => match y mod 1 with
         | 0 | _ => 0%R
         end
  | 1 => match y mod 1 with
         | 0 => C1
         | S _ => 0%R
         end
  | S (S _) => 0%R
  end)%C = (if (x =? 2 * k + 1) && (y =? 0) then C1 else 0%R))
Crunching: (basis_vector n k ⊗ ∣1⟩ = basis_vector (2 * n) (2 * k + 1))
Crunching:
((fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) ⊗ ∣1⟩ =
 (fun i j : nat => if (i =? S (k + k)) && (j =? 0) then C1 else 0%R))
Crunching:
((fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) ⊗ ∣1⟩ =
 (fun i j : nat => if (i =? S (k + k)) && (j =? 0) then C1 else 0%R))
Crunching:
((fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) ⊗ ∣1⟩ =
 (fun i j : nat => if (i =? 2 * k + 1) && (j =? 0) then C1 else 0%R))
Crunching:
((fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) ⊗ ∣1⟩ =
 (fun i j : nat => if (i =? 2 * k + 1) && (j =? 0) then C1 else 0%R))
Crunching:
((fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) ⊗ ∣1⟩ =
 (fun i j : nat => if (i =? 2 * k + 1) && (j =? 0) then C1 else 0%R))
Crunching:
((fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) ⊗ ∣1⟩ =
 (fun i j : nat => if (i =? 2 * k + 1) && (j =? 0) then C1 else 0%R))
Crunching:
((fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) ⊗ ∣1⟩ =
 (fun i j : nat => if (i =? 2 * k + 1) && (j =? 0) then C1 else 0%R))
Crunching:
((fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) ⊗ ∣1⟩ =
 (fun i j : nat => if (i =? 2 * k + 1) && (j =? 0) then C1 else 0%R))
Crunching:
(S n <> 0 -> basis_vector (S n) k ⊗ ∣1⟩ = basis_vector (2 * S n) (2 * k + 1))
Crunching:
((fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) ⊗ ∣1⟩ =
 (fun i j : nat => if (i =? 2 * k + 1) && (j =? 0) then C1 else 0%R))
Crunching: (basis_vector n k ⊗ ∣1⟩ = basis_vector (2 * n) (2 * k + 1))
Crunching:
((fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) ⊗ ∣1⟩ =
 (fun i j : nat => if (i =? 2 * k + 1) && (j =? 0) then C1 else 0%R))
Crunching:
((fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) ⊗ ∣1⟩ =
 (fun i j : nat => if (i =? 2 * k + 1) && (j =? 0) then C1 else 0%R))
Crunching:
((fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) ⊗ ∣1⟩ =
 (fun i j : nat => if (i =? 2 * k + 1) && (j =? 0) then C1 else 0%R))
Crunching:
((fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) ⊗ ∣1⟩ =
 (fun i j : nat => if (i =? 2 * k + 1) && (j =? 0) then C1 else 0%R))
Crunching:
((fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) ⊗ ∣1⟩ =
 (fun i j : nat => if (i =? 2 * k + 1) && (j =? 0) then C1 else 0%R))
Crunching: (basis_vector n k ⊗ ∣1⟩ = basis_vector (2 * n) (2 * k + 1))
Crunching:
((fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) ⊗ ∣1⟩ =
 (fun i j : nat => if (i =? 2 * k + 1) && (j =? 0) then C1 else 0%R))
Crunching: (basis_vector n k ⊗ ∣1⟩ = basis_vector (2 * n) (2 * k + 1))
Crunching:
((fun i j : nat => if (i =? m) && (j =? 0) then C1 else 0%R) ⊗ ∣1⟩ =
 (fun i j : nat => if (i =? 2 * m + 1) && (j =? 0) then C1 else 0%R))
Crunching:
((fun i j : nat => if (i =? m) && (j =? 0) then C1 else 0%R) ⊗ ∣1⟩ =
 (fun i j : nat => if (i =? 2 * m + 1) && (j =? 0) then C1 else 0%R))
Crunching:
((fun i j : nat => if (i =? m) && (j =? 0) then C1 else 0%R) ⊗ ∣1⟩ =
 (fun i j : nat => if (i =? 2 * m + 1) && (j =? 0) then C1 else 0%R))
Crunching: (basis_vector n m ⊗ ∣1⟩ = basis_vector (2 * n) (2 * m + 1))
Crunching:
((fun i j : nat => if (i =? m) && (j =? 0) then C1 else 0%R) ⊗ ∣1⟩ =
 (fun i j : nat => if (i =? 2 * m + 1) && (j =? 0) then C1 else 0%R))
Crunching: (basis_vector n m ⊗ ∣1⟩ = basis_vector (2 * n) (2 * m + 1))
Crunching: (basis_vector H m ⊗ ∣1⟩ = basis_vector (2 * H) (2 * m + 1))
Crunching:
((fun i j : nat => if (i =? Compat) && (j =? 0) then C1 else 0%R) ⊗ ∣1⟩ =
 (fun i j : nat => if (i =? 2 * Compat + 1) && (j =? 0) then C1 else 0%R))
Crunching:
((fun i j : nat => if (i =? Hn) && (j =? 0) then C1 else 0%R) ⊗ ∣1⟩ =
 (fun i j : nat => if (i =? 2 * Hn + 1) && (j =? 0) then C1 else 0%R))
Crunching: (basis_vector n Hn ⊗ ∣1⟩ = basis_vector (2 * n) (2 * Hn + 1))
Crunching:
((fun i j : nat => if (i =? k) && (j =? 0) then C1 else 0%R) ⊗ ∣1⟩ =
 (fun i j : nat => if (i =? 2 * k + 1) && (j =? 0) then C1 else 0%R))
Crunching: (forall n : nat, n ⨂ ∣0⟩ = basis_vector (2 ^ n) 0)
Crunching: (forall n : nat, n ⨂ ∣0⟩ = basis_vector (2 ^ n) 0)
Crunching: (r ⨂ ∣0⟩ = basis_vector (2 ^ r) 0)
Crunching: (forall n : nat, n ⨂ ∣0⟩ = basis_vector (2 ^ n) 0)
Crunching:
(((((R1 + (R1 + R1) * (R1 + (R1 + R1))) *
    / ((R1 + R1) * ((R1 + R1) * (R1 + R1))) < f1)%R \/
   ((R1 + (R1 + R1) * (R1 + (R1 + R1))) *
    / ((R1 + R1) * ((R1 + R1) * (R1 + R1))))%R = f1) /\
  ((f1 < (R1 + (R1 + R1) * (R1 + (R1 + R1))) * / ((R1 + R1) * (R1 + R1)))%R \/
   f1 = ((R1 + (R1 + R1) * (R1 + (R1 + R1))) * / ((R1 + R1) * (R1 + R1)))%R)) /\
 (- (let (x, _) := exist_cos (f1 * f1) in x))%R = R0 ->
 (fix Ffix (x0 x1 x2 : nat) (x3 : nat -> nat -> R * R) {struct x0} :
      nat -> nat -> R * R :=
    match x0 with
    | 0 =>
        fun x4 x5 : nat =>
        if
         if
          (fix Ffix0 (x6 x7 : nat) {struct x6} : bool :=
             match x6 with
             | 0 => match x7 with
                    | 0 => true
                    | S _ => false
                    end
             | S x8 => match x7 with
                       | 0 => false
                       | S x9 => Ffix0 x8 x9
                       end
             end) x4 x5
         then
          (fix Ffix0 (x6 x7 : nat) {struct x6} : bool :=
             match x6 with
             | 0 => true
             | S x8 => match x7 with
                       | 0 => false
                       | S x9 => Ffix0 x8 x9
                       end
             end) x4 0
         else false
        then (R1, R0)
        else (R0, R0)
    | S x4 =>
        fun x5 x6 : nat =>
        (((let (H, _) :=
             Ffix x4 x1 x2 x3
               match x1 with
               | 0%nat => x1
               | S x7 =>
                   let (H, _) :=
                     (fix Ffix0 (x8 x9 x10 x11 : nat) {struct x8} :
                          nat * nat :=
                        match x8 with
                        | 0%nat => (x10, x11)
                        | S x12 =>
                            match x11 with
                            | 0%nat => Ffix0 x12 x9 (S x10) x9
                            | S x13 => Ffix0 x12 x9 x10 x13
                            end
                        end) x5 x7 0%nat x7 in
                   H
               end
               match x2 with
               | 0%nat => x2
               | S x7 =>
                   let (H, _) :=
                     (fix Ffix0 (x8 x9 x10 x11 : nat) {struct x8} :
                          nat * nat :=
                        match x8 with
                        | 0%nat => (x10, x11)
                        | S x12 =>
                            match x11 with
                            | 0%nat => Ffix0 x12 x9 (S x10) x9
                            | S x13 => Ffix0 x12 x9 x10 x13
                            end
                        end) x6 x7 0%nat x7 in
                   H
               end in
           H) *
          (let (H, _) :=
             x3
               match x1 with
               | 0%nat => x5
               | S x7 =>
                   (fix Ffix0 (x8 x9 : nat) {struct x8} : nat :=
                      match x8 with
                      | 0%nat => x8
                      | S x10 =>
                          match x9 with
                          | 0%nat => x8
                          | S x11 => Ffix0 x10 x11
                          end
                      end) x7
                     (let (_, H) :=
                        (fix Ffix0 (x8 x9 x10 x11 : nat) {struct x8} :
                             nat * nat :=
                           match x8 with
                           | 0%nat => (x10, x11)
                           | S x12 =>
                               match x11 with
                               | 0%nat => Ffix0 x12 x9 (S x10) x9
                               | S x13 => Ffix0 x12 x9 x10 x13
                               end
                           end) x5 x7 0%nat x7 in
                      H)
               end
               match x2 with
               | 0%nat => x6
               | S x7 =>
                   (fix Ffix0 (x8 x9 : nat) {struct x8} : nat :=
                      match x8 with
                      | 0%nat => x8
                      | S x10 =>
                          match x9 with
                          | 0%nat => x8
                          | S x11 => Ffix0 x10 x11
                          end
                      end) x7
                     (let (_, H) :=
                        (fix Ffix0 (x8 x9 x10 x11 : nat) {struct x8} :
                             nat * nat :=
                           match x8 with
                           | 0%nat => (x10, x11)
                           | S x12 =>
                               match x11 with
                               | 0%nat => Ffix0 x12 x9 (S x10) x9
                               | S x13 => Ffix0 x12 x9 x10 x13
                               end
                           end) x6 x7 0%nat x7 in
                      H)
               end in
           H) +
          -
          ((let (_, H) :=
              Ffix x4 x1 x2 x3
                match x1 with
                | 0%nat => x1
                | S x7 =>
                    let (H, _) :=
                      (fix Ffix0 (x8 x9 x10 x11 : nat) {struct x8} :
                           nat * nat :=
                         match x8 with
                         | 0%nat => (x10, x11)
                         | S x12 =>
                             match x11 with
                             | 0%nat => Ffix0 x12 x9 (S x10) x9
                             | S x13 => Ffix0 x12 x9 x10 x13
                             end
                         end) x5 x7 0%nat x7 in
                    H
                end
                match x2 with
                | 0%nat => x2
                | S x7 =>
                    let (H, _) :=
                      (fix Ffix0 (x8 x9 x10 x11 : nat) {struct x8} :
                           nat * nat :=
                         match x8 with
                         | 0%nat => (x10, x11)
                         | S x12 =>
                             match x11 with
                             | 0%nat => Ffix0 x12 x9 (S x10) x9
                             | S x13 => Ffix0 x12 x9 x10 x13
                             end
                         end) x6 x7 0%nat x7 in
                    H
                end in
            H) *
           (let (_, H) :=
              x3
                match x1 with
                | 0%nat => x5
                | S x7 =>
                    (fix Ffix0 (x8 x9 : nat) {struct x8} : nat :=
                       match x8 with
                       | 0%nat => x8
                       | S x10 =>
                           match x9 with
                           | 0%nat => x8
                           | S x11 => Ffix0 x10 x11
                           end
                       end) x7
                      (let (_, H) :=
                         (fix Ffix0 (x8 x9 x10 x11 : nat) {struct x8} :
                              nat * nat :=
                            match x8 with
                            | 0%nat => (x10, x11)
                            | S x12 =>
                                match x11 with
                                | 0%nat => Ffix0 x12 x9 (S x10) x9
                                | S x13 => Ffix0 x12 x9 x10 x13
                                end
                            end) x5 x7 0%nat x7 in
                       H)
                end
                match x2 with
                | 0%nat => x6
                | S x7 =>
                    (fix Ffix0 (x8 x9 : nat) {struct x8} : nat :=
                       match x8 with
                       | 0%nat => x8
                       | S x10 =>
                           match x9 with
                           | 0%nat => x8
                           | S x11 => Ffix0 x10 x11
                           end
                       end) x7
                      (let (_, H) :=
                         (fix Ffix0 (x8 x9 x10 x11 : nat) {struct x8} :
                              nat * nat :=
                            match x8 with
                            | 0%nat => (x10, x11)
                            | S x12 =>
                                match x11 with
                                | 0%nat => Ffix0 x12 x9 (S x10) x9
                                | S x13 => Ffix0 x12 x9 x10 x13
                                end
                            end) x6 x7 0%nat x7 in
                       H)
                end in
            H)))%R,
        ((let (H, _) :=
            Ffix x4 x1 x2 x3
              match x1 with
              | 0%nat => x1
              | S x7 =>
                  let (H, _) :=
                    (fix Ffix0 (x8 x9 x10 x11 : nat) {struct x8} :
                         nat * nat :=
                       match x8 with
                       | 0%nat => (x10, x11)
                       | S x12 =>
                           match x11 with
                           | 0%nat => Ffix0 x12 x9 (S x10) x9
                           | S x13 => Ffix0 x12 x9 x10 x13
                           end
                       end) x5 x7 0%nat x7 in
                  H
              end
              match x2 with
              | 0%nat => x2
              | S x7 =>
                  let (H, _) :=
                    (fix Ffix0 (x8 x9 x10 x11 : nat) {struct x8} :
                         nat * nat :=
                       match x8 with
                       | 0%nat => (x10, x11)
                       | S x12 =>
                           match x11 with
                           | 0%nat => Ffix0 x12 x9 (S x10) x9
                           | S x13 => Ffix0 x12 x9 x10 x13
                           end
                       end) x6 x7 0%nat x7 in
                  H
              end in
          H) *
         (let (_, H) :=
            x3
              match x1 with
              | 0%nat => x5
              | S x7 =>
                  (fix Ffix0 (x8 x9 : nat) {struct x8} : nat :=
                     match x8 with
                     | 0%nat => x8
                     | S x10 =>
                         match x9 with
                         | 0%nat => x8
                         | S x11 => Ffix0 x10 x11
                         end
                     end) x7
                    (let (_, H) :=
                       (fix Ffix0 (x8 x9 x10 x11 : nat) {struct x8} :
                            nat * nat :=
                          match x8 with
                          | 0%nat => (x10, x11)
                          | S x12 =>
                              match x11 with
                              | 0%nat => Ffix0 x12 x9 (S x10) x9
                              | S x13 => Ffix0 x12 x9 x10 x13
                              end
                          end) x5 x7 0%nat x7 in
                     H)
              end
              match x2 with
              | 0%nat => x6
              | S x7 =>
                  (fix Ffix0 (x8 x9 : nat) {struct x8} : nat :=
                     match x8 with
                     | 0%nat => x8
                     | S x10 =>
                         match x9 with
                         | 0%nat => x8
                         | S x11 => Ffix0 x10 x11
                         end
                     end) x7
                    (let (_, H) :=
                       (fix Ffix0 (x8 x9 x10 x11 : nat) {struct x8} :
                            nat * nat :=
                          match x8 with
                          | 0%nat => (x10, x11)
                          | S x12 =>
                              match x11 with
                              | 0%nat => Ffix0 x12 x9 (S x10) x9
                              | S x13 => Ffix0 x12 x9 x10 x13
                              end
                          end) x6 x7 0%nat x7 in
                     H)
              end in
          H) +
         (let (_, H) :=
            Ffix x4 x1 x2 x3
              match x1 with
              | 0%nat => x1
              | S x7 =>
                  let (H, _) :=
                    (fix Ffix0 (x8 x9 x10 x11 : nat) {struct x8} :
                         nat * nat :=
                       match x8 with
                       | 0%nat => (x10, x11)
                       | S x12 =>
                           match x11 with
                           | 0%nat => Ffix0 x12 x9 (S x10) x9
                           | S x13 => Ffix0 x12 x9 x10 x13
                           end
                       end) x5 x7 0%nat x7 in
                  H
              end
              match x2 with
              | 0%nat => x2
              | S x7 =>
                  let (H, _) :=
                    (fix Ffix0 (x8 x9 x10 x11 : nat) {struct x8} :
                         nat * nat :=
                       match x8 with
                       | 0%nat => (x10, x11)
                       | S x12 =>
                           match x11 with
                           | 0%nat => Ffix0 x12 x9 (S x10) x9
                           | S x13 => Ffix0 x12 x9 x10 x13
                           end
                       end) x6 x7 0%nat x7 in
                  H
              end in
          H) *
         (let (H, _) :=
            x3
              match x1 with
              | 0%nat => x5
              | S x7 =>
                  (fix Ffix0 (x8 x9 : nat) {struct x8} : nat :=
                     match x8 with
                     | 0%nat => x8
                     | S x10 =>
                         match x9 with
                         | 0%nat => x8
                         | S x11 => Ffix0 x10 x11
                         end
                     end) x7
                    (let (_, H) :=
                       (fix Ffix0 (x8 x9 x10 x11 : nat) {struct x8} :
                            nat * nat :=
                          match x8 with
                          | 0%nat => (x10, x11)
                          | S x12 =>
                              match x11 with
                              | 0%nat => Ffix0 x12 x9 (S x10) x9
                              | S x13 => Ffix0 x12 x9 x10 x13
                              end
                          end) x5 x7 0%nat x7 in
                     H)
              end
              match x2 with
              | 0%nat => x6
              | S x7 =>
                  (fix Ffix0 (x8 x9 : nat) {struct x8} : nat :=
                     match x8 with
                     | 0%nat => x8
                     | S x10 =>
                         match x9 with
                         | 0%nat => x8
                         | S x11 => Ffix0 x10 x11
                         end
                     end) x7
                    (let (_, H) :=
                       (fix Ffix0 (x8 x9 x10 x11 : nat) {struct x8} :
                            nat * nat :=
                          match x8 with
                          | 0%nat => (x10, x11)
                          | S x12 =>
                              match x11 with
                              | 0%nat => Ffix0 x12 x9 (S x10) x9
                              | S x13 => Ffix0 x12 x9 x10 x13
                              end
                          end) x6 x7 0%nat x7 in
                     H)
              end in
          H))%R)
    end) m 2 1
   (fun x0 x1 : nat =>
    match x0 with
    | 0 => match x1 with
           | 0 => (R1, R0)
           | S _ => (R0, R0)
           end
    | 1 => match x1 with
           | 0 | _ => (R0, R0)
           end
    | S (S _) => (R0, R0)
    end) =
 (fun x0 x1 : nat =>
  if
   if
    (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
       match x2 with
       | 0 => match x3 with
              | 0 => true
              | S _ => false
              end
       | S x4 => match x3 with
                 | 0 => false
                 | S x5 => Ffix x4 x5
                 end
       end) x0 0
   then
    (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
       match x2 with
       | 0 => match x3 with
              | 0 => true
              | S _ => false
              end
       | S x4 => match x3 with
                 | 0 => false
                 | S x5 => Ffix x4 x5
                 end
       end) x1 0
   else false
  then (R1, R0)
  else (R0, R0)))
Crunching: (r ⨂ ∣0⟩ = basis_vector (2 ^ r) 0)
Crunching: (forall n : nat, n ⨂ ∣0⟩ = basis_vector (2 ^ n) 0)
Crunching:
(((((R1 + (R1 + R1) * (R1 + (R1 + R1))) *
    / ((R1 + R1) * ((R1 + R1) * (R1 + R1))) < f1)%R \/
   ((R1 + (R1 + R1) * (R1 + (R1 + R1))) *
    / ((R1 + R1) * ((R1 + R1) * (R1 + R1))))%R = f1) /\
  ((f1 < (R1 + (R1 + R1) * (R1 + (R1 + R1))) * / ((R1 + R1) * (R1 + R1)))%R \/
   f1 = ((R1 + (R1 + R1) * (R1 + (R1 + R1))) * / ((R1 + R1) * (R1 + R1)))%R)) /\
 (- (let (x, _) := exist_cos (f1 * f1) in x))%R = R0 ->
 (fix Ffix (x0 x1 x2 : nat) (x3 : nat -> nat -> R * R) {struct x0} :
      nat -> nat -> R * R :=
    match x0 with
    | 0 =>
        fun x4 x5 : nat =>
        if
         if
          (fix Ffix0 (x6 x7 : nat) {struct x6} : bool :=
             match x6 with
             | 0 => match x7 with
                    | 0 => true
                    | S _ => false
                    end
             | S x8 => match x7 with
                       | 0 => false
                       | S x9 => Ffix0 x8 x9
                       end
             end) x4 x5
         then
          (fix Ffix0 (x6 x7 : nat) {struct x6} : bool :=
             match x6 with
             | 0 => true
             | S x8 => match x7 with
                       | 0 => false
                       | S x9 => Ffix0 x8 x9
                       end
             end) x4 0
         else false
        then (R1, R0)
        else (R0, R0)
    | S x4 =>
        fun x5 x6 : nat =>
        (((let (H, _) :=
             Ffix x4 x1 x2 x3
               match x1 with
               | 0%nat => x1
               | S x7 =>
                   let (H, _) :=
                     (fix Ffix0 (x8 x9 x10 x11 : nat) {struct x8} :
                          nat * nat :=
                        match x8 with
                        | 0%nat => (x10, x11)
                        | S x12 =>
                            match x11 with
                            | 0%nat => Ffix0 x12 x9 (S x10) x9
                            | S x13 => Ffix0 x12 x9 x10 x13
                            end
                        end) x5 x7 0%nat x7 in
                   H
               end
               match x2 with
               | 0%nat => x2
               | S x7 =>
                   let (H, _) :=
                     (fix Ffix0 (x8 x9 x10 x11 : nat) {struct x8} :
                          nat * nat :=
                        match x8 with
                        | 0%nat => (x10, x11)
                        | S x12 =>
                            match x11 with
                            | 0%nat => Ffix0 x12 x9 (S x10) x9
                            | S x13 => Ffix0 x12 x9 x10 x13
                            end
                        end) x6 x7 0%nat x7 in
                   H
               end in
           H) *
          (let (H, _) :=
             x3
               match x1 with
               | 0%nat => x5
               | S x7 =>
                   (fix Ffix0 (x8 x9 : nat) {struct x8} : nat :=
                      match x8 with
                      | 0%nat => x8
                      | S x10 =>
                          match x9 with
                          | 0%nat => x8
                          | S x11 => Ffix0 x10 x11
                          end
                      end) x7
                     (let (_, H) :=
                        (fix Ffix0 (x8 x9 x10 x11 : nat) {struct x8} :
                             nat * nat :=
                           match x8 with
                           | 0%nat => (x10, x11)
                           | S x12 =>
                               match x11 with
                               | 0%nat => Ffix0 x12 x9 (S x10) x9
                               | S x13 => Ffix0 x12 x9 x10 x13
                               end
                           end) x5 x7 0%nat x7 in
                      H)
               end
               match x2 with
               | 0%nat => x6
               | S x7 =>
                   (fix Ffix0 (x8 x9 : nat) {struct x8} : nat :=
                      match x8 with
                      | 0%nat => x8
                      | S x10 =>
                          match x9 with
                          | 0%nat => x8
                          | S x11 => Ffix0 x10 x11
                          end
                      end) x7
                     (let (_, H) :=
                        (fix Ffix0 (x8 x9 x10 x11 : nat) {struct x8} :
                             nat * nat :=
                           match x8 with
                           | 0%nat => (x10, x11)
                           | S x12 =>
                               match x11 with
                               | 0%nat => Ffix0 x12 x9 (S x10) x9
                               | S x13 => Ffix0 x12 x9 x10 x13
                               end
                           end) x6 x7 0%nat x7 in
                      H)
               end in
           H) +
          -
          ((let (_, H) :=
              Ffix x4 x1 x2 x3
                match x1 with
                | 0%nat => x1
                | S x7 =>
                    let (H, _) :=
                      (fix Ffix0 (x8 x9 x10 x11 : nat) {struct x8} :
                           nat * nat :=
                         match x8 with
                         | 0%nat => (x10, x11)
                         | S x12 =>
                             match x11 with
                             | 0%nat => Ffix0 x12 x9 (S x10) x9
                             | S x13 => Ffix0 x12 x9 x10 x13
                             end
                         end) x5 x7 0%nat x7 in
                    H
                end
                match x2 with
                | 0%nat => x2
                | S x7 =>
                    let (H, _) :=
                      (fix Ffix0 (x8 x9 x10 x11 : nat) {struct x8} :
                           nat * nat :=
                         match x8 with
                         | 0%nat => (x10, x11)
                         | S x12 =>
                             match x11 with
                             | 0%nat => Ffix0 x12 x9 (S x10) x9
                             | S x13 => Ffix0 x12 x9 x10 x13
                             end
                         end) x6 x7 0%nat x7 in
                    H
                end in
            H) *
           (let (_, H) :=
              x3
                match x1 with
                | 0%nat => x5
                | S x7 =>
                    (fix Ffix0 (x8 x9 : nat) {struct x8} : nat :=
                       match x8 with
                       | 0%nat => x8
                       | S x10 =>
                           match x9 with
                           | 0%nat => x8
                           | S x11 => Ffix0 x10 x11
                           end
                       end) x7
                      (let (_, H) :=
                         (fix Ffix0 (x8 x9 x10 x11 : nat) {struct x8} :
                              nat * nat :=
                            match x8 with
                            | 0%nat => (x10, x11)
                            | S x12 =>
                                match x11 with
                                | 0%nat => Ffix0 x12 x9 (S x10) x9
                                | S x13 => Ffix0 x12 x9 x10 x13
                                end
                            end) x5 x7 0%nat x7 in
                       H)
                end
                match x2 with
                | 0%nat => x6
                | S x7 =>
                    (fix Ffix0 (x8 x9 : nat) {struct x8} : nat :=
                       match x8 with
                       | 0%nat => x8
                       | S x10 =>
                           match x9 with
                           | 0%nat => x8
                           | S x11 => Ffix0 x10 x11
                           end
                       end) x7
                      (let (_, H) :=
                         (fix Ffix0 (x8 x9 x10 x11 : nat) {struct x8} :
                              nat * nat :=
                            match x8 with
                            | 0%nat => (x10, x11)
                            | S x12 =>
                                match x11 with
                                | 0%nat => Ffix0 x12 x9 (S x10) x9
                                | S x13 => Ffix0 x12 x9 x10 x13
                                end
                            end) x6 x7 0%nat x7 in
                       H)
                end in
            H)))%R,
        ((let (H, _) :=
            Ffix x4 x1 x2 x3
              match x1 with
              | 0%nat => x1
              | S x7 =>
                  let (H, _) :=
                    (fix Ffix0 (x8 x9 x10 x11 : nat) {struct x8} :
                         nat * nat :=
                       match x8 with
                       | 0%nat => (x10, x11)
                       | S x12 =>
                           match x11 with
                           | 0%nat => Ffix0 x12 x9 (S x10) x9
                           | S x13 => Ffix0 x12 x9 x10 x13
                           end
                       end) x5 x7 0%nat x7 in
                  H
              end
              match x2 with
              | 0%nat => x2
              | S x7 =>
                  let (H, _) :=
                    (fix Ffix0 (x8 x9 x10 x11 : nat) {struct x8} :
                         nat * nat :=
                       match x8 with
                       | 0%nat => (x10, x11)
                       | S x12 =>
                           match x11 with
                           | 0%nat => Ffix0 x12 x9 (S x10) x9
                           | S x13 => Ffix0 x12 x9 x10 x13
                           end
                       end) x6 x7 0%nat x7 in
                  H
              end in
          H) *
         (let (_, H) :=
            x3
              match x1 with
              | 0%nat => x5
              | S x7 =>
                  (fix Ffix0 (x8 x9 : nat) {struct x8} : nat :=
                     match x8 with
                     | 0%nat => x8
                     | S x10 =>
                         match x9 with
                         | 0%nat => x8
                         | S x11 => Ffix0 x10 x11
                         end
                     end) x7
                    (let (_, H) :=
                       (fix Ffix0 (x8 x9 x10 x11 : nat) {struct x8} :
                            nat * nat :=
                          match x8 with
                          | 0%nat => (x10, x11)
                          | S x12 =>
                              match x11 with
                              | 0%nat => Ffix0 x12 x9 (S x10) x9
                              | S x13 => Ffix0 x12 x9 x10 x13
                              end
                          end) x5 x7 0%nat x7 in
                     H)
              end
              match x2 with
              | 0%nat => x6
              | S x7 =>
                  (fix Ffix0 (x8 x9 : nat) {struct x8} : nat :=
                     match x8 with
                     | 0%nat => x8
                     | S x10 =>
                         match x9 with
                         | 0%nat => x8
                         | S x11 => Ffix0 x10 x11
                         end
                     end) x7
                    (let (_, H) :=
                       (fix Ffix0 (x8 x9 x10 x11 : nat) {struct x8} :
                            nat * nat :=
                          match x8 with
                          | 0%nat => (x10, x11)
                          | S x12 =>
                              match x11 with
                              | 0%nat => Ffix0 x12 x9 (S x10) x9
                              | S x13 => Ffix0 x12 x9 x10 x13
                              end
                          end) x6 x7 0%nat x7 in
                     H)
              end in
          H) +
         (let (_, H) :=
            Ffix x4 x1 x2 x3
              match x1 with
              | 0%nat => x1
              | S x7 =>
                  let (H, _) :=
                    (fix Ffix0 (x8 x9 x10 x11 : nat) {struct x8} :
                         nat * nat :=
                       match x8 with
                       | 0%nat => (x10, x11)
                       | S x12 =>
                           match x11 with
                           | 0%nat => Ffix0 x12 x9 (S x10) x9
                           | S x13 => Ffix0 x12 x9 x10 x13
                           end
                       end) x5 x7 0%nat x7 in
                  H
              end
              match x2 with
              | 0%nat => x2
              | S x7 =>
                  let (H, _) :=
                    (fix Ffix0 (x8 x9 x10 x11 : nat) {struct x8} :
                         nat * nat :=
                       match x8 with
                       | 0%nat => (x10, x11)
                       | S x12 =>
                           match x11 with
                           | 0%nat => Ffix0 x12 x9 (S x10) x9
                           | S x13 => Ffix0 x12 x9 x10 x13
                           end
                       end) x6 x7 0%nat x7 in
                  H
              end in
          H) *
         (let (H, _) :=
            x3
              match x1 with
              | 0%nat => x5
              | S x7 =>
                  (fix Ffix0 (x8 x9 : nat) {struct x8} : nat :=
                     match x8 with
                     | 0%nat => x8
                     | S x10 =>
                         match x9 with
                         | 0%nat => x8
                         | S x11 => Ffix0 x10 x11
                         end
                     end) x7
                    (let (_, H) :=
                       (fix Ffix0 (x8 x9 x10 x11 : nat) {struct x8} :
                            nat * nat :=
                          match x8 with
                          | 0%nat => (x10, x11)
                          | S x12 =>
                              match x11 with
                              | 0%nat => Ffix0 x12 x9 (S x10) x9
                              | S x13 => Ffix0 x12 x9 x10 x13
                              end
                          end) x5 x7 0%nat x7 in
                     H)
              end
              match x2 with
              | 0%nat => x6
              | S x7 =>
                  (fix Ffix0 (x8 x9 : nat) {struct x8} : nat :=
                     match x8 with
                     | 0%nat => x8
                     | S x10 =>
                         match x9 with
                         | 0%nat => x8
                         | S x11 => Ffix0 x10 x11
                         end
                     end) x7
                    (let (_, H) :=
                       (fix Ffix0 (x8 x9 x10 x11 : nat) {struct x8} :
                            nat * nat :=
                          match x8 with
                          | 0%nat => (x10, x11)
                          | S x12 =>
                              match x11 with
                              | 0%nat => Ffix0 x12 x9 (S x10) x9
                              | S x13 => Ffix0 x12 x9 x10 x13
                              end
                          end) x6 x7 0%nat x7 in
                     H)
              end in
          H))%R)
    end) m 2 1
   (fun x0 x1 : nat =>
    match x0 with
    | 0 => match x1 with
           | 0 => (R1, R0)
           | S _ => (R0, R0)
           end
    | 1 => match x1 with
           | 0 | _ => (R0, R0)
           end
    | S (S _) => (R0, R0)
    end) =
 (fun x0 x1 : nat =>
  if
   if
    (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
       match x2 with
       | 0 => match x3 with
              | 0 => true
              | S _ => false
              end
       | S x4 => match x3 with
                 | 0 => false
                 | S x5 => Ffix x4 x5
                 end
       end) x0 0
   then
    (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
       match x2 with
       | 0 => match x3 with
              | 0 => true
              | S _ => false
              end
       | S x4 => match x3 with
                 | 0 => false
                 | S x5 => Ffix x4 x5
                 end
       end) x1 0
   else false
  then (R1, R0)
  else (R0, R0)))
Crunching: (r ⨂ ∣0⟩ = basis_vector (2 ^ r) 0)
Crunching:
(r ⨂ ∣0⟩ = (fun i j : nat => if (i =? 0) && (j =? 0) then C1 else 0%R))
Crunching:
(exists N : nat, forall n : nat, n >= N -> (R_dist (PI_2_3_7_tg n) 0 < eps)%R)
Crunching: (forall n : nat, n ⨂ ∣0⟩ = basis_vector (2 ^ n) 0)
Crunching:
(((((R1 + (R1 + R1) * (R1 + (R1 + R1))) *
    (/ (R1 + R1) * / ((R1 + R1) * (R1 + R1))) < f1)%R \/
   ((R1 + (R1 + R1) * (R1 + (R1 + R1))) *
    (/ (R1 + R1) * / ((R1 + R1) * (R1 + R1))))%R = f1) /\
  ((f1 < (R1 + (R1 + R1) * (R1 + (R1 + R1))) * / ((R1 + R1) * (R1 + R1)))%R \/
   f1 = ((R1 + (R1 + R1) * (R1 + (R1 + R1))) * / ((R1 + R1) * (R1 + R1)))%R)) /\
 (- (let (a, _) := exist_cos (f1 * f1) in a))%R = R0 ->
 (fun x y : nat =>
  if
   if
    (fix eqb (n m : nat) {struct n} : bool :=
       match n with
       | 0 => match m with
              | 0 => true
              | S _ => false
              end
       | S n' => match m with
                 | 0 => false
                 | S m' => eqb n' m'
                 end
       end) x y
   then
    (fix leb (n m : nat) {struct n} : bool :=
       match n with
       | 0 => true
       | S n' => match m with
                 | 0 => false
                 | S m' => leb n' m'
                 end
       end) x 0
   else false
  then (R1, R0)
  else (R0, R0)) =
 (fun i j : nat =>
  if
   if
    (fix eqb (n m : nat) {struct n} : bool :=
       match n with
       | 0 => match m with
              | 0 => true
              | S _ => false
              end
       | S n' => match m with
                 | 0 => false
                 | S m' => eqb n' m'
                 end
       end) i 0
   then
    (fix eqb (n m : nat) {struct n} : bool :=
       match n with
       | 0 => match m with
              | 0 => true
              | S _ => false
              end
       | S n' => match m with
                 | 0 => false
                 | S m' => eqb n' m'
                 end
       end) j 0
   else false
  then (R1, R0)
  else (R0, R0)))
Crunching: (0 ⨂ ∣0⟩ = basis_vector 1 0)
Crunching:
(((((R1 + (R1 + R1) * (R1 + (R1 + R1))) *
    (/ (R1 + R1) * / ((R1 + R1) * (R1 + R1))) < f1)%R \/
   ((R1 + (R1 + R1) * (R1 + (R1 + R1))) *
    (/ (R1 + R1) * / ((R1 + R1) * (R1 + R1))))%R = f1) /\
  ((f1 < (R1 + (R1 + R1) * (R1 + (R1 + R1))) * / ((R1 + R1) * (R1 + R1)))%R \/
   f1 = ((R1 + (R1 + R1) * (R1 + (R1 + R1))) * / ((R1 + R1) * (R1 + R1)))%R)) /\
 (- (let (a, _) := exist_cos (f1 * f1) in a))%R = R0 ->
 (fun x y : nat =>
  if
   if
    (fix eqb (n m : nat) {struct n} : bool :=
       match n with
       | 0 => match m with
              | 0 => true
              | S _ => false
              end
       | S n' => match m with
                 | 0 => false
                 | S m' => eqb n' m'
                 end
       end) x y
   then
    (fix leb (n m : nat) {struct n} : bool :=
       match n with
       | 0 => true
       | S n' => match m with
                 | 0 => false
                 | S m' => leb n' m'
                 end
       end) x 0
   else false
  then (R1, R0)
  else (R0, R0)) =
 (fun i j : nat =>
  if
   if
    (fix eqb (n m : nat) {struct n} : bool :=
       match n with
       | 0 => match m with
              | 0 => true
              | S _ => false
              end
       | S n' => match m with
                 | 0 => false
                 | S m' => eqb n' m'
                 end
       end) i 0
   then
    (fix eqb (n m : nat) {struct n} : bool :=
       match n with
       | 0 => match m with
              | 0 => true
              | S _ => false
              end
       | S n' => match m with
                 | 0 => false
                 | S m' => eqb n' m'
                 end
       end) j 0
   else false
  then (R1, R0)
  else (R0, R0)))
Crunching:
(forall x : nat,
 (fun x0 : nat =>
  if
   if
    (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
       match x1 with
       | 0 => match x2 with
              | 0 => true
              | S _ => false
              end
       | S x3 => match x2 with
                 | 0 => false
                 | S x4 => Ffix x3 x4
                 end
       end) x x0
   then
    (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
       match x1 with
       | 0 => true
       | S x3 => match x2 with
                 | 0 => false
                 | S x4 => Ffix x3 x4
                 end
       end) x 0
   else false
  then (R1, R0)
  else (R0, R0)) =
 (fun x0 : nat =>
  if
   if
    (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
       match x1 with
       | 0 => match x2 with
              | 0 => true
              | S _ => false
              end
       | S x3 => match x2 with
                 | 0 => false
                 | S x4 => Ffix x3 x4
                 end
       end) x 0
   then
    (fix Ffix (x1 x2 : nat) {struct x1} : bool :=
       match x1 with
       | 0 => match x2 with
              | 0 => true
              | S _ => false
              end
       | S x3 => match x2 with
                 | 0 => false
                 | S x4 => Ffix x3 x4
                 end
       end) x0 0
   else false
  then (R1, R0)
  else (R0, R0)))
Crunching:
(((((R1 + (R1 + R1) * (R1 + (R1 + R1))) *
    / ((R1 + R1) * ((R1 + R1) * (R1 + R1))) < f1)%R \/
   ((R1 + (R1 + R1) * (R1 + (R1 + R1))) *
    / ((R1 + R1) * ((R1 + R1) * (R1 + R1))))%R = f1) /\
  ((f1 < (R1 + (R1 + R1) * (R1 + (R1 + R1))) * / ((R1 + R1) * (R1 + R1)))%R \/
   f1 = ((R1 + (R1 + R1) * (R1 + (R1 + R1))) * / ((R1 + R1) * (R1 + R1)))%R)) /\
 (- (let (x, _) := exist_cos (f1 * f1) in x))%R = R0 ->
 (fix Ffix (x0 x1 x2 : nat) (x3 : nat -> nat -> R * R) {struct x0} :
      nat -> nat -> R * R :=
    match x0 with
    | 0 =>
        fun x4 x5 : nat =>
        if
         if
          (fix Ffix0 (x6 x7 : nat) {struct x6} : bool :=
             match x6 with
             | 0 => match x7 with
                    | 0 => true
                    | S _ => false
                    end
             | S x8 => match x7 with
                       | 0 => false
                       | S x9 => Ffix0 x8 x9
                       end
             end) x4 x5
         then
          (fix Ffix0 (x6 x7 : nat) {struct x6} : bool :=
             match x6 with
             | 0 => true
             | S x8 => match x7 with
                       | 0 => false
                       | S x9 => Ffix0 x8 x9
                       end
             end) x4 0
         else false
        then (R1, R0)
        else (R0, R0)
    | S x4 =>
        fun x5 x6 : nat =>
        (((let (H, _) :=
             Ffix x4 x1 x2 x3
               match x1 with
               | 0%nat => x1
               | S x7 =>
                   let (H, _) :=
                     (fix Ffix0 (x8 x9 x10 x11 : nat) {struct x8} :
                          nat * nat :=
                        match x8 with
                        | 0%nat => (x10, x11)
                        | S x12 =>
                            match x11 with
                            | 0%nat => Ffix0 x12 x9 (S x10) x9
                            | S x13 => Ffix0 x12 x9 x10 x13
                            end
                        end) x5 x7 0%nat x7 in
                   H
               end
               match x2 with
               | 0%nat => x2
               | S x7 =>
                   let (H, _) :=
                     (fix Ffix0 (x8 x9 x10 x11 : nat) {struct x8} :
                          nat * nat :=
                        match x8 with
                        | 0%nat => (x10, x11)
                        | S x12 =>
                            match x11 with
                            | 0%nat => Ffix0 x12 x9 (S x10) x9
                            | S x13 => Ffix0 x12 x9 x10 x13
                            end
                        end) x6 x7 0%nat x7 in
                   H
               end in
           H) *
          (let (H, _) :=
             x3
               match x1 with
               | 0%nat => x5
               | S x7 =>
                   (fix Ffix0 (x8 x9 : nat) {struct x8} : nat :=
                      match x8 with
                      | 0%nat => x8
                      | S x10 =>
                          match x9 with
                          | 0%nat => x8
                          | S x11 => Ffix0 x10 x11
                          end
                      end) x7
                     (let (_, H) :=
                        (fix Ffix0 (x8 x9 x10 x11 : nat) {struct x8} :
                             nat * nat :=
                           match x8 with
                           | 0%nat => (x10, x11)
                           | S x12 =>
                               match x11 with
                               | 0%nat => Ffix0 x12 x9 (S x10) x9
                               | S x13 => Ffix0 x12 x9 x10 x13
                               end
                           end) x5 x7 0%nat x7 in
                      H)
               end
               match x2 with
               | 0%nat => x6
               | S x7 =>
                   (fix Ffix0 (x8 x9 : nat) {struct x8} : nat :=
                      match x8 with
                      | 0%nat => x8
                      | S x10 =>
                          match x9 with
                          | 0%nat => x8
                          | S x11 => Ffix0 x10 x11
                          end
                      end) x7
                     (let (_, H) :=
                        (fix Ffix0 (x8 x9 x10 x11 : nat) {struct x8} :
                             nat * nat :=
                           match x8 with
                           | 0%nat => (x10, x11)
                           | S x12 =>
                               match x11 with
                               | 0%nat => Ffix0 x12 x9 (S x10) x9
                               | S x13 => Ffix0 x12 x9 x10 x13
                               end
                           end) x6 x7 0%nat x7 in
                      H)
               end in
           H) +
          -
          ((let (_, H) :=
              Ffix x4 x1 x2 x3
                match x1 with
                | 0%nat => x1
                | S x7 =>
                    let (H, _) :=
                      (fix Ffix0 (x8 x9 x10 x11 : nat) {struct x8} :
                           nat * nat :=
                         match x8 with
                         | 0%nat => (x10, x11)
                         | S x12 =>
                             match x11 with
                             | 0%nat => Ffix0 x12 x9 (S x10) x9
                             | S x13 => Ffix0 x12 x9 x10 x13
                             end
                         end) x5 x7 0%nat x7 in
                    H
                end
                match x2 with
                | 0%nat => x2
                | S x7 =>
                    let (H, _) :=
                      (fix Ffix0 (x8 x9 x10 x11 : nat) {struct x8} :
                           nat * nat :=
                         match x8 with
                         | 0%nat => (x10, x11)
                         | S x12 =>
                             match x11 with
                             | 0%nat => Ffix0 x12 x9 (S x10) x9
                             | S x13 => Ffix0 x12 x9 x10 x13
                             end
                         end) x6 x7 0%nat x7 in
                    H
                end in
            H) *
           (let (_, H) :=
              x3
                match x1 with
                | 0%nat => x5
                | S x7 =>
                    (fix Ffix0 (x8 x9 : nat) {struct x8} : nat :=
                       match x8 with
                       | 0%nat => x8
                       | S x10 =>
                           match x9 with
                           | 0%nat => x8
                           | S x11 => Ffix0 x10 x11
                           end
                       end) x7
                      (let (_, H) :=
                         (fix Ffix0 (x8 x9 x10 x11 : nat) {struct x8} :
                              nat * nat :=
                            match x8 with
                            | 0%nat => (x10, x11)
                            | S x12 =>
                                match x11 with
                                | 0%nat => Ffix0 x12 x9 (S x10) x9
                                | S x13 => Ffix0 x12 x9 x10 x13
                                end
                            end) x5 x7 0%nat x7 in
                       H)
                end
                match x2 with
                | 0%nat => x6
                | S x7 =>
                    (fix Ffix0 (x8 x9 : nat) {struct x8} : nat :=
                       match x8 with
                       | 0%nat => x8
                       | S x10 =>
                           match x9 with
                           | 0%nat => x8
                           | S x11 => Ffix0 x10 x11
                           end
                       end) x7
                      (let (_, H) :=
                         (fix Ffix0 (x8 x9 x10 x11 : nat) {struct x8} :
                              nat * nat :=
                            match x8 with
                            | 0%nat => (x10, x11)
                            | S x12 =>
                                match x11 with
                                | 0%nat => Ffix0 x12 x9 (S x10) x9
                                | S x13 => Ffix0 x12 x9 x10 x13
                                end
                            end) x6 x7 0%nat x7 in
                       H)
                end in
            H)))%R,
        ((let (H, _) :=
            Ffix x4 x1 x2 x3
              match x1 with
              | 0%nat => x1
              | S x7 =>
                  let (H, _) :=
                    (fix Ffix0 (x8 x9 x10 x11 : nat) {struct x8} :
                         nat * nat :=
                       match x8 with
                       | 0%nat => (x10, x11)
                       | S x12 =>
                           match x11 with
                           | 0%nat => Ffix0 x12 x9 (S x10) x9
                           | S x13 => Ffix0 x12 x9 x10 x13
                           end
                       end) x5 x7 0%nat x7 in
                  H
              end
              match x2 with
              | 0%nat => x2
              | S x7 =>
                  let (H, _) :=
                    (fix Ffix0 (x8 x9 x10 x11 : nat) {struct x8} :
                         nat * nat :=
                       match x8 with
                       | 0%nat => (x10, x11)
                       | S x12 =>
                           match x11 with
                           | 0%nat => Ffix0 x12 x9 (S x10) x9
                           | S x13 => Ffix0 x12 x9 x10 x13
                           end
                       end) x6 x7 0%nat x7 in
                  H
              end in
          H) *
         (let (_, H) :=
            x3
              match x1 with
              | 0%nat => x5
              | S x7 =>
                  (fix Ffix0 (x8 x9 : nat) {struct x8} : nat :=
                     match x8 with
                     | 0%nat => x8
                     | S x10 =>
                         match x9 with
                         | 0%nat => x8
                         | S x11 => Ffix0 x10 x11
                         end
                     end) x7
                    (let (_, H) :=
                       (fix Ffix0 (x8 x9 x10 x11 : nat) {struct x8} :
                            nat * nat :=
                          match x8 with
                          | 0%nat => (x10, x11)
                          | S x12 =>
                              match x11 with
                              | 0%nat => Ffix0 x12 x9 (S x10) x9
                              | S x13 => Ffix0 x12 x9 x10 x13
                              end
                          end) x5 x7 0%nat x7 in
                     H)
              end
              match x2 with
              | 0%nat => x6
              | S x7 =>
                  (fix Ffix0 (x8 x9 : nat) {struct x8} : nat :=
                     match x8 with
                     | 0%nat => x8
                     | S x10 =>
                         match x9 with
                         | 0%nat => x8
                         | S x11 => Ffix0 x10 x11
                         end
                     end) x7
                    (let (_, H) :=
                       (fix Ffix0 (x8 x9 x10 x11 : nat) {struct x8} :
                            nat * nat :=
                          match x8 with
                          | 0%nat => (x10, x11)
                          | S x12 =>
                              match x11 with
                              | 0%nat => Ffix0 x12 x9 (S x10) x9
                              | S x13 => Ffix0 x12 x9 x10 x13
                              end
                          end) x6 x7 0%nat x7 in
                     H)
              end in
          H) +
         (let (_, H) :=
            Ffix x4 x1 x2 x3
              match x1 with
              | 0%nat => x1
              | S x7 =>
                  let (H, _) :=
                    (fix Ffix0 (x8 x9 x10 x11 : nat) {struct x8} :
                         nat * nat :=
                       match x8 with
                       | 0%nat => (x10, x11)
                       | S x12 =>
                           match x11 with
                           | 0%nat => Ffix0 x12 x9 (S x10) x9
                           | S x13 => Ffix0 x12 x9 x10 x13
                           end
                       end) x5 x7 0%nat x7 in
                  H
              end
              match x2 with
              | 0%nat => x2
              | S x7 =>
                  let (H, _) :=
                    (fix Ffix0 (x8 x9 x10 x11 : nat) {struct x8} :
                         nat * nat :=
                       match x8 with
                       | 0%nat => (x10, x11)
                       | S x12 =>
                           match x11 with
                           | 0%nat => Ffix0 x12 x9 (S x10) x9
                           | S x13 => Ffix0 x12 x9 x10 x13
                           end
                       end) x6 x7 0%nat x7 in
                  H
              end in
          H) *
         (let (H, _) :=
            x3
              match x1 with
              | 0%nat => x5
              | S x7 =>
                  (fix Ffix0 (x8 x9 : nat) {struct x8} : nat :=
                     match x8 with
                     | 0%nat => x8
                     | S x10 =>
                         match x9 with
                         | 0%nat => x8
                         | S x11 => Ffix0 x10 x11
                         end
                     end) x7
                    (let (_, H) :=
                       (fix Ffix0 (x8 x9 x10 x11 : nat) {struct x8} :
                            nat * nat :=
                          match x8 with
                          | 0%nat => (x10, x11)
                          | S x12 =>
                              match x11 with
                              | 0%nat => Ffix0 x12 x9 (S x10) x9
                              | S x13 => Ffix0 x12 x9 x10 x13
                              end
                          end) x5 x7 0%nat x7 in
                     H)
              end
              match x2 with
              | 0%nat => x6
              | S x7 =>
                  (fix Ffix0 (x8 x9 : nat) {struct x8} : nat :=
                     match x8 with
                     | 0%nat => x8
                     | S x10 =>
                         match x9 with
                         | 0%nat => x8
                         | S x11 => Ffix0 x10 x11
                         end
                     end) x7
                    (let (_, H) :=
                       (fix Ffix0 (x8 x9 x10 x11 : nat) {struct x8} :
                            nat * nat :=
                          match x8 with
                          | 0%nat => (x10, x11)
                          | S x12 =>
                              match x11 with
                              | 0%nat => Ffix0 x12 x9 (S x10) x9
                              | S x13 => Ffix0 x12 x9 x10 x13
                              end
                          end) x6 x7 0%nat x7 in
                     H)
              end in
          H))%R)
    end) m 2 1
   (fun x0 x1 : nat =>
    match x0 with
    | 0 => match x1 with
           | 0 => (R1, R0)
           | S _ => (R0, R0)
           end
    | 1 => match x1 with
           | 0 | _ => (R0, R0)
           end
    | S (S _) => (R0, R0)
    end) =
 (fun x0 x1 : nat =>
  if
   if
    (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
       match x2 with
       | 0 => match x3 with
              | 0 => true
              | S _ => false
              end
       | S x4 => match x3 with
                 | 0 => false
                 | S x5 => Ffix x4 x5
                 end
       end) x0 0
   then
    (fix Ffix (x2 x3 : nat) {struct x2} : bool :=
       match x2 with
       | 0 => match x3 with
              | 0 => true
              | S _ => false
              end
       | S x4 => match x3 with
                 | 0 => false
                 | S x5 => Ffix x4 x5
                 end
       end) x1 0
   else false
  then (R1, R0)
  else (R0, R0)))
Crunching: (m ⨂ ∣ 0 ⟩ = basis_vector (2 ^ m) 0)
Crunching: (r ⨂ ∣0⟩ = basis_vector (2 ^ r) 0)
Crunching:
(r ⨂ ∣0⟩ = (fun i j : nat => if (i =? 0) && (j =? 0) then C1 else 0%R))
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (H1 <= x -> product Eqf (update Lef x y) H1 = product Eqf Lef H1)
Crunching:
(((fix product (x y : nat -> bool) (n : nat) {struct n} : bool :=
     match n with
     | 0 => false
     | S n' =>
         if if x n' then y n' else false
         then if product x y n' then false else true
         else if product x y n' then true else false
     end) p1
    (fun j : nat =>
     if
      (fix eqb (n m : nat) {struct n} : bool :=
         match n with
         | 0 => match m with
                | 0 => true
                | S _ => false
                end
         | S n' => match m with
                   | 0 => false
                   | S m' => eqb n' m'
                   end
         end) j H2
     then a
     else H3 j) n = true ->
  (fix product (x y : nat -> bool) (n : nat) {struct n} : bool :=
     match n with
     | 0 => false
     | S n' =>
         if if x n' then y n' else false
         then if product x y n' then false else true
         else if product x y n' then true else false
     end) p1 H3 n = true) /\
 ((fix product (x y : nat -> bool) (n : nat) {struct n} : bool :=
     match n with
     | 0 => false
     | S n' =>
         if if x n' then y n' else false
         then if product x y n' then false else true
         else if product x y n' then true else false
     end) p1 H3 n = true ->
  (fix product (x y : nat -> bool) (n : nat) {struct n} : bool :=
     match n with
     | 0 => false
     | S n' =>
         if if x n' then y n' else false
         then if product x y n' then false else true
         else if product x y n' then true else false
     end) p1
    (fun j : nat =>
     if
      (fix eqb (n m : nat) {struct n} : bool :=
         match n with
         | 0 => match m with
                | 0 => true
                | S _ => false
                end
         | S n' => match m with
                   | 0 => false
                   | S m' => eqb n' m'
                   end
         end) j H2
     then a
     else H3 j) n = true))
Crunching: (Hd <= x -> product p1 (update H3 x Hc) Hd = product p1 H3 Hd)
Crunching: (product (fun _ : nat => false) a n = false)
Crunching: (product (fun _ : nat => false) H H17 = false)
Crunching: (forall n : nat, nat_to_funbool n 0 = (fun _ : nat => false))
Crunching: (forall n : nat, nat_to_funbool n 0 = (fun _ : nat => false))
Crunching: (forall n : nat, nat_to_funbool n 0 = (fun _ : nat => false))
Crunching: (forall n : nat, nat_to_funbool n 0 = (fun _ : nat => false))
Crunching:
(nat_to_funbool l 0 = (fun _ : nat => false) <->
 nat_to_funbool (S l) 0 = (fun _ : nat => false))
Crunching: (forall n : nat, nat_to_funbool n 0 = (fun _ : nat => false))
Crunching:
(nat_to_funbool l 0 = (fun _ : nat => false) <->
 nat_to_funbool (S l) 0 = (fun _ : nat => false))
Crunching:
(update (list_to_funbool (Hd'd - 1) (repeat false (Hd'd - 1))) 
   (Hd'd - 1) true = (fun x : nat => x =? Hd'd - 1))
Crunching:
(update (list_to_funbool (Hd'd - 1) (repeat false (Hd'd - 1))) 
   (Hd'd - 1) true = (fun x : nat => x =? Hd'd - 1))
Crunching:
(update (list_to_funbool (Hd'd - 1) (repeat false (Hd'd - 1))) 
   (Hd'd - 1) true = (fun x : nat => x =? Hd'd - 1))
Crunching:
(update (list_to_funbool (Hd'd - 1) (repeat false (Hd'd - 1))) 
   (Hd'd - 1) true = (fun x : nat => x =? Hd'd - 1))
Crunching:
(update (list_to_funbool (Hd'd - 1) (repeat false (Hd'd - 1))) 
   (Hd'd - 1) true = (fun x : nat => x =? Hd'd - 1))
Crunching:
(update (list_to_funbool (Hd'd - 1) (repeat false (Hd'd - 1))) 
   (Hd'd - 1) true = (fun x : nat => x =? Hd'd - 1))
Crunching:
(update (list_to_funbool (Hd'd - 1) (repeat false (Hd'd - 1))) 
   (Hd'd - 1) true = (fun x : nat => x =? Hd'd - 1))
Crunching:
((fun x : nat => x =? Hd'd - 1) =
 update (list_to_funbool (Hd'd - 1) (repeat false (Hd'd - 1))) 
   (Hd'd - 1) true)
Crunching:
((fun x : nat => x =? Hd'd - 1) =
 update (list_to_funbool (Hd'd - 1) (repeat false (Hd'd - 1))) 
   (Hd'd - 1) true)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching:
(R ->
 vkron 1 (fun k : nat => ∣0⟩ .+ (-1) ^ f k .* ∣1⟩) x y =
 big_sum
   (fun k : nat =>
    (-1) ^ product f (nat_to_funbool 1 k) 1 .* basis_vector (2 ^ 1) k)
   (2 ^ 1) x y)
Crunching: (H8 * del2 + H8 * del2 <= del2 * del2 + H8 * H8)
Crunching: (del2 * H8 + del2 * H8 <= del2 * del2 + H8 * H8)
Crunching: (H8 * del2 + H8 * del2 <= del2 * del2 + H8 * H8)
Crunching: (H8 * del2 + H8 * del2 <= del2 * del2 + H8 * H8)
Crunching: (del2 * H8 + del2 * H8 <= del2 * del2 + H8 * H8)
Crunching: (del2 * H8 + del2 * H8 <= del2 * del2 + H8 * H8)
Crunching: (H8 * del2 + del2 * H8 <= del2 * del2 + H8 * H8)
Crunching: (H8 * del2 + del2 * H8 <= del2 * del2 + H8 * H8)
Crunching: (H8 * del2 + del2 * H8 <= del2 * del2 + H8 * H8)
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching: (∣1⟩ = basis_vector 2 1)
Crunching: (list2D_to_matrix [[e]; [e0]] = hadamard × ∣ true ⟩)
Crunching:
(list2D_to_matrix [[C1 / √ 2]; [- (C1 / √ 2)]] =
 / √ 2 .* (∣ 0 ⟩ .+ (-1) ^ true .* ∣ 1 ⟩))
Crunching: (list2D_to_matrix [[e]; [e0]] = hadamard × ∣ false ⟩)
Crunching:
(list2D_to_matrix [[C1 / √ 2]; [C1 / √ 2]] =
 / √ 2 .* (∣ 0 ⟩ .+ (-1) ^ false .* ∣ 1 ⟩))
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching:
((forall r1 r2 : R, r1 < r2 -> ~ r2 < r1) ->
 (forall r1 r2 : R, r1 < r2 \/ r1 > r2 -> r1 <> r2) ->
 H0 ⨂ hadamard × H0 ⨂ ∣0⟩ =
 / √ (2 ^ H0) .* big_sum (fun k : nat => basis_vector (2 ^ H0) k) (2 ^ H0))
Crunching: (∣0⟩ = basis_vector 2 0)
Crunching:
((forall r1 r2 : R, r1 < r2 -> ~ r2 < r1) ->
 (forall r1 r2 : R, r1 < r2 \/ r1 > r2 -> r1 <> r2) ->
 H0 ⨂ hadamard × H0 ⨂ ∣0⟩ =
 / √ (2 ^ H0) .* big_sum (fun k : nat => basis_vector (2 ^ H0) k) (2 ^ H0))
Crunching:
((forall N : nat, INR N <= 2 ^ N) ->
 H0 ⨂ hadamard × H0 ⨂ ∣0⟩ =
 (fun x y : nat =>
  / √ (2 ^ H0) *
  big_sum (fun k : nat => basis_vector (2 ^ H0) k) (2 ^ H0) x y))
Crunching:
((forall N : nat, INR N <= 2 ^ N) ->
 H0 ⨂ hadamard × H0 ⨂ ∣0⟩ =
 (fun x y : nat =>
  / √ (2 ^ H0) *
  big_sum (fun k : nat => basis_vector (2 ^ H0) k) (2 ^ H0) x y))
Crunching: (list2D_to_matrix [[e]; [e0]] = 1 ⨂ hadamard × z)
Crunching:
(list2D_to_matrix
   [[C1 / √ 2 * z 0%nat 0%nat + C1 / √ 2 * z 1%nat 0%nat];
   [C1 / √ 2 * z 0%nat 0%nat + - (C1 / √ 2) * z 1%nat 0%nat]] =
 / √ (2 ^ 1) .* P)
Crunching: (0 = / √ 2 * z 0%nat 1%nat + / √ 2 * z 1%nat 1%nat)
Crunching: (0 = / √ 2 * z 0%nat (S (S y)) + / √ 2 * z 1%nat (S (S y)))
Crunching: (0 = / √ 2 * z 0%nat 1%nat + - (/ √ 2 * z 1%nat 1%nat))
Crunching: (0 = / √ 2 * z 0%nat (S (S y)) + - (/ √ 2 * z 1%nat (S (S y))))
Crunching:
(n ⨂ hadamard × n ⨂ ∣0⟩ =
 /
 √ (fix pow (r : R) (n : nat) {struct n} : R :=
      match n with
      | 0%nat => 1
      | S n0 => (r * pow r n0)%R
      end) 2 n .* big_sum (fun k : nat => basis_vector (2 ^ n) k) (2 ^ n))
Crunching:
((m' > 0)%nat ->
 m' ⨂ hadamard × m' ⨂ ∣0⟩ =
 /
 √ (fix pow (r : R) (n : nat) {struct n} : R :=
      match n with
      | 0%nat => 1
      | S n0 => (r * pow r n0)%R
      end) 2 m' .* big_sum (fun k : nat => basis_vector (2 ^ m') k) (2 ^ m'))
Crunching: (∣0⟩ = basis_vector 2 0)
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building ident_interp...
Building base_eq_dec...
Building base_beq_and_reflect...
Building base_beq...
Building reflect_base_beq...
Building baseHasNatAndCorrect...
Building baseHasNat...
Building baseHasNatCorrect...
Building base_interp_beq...
Building reflect_base_interp_beq...
Building try_make_base_transport_cps...
Building try_make_base_transport_cps_correct...
Building all_idents...
Building all_ident_and_interp...
Building buildEagerIdentAndInterpCorrect...
Building buildEagerIdent...
Building buildInterpEagerIdentCorrect...
Building toRestrictedIdentAndCorrect...
Building toRestrictedIdent...
Building toFromRestrictedIdent...
Building buildIdentAndInterpCorrect...
Building buildIdent...
Building buildInterpIdentCorrect...
Building ident_is_var_like...
Building eqv_Reflexive_Proper...
Building ident_interp_Proper...
Building invertIdent...
Building buildInvertIdentCorrect...
Building base_default...
Building package...
Building all_base...
Building all_idents...
Building ident_index...
Building eta_ident_cps_gen...
Building eta_ident_cps_gen_expand_literal...
Building eta_ident_cps...
Building simple_idents...
Building all_raw_idents...
Building raw_ident_index...
Building raw_ident_index_idempotent...
Building eta_raw_ident_cps_gen...
Building raw_ident_to_ident...
Building raw_ident_infos_of...
Building split_raw_ident_gen...
Building invert_bind_args...
Building invert_bind_args_unknown...
Building all_pattern_idents...
Building eta_pattern_ident_cps_gen...
Building eta_pattern_ident_cps_gen_expand_literal...
Building split_types...
Building add_types_from_raw_sig...
Building to_type_split_types_subst_default_eq...
Building projT1_add_types_from_raw_sig_eq...
Building arg_types_unfolded...
Building type_of_list_arg_types_beq_unfolded...
Building to_typed_unfolded...
Building of_typed_ident_unfolded...
Building arg_types_of_typed_ident_unfolded...
Building unify...
Building unify_unknown...
Building final ident package...
Proving is_simple_correct0...
Tactic call ran for 0.365 secs (0.356u,0.008s) (success)
Proving invert_bind_args_raw_to_typed...
Tactic call ran for 0.217 secs (0.212u,0.004s) (success)
Proving fold_invert_bind_args...
Tactic call ran for 0.022 secs (0.022u,0.s) (success)
Proving split_ident_to_ident...
Tactic call ran for 0.013 secs (0.013u,0.s) (success)
Proving eq_indep_types_of_eq_types...
Tactic call ran for 0.767 secs (0.755u,0.011s) (success)
Proving fold_eta_ident_cps...
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving fold_unify...
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving to_typed_of_typed_ident...
Tactic call ran for 1.42 secs (1.407u,0.012s) (success)
Proving eq_invert_bind_args_unknown...
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving eq_unify_unknown...
Tactic call ran for 0. secs (0.u,0.s) (success)
Reifying...
Compiling decision tree...
Splitting rewrite rules...
Assembling rewrite_head...
Reducing rewrite_head...
Tactic call ran for 0.156 secs (0.153u,0.003s) (success)
Tactic call ran for 0.113 secs (0.108u,0.005s) (success)
Tactic call ran for 0.109 secs (0.109u,0.s) (success)
Assembling rewrite_head_no_dtree...
Reducing rewrite_head_no_dtree...
Proving Rewriter_Wf...
Tactic call ran for 0.068 secs (0.067u,0.s) (success)
Tactic call ran for 0.931 secs (0.918u,0.012s) (success)
Proving Rewriter_Interp...
Tactic call ran for 0.782 secs (0.77u,0.011s) (success)
Tactic call ran for 0.578 secs (0.573u,0.004s) (success)
Assembling verified rewriter...
Refining with verified rewriter...
Finished transaction in 19.575 secs (19.291u,0.283s) (successful)
simplified dependent [if true]
e : (x <? n1)  = true
if (x <? n1)
then (fun E0 : (x <? n1) = true => AA (ltN_of_nat x n1 E0))
else
(fun E0 : (x <? n1) = false =>
 BB (ltN_of_nat (x - n1) n2 (ltN_split_lemma1 (ltN_plus_lemma1 e) E0)))
rewrite if_dtt
if (n1 + x <? n1)
then (fun E0 : (n1 + x <? n1) = true => AA (ltN_of_nat (n1 + x) n1 E0))
else
(fun E0 : (n1 + x <? n1) = false =>
 BB (ltN_of_nat (n1 + x - n1) n2 (ltN_split_lemma1 (plus_ltN_lemma1 e) E0)))
rewrite if_dtt
if (x <? n1)
then
(fun E0 : (x <? n1) = true =>
 AA (exist (fun k : nat => (k <? n1) = true) x E0))
else
(fun E0 : (x <? n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true) (x - n1) (ltN_split_lemma1 e E0)))
rewrite if_dtt
if (x0 <? n)
then
(fun E0 : (x0 <? n) = true =>
 AA (exist (fun k : nat => (k <? n) = true) x0 E0))
else
(fun E0 : (x0 <? n) = false =>
 BB (exist (fun k : nat => (k <? 0) = true) (x0 - n) (ltN_split_lemma1 e E0)))
destruct  (Nat.add_0_r n)  in  x
rewrite if_dtt
if (S x <? S n1)
then
(fun E0 : (S x <? S n1) = true =>
 AA (exist (fun k : nat => (k <? S n1) = true) (S x) E0))
else
(fun E0 : (S x <? S n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true) (x - n1) (ltN_split_lemma1 e E0)))
simplified dependent [if true]
p : (S x <? S n1)  = true
if (S x <? S n1)
then
(fun E0 : (x <? n1) = true =>
 AA (exist (fun k : nat => (k <? n1) = true) x E0))
else
(fun E0 : (x <? n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true) (x - n1) (ltN_split_lemma1 e E0)))
simplified dependent [if false]
p : (S x <? S n1)  = true
if (S x <? S n1)
then
(fun E0 : (x <? n1) = true =>
 AA (exist (fun k : nat => (k <? n1) = true) x E0))
else
(fun E0 : (x <? n1) = false =>
 BB
   (exist (fun k : nat => (k <? n2) = true) (x - n1) (ltN_split_lemma1 e E0)))
rewrite if_dtt
if (proj1_sig x =? proj1_sig k)
then (fun _ : (proj1_sig x =? proj1_sig k) = true => AA tt)
else
(fun E0 : (proj1_sig x =? proj1_sig k) = false =>
 BB
   ((if proj1_sig x <? proj1_sig k as b1
      return ((proj1_sig x <? proj1_sig k) = b1 -> ltN n)
     then
      fun E1 : (proj1_sig x <? proj1_sig k) = true =>
      ltN_of_nat (proj1_sig x) n (ltN_pop_lemma1 n k x E1)
     else
      fun E1 : (proj1_sig x <? proj1_sig k) = false =>
      ltN_of_nat (Init.Nat.pred (proj1_sig x)) n (ltN_pop_lemma2 n k x E1 E0))
      eq_refl))
Finished transaction in 64.984 secs (64.812u,0.178s) (successful)
Finished transaction in 11.984 secs (11.675u,0.31s) (successful)
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 n (ltN_pred_lemma0 k k0 E)))
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 n (ltN_pred_lemma0 k k0 E)))
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 n (ltN_pred_lemma0 k k0 E)))
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 n (ltN_pred_lemma0 k k0 E)))
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 n (ltN_pred_lemma0 k k0 E)))
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 n (ltN_pred_lemma0 k k0 E)))
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 n (ltN_pred_lemma0 k k0 E)))
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 n (ltN_pred_lemma0 k k0 E)))
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 n (ltN_pred_lemma0 k k0 E)))
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 n (ltN_pred_lemma0 k k0 E)))
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 n (ltN_pred_lemma0 k k0 E)))
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 n (ltN_pred_lemma0 k k0 E)))
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 n (ltN_pred_lemma0 k k0 E)))
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 n (ltN_pred_lemma0 k k0 E)))
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 n (ltN_pred_lemma0 k k0 E)))
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 n (ltN_pred_lemma0 k k0 E)))
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 n (ltN_pred_lemma0 k k0 E)))
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 n (ltN_pred_lemma0 k k0 E)))
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 n (ltN_pred_lemma0 k k0 E)))
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 n (ltN_pred_lemma0 k k0 E)))
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 n (ltN_pred_lemma0 k k0 E)))
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 n (ltN_pred_lemma0 k k0 E)))
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 n (ltN_pred_lemma0 k k0 E)))
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 n (ltN_pred_lemma0 k k0 E)))
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 n (ltN_pred_lemma0 k k0 E)))
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 n (ltN_pred_lemma0 k k0 E)))
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 n (ltN_pred_lemma0 k k0 E)))
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 n (ltN_pred_lemma0 k k0 E)))
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 n (ltN_pred_lemma0 k k0 E)))
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 n (ltN_pred_lemma0 k k0 E)))
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 n (ltN_pred_lemma0 k k0 E)))
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 n (ltN_pred_lemma0 k k0 E)))
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 n (ltN_pred_lemma0 k k0 E)))
rewrite match_nat_dtt
match (proj1_sig k) with
| 0 => (fun _ : proj1_sig k = 0 => None)
| S m =>
(fun (k0 : nat) (E : proj1_sig k = S k0) =>
 Some (ltN_of_nat k0 n (ltN_pred_lemma0 k k0 E)))
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: w]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: w]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
((fix app (l m : list x) {struct l} : list x := match l with
                                                | [] => m
                                                | a :: l1 => a :: app l1 m
                                                end) l ys = (fix F (l : list x) : list x := match l with
                                                                                            | [] => ys
                                                                                            | y :: l0 => y :: F l0
                                                                                            end) l)
((fix app (l m : list x) {struct l} : list x := match l with
                                                | [] => m
                                                | a :: l1 => a :: app l1 m
                                                end) l ys = (fix F (l : list x) : list x := match l with
                                                                                            | [] => ys
                                                                                            | y :: l0 => y :: F l0
                                                                                            end) l)
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building ident_interp...
Building base_eq_dec...
Building base_beq_and_reflect...
Building base_beq...
Building reflect_base_beq...
Building baseHasNatAndCorrect...
Building baseHasNat...
Building baseHasNatCorrect...
Building base_interp_beq...
Building reflect_base_interp_beq...
Building try_make_base_transport_cps...
Building try_make_base_transport_cps_correct...
Building all_idents...
Building all_ident_and_interp...
Building buildEagerIdentAndInterpCorrect...
Building buildEagerIdent...
Building buildInterpEagerIdentCorrect...
Building toRestrictedIdentAndCorrect...
Building toRestrictedIdent...
Building toFromRestrictedIdent...
Building buildIdentAndInterpCorrect...
Building buildIdent...
Building buildInterpIdentCorrect...
Building ident_is_var_like...
Building eqv_Reflexive_Proper...
Building ident_interp_Proper...
Building invertIdent...
Building buildInvertIdentCorrect...
Building base_default...
Building package...
Building all_base...
Building all_idents...
Building ident_index...
Building eta_ident_cps_gen...
Building eta_ident_cps_gen_expand_literal...
Building eta_ident_cps...
Building simple_idents...
Building all_raw_idents...
Building raw_ident_index...
Building raw_ident_index_idempotent...
Building eta_raw_ident_cps_gen...
Building raw_ident_to_ident...
Building raw_ident_infos_of...
Building split_raw_ident_gen...
Building invert_bind_args...
Building invert_bind_args_unknown...
Building all_pattern_idents...
Building eta_pattern_ident_cps_gen...
Building eta_pattern_ident_cps_gen_expand_literal...
Building split_types...
Building add_types_from_raw_sig...
Building to_type_split_types_subst_default_eq...
Building projT1_add_types_from_raw_sig_eq...
Building arg_types_unfolded...
Building type_of_list_arg_types_beq_unfolded...
Building to_typed_unfolded...
Building of_typed_ident_unfolded...
Building arg_types_of_typed_ident_unfolded...
Building unify...
Building unify_unknown...
Building final ident package...
Proving is_simple_correct0...
Tactic call ran for 0.636 secs (0.62u,0.016s) (success)
Proving invert_bind_args_raw_to_typed...
Tactic call ran for 0.335 secs (0.325u,0.01s) (success)
Proving fold_invert_bind_args...
Tactic call ran for 0.075 secs (0.074u,0.s) (success)
Proving split_ident_to_ident...
Tactic call ran for 0.02 secs (0.02u,0.s) (success)
Proving eq_indep_types_of_eq_types...
Tactic call ran for 1.001 secs (0.976u,0.024s) (success)
Proving fold_eta_ident_cps...
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving fold_unify...
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving to_typed_of_typed_ident...
Tactic call ran for 1.719 secs (1.706u,0.012s) (success)
Proving eq_invert_bind_args_unknown...
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving eq_unify_unknown...
Tactic call ran for 0. secs (0.u,0.s) (success)
Reifying...
Compiling decision tree...
Splitting rewrite rules...
Assembling rewrite_head...
Reducing rewrite_head...
Tactic call ran for 0.364 secs (0.359u,0.004s) (success)
Tactic call ran for 3.093 secs (3.007u,0.086s) (success)
Tactic call ran for 0.178 secs (0.177u,0.s) (success)
Assembling rewrite_head_no_dtree...
Reducing rewrite_head_no_dtree...
Proving Rewriter_Wf...
Tactic call ran for 0.362 secs (0.362u,0.s) (success)
Tactic call ran for 1.825 secs (1.791u,0.034s) (success)
Proving Rewriter_Interp...
Tactic call ran for 2.487 secs (2.475u,0.012s) (success)
Tactic call ran for 1.156 secs (1.152u,0.003s) (success)
Assembling verified rewriter...
Refining with verified rewriter...
Finished transaction in 42.216 secs (41.663u,0.556s) (successful)
Finished transaction in 2.331 secs (2.266u,0.066s) (successful)
Finished transaction in 2.264 secs (2.23u,0.033s) (successful)
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building ident_interp...
Building base_eq_dec...
Building base_beq_and_reflect...
Building base_beq...
Building reflect_base_beq...
Building baseHasNatAndCorrect...
Building baseHasNat...
Building baseHasNatCorrect...
Building base_interp_beq...
Building reflect_base_interp_beq...
Building try_make_base_transport_cps...
Building try_make_base_transport_cps_correct...
Building all_idents...
Building all_ident_and_interp...
Building buildEagerIdentAndInterpCorrect...
Building buildEagerIdent...
Building buildInterpEagerIdentCorrect...
Building toRestrictedIdentAndCorrect...
Building toRestrictedIdent...
Building toFromRestrictedIdent...
Building buildIdentAndInterpCorrect...
Building buildIdent...
Building buildInterpIdentCorrect...
Building ident_is_var_like...
Building eqv_Reflexive_Proper...
Building ident_interp_Proper...
Building invertIdent...
Building buildInvertIdentCorrect...
Building base_default...
Building package...
Building all_base...
Building all_idents...
Building ident_index...
Building eta_ident_cps_gen...
Building eta_ident_cps_gen_expand_literal...
Building eta_ident_cps...
Building simple_idents...
Building all_raw_idents...
Building raw_ident_index...
Building raw_ident_index_idempotent...
Building eta_raw_ident_cps_gen...
Building raw_ident_to_ident...
Building raw_ident_infos_of...
Building split_raw_ident_gen...
Building invert_bind_args...
Building invert_bind_args_unknown...
Building all_pattern_idents...
Building eta_pattern_ident_cps_gen...
Building eta_pattern_ident_cps_gen_expand_literal...
Building split_types...
Building add_types_from_raw_sig...
Building to_type_split_types_subst_default_eq...
Building projT1_add_types_from_raw_sig_eq...
Building arg_types_unfolded...
Building type_of_list_arg_types_beq_unfolded...
Building to_typed_unfolded...
Building of_typed_ident_unfolded...
Building arg_types_of_typed_ident_unfolded...
Building unify...
Building unify_unknown...
Building final ident package...
Proving is_simple_correct0...
Tactic call ran for 0.321 secs (0.318u,0.003s) (success)
Proving invert_bind_args_raw_to_typed...
Tactic call ran for 0.198 secs (0.197u,0.001s) (success)
Proving fold_invert_bind_args...
Tactic call ran for 0.019 secs (0.019u,0.s) (success)
Proving split_ident_to_ident...
Tactic call ran for 0.012 secs (0.012u,0.s) (success)
Proving eq_indep_types_of_eq_types...
Tactic call ran for 0.715 secs (0.712u,0.002s) (success)
Proving fold_eta_ident_cps...
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving fold_unify...
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving to_typed_of_typed_ident...
Tactic call ran for 1.369 secs (1.363u,0.004s) (success)
Proving eq_invert_bind_args_unknown...
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving eq_unify_unknown...
Tactic call ran for 0. secs (0.u,0.s) (success)
Reifying...
Compiling decision tree...
Splitting rewrite rules...
Assembling rewrite_head...
Reducing rewrite_head...
Tactic call ran for 0.006 secs (0.006u,0.s) (success)
Tactic call ran for 0.001 secs (0.001u,0.s) (success)
Tactic call ran for 0.023 secs (0.023u,0.s) (success)
Assembling rewrite_head_no_dtree...
Reducing rewrite_head_no_dtree...
Proving Rewriter_Wf...
Tactic call ran for 0.006 secs (0.006u,0.s) (success)
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving Rewriter_Interp...
Tactic call ran for 0.061 secs (0.061u,0.s) (success)
Tactic call ran for 0. secs (0.u,0.s) (success)
Assembling verified rewriter...
Refining with verified rewriter...
Finished transaction in 11.033 secs (10.985u,0.039s) (successful)
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building ident_interp...
Building base_eq_dec...
Building base_beq_and_reflect...
Building base_beq...
Building reflect_base_beq...
Building baseHasNatAndCorrect...
Building baseHasNat...
Building baseHasNatCorrect...
Building base_interp_beq...
Building reflect_base_interp_beq...
Building try_make_base_transport_cps...
Building try_make_base_transport_cps_correct...
Building all_idents...
Building all_ident_and_interp...
Building buildEagerIdentAndInterpCorrect...
Building buildEagerIdent...
Building buildInterpEagerIdentCorrect...
Building toRestrictedIdentAndCorrect...
Building toRestrictedIdent...
Building toFromRestrictedIdent...
Building buildIdentAndInterpCorrect...
Building buildIdent...
Building buildInterpIdentCorrect...
Building ident_is_var_like...
Building eqv_Reflexive_Proper...
Building ident_interp_Proper...
Building invertIdent...
Building buildInvertIdentCorrect...
Building base_default...
Building package...
Building all_base...
Building all_idents...
Building ident_index...
Building eta_ident_cps_gen...
Building eta_ident_cps_gen_expand_literal...
Building eta_ident_cps...
Building simple_idents...
Building all_raw_idents...
Building raw_ident_index...
Building raw_ident_index_idempotent...
Building eta_raw_ident_cps_gen...
Building raw_ident_to_ident...
Building raw_ident_infos_of...
Building split_raw_ident_gen...
Building invert_bind_args...
Building invert_bind_args_unknown...
Building all_pattern_idents...
Building eta_pattern_ident_cps_gen...
Building eta_pattern_ident_cps_gen_expand_literal...
Building split_types...
Building add_types_from_raw_sig...
Building to_type_split_types_subst_default_eq...
Building projT1_add_types_from_raw_sig_eq...
rewrite if_dtt
if (proj1_sig y <? proj1_sig x)
then
(fun E1 : (proj1_sig y <? proj1_sig x) = true =>
 ltN_of_nat (proj1_sig y) (S n) (ltN_intro_lemma1 n x y E1))
else
(fun E1 : (proj1_sig y <? proj1_sig x) = false =>
 ltN_of_nat (S (proj1_sig y)) (S n) (ltN_intro_lemma2 n x y E1))
Building arg_types_unfolded...
Building type_of_list_arg_types_beq_unfolded...
Building to_typed_unfolded...
Building of_typed_ident_unfolded...
Building arg_types_of_typed_ident_unfolded...
Building unify...
rewrite if_dtt
if (proj1_sig y <? proj1_sig x)
then
(fun E1 : (proj1_sig y <? proj1_sig x) = true =>
 ltN_of_nat (proj1_sig y) (S n) (ltN_intro_lemma1 n x y E1))
else
(fun E1 : (proj1_sig y <? proj1_sig x) = false =>
 ltN_of_nat (S (proj1_sig y)) (S n) (ltN_intro_lemma2 n x y E1))
Building unify_unknown...
Building final ident package...
Proving is_simple_correct0...
Tactic call ran for 0.425 secs (0.423u,0.001s) (success)
Proving invert_bind_args_raw_to_typed...
Tactic call ran for 0.26 secs (0.258u,0.002s) (success)
Proving fold_invert_bind_args...
Tactic call ran for 0.026 secs (0.026u,0.s) (success)
Proving split_ident_to_ident...
Tactic call ran for 0.014 secs (0.014u,0.s) (success)
Proving eq_indep_types_of_eq_types...
rewrite if_dtt
if (proj1_sig y <? proj1_sig x)
then (fun _ : (proj1_sig y <? proj1_sig x) = true => proj1_sig y)
else (fun _ : (proj1_sig y <? proj1_sig x) = false => S (proj1_sig y))
Tactic call ran for 0.851 secs (0.843u,0.007s) (success)
Proving fold_eta_ident_cps...
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving fold_unify...
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving to_typed_of_typed_ident...
rewrite if_dtt
if (proj1_sig y <? proj1_sig x)
then
(fun E1 : (proj1_sig y <? proj1_sig x) = true =>
 ltN_of_nat (proj1_sig y) (S n) (ltN_intro_lemma1 n x y E1))
else
(fun E1 : (proj1_sig y <? proj1_sig x) = false =>
 ltN_of_nat (S (proj1_sig y)) (S n) (ltN_intro_lemma2 n x y E1))
Tactic call ran for 1.586 secs (1.583u,0.002s) (success)
Proving eq_invert_bind_args_unknown...
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving eq_unify_unknown...
Tactic call ran for 0. secs (0.u,0.s) (success)
rewrite if_dtt
if
match proj1_sig x with
| 0 => false
| S m' => proj1_sig (exist (fun k : nat => (k <? n) = true) x0 e) <=? m'
end
then
(fun
   E1 : match proj1_sig x with
        | 0 => false
        | S m' =>
            proj1_sig (exist (fun k : nat => (k <? n) = true) x0 e) <=? m'
        end = true =>
 ltN_of_nat (proj1_sig (exist (fun k : nat => (k <? n) = true) x0 e)) 
   (S n)
   (ltN_intro_lemma1 n x (exist (fun k : nat => (k <? n) = true) x0 e) E1))
else
(fun
   E1 : match proj1_sig x with
        | 0 => false
        | S m' =>
            proj1_sig (exist (fun k : nat => (k <? n) = true) x0 e) <=? m'
        end = false =>
 ltN_of_nat (S (proj1_sig (exist (fun k : nat => (k <? n) = true) x0 e)))
   (S n)
   (ltN_intro_lemma2 n x (exist (fun k : nat => (k <? n) = true) x0 e) E1))
rewrite if_dtt
if (proj1_sig y <? proj1_sig x)
then (fun _ : (proj1_sig y <? proj1_sig x) = true => proj1_sig y)
else (fun _ : (proj1_sig y <? proj1_sig x) = false => S (proj1_sig y))
Reifying...
Compiling decision tree...
Splitting rewrite rules...
Assembling rewrite_head...
Reducing rewrite_head...
Tactic call ran for 0.144 secs (0.143u,0.001s) (success)
Tactic call ran for 0.168 secs (0.167u,0.001s) (success)
Tactic call ran for 0.095 secs (0.095u,0.s) (success)
Assembling rewrite_head_no_dtree...
Reducing rewrite_head_no_dtree...
Proving Rewriter_Wf...
Tactic call ran for 0.086 secs (0.086u,0.s) (success)
rewrite if_dtt
if (proj1_sig y <? proj1_sig x)
then
(fun E1 : (proj1_sig y <? proj1_sig x) = true =>
 ltN_of_nat (proj1_sig y) (S n) (ltN_intro_lemma1 n x y E1))
else
(fun E1 : (proj1_sig y <? proj1_sig x) = false =>
 ltN_of_nat (S (proj1_sig y)) (S n) (ltN_intro_lemma2 n x y E1))
Tactic call ran for 1.124 secs (1.117u,0.006s) (success)
Proving Rewriter_Interp...
Tactic call ran for 1.184 secs (1.182u,0.s) (success)
Tactic call ran for 0.733 secs (0.73u,0.002s) (success)
rewrite if_dtt
if
match proj1_sig x with
| 0 => false
| S m' => proj1_sig (exist (fun k : nat => (k <? n) = true) x0 e) <=? m'
end
then
(fun
   E1 : match proj1_sig x with
        | 0 => false
        | S m' =>
            proj1_sig (exist (fun k : nat => (k <? n) = true) x0 e) <=? m'
        end = true =>
 ltN_of_nat (proj1_sig (exist (fun k : nat => (k <? n) = true) x0 e)) 
   (S n)
   (ltN_intro_lemma1 n x (exist (fun k : nat => (k <? n) = true) x0 e) E1))
else
(fun
   E1 : match proj1_sig x with
        | 0 => false
        | S m' =>
            proj1_sig (exist (fun k : nat => (k <? n) = true) x0 e) <=? m'
        end = false =>
 ltN_of_nat (S (proj1_sig (exist (fun k : nat => (k <? n) = true) x0 e)))
   (S n)
   (ltN_intro_lemma2 n x (exist (fun k : nat => (k <? n) = true) x0 e) E1))
Assembling verified rewriter...
Refining with verified rewriter...
Finished transaction in 22.946 secs (22.845u,0.078s) (successful)
rewrite if_dtt
if (proj1_sig y <? proj1_sig x)
then (fun _ : (proj1_sig y <? proj1_sig x) = true => proj1_sig y)
else (fun _ : (proj1_sig y <? proj1_sig x) = false => S (proj1_sig y))
Success: (dlet y0 : Z := e1 + e2 in
          [y; y + 1; y + 2; y + y0; y + (y0 + 1)])
Success: [x1; x1; x1; x2; x2; x2; x3; x3; x3]
rewrite if_dtt
if (proj1_sig y <? proj1_sig x)
then
(fun E1 : (proj1_sig y <? proj1_sig x) = true =>
 ltN_of_nat (proj1_sig y) (S n) (ltN_intro_lemma1 n x y E1))
else
(fun E1 : (proj1_sig y <? proj1_sig x) = false =>
 ltN_of_nat (S (proj1_sig y)) (S n) (ltN_intro_lemma2 n x y E1))
rewrite if_dtt
if (proj1_sig y <? proj1_sig x)
then
(fun E1 : (proj1_sig y <? proj1_sig x) = true =>
 ltN_of_nat (proj1_sig y) (S n) (ltN_intro_lemma1 n x y E1))
else
(fun E1 : (proj1_sig y <? proj1_sig x) = false =>
 ltN_of_nat (S (proj1_sig y)) (S n) (ltN_intro_lemma2 n x y E1))
rewrite if_dtt
if
match proj1_sig x with
| 0 => false
| S m' => proj1_sig (exist (fun k : nat => (k <? n) = true) x0 e) <=? m'
end
then
(fun
   E1 : match proj1_sig x with
        | 0 => false
        | S m' =>
            proj1_sig (exist (fun k : nat => (k <? n) = true) x0 e) <=? m'
        end = true =>
 ltN_of_nat (proj1_sig (exist (fun k : nat => (k <? n) = true) x0 e)) 
   (S n)
   (ltN_intro_lemma1 n x (exist (fun k : nat => (k <? n) = true) x0 e) E1))
else
(fun
   E1 : match proj1_sig x with
        | 0 => false
        | S m' =>
            proj1_sig (exist (fun k : nat => (k <? n) = true) x0 e) <=? m'
        end = false =>
 ltN_of_nat (S (proj1_sig (exist (fun k : nat => (k <? n) = true) x0 e)))
   (S n)
   (ltN_intro_lemma2 n x (exist (fun k : nat => (k <? n) = true) x0 e) E1))
rewrite if_dtt
if (proj1_sig y <? proj1_sig x)
then (fun _ : (proj1_sig y <? proj1_sig x) = true => proj1_sig y)
else (fun _ : (proj1_sig y <? proj1_sig x) = false => S (proj1_sig y))
     = err "msqrt: missed mu0<1"
     : E FF
     = ret 0.019054260631166435%float
     : E FF
     = ret 0.0027158307793357069%float
     : E FF
     = ret 0.00062770722533873587%float
     : E FF
     = ret 0.00016685132944658826%float
     : E FF
     = ret 4.7498455945126596e-05%float
     : E FF
     = ret 1.4097830869872009e-05%float
     : E FF
     = ret 4.306735966350321e-06%float
     : E FF
     = ret 1.3443005331964648e-06%float
     : E FF
     = ret 4.2675434309288284e-07%float
     : E FF
     = ret 6.3857338167259186e-13%float
     : E FF
     = err "msqrt: missed mu0<1"
     : E FF
     = err "msqrt: missed mu0<1"
     : E FF
     = err "msqrt: missed mu0<1"
     : E FF
     = ret 0.020043240427919461%float
     : E FF
     = err "msqrt: missed mu0<1"
     : E FF
     = err "msqrt: missed 0<delta"
     : E FF
     = ret 0.01016690008922291%float
     : E FF
     = ret 0.0037377455251410823%float
     : E FF
     = ret 0.0019091978629927784%float
     : E FF
     = ret 0.0010782160772482797%float
     : E FF
     = ret 0.00064239238802731046%float
     : E FF
     = ret 9.7192075699687093e-05%float
     : E FF
     = err "msqrt: missed mu0<1"
     : E FF
     = ret 0.0033595091724205831%float
     : E FF
     = ret 1.2479890519241319e-06%float
     : E FF
     = ret 6.8778214963336185e-10%float
     : E FF
     = err "msqrt: missed mu0<1"
     : E FF
     = err "msqrt: missed mu0<1"
     : E FF
     = ret 6.9214269464063779e-05%float
     : E FF
     = ret 1.3524254710726107e-07%float
     : E FF
Finished transaction in 0.003 secs (0.003u,0.s) (successful)
     = ret 1.3524254710726107e-07%float
     : E FF
Finished transaction in 0.003 secs (0.003u,0.s) (successful)
     = ret 4.3520742565301479e-14%float
     : E FF
Finished transaction in 0.008 secs (0.008u,0.s) (successful)
     = ret 2.64233079860787e-14%float
     : E FF
Finished transaction in 0.017 secs (0.017u,0.s) (successful)
     = ret 2.8865798640254057e-14%float
     : E FF
Finished transaction in 0.03 secs (0.03u,0.s) (successful)
     = ret 3.264055692397959e-14%float
     : E FF
Finished transaction in 0.047 secs (0.047u,0.s) (successful)
     = ret 4.8405723873656749e-14%float
     : E FF
Finished transaction in 0.07 secs (0.07u,0.s) (successful)
     = ret 4.7961634663806674e-14%float
     : E FF
Finished transaction in 0.098 secs (0.098u,0.s) (successful)
Finished transaction in 0.01 secs (0.01u,0.s) (successful)
Finished transaction in 0.01 secs (0.01u,0.s) (successful)
Finished transaction in 0.035 secs (0.035u,0.s) (successful)
Finished transaction in 0.121 secs (0.121u,0.s) (successful)
Finished transaction in 0.334 secs (0.334u,0.s) (successful)
Finished transaction in 0.757 secs (0.757u,0.s) (successful)
Finished transaction in 1.501 secs (1.501u,0.s) (successful)
Finished transaction in 2.707 secs (2.706u,0.s) (successful)
Finished transaction in 0. secs (0.u,0.s) (successful)
Finished transaction in 0. secs (0.u,0.s) (successful)
Finished transaction in 0. secs (0.u,0.s) (successful)
Finished transaction in 0. secs (0.u,0.s) (successful)
Finished transaction in 0. secs (0.u,0.s) (successful)
Finished transaction in 0. secs (0.u,0.s) (successful)
Finished transaction in 0. secs (0.u,0.s) (successful)
Finished transaction in 0. secs (0.u,0.s) (successful)
     = ret 0.15148746656688988%float
     : E FF
     = ret 0.15139658307288195%float
     : E FF
     = ret 0.15139657739821419%float
     : E FF
     = ret 0.061446269198929239%float
     : E FF
     = ret 0.055199058172036616%float
     : E FF
     = ret 0.055198568077180994%float
     : E FF
     = err "msqrt: missed mu0<1"
     : E FF
     = ret 0.018492804666128928%float
     : E FF
     = ret 0.018483580455310147%float
     : E FF
     = err "msqrt: missed 0<delta"
     : E FF
     = ret 0.0019586963778410399%float
     : E FF
     = ret 0.0019558414535714858%float
     : E FF
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building ident_interp...
Building base_eq_dec...
Building base_beq_and_reflect...
Building base_beq...
Building reflect_base_beq...
Building baseHasNatAndCorrect...
Building baseHasNat...
Building baseHasNatCorrect...
Building base_interp_beq...
Building reflect_base_interp_beq...
Building try_make_base_transport_cps...
Building try_make_base_transport_cps_correct...
Building all_idents...
Building all_ident_and_interp...
Building buildEagerIdentAndInterpCorrect...
Building buildEagerIdent...
Building buildInterpEagerIdentCorrect...
Building toRestrictedIdentAndCorrect...
Building toRestrictedIdent...
Building toFromRestrictedIdent...
Building buildIdentAndInterpCorrect...
Building buildIdent...
Building buildInterpIdentCorrect...
Building ident_is_var_like...
Building eqv_Reflexive_Proper...
Building ident_interp_Proper...
Building invertIdent...
Building buildInvertIdentCorrect...
Building base_default...
Building package...
Building all_base...
Building all_idents...
Building ident_index...
Building eta_ident_cps_gen...
Building eta_ident_cps_gen_expand_literal...
Building eta_ident_cps...
Building simple_idents...
Building all_raw_idents...
Building raw_ident_index...
Building raw_ident_index_idempotent...
Building eta_raw_ident_cps_gen...
Building raw_ident_to_ident...
Building raw_ident_infos_of...
Building split_raw_ident_gen...
Building invert_bind_args...
Building invert_bind_args_unknown...
Building all_pattern_idents...
Building eta_pattern_ident_cps_gen...
Building eta_pattern_ident_cps_gen_expand_literal...
Building split_types...
Building add_types_from_raw_sig...
Building to_type_split_types_subst_default_eq...
Building projT1_add_types_from_raw_sig_eq...
Building arg_types_unfolded...
Building type_of_list_arg_types_beq_unfolded...
Building to_typed_unfolded...
Building of_typed_ident_unfolded...
Building arg_types_of_typed_ident_unfolded...
Building unify...
Building unify_unknown...
Building final ident package...
Proving is_simple_correct0...
Tactic call ran for 0.357 secs (0.353u,0.003s) (success)
Proving invert_bind_args_raw_to_typed...
Tactic call ran for 0.219 secs (0.216u,0.002s) (success)
Proving fold_invert_bind_args...
Tactic call ran for 0.023 secs (0.023u,0.s) (success)
Proving split_ident_to_ident...
Tactic call ran for 0.013 secs (0.013u,0.s) (success)
Proving eq_indep_types_of_eq_types...
Tactic call ran for 0.754 secs (0.741u,0.012s) (success)
Proving fold_eta_ident_cps...
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving fold_unify...
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving to_typed_of_typed_ident...
Tactic call ran for 1.415 secs (1.397u,0.017s) (success)
Proving eq_invert_bind_args_unknown...
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving eq_unify_unknown...
Tactic call ran for 0. secs (0.u,0.s) (success)
Reifying...
Compiling decision tree...
Splitting rewrite rules...
Assembling rewrite_head...
Reducing rewrite_head...
Tactic call ran for 0.071 secs (0.068u,0.003s) (success)
Tactic call ran for 0.032 secs (0.032u,0.s) (success)
Tactic call ran for 0.057 secs (0.057u,0.s) (success)
Assembling rewrite_head_no_dtree...
Reducing rewrite_head_no_dtree...
Proving Rewriter_Wf...
Tactic call ran for 0.03 secs (0.03u,0.s) (success)
Tactic call ran for 0.416 secs (0.411u,0.004s) (success)
Proving Rewriter_Interp...
Tactic call ran for 0.379 secs (0.376u,0.002s) (success)
Tactic call ran for 0.181 secs (0.178u,0.002s) (success)
Assembling verified rewriter...
Refining with verified rewriter...
Finished transaction in 15.206 secs (14.982u,0.224s) (successful)
Finished transaction in 5.086 secs (5.006u,0.079s) (successful)
Finished transaction in 2.694 secs (2.652u,0.042s) (successful)
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building ident_interp...
Building base_eq_dec...
Building base_beq_and_reflect...
Building base_beq...
Building reflect_base_beq...
Building baseHasNatAndCorrect...
Building baseHasNat...
Building baseHasNatCorrect...
Building base_interp_beq...
Building reflect_base_interp_beq...
Building try_make_base_transport_cps...
Building try_make_base_transport_cps_correct...
Building all_idents...
Building all_ident_and_interp...
Building buildEagerIdentAndInterpCorrect...
Building buildEagerIdent...
Building buildInterpEagerIdentCorrect...
Building toRestrictedIdentAndCorrect...
Building toRestrictedIdent...
Building toFromRestrictedIdent...
Building buildIdentAndInterpCorrect...
Building buildIdent...
Building buildInterpIdentCorrect...
Building ident_is_var_like...
Building eqv_Reflexive_Proper...
Building ident_interp_Proper...
Building invertIdent...
Building buildInvertIdentCorrect...
Building base_default...
Building package...
Building all_base...
Building all_idents...
Building ident_index...
Building eta_ident_cps_gen...
Building eta_ident_cps_gen_expand_literal...
Building eta_ident_cps...
Building simple_idents...
Building all_raw_idents...
Building raw_ident_index...
Building raw_ident_index_idempotent...
Building eta_raw_ident_cps_gen...
Building raw_ident_to_ident...
Building raw_ident_infos_of...
Building split_raw_ident_gen...
Building invert_bind_args...
Building invert_bind_args_unknown...
Building all_pattern_idents...
Building eta_pattern_ident_cps_gen...
Building eta_pattern_ident_cps_gen_expand_literal...
Building split_types...
Building add_types_from_raw_sig...
Building to_type_split_types_subst_default_eq...
Building projT1_add_types_from_raw_sig_eq...
Building arg_types_unfolded...
Building type_of_list_arg_types_beq_unfolded...
Building to_typed_unfolded...
Building of_typed_ident_unfolded...
Building arg_types_of_typed_ident_unfolded...
Building unify...
Building unify_unknown...
Building final ident package...
Proving is_simple_correct0...
Tactic call ran for 0.45 secs (0.446u,0.003s) (success)
Proving invert_bind_args_raw_to_typed...
Tactic call ran for 0.265 secs (0.256u,0.009s) (success)
Proving fold_invert_bind_args...
Tactic call ran for 0.026 secs (0.026u,0.s) (success)
Proving split_ident_to_ident...
Tactic call ran for 0.02 secs (0.018u,0.001s) (success)
Proving eq_indep_types_of_eq_types...
Tactic call ran for 0.895 secs (0.878u,0.017s) (success)
Proving fold_eta_ident_cps...
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving fold_unify...
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving to_typed_of_typed_ident...
Tactic call ran for 1.696 secs (1.674u,0.021s) (success)
Proving eq_invert_bind_args_unknown...
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving eq_unify_unknown...
Tactic call ran for 0. secs (0.u,0.s) (success)
Reifying...
Compiling decision tree...
Splitting rewrite rules...
Assembling rewrite_head...
Reducing rewrite_head...
Tactic call ran for 0.244 secs (0.243u,0.001s) (success)
Tactic call ran for 0.99 secs (0.975u,0.014s) (success)
Tactic call ran for 0.138 secs (0.138u,0.s) (success)
Assembling rewrite_head_no_dtree...
Reducing rewrite_head_no_dtree...
Proving Rewriter_Wf...
Tactic call ran for 0.233 secs (0.229u,0.003s) (success)
Tactic call ran for 1.896 secs (1.859u,0.037s) (success)
Proving Rewriter_Interp...
Tactic call ran for 2.093 secs (2.077u,0.015s) (success)
Tactic call ran for 1.578 secs (1.561u,0.016s) (success)
Assembling verified rewriter...
Refining with verified rewriter...
OrdersEx.Nat_as_OT.add_0_r: forall n : nat, n + 0 = n
OrdersEx.Nat_as_DT.add_0_r: forall n : nat, n + 0 = n
Nat.add_0_r: forall n : nat, n + 0 = n
NPeano.Nat.add_0_r: forall n : nat, n + 0 = n
Building index_of_base...
Building base_type_list...
Building eta_base_cps_gen...
Building eta_base_cps...
Building base_interp...
Building all_base...
Building all_base_and_interp...
Building index_of_ident...
Building ident_interp...
Building base_eq_dec...
Building base_beq_and_reflect...
Building base_beq...
Building reflect_base_beq...
Building baseHasNatAndCorrect...
Building baseHasNat...
Building baseHasNatCorrect...
Building base_interp_beq...
Building reflect_base_interp_beq...
Building try_make_base_transport_cps...
Building try_make_base_transport_cps_correct...
Building all_idents...
Building all_ident_and_interp...
Building buildEagerIdentAndInterpCorrect...
Building buildEagerIdent...
Building buildInterpEagerIdentCorrect...
Building toRestrictedIdentAndCorrect...
Building toRestrictedIdent...
Building toFromRestrictedIdent...
Building buildIdentAndInterpCorrect...
Building buildIdent...
Building buildInterpIdentCorrect...
Building ident_is_var_like...
Building eqv_Reflexive_Proper...
Building ident_interp_Proper...
Building invertIdent...
Building buildInvertIdentCorrect...
Building base_default...
Building package...
Building all_base...
Building all_idents...
Building ident_index...
Building eta_ident_cps_gen...
Building eta_ident_cps_gen_expand_literal...
Building eta_ident_cps...
Building simple_idents...
Building all_raw_idents...
Building raw_ident_index...
Building raw_ident_index_idempotent...
Building eta_raw_ident_cps_gen...
Building raw_ident_to_ident...
Building raw_ident_infos_of...
Building split_raw_ident_gen...
Building invert_bind_args...
Building invert_bind_args_unknown...
Building all_pattern_idents...
Building eta_pattern_ident_cps_gen...
Building eta_pattern_ident_cps_gen_expand_literal...
Building split_types...
Building add_types_from_raw_sig...
Building to_type_split_types_subst_default_eq...
Building projT1_add_types_from_raw_sig_eq...
Building arg_types_unfolded...
Building type_of_list_arg_types_beq_unfolded...
Building to_typed_unfolded...
Building of_typed_ident_unfolded...
Building arg_types_of_typed_ident_unfolded...
Building unify...
Building unify_unknown...
Building final ident package...
Proving is_simple_correct0...
Tactic call ran for 0.348 secs (0.338u,0.01s) (success)
Proving invert_bind_args_raw_to_typed...
Tactic call ran for 0.216 secs (0.211u,0.004s) (success)
Proving fold_invert_bind_args...
Tactic call ran for 0.024 secs (0.022u,0.001s) (success)
Proving split_ident_to_ident...
Tactic call ran for 0.013 secs (0.013u,0.s) (success)
Proving eq_indep_types_of_eq_types...
Tactic call ran for 0.746 secs (0.736u,0.009s) (success)
Proving fold_eta_ident_cps...
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving fold_unify...
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving to_typed_of_typed_ident...
Tactic call ran for 1.433 secs (1.402u,0.03s) (success)
Proving eq_invert_bind_args_unknown...
Tactic call ran for 0. secs (0.u,0.s) (success)
Proving eq_unify_unknown...
Tactic call ran for 0. secs (0.u,0.s) (success)
Reifying...
Compiling decision tree...
Splitting rewrite rules...
Assembling rewrite_head...
Reducing rewrite_head...
Tactic call ran for 0.023 secs (0.022u,0.001s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Tactic call ran for 0.026 secs (0.026u,0.s) (success)
Assembling rewrite_head_no_dtree...
Reducing rewrite_head_no_dtree...
Proving Rewriter_Wf...
Tactic call ran for 0.009 secs (0.009u,0.s) (success)
Tactic call ran for 0.086 secs (0.086u,0.s) (success)
Proving Rewriter_Interp...
Tactic call ran for 0.153 secs (0.148u,0.005s) (success)
Tactic call ran for 0.002 secs (0.002u,0.s) (success)
Assembling verified rewriter...
Refining with verified rewriter...
(ret [[0.33333333333332099; 0.33333333333334692]])
(ret [[0.39052428152232477; 0.3905243021208048]])
(ret [[0.39051452913860984; 0.39053541828418686]])
(ret [[0.40546510799655183; 0.40546510821793463]])
(ret [[0.40546510810804604; 0.40546510810828312]])
     = ret 2.8754776337791554e-14%float
     : E FF
     = ret 1.1539903023827236e-05%float
     : E FF
     = ret
         {|
           approx.pol :=
             [[[109.9761759193364; 109.9761759193364]];
             [[91.024979933356605; 91.024979933356605]];
             [[-0.013094741799676513; -0.013094741799676513]];
             [[0.0068657782589525594; 0.0068657782589525594]];
             [[-0.0036010109553458848; -0.0036010109553458848]];
             [[0.0018905493185753925; 0.0018905493185753925]];
             [[-0.00099590478953359707; -0.00099590478953359707]];
             [[0.00053090310183563356; 0.00053090310183563356]];
             [[-0.00029486341253459614; -0.00029486341253459614]];
             [[0.011210177712916903; 0.011210177712916903]];
             [[0.026815037081536274; 0.026815037081536274]]];
           approx.rem := [[-0.074844644956674256; 0.074844644956674242]];
           approx.cont := true
         |}
     : Static.sval (chebyshev_model_ops (fromZ 18) (fromZ 200)) FUN
     = ret (Specific_ops.Float 5567862537815687%Z (-58)%Z)
     : E FF
Finished transaction in 0.626 secs (0.564u,0.061s) (successful)
     = ret (Specific_ops.Float 5567862537815687%Z (-57)%Z)
     : E FF
Finished transaction in 0.558 secs (0.553u,0.005s) (successful)
     = ret
         {|
           approx.pol :=
             [[[Specific_ops.Float 720357451616277761%Z (-58)%Z;
              Specific_ops.Float 720357451616277761%Z (-58)%Z]];
             [[Specific_ops.Float 1094558786233859380%Z (-58)%Z;
             Specific_ops.Float 1094558786233859380%Z (-58)%Z]];
             [[Specific_ops.Float 977308976456680341%Z (-59)%Z;
             Specific_ops.Float 977308976456680341%Z (-59)%Z]];
             [[Specific_ops.Float 911430244636437681%Z (-61)%Z;
             Specific_ops.Float 911430244636437681%Z (-61)%Z]];
             [[Specific_ops.Float (-875073714472971280)%Z (-63)%Z;
             Specific_ops.Float (-875073714472971280)%Z (-63)%Z]];
             [[Specific_ops.Float (-749224186984049261)%Z (-62)%Z;
             Specific_ops.Float (-749224186984049261)%Z (-62)%Z]];
             [[Specific_ops.Float (-922337203685477604)%Z (-63)%Z;
             Specific_ops.Float (-922337203685477604)%Z (-63)%Z]];
             [[Specific_ops.Float (-692452066805713429)%Z (-64)%Z;
             Specific_ops.Float (-692452066805713429)%Z (-64)%Z]];
             [[Specific_ops.Float (-756215827400101205)%Z (-67)%Z;
             Specific_ops.Float (-756215827400101205)%Z (-67)%Z]];
             [[Specific_ops.Float 698045379138553685%Z (-67)%Z;
             Specific_ops.Float 698045379138553685%Z (-67)%Z]];
             [[Specific_ops.Float 684621429539735211%Z (-67)%Z;
             Specific_ops.Float 684621429539735211%Z (-67)%Z]];
             [[Specific_ops.Float 733842578068733952%Z (-68)%Z;
             Specific_ops.Float 733842578068733952%Z (-68)%Z]];
             [[Specific_ops.Float 894929973254551552%Z (-69)%Z;
             Specific_ops.Float 894929973254551552%Z (-69)%Z]]];
           approx.rem :=
             [[Specific_ops.Float (-929534692799689239)%Z (-69)%Z;
             Specific_ops.Float 929534692799689239%Z (-69)%Z]];
           approx.cont := true
         |}
     : Static.sval chebyshev11_model_ops FUN
Finished transaction in 0.739 secs (0.735u,0.003s) (successful)
     = ret
         {|
           approx.pol :=
             [[[Specific_ops.Float 720357451616277761%Z (-57)%Z;
              Specific_ops.Float 720357451616277761%Z (-57)%Z]];
             [[Specific_ops.Float 1094558786233859380%Z (-57)%Z;
             Specific_ops.Float 1094558786233859380%Z (-57)%Z]];
             [[Specific_ops.Float 977308976456680341%Z (-58)%Z;
             Specific_ops.Float 977308976456680341%Z (-58)%Z]];
             [[Specific_ops.Float 911430244636437681%Z (-60)%Z;
             Specific_ops.Float 911430244636437681%Z (-60)%Z]];
             [[Specific_ops.Float (-875073714472971280)%Z (-62)%Z;
             Specific_ops.Float (-875073714472971280)%Z (-62)%Z]];
             [[Specific_ops.Float (-749224186984049261)%Z (-61)%Z;
             Specific_ops.Float (-749224186984049261)%Z (-61)%Z]];
             [[Specific_ops.Float (-922337203685477604)%Z (-62)%Z;
             Specific_ops.Float (-922337203685477604)%Z (-62)%Z]];
             [[Specific_ops.Float (-692452066805713429)%Z (-63)%Z;
             Specific_ops.Float (-692452066805713429)%Z (-63)%Z]];
             [[Specific_ops.Float (-756215827400101205)%Z (-66)%Z;
             Specific_ops.Float (-756215827400101205)%Z (-66)%Z]];
             [[Specific_ops.Float 698045379138553685%Z (-66)%Z;
             Specific_ops.Float 698045379138553685%Z (-66)%Z]];
             [[Specific_ops.Float 684621429539735211%Z (-66)%Z;
             Specific_ops.Float 684621429539735211%Z (-66)%Z]];
             [[Specific_ops.Float 733842578068733952%Z (-67)%Z;
             Specific_ops.Float 733842578068733952%Z (-67)%Z]];
             [[Specific_ops.Float 894929973254551552%Z (-68)%Z;
             Specific_ops.Float 894929973254551552%Z (-68)%Z]]];
           approx.rem :=
             [[Specific_ops.Float (-929534692799689239)%Z (-68)%Z;
             Specific_ops.Float 929534692799689239%Z (-68)%Z]];
           approx.cont := true
         |}
     : Static.sval chebyshev11_model_ops FUN
Finished transaction in 0.776 secs (0.745u,0.031s) (successful)
     = ret 2.8754776337791554e-14%float
     : E FF
     = ret 1.1539903023827236e-05%float
     : E FF
     = ret
         {|
           approx.pol :=
             [[[109.9761759193364; 109.9761759193364]];
             [[91.024979933356605; 91.024979933356605]];
             [[-0.013094741799676513; -0.013094741799676513]];
             [[0.0068657782589525594; 0.0068657782589525594]];
             [[-0.0036010109553458848; -0.0036010109553458848]];
             [[0.0018905493185753925; 0.0018905493185753925]];
             [[-0.00099590478953359707; -0.00099590478953359707]];
             [[0.00053090310183563356; 0.00053090310183563356]];
             [[-0.00029486341253459614; -0.00029486341253459614]];
             [[0.011210177712916903; 0.011210177712916903]];
             [[0.026815037081536274; 0.026815037081536274]]];
           approx.rem := [[-0.074844644956674256; 0.074844644956674242]];
           approx.cont := true
         |}
     : Static.sval (chebyshev_model_ops (fromZ 18) (fromZ 200)) FUN
     = ret (Specific_ops.Float 5567862537815687%Z (-58)%Z)
     : E FF
Finished transaction in 0.58 secs (0.557u,0.023s) (successful)
     = ret (Specific_ops.Float 5567862537815687%Z (-57)%Z)
     : E FF
Finished transaction in 0.543 secs (0.543u,0.s) (successful)
     = ret
         {|
           approx.pol :=
             [[[Specific_ops.Float 720357451616277761%Z (-58)%Z;
              Specific_ops.Float 720357451616277761%Z (-58)%Z]];
             [[Specific_ops.Float 1094558786233859380%Z (-58)%Z;
             Specific_ops.Float 1094558786233859380%Z (-58)%Z]];
             [[Specific_ops.Float 977308976456680341%Z (-59)%Z;
             Specific_ops.Float 977308976456680341%Z (-59)%Z]];
             [[Specific_ops.Float 911430244636437681%Z (-61)%Z;
             Specific_ops.Float 911430244636437681%Z (-61)%Z]];
             [[Specific_ops.Float (-875073714472971280)%Z (-63)%Z;
             Specific_ops.Float (-875073714472971280)%Z (-63)%Z]];
             [[Specific_ops.Float (-749224186984049261)%Z (-62)%Z;
             Specific_ops.Float (-749224186984049261)%Z (-62)%Z]];
             [[Specific_ops.Float (-922337203685477604)%Z (-63)%Z;
             Specific_ops.Float (-922337203685477604)%Z (-63)%Z]];
             [[Specific_ops.Float (-692452066805713429)%Z (-64)%Z;
             Specific_ops.Float (-692452066805713429)%Z (-64)%Z]];
             [[Specific_ops.Float (-756215827400101205)%Z (-67)%Z;
             Specific_ops.Float (-756215827400101205)%Z (-67)%Z]];
             [[Specific_ops.Float 698045379138553685%Z (-67)%Z;
             Specific_ops.Float 698045379138553685%Z (-67)%Z]];
             [[Specific_ops.Float 684621429539735211%Z (-67)%Z;
             Specific_ops.Float 684621429539735211%Z (-67)%Z]];
             [[Specific_ops.Float 733842578068733952%Z (-68)%Z;
             Specific_ops.Float 733842578068733952%Z (-68)%Z]];
             [[Specific_ops.Float 894929973254551552%Z (-69)%Z;
             Specific_ops.Float 894929973254551552%Z (-69)%Z]]];
           approx.rem :=
             [[Specific_ops.Float (-929534692799689239)%Z (-69)%Z;
             Specific_ops.Float 929534692799689239%Z (-69)%Z]];
           approx.cont := true
         |}
     : Static.sval chebyshev11_model_ops FUN
Finished transaction in 0.719 secs (0.719u,0.s) (successful)
     = ret
         {|
           approx.pol :=
             [[[Specific_ops.Float 720357451616277761%Z (-57)%Z;
              Specific_ops.Float 720357451616277761%Z (-57)%Z]];
             [[Specific_ops.Float 1094558786233859380%Z (-57)%Z;
             Specific_ops.Float 1094558786233859380%Z (-57)%Z]];
             [[Specific_ops.Float 977308976456680341%Z (-58)%Z;
             Specific_ops.Float 977308976456680341%Z (-58)%Z]];
             [[Specific_ops.Float 911430244636437681%Z (-60)%Z;
             Specific_ops.Float 911430244636437681%Z (-60)%Z]];
             [[Specific_ops.Float (-875073714472971280)%Z (-62)%Z;
             Specific_ops.Float (-875073714472971280)%Z (-62)%Z]];
             [[Specific_ops.Float (-749224186984049261)%Z (-61)%Z;
             Specific_ops.Float (-749224186984049261)%Z (-61)%Z]];
             [[Specific_ops.Float (-922337203685477604)%Z (-62)%Z;
             Specific_ops.Float (-922337203685477604)%Z (-62)%Z]];
             [[Specific_ops.Float (-692452066805713429)%Z (-63)%Z;
             Specific_ops.Float (-692452066805713429)%Z (-63)%Z]];
             [[Specific_ops.Float (-756215827400101205)%Z (-66)%Z;
             Specific_ops.Float (-756215827400101205)%Z (-66)%Z]];
             [[Specific_ops.Float 698045379138553685%Z (-66)%Z;
             Specific_ops.Float 698045379138553685%Z (-66)%Z]];
             [[Specific_ops.Float 684621429539735211%Z (-66)%Z;
             Specific_ops.Float 684621429539735211%Z (-66)%Z]];
             [[Specific_ops.Float 733842578068733952%Z (-67)%Z;
             Specific_ops.Float 733842578068733952%Z (-67)%Z]];
             [[Specific_ops.Float 894929973254551552%Z (-68)%Z;
             Specific_ops.Float 894929973254551552%Z (-68)%Z]]];
           approx.rem :=
             [[Specific_ops.Float (-929534692799689239)%Z (-68)%Z;
             Specific_ops.Float 929534692799689239%Z (-68)%Z]];
           approx.cont := true
         |}
     : Static.sval chebyshev11_model_ops FUN
Finished transaction in 0.721 secs (0.721u,0.s) (successful)
     = (ω ^ (ω ^ ω ^ 2 + 1) + 2)%pT1
     : ppT1
Debug:
In environment
c, u : int -> int -> rat
c_ann : c.Ann c
c_Sn := c.Sn_ c_ann : c.Sn c
c_Sk := c.Sk_ c_ann : c.Sk c
u_ann : u.Ann u
u_Sn2 := u.Sn2_ u_ann : u.Sn2 u
u_SnSk := u.SnSk_ u_ann : u.SnSk u
u_Sk2 := u.Sk2_ u_ann : u.Sk2 u
v := fun n k : int => c n k * u n k : int -> int -> rat_Ring
n : nat
r : int
H : precond.Sn2 n r
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: c (int.shift 2 n) r; u (int.shift 2 n) r; 
        Sn2_cf0_0 n r; c n r; u n r; Sn2_cf1_0 n r; 
        c (int.shift 1 n) r; u (int.shift 1 n) r; 
        Sn2_cf0_1 n r; c n (int.shift 1 r); u n (int.shift 1 r)]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
H3: alpha = g2h from
g2h_zero: g2h zero = T1.zero
H2: g2h from <> T1.zero
H4: g2h to = hcanon (g2h from) i.+1
g2h_succ: forall a : T1, g2h (T1succ a) = succ (g2h a)
hnf_g2h: forall a : T1, nf (g2h a) = T1nf a
g2h_eqE: forall a b : T1, g2h a = g2h b <-> a = b
T1Bridge.T1eqE: forall [a b : T1], T1eq a b -> g2h a = g2h b
g2h_plusE: forall a b : T1, g2h (a + b) = (g2h a + g2h b)%t1
g2h_multE: forall a b : T1, g2h (a * b) = (g2h a * g2h b)%t1
g2h_canon: forall (a : T1) (i : nat), g2h (canon a i) = hcanon (g2h a) i
g2h_phi0: forall a : T1, g2h (phi0 a) = T1.phi0 (g2h a)
g2h_diffE: forall a b : T1, g2h a <> g2h b <-> a <> b
g2h_cons:
  forall (a : T1) (n : nat) (b : T1),
  g2h (cons a n b) = T1.cons (g2h a) n (g2h b)
compare_g2h: forall a beta : T1, compare (g2h a) (g2h beta) = compare a beta
refines1_R:
  forall (f : hT1 -> hT1) (f' : T1 -> T1),
  refines1 f f' <-> (forall y : T1, f (g2h y) = g2h (f' y))
refines2_R:
  forall (f : hT1 -> hT1 -> hT1) (f' : T1 -> T1 -> T1),
  refines2 f f' <-> (forall y z : T1, f (g2h y) (g2h z) = g2h (f' y z))
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
spq : 0 <= k
H : k < n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P1_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
LTa : 0 <= k
LTb : k < n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P1_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
x : 0 <= k
H : k < n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P1_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
s1 : 0 <= k
s2 : k < n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P1_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
spq : 0 <= k
H : k < n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P1_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
LTa : 0 <= k
LTb : k < n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P1_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
x : 0 <= k
H : k < n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P1_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
s1 : 0 <= k
s2 : k < n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P1_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
k : int
n : nat
hmn : 0 <= k
hi : k < n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: ((0%Q +
           ((((match k with
               | Posz elpi_ctx_entry_4_ => iterop elpi_ctx_entry_4_ addq 1 0
               | Negz elpi_ctx_entry_4_ =>
                   (-
                    match elpi_ctx_entry_4_ with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 => 1%Q + loop i
                            end) elpi_ctx_entry_4_)%Q
                    end)%Q
               end * ((rat_of_Z 2 * iterop n addq 1 0)%Q + rat_of_Z 3)%Q)%Q *
              ((- iterop n addq 1 0)%Q +
               match k with
               | Posz elpi_ctx_entry_4_ => iterop elpi_ctx_entry_4_ addq 1 0
               | Negz elpi_ctx_entry_4_ =>
                   (-
                    match elpi_ctx_entry_4_ with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 => 1%Q + loop i
                            end) elpi_ctx_entry_4_)%Q
                    end)%Q
               end)%Q)%Q * s (n + 1)%Nrec (intZmod.addz k 1))%Q +
            (((((- rat_of_Z 1)%Q *
                match k with
                | Posz elpi_ctx_entry_4_ => iterop elpi_ctx_entry_4_ addq 1 0
                | Negz elpi_ctx_entry_4_ =>
                    (-
                     match elpi_ctx_entry_4_ with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 => 1%Q + loop i
                             end) elpi_ctx_entry_4_)%Q
                     end)%Q
                end)%Q * ((rat_of_Z 2 * iterop n addq 1 0)%Q + rat_of_Z 3)%Q)%Q *
              ((- iterop n addq 1 0)%Q +
               match k with
               | Posz elpi_ctx_entry_4_ => iterop elpi_ctx_entry_4_ addq 1 0
               | Negz elpi_ctx_entry_4_ =>
                   (-
                    match elpi_ctx_entry_4_ with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 => 1%Q + loop i
                            end) elpi_ctx_entry_4_)%Q
                    end)%Q
               end)%Q)%Q * s n (intZmod.addz k 1))%Q)%Q)%Q +
          (((((iterop n addq 1 0 + rat_of_Z 2)%Q *
              ((iterop n addq 1 0 + rat_of_Z 2)%Q *
               (iterop n addq 1 0 + rat_of_Z 2)%Q)%Q)%Q *
             s ((n + 1)%Nrec + 1)%Nrec k)%Q +
            ((((- rat_of_Z 1)%Q *
               ((rat_of_Z 2 * iterop n addq 1 0)%Q + rat_of_Z 3)%Q)%Q *
              (((((iterop n addq 1 0 * iterop n addq 1 0)%Q +
                  (rat_of_Z 3 * iterop n addq 1 0)%Q)%Q +
                 ((-
                   match k with
                   | Posz elpi_ctx_entry_4_ =>
                       iterop elpi_ctx_entry_4_ addq 1 0
                   | Negz elpi_ctx_entry_4_ =>
                       (-
                        match elpi_ctx_entry_4_ with
                        | 0 => 1%Q
                        | _.+1 =>
                            (1%Q +
                             (fix loop (m : nat) : rat :=
                                match m with
                                | 0 => 0
                                | 1 => 1
                                | (_.+1 as i).+1 => 1%Q + loop i
                                end) elpi_ctx_entry_4_)%Q
                        end)%Q
                   end)%Q * iterop n addq 1 0)%Q)%Q +
                (match k with
                 | Posz elpi_ctx_entry_4_ =>
                     iterop elpi_ctx_entry_4_ addq 1 0
                 | Negz elpi_ctx_entry_4_ =>
                     (-
                      match elpi_ctx_entry_4_ with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) elpi_ctx_entry_4_)%Q
                      end)%Q
                 end *
                 match k with
                 | Posz elpi_ctx_entry_4_ =>
                     iterop elpi_ctx_entry_4_ addq 1 0
                 | Negz elpi_ctx_entry_4_ =>
                     (-
                      match elpi_ctx_entry_4_ with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) elpi_ctx_entry_4_)%Q
                      end)%Q
                 end)%Q)%Q + rat_of_Z 3)%Q)%Q * s (n + 1)%Nrec k)%Q)%Q +
           ((((((((((rat_of_Z 2 *
                     (match k with
                      | Posz elpi_ctx_entry_4_ =>
                          iterop elpi_ctx_entry_4_ addq 1 0
                      | Negz elpi_ctx_entry_4_ =>
                          (-
                           match elpi_ctx_entry_4_ with
                           | 0 => 1%Q
                           | _.+1 =>
                               (1%Q +
                                (fix loop (m : nat) : rat :=
                                   match m with
                                   | 0 => 0
                                   | 1 => 1
                                   | (_.+1 as i).+1 => 1%Q + loop i
                                   end) elpi_ctx_entry_4_)%Q
                           end)%Q
                      end *
                      match k with
                      | Posz elpi_ctx_entry_4_ =>
                          iterop elpi_ctx_entry_4_ addq 1 0
                      | Negz elpi_ctx_entry_4_ =>
                          (-
                           match elpi_ctx_entry_4_ with
                           | 0 => 1%Q
                           | _.+1 =>
                               (1%Q +
                                (fix loop (m : nat) : rat :=
                                   match m with
                                   | 0 => 0
                                   | 1 => 1
                                   | (_.+1 as i).+1 => 1%Q + loop i
                                   end) elpi_ctx_entry_4_)%Q
                           end)%Q
                      end)%Q)%Q * iterop n addq 1 0)%Q +
                   (rat_of_Z 3 *
                    (match k with
                     | Posz elpi_ctx_entry_4_ =>
                         iterop elpi_ctx_entry_4_ addq 1 0
                     | Negz elpi_ctx_entry_4_ =>
                         (-
                          match elpi_ctx_entry_4_ with
                          | 0 => 1%Q
                          | _.+1 =>
                              (1%Q +
                               (fix loop (m : nat) : rat :=
                                  match m with
                                  | 0 => 0
                                  | 1 => 1
                                  | (_.+1 as i).+1 => 1%Q + loop i
                                  end) elpi_ctx_entry_4_)%Q
                          end)%Q
                     end *
                     match k with
                     | Posz elpi_ctx_entry_4_ =>
                         iterop elpi_ctx_entry_4_ addq 1 0
                     | Negz elpi_ctx_entry_4_ =>
                         (-
                          match elpi_ctx_entry_4_ with
                          | 0 => 1%Q
                          | _.+1 =>
                              (1%Q +
                               (fix loop (m : nat) : rat :=
                                  match m with
                                  | 0 => 0
                                  | 1 => 1
                                  | (_.+1 as i).+1 => 1%Q + loop i
                                  end) elpi_ctx_entry_4_)%Q
                          end)%Q
                     end)%Q)%Q)%Q +
                  (((- rat_of_Z 2)%Q *
                    match k with
                    | Posz elpi_ctx_entry_4_ =>
                        iterop elpi_ctx_entry_4_ addq 1 0
                    | Negz elpi_ctx_entry_4_ =>
                        (-
                         match elpi_ctx_entry_4_ with
                         | 0 => 1%Q
                         | _.+1 =>
                             (1%Q +
                              (fix loop (m : nat) : rat :=
                                 match m with
                                 | 0 => 0
                                 | 1 => 1
                                 | (_.+1 as i).+1 => 1%Q + loop i
                                 end) elpi_ctx_entry_4_)%Q
                         end)%Q
                    end)%Q * (iterop n addq 1 0 * iterop n addq 1 0)%Q)%Q)%Q +
                 (((- rat_of_Z 3)%Q *
                   match k with
                   | Posz elpi_ctx_entry_4_ =>
                       iterop elpi_ctx_entry_4_ addq 1 0
                   | Negz elpi_ctx_entry_4_ =>
                       (-
                        match elpi_ctx_entry_4_ with
                        | 0 => 1%Q
                        | _.+1 =>
                            (1%Q +
                             (fix loop (m : nat) : rat :=
                                match m with
                                | 0 => 0
                                | 1 => 1
                                | (_.+1 as i).+1 => 1%Q + loop i
                                end) elpi_ctx_entry_4_)%Q
                        end)%Q
                   end)%Q * iterop n addq 1 0)%Q)%Q +
                (iterop n addq 1 0 *
                 (iterop n addq 1 0 * iterop n addq 1 0)%Q)%Q)%Q +
               (rat_of_Z 3 * (iterop n addq 1 0 * iterop n addq 1 0)%Q)%Q)%Q +
              (rat_of_Z 3 * iterop n addq 1 0)%Q)%Q + 
             rat_of_Z 1)%Q * s n k)%Q)%Q)%Q; 0%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
spq : 0 <= k
H : k < n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P1_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
spq : 0 <= k
H : k < n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P1_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
LTa : 0 <= k
LTb : k < n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P1_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
LTa : 0 <= k
LTb : k < n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P1_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
x : 0 <= k
H : k < n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P1_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
x : 0 <= k
H : k < n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P1_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
s1 : 0 <= k
s2 : k < n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P1_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
s1 : 0 <= k
s2 : k < n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P1_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
k : int
n : nat
hmn : 0 <= k
hi : k < n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: ((0%Q +
           ((((match k with
               | Posz elpi_ctx_entry_4_ => iterop elpi_ctx_entry_4_ addq 1 0
               | Negz elpi_ctx_entry_4_ =>
                   (-
                    match elpi_ctx_entry_4_ with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 => 1%Q + loop i
                            end) elpi_ctx_entry_4_)%Q
                    end)%Q
               end * ((rat_of_Z 2 * iterop n addq 1 0)%Q + rat_of_Z 3)%Q)%Q *
              ((- iterop n addq 1 0)%Q +
               match k with
               | Posz elpi_ctx_entry_4_ => iterop elpi_ctx_entry_4_ addq 1 0
               | Negz elpi_ctx_entry_4_ =>
                   (-
                    match elpi_ctx_entry_4_ with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 => 1%Q + loop i
                            end) elpi_ctx_entry_4_)%Q
                    end)%Q
               end)%Q)%Q * s (n + 1)%Nrec (intZmod.addz k 1))%Q +
            (((((- rat_of_Z 1)%Q *
                match k with
                | Posz elpi_ctx_entry_4_ => iterop elpi_ctx_entry_4_ addq 1 0
                | Negz elpi_ctx_entry_4_ =>
                    (-
                     match elpi_ctx_entry_4_ with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 => 1%Q + loop i
                             end) elpi_ctx_entry_4_)%Q
                     end)%Q
                end)%Q * ((rat_of_Z 2 * iterop n addq 1 0)%Q + rat_of_Z 3)%Q)%Q *
              ((- iterop n addq 1 0)%Q +
               match k with
               | Posz elpi_ctx_entry_4_ => iterop elpi_ctx_entry_4_ addq 1 0
               | Negz elpi_ctx_entry_4_ =>
                   (-
                    match elpi_ctx_entry_4_ with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 => 1%Q + loop i
                            end) elpi_ctx_entry_4_)%Q
                    end)%Q
               end)%Q)%Q * s n (intZmod.addz k 1))%Q)%Q)%Q +
          (((((iterop n addq 1 0 + rat_of_Z 2)%Q *
              ((iterop n addq 1 0 + rat_of_Z 2)%Q *
               (iterop n addq 1 0 + rat_of_Z 2)%Q)%Q)%Q *
             s ((n + 1)%Nrec + 1)%Nrec k)%Q +
            ((((- rat_of_Z 1)%Q *
               ((rat_of_Z 2 * iterop n addq 1 0)%Q + rat_of_Z 3)%Q)%Q *
              (((((iterop n addq 1 0 * iterop n addq 1 0)%Q +
                  (rat_of_Z 3 * iterop n addq 1 0)%Q)%Q +
                 ((-
                   match k with
                   | Posz elpi_ctx_entry_4_ =>
                       iterop elpi_ctx_entry_4_ addq 1 0
                   | Negz elpi_ctx_entry_4_ =>
                       (-
                        match elpi_ctx_entry_4_ with
                        | 0 => 1%Q
                        | _.+1 =>
                            (1%Q +
                             (fix loop (m : nat) : rat :=
                                match m with
                                | 0 => 0
                                | 1 => 1
                                | (_.+1 as i).+1 => 1%Q + loop i
                                end) elpi_ctx_entry_4_)%Q
                        end)%Q
                   end)%Q * iterop n addq 1 0)%Q)%Q +
                (match k with
                 | Posz elpi_ctx_entry_4_ =>
                     iterop elpi_ctx_entry_4_ addq 1 0
                 | Negz elpi_ctx_entry_4_ =>
                     (-
                      match elpi_ctx_entry_4_ with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) elpi_ctx_entry_4_)%Q
                      end)%Q
                 end *
                 match k with
                 | Posz elpi_ctx_entry_4_ =>
                     iterop elpi_ctx_entry_4_ addq 1 0
                 | Negz elpi_ctx_entry_4_ =>
                     (-
                      match elpi_ctx_entry_4_ with
                      | 0 => 1%Q
                      | _.+1 =>
                          (1%Q +
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 => 1%Q + loop i
                              end) elpi_ctx_entry_4_)%Q
                      end)%Q
                 end)%Q)%Q + rat_of_Z 3)%Q)%Q * s (n + 1)%Nrec k)%Q)%Q +
           ((((((((((rat_of_Z 2 *
                     (match k with
                      | Posz elpi_ctx_entry_4_ =>
                          iterop elpi_ctx_entry_4_ addq 1 0
                      | Negz elpi_ctx_entry_4_ =>
                          (-
                           match elpi_ctx_entry_4_ with
                           | 0 => 1%Q
                           | _.+1 =>
                               (1%Q +
                                (fix loop (m : nat) : rat :=
                                   match m with
                                   | 0 => 0
                                   | 1 => 1
                                   | (_.+1 as i).+1 => 1%Q + loop i
                                   end) elpi_ctx_entry_4_)%Q
                           end)%Q
                      end *
                      match k with
                      | Posz elpi_ctx_entry_4_ =>
                          iterop elpi_ctx_entry_4_ addq 1 0
                      | Negz elpi_ctx_entry_4_ =>
                          (-
                           match elpi_ctx_entry_4_ with
                           | 0 => 1%Q
                           | _.+1 =>
                               (1%Q +
                                (fix loop (m : nat) : rat :=
                                   match m with
                                   | 0 => 0
                                   | 1 => 1
                                   | (_.+1 as i).+1 => 1%Q + loop i
                                   end) elpi_ctx_entry_4_)%Q
                           end)%Q
                      end)%Q)%Q * iterop n addq 1 0)%Q +
                   (rat_of_Z 3 *
                    (match k with
                     | Posz elpi_ctx_entry_4_ =>
                         iterop elpi_ctx_entry_4_ addq 1 0
                     | Negz elpi_ctx_entry_4_ =>
                         (-
                          match elpi_ctx_entry_4_ with
                          | 0 => 1%Q
                          | _.+1 =>
                              (1%Q +
                               (fix loop (m : nat) : rat :=
                                  match m with
                                  | 0 => 0
                                  | 1 => 1
                                  | (_.+1 as i).+1 => 1%Q + loop i
                                  end) elpi_ctx_entry_4_)%Q
                          end)%Q
                     end *
                     match k with
                     | Posz elpi_ctx_entry_4_ =>
                         iterop elpi_ctx_entry_4_ addq 1 0
                     | Negz elpi_ctx_entry_4_ =>
                         (-
                          match elpi_ctx_entry_4_ with
                          | 0 => 1%Q
                          | _.+1 =>
                              (1%Q +
                               (fix loop (m : nat) : rat :=
                                  match m with
                                  | 0 => 0
                                  | 1 => 1
                                  | (_.+1 as i).+1 => 1%Q + loop i
                                  end) elpi_ctx_entry_4_)%Q
                          end)%Q
                     end)%Q)%Q)%Q +
                  (((- rat_of_Z 2)%Q *
                    match k with
                    | Posz elpi_ctx_entry_4_ =>
                        iterop elpi_ctx_entry_4_ addq 1 0
                    | Negz elpi_ctx_entry_4_ =>
                        (-
                         match elpi_ctx_entry_4_ with
                         | 0 => 1%Q
                         | _.+1 =>
                             (1%Q +
                              (fix loop (m : nat) : rat :=
                                 match m with
                                 | 0 => 0
                                 | 1 => 1
                                 | (_.+1 as i).+1 => 1%Q + loop i
                                 end) elpi_ctx_entry_4_)%Q
                         end)%Q
                    end)%Q * (iterop n addq 1 0 * iterop n addq 1 0)%Q)%Q)%Q +
                 (((- rat_of_Z 3)%Q *
                   match k with
                   | Posz elpi_ctx_entry_4_ =>
                       iterop elpi_ctx_entry_4_ addq 1 0
                   | Negz elpi_ctx_entry_4_ =>
                       (-
                        match elpi_ctx_entry_4_ with
                        | 0 => 1%Q
                        | _.+1 =>
                            (1%Q +
                             (fix loop (m : nat) : rat :=
                                match m with
                                | 0 => 0
                                | 1 => 1
                                | (_.+1 as i).+1 => 1%Q + loop i
                                end) elpi_ctx_entry_4_)%Q
                        end)%Q
                   end)%Q * iterop n addq 1 0)%Q)%Q +
                (iterop n addq 1 0 *
                 (iterop n addq 1 0 * iterop n addq 1 0)%Q)%Q)%Q +
               (rat_of_Z 3 * (iterop n addq 1 0 * iterop n addq 1 0)%Q)%Q)%Q +
              (rat_of_Z 3 * iterop n addq 1 0)%Q)%Q + 
             rat_of_Z 1)%Q * s n k)%Q)%Q)%Q; 0%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
q : 0 <= k
r : k < n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P1_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
H : 0 <= k
H0 : k < n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P1_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
eqPQ : 0 <= k
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l = [:: P1_horner s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Inductive hydras.Epsilon0.T1.T1
Inductive gaia.schutte.ssete9.CantorOrdinal.T1
  (shorter name to refer to it in current context is CantorOrdinal.T1)
Notation gaia_hydras.T1Bridge.T1
  (shorter name to refer to it in current context is T1Bridge.T1)
Module hydras.Epsilon0.T1
T2.T2
     : Set
Inductive T2 : Set :=
    zero : T2.T2 | gcons : T2.T2 -> T2.T2 -> nat -> T2.T2 -> T2.T2.

Arguments gcons _ _ _%nat_scope _
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
p : 0 <= k
H : intOrdered.ltz (intZmod.addz k 1) n
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: ((match
             (((match k with
                | Posz elpi_ctx_entry_4_ => iterop elpi_ctx_entry_4_ addq 1 0
                | Negz elpi_ctx_entry_4_ =>
                    (-
                     match elpi_ctx_entry_4_ with
                     | 0 => 1%Q
                     | _.+1 =>
                         match
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 =>
                                  match loop i with
                                  | {| valq := y |} =>
                                      fracq
                                        (let (y1, y2) := y in
                                         match y2 with
                                         | Posz 1 =>
                                             match y1 with
                                             | Posz 0 => (1, 1)
                                             | Posz 1 => (2, 1)
                                             | Posz
                                               (_.+2 as elpi_ctx_entry_16_) =>
                                                 (elpi_ctx_entry_16_.+1, 1)
                                             | Negz _ =>
                                                 (
                                                 match y1 with
                                                 | Posz n' => n'.+1
                                                 | Negz n' =>
                                                 if ... then 0 else ...
                                                 end, 1)
                                             end
                                         | _ =>
                                             (intZmod.addz
                                                match y2 with
                                                | Posz n' => (n' + 0)%coq_nat
                                                | Negz n' =>
                                                 Negz (n' + 0)%coq_nat
                                                end y1, y2)
                                         end)
                                  end
                              end) elpi_ctx_entry_4_
                         with
                         | {| valq := y |} =>
                             fracq
                               (let (y1, y2) := y in
                                match y2 with
                                | Posz 1 =>
                                    match y1 with
                                    | Posz 0 => (1, 1)
                                    | Posz 1 => (2, 1)
                                    | Posz (_.+2 as elpi_ctx_entry_12_) =>
                                        (elpi_ctx_entry_12_.+1, 1)
                                    | Negz _ =>
                                        (match y1 with
                                         | Posz n' => n'.+1
                                         | Negz n' =>
                                             if eqn (n' - 0)%Nrec 0
                                             then 0
                                             else Negz (n' - 1)%Nrec
                                         end, 1)
                                    end
                                | _ =>
                                    (intZmod.addz
                                       match y2 with
                                       | Posz n' => (n' + 0)%coq_nat
                                       | Negz n' => Negz (n' + 0)%coq_nat
                                       end y1, y2)
                                end)
                         end
                     end)%Q
                end + rat_of_Z 2)%Q *
               ((match n with
                 | Posz elpi_ctx_entry_4_ =>
                     iterop elpi_ctx_entry_4_ addq 1 0
                 | Negz elpi_ctx_entry_4_ =>
                     (-
                      match elpi_ctx_entry_4_ with
                      | 0 => 1%Q
                      | _.+1 =>
                          match
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as i).+1 =>
                                   match loop i with
                                   | {| valq := y |} =>
                                       fracq
                                         (let (y1, y2) := y in
                                          match y2 with
                                          | Posz 1 =>
                                              match y1 with
                                              | Posz 0 => (1, 1)
                                              | Posz 1 => (2, 1)
                                              | Posz
                                                (_.+2 as elpi_ctx_entry_16_) =>
                                                 (elpi_ctx_entry_16_.+1, 1)
                                              | Negz _ =>
                                                 (
                                                 match ... with
                                                 | ... n'.+1
                                                 | ... ...
                                                 end, 1)
                                              end
                                          | _ =>
                                              (intZmod.addz
                                                 match ... with
                                                 | ... => (...)%coq_nat
                                                 | ... => Negz ...%coq_nat
                                                 end y1, y2)
                                          end)
                                   end
                               end) elpi_ctx_entry_4_
                          with
                          | {| valq := y |} =>
                              fracq
                                (let (y1, y2) := y in
                                 match y2 with
                                 | Posz 1 =>
                                     match y1 with
                                     | Posz 0 => (1, 1)
                                     | Posz 1 => (2, 1)
                                     | Posz (_.+2 as elpi_ctx_entry_12_) =>
                                         (elpi_ctx_entry_12_.+1, 1)
                                     | Negz _ =>
                                         (match y1 with
                                          | Posz n' => n'.+1
                                          | Negz n' =>
                                              if eqn (n' - 0)%Nrec 0
                                              then 0
                                              else Negz (n' - 1)%Nrec
                                          end, 1)
                                     end
                                 | _ =>
                                     (intZmod.addz
                                        match y2 with
                                        | Posz n' => (n' + 0)%coq_nat
                                        | Negz n' => Negz (n' + 0)%coq_nat
                                        end y1, y2)
                                 end)
                          end
                      end)%Q
                 end + rat_of_Z 2)%Q +
                match k with
                | Posz elpi_ctx_entry_4_ => iterop elpi_ctx_entry_4_ addq 1 0
                | Negz elpi_ctx_entry_4_ =>
                    (-
                     match elpi_ctx_entry_4_ with
                     | 0 => 1%Q
                     | _.+1 =>
                         match
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 =>
                                  match loop i with
                                  | {| valq := y |} =>
                                      fracq
                                        (let (y1, y2) := y in
                                         match y2 with
                                         | Posz 1 =>
                                             match y1 with
                                             | Posz 0 => (1, 1)
                                             | Posz 1 => (2, 1)
                                             | Posz
                                               (_.+2 as elpi_ctx_entry_16_) =>
                                                 (elpi_ctx_entry_16_.+1, 1)
                                             | Negz _ =>
                                                 (
                                                 match y1 with
                                                 | Posz n' => n'.+1
                                                 | Negz n' =>
                                                 if ... then 0 else ...
                                                 end, 1)
                                             end
                                         | _ =>
                                             (intZmod.addz
                                                match y2 with
                                                | Posz n' => (n' + 0)%coq_nat
                                                | Negz n' =>
                                                 Negz (n' + 0)%coq_nat
                                                end y1, y2)
                                         end)
                                  end
                              end) elpi_ctx_entry_4_
                         with
                         | {| valq := y |} =>
                             fracq
                               (let (y1, y2) := y in
                                match y2 with
                                | Posz 1 =>
                                    match y1 with
                                    | Posz 0 => (1, 1)
                                    | Posz 1 => (2, 1)
                                    | Posz (_.+2 as elpi_ctx_entry_12_) =>
                                        (elpi_ctx_entry_12_.+1, 1)
                                    | Negz _ =>
                                        (match y1 with
                                         | Posz n' => n'.+1
                                         | Negz n' =>
                                             if eqn (n' - 0)%Nrec 0
                                             then 0
                                             else Negz (n' - 1)%Nrec
                                         end, 1)
                                    end
                                | _ =>
                                    (intZmod.addz
                                       match y2 with
                                       | Posz n' => (n' + 0)%coq_nat
                                       | Negz n' => Negz (n' + 0)%coq_nat
                                       end y1, y2)
                                end)
                         end
                     end)%Q
                end)%Q)%Q *
              (((-
                 match n with
                 | Posz elpi_ctx_entry_4_ =>
                     iterop elpi_ctx_entry_4_ addq 1 0
                 | Negz elpi_ctx_entry_4_ =>
                     (-
                      match elpi_ctx_entry_4_ with
                      | 0 => 1%Q
                      | _.+1 =>
                          match
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as i).+1 =>
                                   match loop i with
                                   | {| valq := y |} =>
                                       fracq
                                         (let (y1, y2) := y in
                                          match y2 with
                                          | Posz 1 =>
                                              match y1 with
                                              | Posz 0 => (1, 1)
                                              | Posz 1 => (2, 1)
                                              | Posz
                                                (_.+2 as elpi_ctx_entry_16_) =>
                                                 (elpi_ctx_entry_16_.+1, 1)
                                              | Negz _ =>
                                                 (
                                                 match ... with
                                                 | ... n'.+1
                                                 | ... ...
                                                 end, 1)
                                              end
                                          | _ =>
                                              (intZmod.addz
                                                 match ... with
                                                 | ... => (...)%coq_nat
                                                 | ... => Negz ...%coq_nat
                                                 end y1, y2)
                                          end)
                                   end
                               end) elpi_ctx_entry_4_
                          with
                          | {| valq := y |} =>
                              fracq
                                (let (y1, y2) := y in
                                 match y2 with
                                 | Posz 1 =>
                                     match y1 with
                                     | Posz 0 => (1, 1)
                                     | Posz 1 => (2, 1)
                                     | Posz (_.+2 as elpi_ctx_entry_12_) =>
                                         (elpi_ctx_entry_12_.+1, 1)
                                     | Negz _ =>
                                         (match y1 with
                                          | Posz n' => n'.+1
                                          | Negz n' =>
                                              if eqn (n' - 0)%Nrec 0
                                              then 0
                                              else Negz (n' - 1)%Nrec
                                          end, 1)
                                     end
                                 | _ =>
                                     (intZmod.addz
                                        match y2 with
                                        | Posz n' => (n' + 0)%coq_nat
                                        | Negz n' => Negz (n' + 0)%coq_nat
                                        end y1, y2)
                                 end)
                          end
                      end)%Q
                 end)%Q +
                match k with
                | Posz elpi_ctx_entry_4_ => iterop elpi_ctx_entry_4_ addq 1 0
                | Negz elpi_ctx_entry_4_ =>
                    (-
                     match elpi_ctx_entry_4_ with
                     | 0 => 1%Q
                     | _.+1 =>
                         match
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 =>
                                  match loop i with
                                  | {| valq := y |} =>
                                      fracq
                                        (let (y1, y2) := y in
                                         match y2 with
                                         | Posz 1 =>
                                             match y1 with
                                             | Posz 0 => (1, 1)
                                             | Posz 1 => (2, 1)
                                             | Posz
                                               (_.+2 as elpi_ctx_entry_16_) =>
                                                 (elpi_ctx_entry_16_.+1, 1)
                                             | Negz _ =>
                                                 (
                                                 match y1 with
                                                 | Posz n' => n'.+1
                                                 | Negz n' =>
                                                 if ... then 0 else ...
                                                 end, 1)
                                             end
                                         | _ =>
                                             (intZmod.addz
                                                match y2 with
                                                | Posz n' => (n' + 0)%coq_nat
                                                | Negz n' =>
                                                 Negz (n' + 0)%coq_nat
                                                end y1, y2)
                                         end)
                                  end
                              end) elpi_ctx_entry_4_
                         with
                         | {| valq := y |} =>
                             fracq
                               (let (y1, y2) := y in
                                match y2 with
                                | Posz 1 =>
                                    match y1 with
                                    | Posz 0 => (1, 1)
                                    | Posz 1 => (2, 1)
                                    | Posz (_.+2 as elpi_ctx_entry_12_) =>
                                        (elpi_ctx_entry_12_.+1, 1)
                                    | Negz _ =>
                                        (match y1 with
                                         | Posz n' => n'.+1
                                         | Negz n' =>
                                             if eqn (n' - 0)%Nrec 0
                                             then 0
                                             else Negz (n' - 1)%Nrec
                                         end, 1)
                                    end
                                | _ =>
                                    (intZmod.addz
                                       match y2 with
                                       | Posz n' => (n' + 0)%coq_nat
                                       | Negz n' => Negz (n' + 0)%coq_nat
                                       end y1, y2)
                                end)
                         end
                     end)%Q
                end)%Q + rat_of_Z 1)%Q)%Q *
             s n (intZmod.addz (intZmod.addz k 1) 1)
           with
           | {| valq := y |} =>
               fracq
                 (let (y1, y2) := y in
                  match y2 with
                  | Posz 1 => (y1, 1)
                  | _ =>
                      (intZmod.addz match y2 with
                                    | Posz _ | _ => 0
                                    end y1, y2)
                  end)
           end +
           ((((((((((- rat_of_Z 2)%Q *
                    (match k with
                     | Posz elpi_ctx_entry_4_ =>
                         iterop elpi_ctx_entry_4_ addq 1 0
                     | Negz elpi_ctx_entry_4_ =>
                         (-
                          match elpi_ctx_entry_4_ with
                          | 0 => 1%Q
                          | _.+1 =>
                              match
                                (fix loop (m : nat) : rat :=
                                   match m with
                                   | 0 => 0
                                   | 1 => 1
                                   | (_.+1 as i).+1 =>
                                       match loop i with
                                       | {| ... |} => fracq (... ...)
                                       end
                                   end) elpi_ctx_entry_4_
                              with
                              | {| valq := y |} =>
                                  fracq
                                    (let (y1, y2) := y in
                                     match y2 with
                                     | Posz 1 =>
                                         match y1 with
                                         | Posz 0 => (1, 1)
                                         | Posz 1 => (2, 1)
                                         | Posz (_.+2 as elpi_ctx_entry_12_) =>
                                             (elpi_ctx_entry_12_.+1, 1)
                                         | Negz _ =>
                                             (match y1 with
                                              | Posz n' => n'.+1
                                              | Negz n' =>
                                                 if ... then 0 else ...
                                              end, 1)
                                         end
                                     | _ =>
                                         (intZmod.addz
                                            match y2 with
                                            | Posz n' => (n' + 0)%coq_nat
                                            | Negz n' =>
                                                Negz (n' + 0)%coq_nat
                                            end y1, y2)
                                     end)
                              end
                          end)%Q
                     end *
                     (match k with
                      | Posz elpi_ctx_entry_4_ =>
                          iterop elpi_ctx_entry_4_ addq 1 0
                      | Negz elpi_ctx_entry_4_ =>
                          (-
                           match elpi_ctx_entry_4_ with
                           | 0 => 1%Q
                           | _.+1 =>
                               match
                                 (fix loop (m : nat) : rat :=
                                    match m with
                                    | 0 => 0
                                    | 1 => 1
                                    | (_.+1 as i).+1 =>
                                        match ... with
                                        | ... => fracq ...
                                        end
                                    end) elpi_ctx_entry_4_
                               with
                               | {| valq := y |} =>
                                   fracq
                                     (let (y1, y2) := y in
                                      match y2 with
                                      | Posz 1 =>
                                          match y1 with
                                          | Posz 0 => (1, 1)
                                          | Posz 1 => (2, 1)
                                          | Posz (_.+2 as elpi_ctx_entry_12_) =>
                                              (elpi_ctx_entry_12_.+1, 1)
                                          | Negz _ =>
                                              (match ... with
                                               | ... n'.+1
                                               | ... ...
                                               end, 1)
                                          end
                                      | _ =>
                                          (intZmod.addz
                                             match ... with
                                             | ... => (...)%coq_nat
                                             | ... => Negz ...%coq_nat
                                             end y1, y2)
                                      end)
                               end
                           end)%Q
                      end *
                      match k with
                      | Posz elpi_ctx_entry_4_ =>
                          iterop elpi_ctx_entry_4_ addq 1 0
                      | Negz elpi_ctx_entry_4_ =>
                          (-
                           match elpi_ctx_entry_4_ with
                           | 0 => 1%Q
                           | _.+1 =>
                               match
                                 (fix loop (m : nat) : rat :=
                                    match m with
                                    | 0 => 0
                                    | 1 => 1
                                    | (_.+1 as i).+1 =>
                                        match ... with
                                        | ... => fracq ...
                                        end
                                    end) elpi_ctx_entry_4_
                               with
                               | {| valq := y |} =>
                                   fracq
                                     (let (y1, y2) := y in
                                      match y2 with
                                      | Posz 1 =>
                                          match y1 with
                                          | Posz 0 => (1, 1)
                                          | Posz 1 => (2, 1)
                                          | Posz (_.+2 as elpi_ctx_entry_12_) =>
                                              (elpi_ctx_entry_12_.+1, 1)
                                          | Negz _ =>
                                              (match ... with
                                               | ... n'.+1
                                               | ... ...
                                               end, 1)
                                          end
                                      | _ =>
                                          (intZmod.addz
                                             match ... with
                                             | ... => (...)%coq_nat
                                             | ... => Negz ...%coq_nat
                                             end y1, y2)
                                      end)
                               end
                           end)%Q
                      end)%Q)%Q)%Q +
                   ((- rat_of_Z 8)%Q *
                    (match k with
                     | Posz elpi_ctx_entry_4_ =>
                         iterop elpi_ctx_entry_4_ addq 1 0
                     | Negz elpi_ctx_entry_4_ =>
                         (-
                          match elpi_ctx_entry_4_ with
                          | 0 => 1%Q
                          | _.+1 =>
                              match
                                (fix loop (m : nat) : rat :=
                                   match m with
                                   | 0 => 0
                                   | 1 => 1
                                   | (_.+1 as i).+1 =>
                                       match loop i with
                                       | {| ... |} => fracq (... ...)
                                       end
                                   end) elpi_ctx_entry_4_
                              with
                              | {| valq := y |} =>
                                  fracq
                                    (let (y1, y2) := y in
                                     match y2 with
                                     | Posz 1 =>
                                         match y1 with
                                         | Posz 0 => (1, 1)
                                         | Posz 1 => (2, 1)
                                         | Posz (_.+2 as elpi_ctx_entry_12_) =>
                                             (elpi_ctx_entry_12_.+1, 1)
                                         | Negz _ =>
                                             (match y1 with
                                              | Posz n' => n'.+1
                                              | Negz n' =>
                                                 if ... then 0 else ...
                                              end, 1)
                                         end
                                     | _ =>
                                         (intZmod.addz
                                            match y2 with
                                            | Posz n' => (n' + 0)%coq_nat
                                            | Negz n' =>
                                                Negz (n' + 0)%coq_nat
                                            end y1, y2)
                                     end)
                              end
                          end)%Q
                     end *
                     match k with
                     | Posz elpi_ctx_entry_4_ =>
                         iterop elpi_ctx_entry_4_ addq 1 0
                     | Negz elpi_ctx_entry_4_ =>
                         (-
                          match elpi_ctx_entry_4_ with
                          | 0 => 1%Q
                          | _.+1 =>
                              match
                                (fix loop (m : nat) : rat :=
                                   match m with
                                   | 0 => 0
                                   | 1 => 1
                                   | (_.+1 as i).+1 =>
                                       match loop i with
                                       | {| ... |} => fracq (... ...)
                                       end
                                   end) elpi_ctx_entry_4_
                              with
                              | {| valq := y |} =>
                                  fracq
                                    (let (y1, y2) := y in
                                     match y2 with
                                     | Posz 1 =>
                                         match y1 with
                                         | Posz 0 => (1, 1)
                                         | Posz 1 => (2, 1)
                                         | Posz (_.+2 as elpi_ctx_entry_12_) =>
                                             (elpi_ctx_entry_12_.+1, 1)
                                         | Negz _ =>
                                             (match y1 with
                                              | Posz n' => n'.+1
                                              | Negz n' =>
                                                 if ... then 0 else ...
                                              end, 1)
                                         end
                                     | _ =>
                                         (intZmod.addz
                                            match y2 with
                                            | Posz n' => (n' + 0)%coq_nat
                                            | Negz n' =>
                                                Negz (n' + 0)%coq_nat
                                            end y1, y2)
                                     end)
                              end
                          end)%Q
                     end)%Q)%Q)%Q +
                  ((- rat_of_Z 11)%Q *
                   match k with
                   | Posz elpi_ctx_entry_4_ =>
                       iterop elpi_ctx_entry_4_ addq 1 0
                   | Negz elpi_ctx_entry_4_ =>
                       (-
                        match elpi_ctx_entry_4_ with
                        | 0 => 1%Q
                        | _.+1 =>
                            match
                              (fix loop (m : nat) : rat :=
                                 match m with
                                 | 0 => 0
                                 | 1 => 1
                                 | (_.+1 as i).+1 =>
                                     match loop i with
                                     | {| valq := y |} =>
                                         fracq
                                           (let (y1, y2) := y in
                                            match y2 with
                                            | Posz 1 =>
                                                match ... with
                                                | ... ...
                                                | ... ...
                                                | ... ...
                                                | ... ...
                                                end
                                            | _ => (intZmod.addz ... y1, y2)
                                            end)
                                     end
                                 end) elpi_ctx_entry_4_
                            with
                            | {| valq := y |} =>
                                fracq
                                  (let (y1, y2) := y in
                                   match y2 with
                                   | Posz 1 =>
                                       match y1 with
                                       | Posz 0 => (1, 1)
                                       | Posz 1 => (2, 1)
                                       | Posz (_.+2 as elpi_ctx_entry_12_) =>
                                           (elpi_ctx_entry_12_.+1, 1)
                                       | Negz _ =>
                                           (match y1 with
                                            | Posz n' => n'.+1
                                            | Negz n' =>
                                                if eqn (n' - 0)%Nrec 0
                                                then 0
                                                else Negz (n' - 1)%Nrec
                                            end, 1)
                                       end
                                   | _ =>
                                       (intZmod.addz
                                          match y2 with
                                          | Posz n' => (n' + 0)%coq_nat
                                          | Negz n' => Negz (n' + 0)%coq_nat
                                          end y1, y2)
                                   end)
                            end
                        end)%Q
                   end)%Q)%Q + (- rat_of_Z 5)%Q)%Q +
                (match k with
                 | Posz elpi_ctx_entry_4_ =>
                     iterop elpi_ctx_entry_4_ addq 1 0
                 | Negz elpi_ctx_entry_4_ =>
                     (-
                      match elpi_ctx_entry_4_ with
                      | 0 => 1%Q
                      | _.+1 =>
                          match
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as i).+1 =>
                                   match loop i with
                                   | {| valq := y |} =>
                                       fracq
                                         (let (y1, y2) := y in
                                          match y2 with
                                          | Posz 1 =>
                                              match y1 with
                                              | Posz 0 => (1, 1)
                                              | Posz 1 => (2, 1)
                                              | Posz
                                                (_.+2 as elpi_ctx_entry_16_) =>
                                                 (elpi_ctx_entry_16_.+1, 1)
                                              | Negz _ =>
                                                 (
                                                 match ... with
                                                 | ... => n'.+1
                                                 | ... => ... ... ...
                                                 end, 1)
                                              end
                                          | _ =>
                                              (intZmod.addz
                                                 match y2 with
                                                 | Posz n' =>
                                                 (n' + 0)%coq_nat
                                                 | Negz n' =>
                                                 Negz (...)%coq_nat
                                                 end y1, y2)
                                          end)
                                   end
                               end) elpi_ctx_entry_4_
                          with
                          | {| valq := y |} =>
                              fracq
                                (let (y1, y2) := y in
                                 match y2 with
                                 | Posz 1 =>
                                     match y1 with
                                     | Posz 0 => (1, 1)
                                     | Posz 1 => (2, 1)
                                     | Posz (_.+2 as elpi_ctx_entry_12_) =>
                                         (elpi_ctx_entry_12_.+1, 1)
                                     | Negz _ =>
                                         (match y1 with
                                          | Posz n' => n'.+1
                                          | Negz n' =>
                                              if eqn (n' - 0)%Nrec 0
                                              then 0
                                              else Negz (n' - 1)%Nrec
                                          end, 1)
                                     end
                                 | _ =>
                                     (intZmod.addz
                                        match y2 with
                                        | Posz n' => (n' + 0)%coq_nat
                                        | Negz n' => Negz (n' + 0)%coq_nat
                                        end y1, y2)
                                 end)
                          end
                      end)%Q
                 end *
                 match n with
                 | Posz elpi_ctx_entry_4_ =>
                     iterop elpi_ctx_entry_4_ addq 1 0
                 | Negz elpi_ctx_entry_4_ =>
                     (-
                      match elpi_ctx_entry_4_ with
                      | 0 => 1%Q
                      | _.+1 =>
                          match
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as i).+1 =>
                                   match loop i with
                                   | {| valq := y |} =>
                                       fracq
                                         (let (y1, y2) := y in
                                          match y2 with
                                          | Posz 1 =>
                                              match y1 with
                                              | Posz 0 => (1, 1)
                                              | Posz 1 => (2, 1)
                                              | Posz
                                                (_.+2 as elpi_ctx_entry_16_) =>
                                                 (elpi_ctx_entry_16_.+1, 1)
                                              | Negz _ =>
                                                 (
                                                 match ... with
                                                 | ... => n'.+1
                                                 | ... => ... ... ...
                                                 end, 1)
                                              end
                                          | _ =>
                                              (intZmod.addz
                                                 match y2 with
                                                 | Posz n' =>
                                                 (n' + 0)%coq_nat
                                                 | Negz n' =>
                                                 Negz (...)%coq_nat
                                                 end y1, y2)
                                          end)
                                   end
                               end) elpi_ctx_entry_4_
                          with
                          | {| valq := y |} =>
                              fracq
                                (let (y1, y2) := y in
                                 match y2 with
                                 | Posz 1 =>
                                     match y1 with
                                     | Posz 0 => (1, 1)
                                     | Posz 1 => (2, 1)
                                     | Posz (_.+2 as elpi_ctx_entry_12_) =>
                                         (elpi_ctx_entry_12_.+1, 1)
                                     | Negz _ =>
                                         (match y1 with
                                          | Posz n' => n'.+1
                                          | Negz n' =>
                                              if eqn (n' - 0)%Nrec 0
                                              then 0
                                              else Negz (n' - 1)%Nrec
                                          end, 1)
                                     end
                                 | _ =>
                                     (intZmod.addz
                                        match y2 with
                                        | Posz n' => (n' + 0)%coq_nat
                                        | Negz n' => Negz (n' + 0)%coq_nat
                                        end y1, y2)
                                 end)
                          end
                      end)%Q
                 end)%Q)%Q +
               (match k with
                | Posz elpi_ctx_entry_4_ => iterop elpi_ctx_entry_4_ addq 1 0
                | Negz elpi_ctx_entry_4_ =>
                    (-
                     match elpi_ctx_entry_4_ with
                     | 0 => 1%Q
                     | _.+1 =>
                         match
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 =>
                                  match loop i with
                                  | {| valq := y |} =>
                                      fracq
                                        (let (y1, y2) := y in
                                         match y2 with
                                         | Posz 1 =>
                                             match y1 with
                                             | Posz 0 => (1, 1)
                                             | Posz 1 => (2, 1)
                                             | Posz
                                               (_.+2 as elpi_ctx_entry_16_) =>
                                                 (elpi_ctx_entry_16_.+1, 1)
                                             | Negz _ =>
                                                 (
                                                 match y1 with
                                                 | Posz n' => n'.+1
                                                 | Negz n' =>
                                                 if eqn ...%Nrec 0
                                                 then 0
                                                 else Negz ...%Nrec
                                                 end, 1)
                                             end
                                         | _ =>
                                             (intZmod.addz
                                                match y2 with
                                                | Posz n' => (n' + 0)%coq_nat
                                                | Negz n' =>
                                                 Negz (n' + 0)%coq_nat
                                                end y1, y2)
                                         end)
                                  end
                              end) elpi_ctx_entry_4_
                         with
                         | {| valq := y |} =>
                             fracq
                               (let (y1, y2) := y in
                                match y2 with
                                | Posz 1 =>
                                    match y1 with
                                    | Posz 0 => (1, 1)
                                    | Posz 1 => (2, 1)
                                    | Posz (_.+2 as elpi_ctx_entry_12_) =>
                                        (elpi_ctx_entry_12_.+1, 1)
                                    | Negz _ =>
                                        (match y1 with
                                         | Posz n' => n'.+1
                                         | Negz n' =>
                                             if eqn (n' - 0)%Nrec 0
                                             then 0
                                             else Negz (n' - 1)%Nrec
                                         end, 1)
                                    end
                                | _ =>
                                    (intZmod.addz
                                       match y2 with
                                       | Posz n' => (n' + 0)%coq_nat
                                       | Negz n' => Negz (n' + 0)%coq_nat
                                       end y1, y2)
                                end)
                         end
                     end)%Q
                end *
                (match n with
                 | Posz elpi_ctx_entry_4_ =>
                     iterop elpi_ctx_entry_4_ addq 1 0
                 | Negz elpi_ctx_entry_4_ =>
                     (-
                      match elpi_ctx_entry_4_ with
                      | 0 => 1%Q
                      | _.+1 =>
                          match
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as i).+1 =>
                                   match loop i with
                                   | {| valq := y |} =>
                                       fracq
                                         (let (y1, y2) := y in
                                          match y2 with
                                          | Posz 1 =>
                                              match y1 with
                                              | Posz 0 => (1, 1)
                                              | Posz 1 => (2, 1)
                                              | Posz
                                                (_.+2 as elpi_ctx_entry_16_) =>
                                                 (elpi_ctx_entry_16_.+1, 1)
                                              | Negz _ =>
                                                 (
                                                 match ... with
                                                 | ... => n'.+1
                                                 | ... => ... ... ...
                                                 end, 1)
                                              end
                                          | _ =>
                                              (intZmod.addz
                                                 match y2 with
                                                 | Posz n' =>
                                                 (n' + 0)%coq_nat
                                                 | Negz n' =>
                                                 Negz (...)%coq_nat
                                                 end y1, y2)
                                          end)
                                   end
                               end) elpi_ctx_entry_4_
                          with
                          | {| valq := y |} =>
                              fracq
                                (let (y1, y2) := y in
                                 match y2 with
                                 | Posz 1 =>
                                     match y1 with
                                     | Posz 0 => (1, 1)
                                     | Posz 1 => (2, 1)
                                     | Posz (_.+2 as elpi_ctx_entry_12_) =>
                                         (elpi_ctx_entry_12_.+1, 1)
                                     | Negz _ =>
                                         (match y1 with
                                          | Posz n' => n'.+1
                                          | Negz n' =>
                                              if eqn (n' - 0)%Nrec 0
                                              then 0
                                              else Negz (n' - 1)%Nrec
                                          end, 1)
                                     end
                                 | _ =>
                                     (intZmod.addz
                                        match y2 with
                                        | Posz n' => (n' + 0)%coq_nat
                                        | Negz n' => Negz (n' + 0)%coq_nat
                                        end y1, y2)
                                 end)
                          end
                      end)%Q
                 end *
                 match n with
                 | Posz elpi_ctx_entry_4_ =>
                     iterop elpi_ctx_entry_4_ addq 1 0
                 | Negz elpi_ctx_entry_4_ =>
                     (-
                      match elpi_ctx_entry_4_ with
                      | 0 => 1%Q
                      | _.+1 =>
                          match
                            (fix loop (m : nat) : rat :=
                               match m with
                               | 0 => 0
                               | 1 => 1
                               | (_.+1 as i).+1 =>
                                   match loop i with
                                   | {| valq := y |} =>
                                       fracq
                                         (let (y1, y2) := y in
                                          match y2 with
                                          | Posz 1 =>
                                              match y1 with
                                              | Posz 0 => (1, 1)
                                              | Posz 1 => (2, 1)
                                              | Posz
                                                (_.+2 as elpi_ctx_entry_16_) =>
                                                 (elpi_ctx_entry_16_.+1, 1)
                                              | Negz _ =>
                                                 (
                                                 match ... with
                                                 | ... => n'.+1
                                                 | ... => ... ... ...
                                                 end, 1)
                                              end
                                          | _ =>
                                              (intZmod.addz
                                                 match y2 with
                                                 | Posz n' =>
                                                 (n' + 0)%coq_nat
                                                 | Negz n' =>
                                                 Negz (...)%coq_nat
                                                 end y1, y2)
                                          end)
                                   end
                               end) elpi_ctx_entry_4_
                          with
                          | {| valq := y |} =>
                              fracq
                                (let (y1, y2) := y in
                                 match y2 with
                                 | Posz 1 =>
                                     match y1 with
                                     | Posz 0 => (1, 1)
                                     | Posz 1 => (2, 1)
                                     | Posz (_.+2 as elpi_ctx_entry_12_) =>
                                         (elpi_ctx_entry_12_.+1, 1)
                                     | Negz _ =>
                                         (match y1 with
                                          | Posz n' => n'.+1
                                          | Negz n' =>
                                              if eqn (n' - 0)%Nrec 0
                                              then 0
                                              else Negz (n' - 1)%Nrec
                                          end, 1)
                                     end
                                 | _ =>
                                     (intZmod.addz
                                        match y2 with
                                        | Posz n' => (n' + 0)%coq_nat
                                        | Negz n' => Negz (n' + 0)%coq_nat
                                        end y1, y2)
                                 end)
                          end
                      end)%Q
                 end)%Q)%Q)%Q +
              (rat_of_Z 2 *
               (match n with
                | Posz elpi_ctx_entry_4_ => iterop elpi_ctx_entry_4_ addq 1 0
                | Negz elpi_ctx_entry_4_ =>
                    (-
                     match elpi_ctx_entry_4_ with
                     | 0 => 1%Q
                     | _.+1 =>
                         match
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 =>
                                  match loop i with
                                  | {| valq := y |} =>
                                      fracq
                                        (let (y1, y2) := y in
                                         match y2 with
                                         | Posz 1 =>
                                             match y1 with
                                             | Posz 0 => (1, 1)
                                             | Posz 1 => (2, 1)
                                             | Posz
                                               (_.+2 as elpi_ctx_entry_16_) =>
                                                 (elpi_ctx_entry_16_.+1, 1)
                                             | Negz _ =>
                                                 (
                                                 match y1 with
                                                 | Posz n' => n'.+1
                                                 | Negz n' =>
                                                 if eqn ...%Nrec 0
                                                 then 0
                                                 else Negz ...%Nrec
                                                 end, 1)
                                             end
                                         | _ =>
                                             (intZmod.addz
                                                match y2 with
                                                | Posz n' => (n' + 0)%coq_nat
                                                | Negz n' =>
                                                 Negz (n' + 0)%coq_nat
                                                end y1, y2)
                                         end)
                                  end
                              end) elpi_ctx_entry_4_
                         with
                         | {| valq := y |} =>
                             fracq
                               (let (y1, y2) := y in
                                match y2 with
                                | Posz 1 =>
                                    match y1 with
                                    | Posz 0 => (1, 1)
                                    | Posz 1 => (2, 1)
                                    | Posz (_.+2 as elpi_ctx_entry_12_) =>
                                        (elpi_ctx_entry_12_.+1, 1)
                                    | Negz _ =>
                                        (match y1 with
                                         | Posz n' => n'.+1
                                         | Negz n' =>
                                             if eqn (n' - 0)%Nrec 0
                                             then 0
                                             else Negz (n' - 1)%Nrec
                                         end, 1)
                                    end
                                | _ =>
                                    (intZmod.addz
                                       match y2 with
                                       | Posz n' => (n' + 0)%coq_nat
                                       | Negz n' => Negz (n' + 0)%coq_nat
                                       end y1, y2)
                                end)
                         end
                     end)%Q
                end *
                match n with
                | Posz elpi_ctx_entry_4_ => iterop elpi_ctx_entry_4_ addq 1 0
                | Negz elpi_ctx_entry_4_ =>
                    (-
                     match elpi_ctx_entry_4_ with
                     | 0 => 1%Q
                     | _.+1 =>
                         match
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 =>
                                  match loop i with
                                  | {| valq := y |} =>
                                      fracq
                                        (let (y1, y2) := y in
                                         match y2 with
                                         | Posz 1 =>
                                             match y1 with
                                             | Posz 0 => (1, 1)
                                             | Posz 1 => (2, 1)
                                             | Posz
                                               (_.+2 as elpi_ctx_entry_16_) =>
                                                 (elpi_ctx_entry_16_.+1, 1)
                                             | Negz _ =>
                                                 (
                                                 match y1 with
                                                 | Posz n' => n'.+1
                                                 | Negz n' =>
                                                 if eqn ...%Nrec 0
                                                 then 0
                                                 else Negz ...%Nrec
                                                 end, 1)
                                             end
                                         | _ =>
                                             (intZmod.addz
                                                match y2 with
                                                | Posz n' => (n' + 0)%coq_nat
                                                | Negz n' =>
                                                 Negz (n' + 0)%coq_nat
                                                end y1, y2)
                                         end)
                                  end
                              end) elpi_ctx_entry_4_
                         with
                         | {| valq := y |} =>
                             fracq
                               (let (y1, y2) := y in
                                match y2 with
                                | Posz 1 =>
                                    match y1 with
                                    | Posz 0 => (1, 1)
                                    | Posz 1 => (2, 1)
                                    | Posz (_.+2 as elpi_ctx_entry_12_) =>
                                        (elpi_ctx_entry_12_.+1, 1)
                                    | Negz _ =>
                                        (match y1 with
                                         | Posz n' => n'.+1
                                         | Negz n' =>
                                             if eqn (n' - 0)%Nrec 0
                                             then 0
                                             else Negz (n' - 1)%Nrec
                                         end, 1)
                                    end
                                | _ =>
                                    (intZmod.addz
                                       match y2 with
                                       | Posz n' => (n' + 0)%coq_nat
                                       | Negz n' => Negz (n' + 0)%coq_nat
                                       end y1, y2)
                                end)
                         end
                     end)%Q
                end)%Q)%Q)%Q +
             (rat_of_Z 2 *
              match n with
              | Posz elpi_ctx_entry_4_ => iterop elpi_ctx_entry_4_ addq 1 0
              | Negz elpi_ctx_entry_4_ =>
                  (-
                   match elpi_ctx_entry_4_ with
                   | 0 => 1%Q
                   | _.+1 =>
                       match
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 =>
                                match loop i with
                                | {| valq := y |} =>
                                    fracq
                                      (let (y1, y2) := y in
                                       match y2 with
                                       | Posz 1 =>
                                           match y1 with
                                           | Posz 0 => (1, 1)
                                           | Posz 1 => (2, 1)
                                           | Posz
                                             (_.+2 as elpi_ctx_entry_16_) =>
                                               (elpi_ctx_entry_16_.+1, 1)
                                           | Negz _ =>
                                               (match y1 with
                                                | Posz n' => n'.+1
                                                | Negz n' =>
                                                 if eqn (n' - 0)%Nrec 0
                                                 then 0
                                                 else Negz (n' - 1)%Nrec
                                                end, 1)
                                           end
                                       | _ =>
                                           (intZmod.addz
                                              match y2 with
                                              | Posz n' => (n' + 0)%coq_nat
                                              | Negz n' =>
                                                 Negz (n' + 0)%coq_nat
                                              end y1, y2)
                                       end)
                                end
                            end) elpi_ctx_entry_4_
                       with
                       | {| valq := y |} =>
                           fracq
                             (let (y1, y2) := y in
                              match y2 with
                              | Posz 1 =>
                                  match y1 with
                                  | Posz 0 => (1, 1)
                                  | Posz 1 => (2, 1)
                                  | Posz (_.+2 as elpi_ctx_entry_12_) =>
                                      (elpi_ctx_entry_12_.+1, 1)
                                  | Negz _ =>
                                      (match y1 with
                                       | Posz n' => n'.+1
                                       | Negz n' =>
                                           if eqn (n' - 0)%Nrec 0
                                           then 0
                                           else Negz (n' - 1)%Nrec
                                       end, 1)
                                  end
                              | _ =>
                                  (intZmod.addz
                                     match y2 with
                                     | Posz n' => (n' + 0)%coq_nat
                                     | Negz n' => Negz (n' + 0)%coq_nat
                                     end y1, y2)
                              end)
                       end
                   end)%Q
              end)%Q)%Q * s n (intZmod.addz k 1))%Q)%Q +
          (((match k with
             | Posz elpi_ctx_entry_4_ => iterop elpi_ctx_entry_4_ addq 1 0
             | Negz elpi_ctx_entry_4_ =>
                 (-
                  match elpi_ctx_entry_4_ with
                  | 0 => 1%Q
                  | _.+1 =>
                      match
                        (fix loop (m : nat) : rat :=
                           match m with
                           | 0 => 0
                           | 1 => 1
                           | (_.+1 as i).+1 =>
                               match loop i with
                               | {| valq := y |} =>
                                   fracq
                                     (let (y1, y2) := y in
                                      match y2 with
                                      | Posz 1 =>
                                          match y1 with
                                          | Posz 0 => (1, 1)
                                          | Posz 1 => (2, 1)
                                          | Posz (_.+2 as elpi_ctx_entry_16_) =>
                                              (elpi_ctx_entry_16_.+1, 1)
                                          | Negz _ =>
                                              (match y1 with
                                               | Posz n' => n'.+1
                                               | Negz n' =>
                                                 if eqn (n' - 0)%Nrec 0
                                                 then 0
                                                 else Negz (n' - 1)%Nrec
                                               end, 1)
                                          end
                                      | _ =>
                                          (intZmod.addz
                                             match y2 with
                                             | Posz n' => (n' + 0)%coq_nat
                                             | Negz n' =>
                                                 Negz (n' + 0)%coq_nat
                                             end y1, y2)
                                      end)
                               end
                           end) elpi_ctx_entry_4_
                      with
                      | {| valq := y |} =>
                          fracq
                            (let (y1, y2) := y in
                             match y2 with
                             | Posz 1 =>
                                 match y1 with
                                 | Posz 0 => (1, 1)
                                 | Posz 1 => (2, 1)
                                 | Posz (_.+2 as elpi_ctx_entry_12_) =>
                                     (elpi_ctx_entry_12_.+1, 1)
                                 | Negz _ =>
                                     (match y1 with
                                      | Posz n' => n'.+1
                                      | Negz n' =>
                                          if eqn (n' - 0)%Nrec 0
                                          then 0
                                          else Negz (n' - 1)%Nrec
                                      end, 1)
                                 end
                             | _ =>
                                 (intZmod.addz
                                    match y2 with
                                    | Posz n' => (n' + 0)%coq_nat
                                    | Negz n' => Negz (n' + 0)%coq_nat
                                    end y1, y2)
                             end)
                      end
                  end)%Q
             end + rat_of_Z 1)%Q *
            ((match k with
              | Posz elpi_ctx_entry_4_ => iterop elpi_ctx_entry_4_ addq 1 0
              | Negz elpi_ctx_entry_4_ =>
                  (-
                   match elpi_ctx_entry_4_ with
                   | 0 => 1%Q
                   | _.+1 =>
                       match
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 =>
                                match loop i with
                                | {| valq := y |} =>
                                    fracq
                                      (let (y1, y2) := y in
                                       match y2 with
                                       | Posz 1 =>
                                           match y1 with
                                           | Posz 0 => (1, 1)
                                           | Posz 1 => (2, 1)
                                           | Posz
                                             (_.+2 as elpi_ctx_entry_16_) =>
                                               (elpi_ctx_entry_16_.+1, 1)
                                           | Negz _ =>
                                               (match y1 with
                                                | Posz n' => n'.+1
                                                | Negz n' =>
                                                 if eqn (n' - 0)%Nrec 0
                                                 then 0
                                                 else Negz (n' - 1)%Nrec
                                                end, 1)
                                           end
                                       | _ =>
                                           (intZmod.addz
                                              match y2 with
                                              | Posz n' => (n' + 0)%coq_nat
                                              | Negz n' =>
                                                 Negz (n' + 0)%coq_nat
                                              end y1, y2)
                                       end)
                                end
                            end) elpi_ctx_entry_4_
                       with
                       | {| valq := y |} =>
                           fracq
                             (let (y1, y2) := y in
                              match y2 with
                              | Posz 1 =>
                                  match y1 with
                                  | Posz 0 => (1, 1)
                                  | Posz 1 => (2, 1)
                                  | Posz (_.+2 as elpi_ctx_entry_12_) =>
                                      (elpi_ctx_entry_12_.+1, 1)
                                  | Negz _ =>
                                      (match y1 with
                                       | Posz n' => n'.+1
                                       | Negz n' =>
                                           if eqn (n' - 0)%Nrec 0
                                           then 0
                                           else Negz (n' - 1)%Nrec
                                       end, 1)
                                  end
                              | _ =>
                                  (intZmod.addz
                                     match y2 with
                                     | Posz n' => (n' + 0)%coq_nat
                                     | Negz n' => Negz (n' + 0)%coq_nat
                                     end y1, y2)
                              end)
                       end
                   end)%Q
              end + rat_of_Z 1)%Q *
             (match k with
              | Posz elpi_ctx_entry_4_ => iterop elpi_ctx_entry_4_ addq 1 0
              | Negz elpi_ctx_entry_4_ =>
                  (-
                   match elpi_ctx_entry_4_ with
                   | 0 => 1%Q
                   | _.+1 =>
                       match
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 =>
                                match loop i with
                                | {| valq := y |} =>
                                    fracq
                                      (let (y1, y2) := y in
                                       match y2 with
                                       | Posz 1 =>
                                           match y1 with
                                           | Posz 0 => (1, 1)
                                           | Posz 1 => (2, 1)
                                           | Posz
                                             (_.+2 as elpi_ctx_entry_16_) =>
                                               (elpi_ctx_entry_16_.+1, 1)
                                           | Negz _ =>
                                               (match y1 with
                                                | Posz n' => n'.+1
                                                | Negz n' =>
                                                 if eqn (n' - 0)%Nrec 0
                                                 then 0
                                                 else Negz (n' - 1)%Nrec
                                                end, 1)
                                           end
                                       | _ =>
                                           (intZmod.addz
                                              match y2 with
                                              | Posz n' => (n' + 0)%coq_nat
                                              | Negz n' =>
                                                 Negz (n' + 0)%coq_nat
                                              end y1, y2)
                                       end)
                                end
                            end) elpi_ctx_entry_4_
                       with
                       | {| valq := y |} =>
                           fracq
                             (let (y1, y2) := y in
                              match y2 with
                              | Posz 1 =>
                                  match y1 with
                                  | Posz 0 => (1, 1)
                                  | Posz 1 => (2, 1)
                                  | Posz (_.+2 as elpi_ctx_entry_12_) =>
                                      (elpi_ctx_entry_12_.+1, 1)
                                  | Negz _ =>
                                      (match y1 with
                                       | Posz n' => n'.+1
                                       | Negz n' =>
                                           if eqn (n' - 0)%Nrec 0
                                           then 0
                                           else Negz (n' - 1)%Nrec
                                       end, 1)
                                  end
                              | _ =>
                                  (intZmod.addz
                                     match y2 with
                                     | Posz n' => (n' + 0)%coq_nat
                                     | Negz n' => Negz (n' + 0)%coq_nat
                                     end y1, y2)
                              end)
                       end
                   end)%Q
              end + rat_of_Z 1)%Q)%Q)%Q * s n k)%Q)%Q; 0%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
     = (ω * 2)%pT1
     : ppT1
     = (ω * 5 + 5)%pT1
     : ppT1
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
telQ := 0 : rat
remP := punk.biv_horner_seqop [:: d.P1_cf0_0; d.P1_cf1_0; d.P1_cf2_0] s n k
 : rat
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: P1_flat s n k; telQ;
         punk.biv_horner_seqop [:: d.P1_cf0_1; d.P1_cf1_1]
           (fun n_ k_ : int => s n_ (int.shift 1 k_)) n k; remP]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
telQ := 0 : rat
remP := punk.biv_horner_seqop [:: d.P1_cf0_0; d.P1_cf1_0; d.P1_cf2_0] s n k
 : rat
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: telQ;
         punk.biv_horner_seqop [:: d.P1_cf0_1; d.P1_cf1_1]
           (fun n_ k_ : int => s n_ (int.shift 1 k_)) n k; remP;
         P1_flat s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
telQ := 0 : rat
remP := punk.biv_horner_seqop [:: d.P1_cf0_0; d.P1_cf1_0; d.P1_cf2_0] s n k
 : rat
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: P1_flat s n k; telQ;
         punk.biv_horner_seqop [:: d.P1_cf0_1; d.P1_cf1_1]
           (fun n_ k_ : int => s n_ (int.shift 1 k_)) n k; remP]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
telQ := 0 : rat
remP := punk.biv_horner_seqop [:: d.P1_cf0_0; d.P1_cf1_0; d.P1_cf2_0] s n k
 : rat
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: telQ;
         punk.biv_horner_seqop [:: d.P1_cf0_1; d.P1_cf1_1]
           (fun n_ k_ : int => s n_ (int.shift 1 k_)) n k; remP;
         P1_flat s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
telQ := 0 : rat
remP := punk.biv_horner_seqop [:: d.P1_cf0_0; d.P1_cf1_0; d.P1_cf2_0] s n k
 : rat
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: P1_flat s n k; telQ;
         punk.biv_horner_seqop [:: d.P1_cf0_1; d.P1_cf1_1]
           (fun n_ k_ : int => s n_ (int.shift 1 k_)) n k; remP]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
free_baseP : forall (t : fieldType) (t0 : vectType t) 
               (s : {vspace t0}) (k : 'I_(\dim s) -> t),
             \sum_(i < \dim s) k i *: (vbasis s)`_i = 0 ->
             forall i : 'I_(\dim s), k i = 0
Unable to unify "true" with "false".
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
free_baseP : forall (t : fieldType) (t0 : vectType t) 
               (s : {vspace t0}) (k : 'I_(\dim s) -> t),
             \sum_(i < \dim s) k i *: (vbasis s)`_i = 0 ->
             forall i : 'I_(\dim s), k i = 0
Unable to unify "true" with "false".
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
free_baseP : forall (t : fieldType) (t0 : vectType t) 
               (s : {vspace t0}) (k : 'I_(\dim s) -> t),
             \sum_(i < \dim s) k i *: (vbasis s)`_i = 0 ->
             forall i : 'I_(\dim s), k i = 0
Unable to unify "true" with "false".
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
free_baseP : forall (t : fieldType) (t0 : vectType t) 
               (s : {vspace t0}) (k : 'I_(\dim s) -> t),
             \sum_(i < \dim s) k i *: (vbasis s)`_i = 0 ->
             forall i : 'I_(\dim s), k i = 0
H : ?Goal0 ?Goal1
H0 : forall B : {set ?Goal}, ?Goal0 B -> B \subset ?Goal1 -> B = ?Goal1
Unable to unify "true" with "false".
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
free_baseP : forall (t : fieldType) (t0 : vectType t) 
               (s : {vspace t0}) (k : 'I_(\dim s) -> t),
             \sum_(i < \dim s) k i *: (vbasis s)`_i = 0 ->
             forall i : 'I_(\dim s), k i = 0
c : ?Goal0 ?Goal1
Hc : forall B : {set ?Goal}, ?Goal0 B -> B \subset ?Goal1 -> B = ?Goal1
Unable to unify "true" with "false".
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
free_baseP : forall (t : fieldType) (t0 : vectType t) 
               (s : {vspace t0}) (k : 'I_(\dim s) -> t),
             \sum_(i < \dim s) k i *: (vbasis s)`_i = 0 ->
             forall i : 'I_(\dim s), k i = 0
Unable to unify "true" with "false".
     = (ω * 2)%pT1
     : ppT1
     = (ω * 5 + 5)%pT1
     : ppT1
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
free_baseP : forall (t : fieldType) (t0 : vectType t) 
               (s : {vspace t0}) (k : 'I_(\dim s) -> t),
             \sum_(i < \dim s) k i *: (vbasis s)`_i = 0 ->
             forall i : 'I_(\dim s), k i = 0
Unable to unify "true" with "false".
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n : nat
k : int
s1 := s n k : rat
s4 := s (int.shift 1 n) k : rat
s3 := s (int.shift 3 n) k : rat
Unable to unify "true" with "false".
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n : nat
k : int
s1 := s n k : rat
s4 := s (int.shift 1 n) k : rat
s3 := s (int.shift 3 n) k : rat
Unable to unify "true" with "false".
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n : nat
k : int
s1 := s n k : rat
Unable to unify "true" with "false".
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
Unable to unify "true" with "false".
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
Unable to unify "true" with "false".
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
Unable to unify "true" with "false".
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
Unable to unify "true" with "false".
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
Unable to unify "true" with "false".
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
s4 := s n k : rat
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: (((((match n with
              | Posz elpi_ctx_entry_3_ => iterop elpi_ctx_entry_3_ addq 1 0
              | Negz elpi_ctx_entry_3_ =>
                  (-
                   match elpi_ctx_entry_3_ with
                   | 0 => 1%Q
                   | _.+1 =>
                       match
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 =>
                                match loop i with
                                | {| valq := y |} =>
                                    fracq
                                      (let (y1, y2) := y in
                                       match y2 with
                                       | Posz 1 =>
                                           match y1 with
                                           | Posz 0 => (1%R, 1%R)
                                           | Posz 1 => (2, 1%R)
                                           | Posz
                                             (_.+2 as elpi_ctx_entry_15_) =>
                                               (elpi_ctx_entry_15_.+1, 1%R)
                                           | Negz _ => ((1 + y1)%R, 1%R)
                                           end
                                       | _ => ((1 * y2 + y1)%R, y2)
                                       end)
                                end
                            end) elpi_ctx_entry_3_
                       with
                       | {| valq := y |} =>
                           fracq
                             (let (y1, y2) := y in
                              match y2 with
                              | Posz 1 =>
                                  match y1 with
                                  | Posz 0 => (1%R, 1%R)
                                  | Posz 1 => (2, 1%R)
                                  | Posz (_.+2 as elpi_ctx_entry_11_) =>
                                      (elpi_ctx_entry_11_.+1, 1%R)
                                  | Negz _ => ((1 + y1)%R, 1%R)
                                  end
                              | _ => ((1 * y2 + y1)%R, y2)
                              end)
                       end
                   end)%Q
              end +
              (-
               match k with
               | Posz elpi_ctx_entry_3_ => iterop elpi_ctx_entry_3_ addq 1 0
               | Negz elpi_ctx_entry_3_ =>
                   (-
                    match elpi_ctx_entry_3_ with
                    | 0 => 1%Q
                    | _.+1 =>
                        match
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 =>
                                 match loop i with
                                 | {| valq := y |} =>
                                     fracq
                                       (let (y1, y2) := y in
                                        match y2 with
                                        | Posz 1 =>
                                            match y1 with
                                            | Posz 0 => (1%R, 1%R)
                                            | Posz 1 => (2, 1%R)
                                            | Posz
                                              (_.+2 as elpi_ctx_entry_15_) =>
                                                (elpi_ctx_entry_15_.+1, 1%R)
                                            | Negz _ => ((1 + y1)%R, 1%R)
                                            end
                                        | _ => ((1 * y2 + y1)%R, y2)
                                        end)
                                 end
                             end) elpi_ctx_entry_3_
                        with
                        | {| valq := y |} =>
                            fracq
                              (let (y1, y2) := y in
                               match y2 with
                               | Posz 1 =>
                                   match y1 with
                                   | Posz 0 => (1%R, 1%R)
                                   | Posz 1 => (2, 1%R)
                                   | Posz (_.+2 as elpi_ctx_entry_11_) =>
                                       (elpi_ctx_entry_11_.+1, 1%R)
                                   | Negz _ => ((1 + y1)%R, 1%R)
                                   end
                               | _ => ((1 * y2 + y1)%R, y2)
                               end)
                        end
                    end)%Q
               end)%Q)%Q * s4)%Q +
            ((((-
                match n with
                | Posz elpi_ctx_entry_3_ => iterop elpi_ctx_entry_3_ addq 1 0
                | Negz elpi_ctx_entry_3_ =>
                    (-
                     match elpi_ctx_entry_3_ with
                     | 0 => 1%Q
                     | _.+1 =>
                         match
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 =>
                                  match loop i with
                                  | {| valq := y |} =>
                                      fracq
                                        (let (y1, y2) := y in
                                         match y2 with
                                         | Posz 1 =>
                                             match y1 with
                                             | Posz 0 => (1%R, 1%R)
                                             | Posz 1 => (2, 1%R)
                                             | Posz
                                               (_.+2 as elpi_ctx_entry_15_) =>
                                                 (elpi_ctx_entry_15_.+1, 1%R)
                                             | Negz _ => ((1 + y1)%R, 1%R)
                                             end
                                         | _ => ((1 * y2 + y1)%R, y2)
                                         end)
                                  end
                              end) elpi_ctx_entry_3_
                         with
                         | {| valq := y |} =>
                             fracq
                               (let (y1, y2) := y in
                                match y2 with
                                | Posz 1 =>
                                    match y1 with
                                    | Posz 0 => (1%R, 1%R)
                                    | Posz 1 => (2, 1%R)
                                    | Posz (_.+2 as elpi_ctx_entry_11_) =>
                                        (elpi_ctx_entry_11_.+1, 1%R)
                                    | Negz _ => ((1 + y1)%R, 1%R)
                                    end
                                | _ => ((1 * y2 + y1)%R, y2)
                                end)
                         end
                     end)%Q
                end)%Q + (- rat_of_Z 2)%Q)%Q +
              (-
               match k with
               | Posz elpi_ctx_entry_3_ => iterop elpi_ctx_entry_3_ addq 1 0
               | Negz elpi_ctx_entry_3_ =>
                   (-
                    match elpi_ctx_entry_3_ with
                    | 0 => 1%Q
                    | _.+1 =>
                        match
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 =>
                                 match loop i with
                                 | {| valq := y |} =>
                                     fracq
                                       (let (y1, y2) := y in
                                        match y2 with
                                        | Posz 1 =>
                                            match y1 with
                                            | Posz 0 => (1%R, 1%R)
                                            | Posz 1 => (2, 1%R)
                                            | Posz
                                              (_.+2 as elpi_ctx_entry_15_) =>
                                                (elpi_ctx_entry_15_.+1, 1%R)
                                            | Negz _ => ((1 + y1)%R, 1%R)
                                            end
                                        | _ => ((1 * y2 + y1)%R, y2)
                                        end)
                                 end
                             end) elpi_ctx_entry_3_
                        with
                        | {| valq := y |} =>
                            fracq
                              (let (y1, y2) := y in
                               match y2 with
                               | Posz 1 =>
                                   match y1 with
                                   | Posz 0 => (1%R, 1%R)
                                   | Posz 1 => (2, 1%R)
                                   | Posz (_.+2 as elpi_ctx_entry_11_) =>
                                       (elpi_ctx_entry_11_.+1, 1%R)
                                   | Negz _ => ((1 + y1)%R, 1%R)
                                   end
                               | _ => ((1 * y2 + y1)%R, y2)
                               end)
                        end
                    end)%Q
               end)%Q)%Q * s (intZmod.addz n 1) k)%Q)%Q +
           (((-
              match n with
              | Posz elpi_ctx_entry_3_ => iterop elpi_ctx_entry_3_ addq 1 0
              | Negz elpi_ctx_entry_3_ =>
                  (-
                   match elpi_ctx_entry_3_ with
                   | 0 => 1%Q
                   | _.+1 =>
                       match
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 =>
                                match loop i with
                                | {| valq := y |} =>
                                    fracq
                                      (let (y1, y2) := y in
                                       match y2 with
                                       | Posz 1 =>
                                           match y1 with
                                           | Posz 0 => (1%R, 1%R)
                                           | Posz 1 => (2, 1%R)
                                           | Posz
                                             (_.+2 as elpi_ctx_entry_15_) =>
                                               (elpi_ctx_entry_15_.+1, 1%R)
                                           | Negz _ => ((1 + y1)%R, 1%R)
                                           end
                                       | _ => ((1 * y2 + y1)%R, y2)
                                       end)
                                end
                            end) elpi_ctx_entry_3_
                       with
                       | {| valq := y |} =>
                           fracq
                             (let (y1, y2) := y in
                              match y2 with
                              | Posz 1 =>
                                  match y1 with
                                  | Posz 0 => (1%R, 1%R)
                                  | Posz 1 => (2, 1%R)
                                  | Posz (_.+2 as elpi_ctx_entry_11_) =>
                                      (elpi_ctx_entry_11_.+1, 1%R)
                                  | Negz _ => ((1 + y1)%R, 1%R)
                                  end
                              | _ => ((1 * y2 + y1)%R, y2)
                              end)
                       end
                   end)%Q
              end)%Q +
             match k with
             | Posz elpi_ctx_entry_3_ => iterop elpi_ctx_entry_3_ addq 1 0
             | Negz elpi_ctx_entry_3_ =>
                 (-
                  match elpi_ctx_entry_3_ with
                  | 0 => 1%Q
                  | _.+1 =>
                      match
                        (fix loop (m : nat) : rat :=
                           match m with
                           | 0 => 0
                           | 1 => 1
                           | (_.+1 as i).+1 =>
                               match loop i with
                               | {| valq := y |} =>
                                   fracq
                                     (let (y1, y2) := y in
                                      match y2 with
                                      | Posz 1 =>
                                          match y1 with
                                          | Posz 0 => (1%R, 1%R)
                                          | Posz 1 => (2, 1%R)
                                          | Posz (_.+2 as elpi_ctx_entry_15_) =>
                                              (elpi_ctx_entry_15_.+1, 1%R)
                                          | Negz _ => ((1 + y1)%R, 1%R)
                                          end
                                      | _ => ((1 * y2 + y1)%R, y2)
                                      end)
                               end
                           end) elpi_ctx_entry_3_
                      with
                      | {| valq := y |} =>
                          fracq
                            (let (y1, y2) := y in
                             match y2 with
                             | Posz 1 =>
                                 match y1 with
                                 | Posz 0 => (1%R, 1%R)
                                 | Posz 1 => (2, 1%R)
                                 | Posz (_.+2 as elpi_ctx_entry_11_) =>
                                     (elpi_ctx_entry_11_.+1, 1%R)
                                 | Negz _ => ((1 + y1)%R, 1%R)
                                 end
                             | _ => ((1 * y2 + y1)%R, y2)
                             end)
                      end
                  end)%Q
             end)%Q * s n (intZmod.addz k 1))%Q)%Q +
          (((match n with
             | Posz elpi_ctx_entry_3_ => iterop elpi_ctx_entry_3_ addq 1 0
             | Negz elpi_ctx_entry_3_ =>
                 (-
                  match elpi_ctx_entry_3_ with
                  | 0 => 1%Q
                  | _.+1 =>
                      match
                        (fix loop (m : nat) : rat :=
                           match m with
                           | 0 => 0
                           | 1 => 1
                           | (_.+1 as i).+1 =>
                               match loop i with
                               | {| valq := y |} =>
                                   fracq
                                     (let (y1, y2) := y in
                                      match y2 with
                                      | Posz 1 =>
                                          match y1 with
                                          | Posz 0 => (1%R, 1%R)
                                          | Posz 1 => (2, 1%R)
                                          | Posz (_.+2 as elpi_ctx_entry_15_) =>
                                              (elpi_ctx_entry_15_.+1, 1%R)
                                          | Negz _ => ((1 + y1)%R, 1%R)
                                          end
                                      | _ => ((1 * y2 + y1)%R, y2)
                                      end)
                               end
                           end) elpi_ctx_entry_3_
                      with
                      | {| valq := y |} =>
                          fracq
                            (let (y1, y2) := y in
                             match y2 with
                             | Posz 1 =>
                                 match y1 with
                                 | Posz 0 => (1%R, 1%R)
                                 | Posz 1 => (2, 1%R)
                                 | Posz (_.+2 as elpi_ctx_entry_11_) =>
                                     (elpi_ctx_entry_11_.+1, 1%R)
                                 | Negz _ => ((1 + y1)%R, 1%R)
                                 end
                             | _ => ((1 * y2 + y1)%R, y2)
                             end)
                      end
                  end)%Q
             end + rat_of_Z 2)%Q +
            match k with
            | Posz elpi_ctx_entry_3_ => iterop elpi_ctx_entry_3_ addq 1 0
            | Negz elpi_ctx_entry_3_ =>
                (-
                 match elpi_ctx_entry_3_ with
                 | 0 => 1%Q
                 | _.+1 =>
                     match
                       (fix loop (m : nat) : rat :=
                          match m with
                          | 0 => 0
                          | 1 => 1
                          | (_.+1 as i).+1 =>
                              match loop i with
                              | {| valq := y |} =>
                                  fracq
                                    (let (y1, y2) := y in
                                     match y2 with
                                     | Posz 1 =>
                                         match y1 with
                                         | Posz 0 => (1%R, 1%R)
                                         | Posz 1 => (2, 1%R)
                                         | Posz (_.+2 as elpi_ctx_entry_15_) =>
                                             (elpi_ctx_entry_15_.+1, 1%R)
                                         | Negz _ => ((1 + y1)%R, 1%R)
                                         end
                                     | _ => ((1 * y2 + y1)%R, y2)
                                     end)
                              end
                          end) elpi_ctx_entry_3_
                     with
                     | {| valq := y |} =>
                         fracq
                           (let (y1, y2) := y in
                            match y2 with
                            | Posz 1 =>
                                match y1 with
                                | Posz 0 => (1%R, 1%R)
                                | Posz 1 => (2, 1%R)
                                | Posz (_.+2 as elpi_ctx_entry_11_) =>
                                    (elpi_ctx_entry_11_.+1, 1%R)
                                | Negz _ => ((1 + y1)%R, 1%R)
                                end
                            | _ => ((1 * y2 + y1)%R, y2)
                            end)
                     end
                 end)%Q
            end)%Q * s (intZmod.addz n 1) (intZmod.addz k 1))%Q)%Q;
         (match
            (((match n with
               | Posz elpi_ctx_entry_3_ => iterop elpi_ctx_entry_3_ addq 1 0
               | Negz elpi_ctx_entry_3_ =>
                   (-
                    match elpi_ctx_entry_3_ with
                    | 0 => 1%Q
                    | _.+1 =>
                        match
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 =>
                                 match loop i with
                                 | {| valq := y |} =>
                                     fracq
                                       (let (y1, y2) := y in
                                        match y2 with
                                        | Posz 1 =>
                                            match y1 with
                                            | Posz 0 => (1%R, 1%R)
                                            | Posz 1 => (2, 1%R)
                                            | Posz
                                              (_.+2 as elpi_ctx_entry_15_) =>
                                                (elpi_ctx_entry_15_.+1, 1%R)
                                            | Negz _ => ((1 + y1)%R, 1%R)
                                            end
                                        | _ => ((1 * y2 + y1)%R, y2)
                                        end)
                                 end
                             end) elpi_ctx_entry_3_
                        with
                        | {| valq := y |} =>
                            fracq
                              (let (y1, y2) := y in
                               match y2 with
                               | Posz 1 =>
                                   match y1 with
                                   | Posz 0 => (1%R, 1%R)
                                   | Posz 1 => (2, 1%R)
                                   | Posz (_.+2 as elpi_ctx_entry_11_) =>
                                       (elpi_ctx_entry_11_.+1, 1%R)
                                   | Negz _ => ((1 + y1)%R, 1%R)
                                   end
                               | _ => ((1 * y2 + y1)%R, y2)
                               end)
                        end
                    end)%Q
               end + rat_of_Z 2)%Q +
              match k with
              | Posz elpi_ctx_entry_3_ => iterop elpi_ctx_entry_3_ addq 1 0
              | Negz elpi_ctx_entry_3_ =>
                  (-
                   match elpi_ctx_entry_3_ with
                   | 0 => 1%Q
                   | _.+1 =>
                       match
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 =>
                                match loop i with
                                | {| valq := y |} =>
                                    fracq
                                      (let (y1, y2) := y in
                                       match y2 with
                                       | Posz 1 =>
                                           match y1 with
                                           | Posz 0 => (1%R, 1%R)
                                           | Posz 1 => (2, 1%R)
                                           | Posz
                                             (_.+2 as elpi_ctx_entry_15_) =>
                                               (elpi_ctx_entry_15_.+1, 1%R)
                                           | Negz _ => ((1 + y1)%R, 1%R)
                                           end
                                       | _ => ((1 * y2 + y1)%R, y2)
                                       end)
                                end
                            end) elpi_ctx_entry_3_
                       with
                       | {| valq := y |} =>
                           fracq
                             (let (y1, y2) := y in
                              match y2 with
                              | Posz 1 =>
                                  match y1 with
                                  | Posz 0 => (1%R, 1%R)
                                  | Posz 1 => (2, 1%R)
                                  | Posz (_.+2 as elpi_ctx_entry_11_) =>
                                      (elpi_ctx_entry_11_.+1, 1%R)
                                  | Negz _ => ((1 + y1)%R, 1%R)
                                  end
                              | _ => ((1 * y2 + y1)%R, y2)
                              end)
                       end
                   end)%Q
              end)%Q * s (intZmod.addz n 1) (intZmod.addz k 1))%Q +
            (((-
               match n with
               | Posz elpi_ctx_entry_3_ => iterop elpi_ctx_entry_3_ addq 1 0
               | Negz elpi_ctx_entry_3_ =>
                   (-
                    match elpi_ctx_entry_3_ with
                    | 0 => 1%Q
                    | _.+1 =>
                        match
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 =>
                                 match loop i with
                                 | {| valq := y |} =>
                                     fracq
                                       (let (y1, y2) := y in
                                        match y2 with
                                        | Posz 1 =>
                                            match y1 with
                                            | Posz 0 => (1%R, 1%R)
                                            | Posz 1 => (2, 1%R)
                                            | Posz
                                              (_.+2 as elpi_ctx_entry_15_) =>
                                                (elpi_ctx_entry_15_.+1, 1%R)
                                            | Negz _ => ((1 + y1)%R, 1%R)
                                            end
                                        | _ => ((1 * y2 + y1)%R, y2)
                                        end)
                                 end
                             end) elpi_ctx_entry_3_
                        with
                        | {| valq := y |} =>
                            fracq
                              (let (y1, y2) := y in
                               match y2 with
                               | Posz 1 =>
                                   match y1 with
                                   | Posz 0 => (1%R, 1%R)
                                   | Posz 1 => (2, 1%R)
                                   | Posz (_.+2 as elpi_ctx_entry_11_) =>
                                       (elpi_ctx_entry_11_.+1, 1%R)
                                   | Negz _ => ((1 + y1)%R, 1%R)
                                   end
                               | _ => ((1 * y2 + y1)%R, y2)
                               end)
                        end
                    end)%Q
               end)%Q +
              match k with
              | Posz elpi_ctx_entry_3_ => iterop elpi_ctx_entry_3_ addq 1 0
              | Negz elpi_ctx_entry_3_ =>
                  (-
                   match elpi_ctx_entry_3_ with
                   | 0 => 1%Q
                   | _.+1 =>
                       match
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 =>
                                match loop i with
                                | {| valq := y |} =>
                                    fracq
                                      (let (y1, y2) := y in
                                       match y2 with
                                       | Posz 1 =>
                                           match y1 with
                                           | Posz 0 => (1%R, 1%R)
                                           | Posz 1 => (2, 1%R)
                                           | Posz
                                             (_.+2 as elpi_ctx_entry_15_) =>
                                               (elpi_ctx_entry_15_.+1, 1%R)
                                           | Negz _ => ((1 + y1)%R, 1%R)
                                           end
                                       | _ => ((1 * y2 + y1)%R, y2)
                                       end)
                                end
                            end) elpi_ctx_entry_3_
                       with
                       | {| valq := y |} =>
                           fracq
                             (let (y1, y2) := y in
                              match y2 with
                              | Posz 1 =>
                                  match y1 with
                                  | Posz 0 => (1%R, 1%R)
                                  | Posz 1 => (2, 1%R)
                                  | Posz (_.+2 as elpi_ctx_entry_11_) =>
                                      (elpi_ctx_entry_11_.+1, 1%R)
                                  | Negz _ => ((1 + y1)%R, 1%R)
                                  end
                              | _ => ((1 * y2 + y1)%R, y2)
                              end)
                       end
                   end)%Q
              end)%Q * s n (intZmod.addz k 1))%Q
          with
          | {| valq := y |} =>
              fracq
                (let (y1, y2) := y in
                 match y2 with
                 | Posz 1 => (y1, 1%R)
                 | _ => ((0 * y2 + y1)%R, y2)
                 end)
          end +
          (((((-
               match n with
               | Posz elpi_ctx_entry_3_ => iterop elpi_ctx_entry_3_ addq 1 0
               | Negz elpi_ctx_entry_3_ =>
                   (-
                    match elpi_ctx_entry_3_ with
                    | 0 => 1%Q
                    | _.+1 =>
                        match
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 =>
                                 match loop i with
                                 | {| valq := y |} =>
                                     fracq
                                       (let (y1, y2) := y in
                                        match y2 with
                                        | Posz 1 =>
                                            match y1 with
                                            | Posz 0 => (1%R, 1%R)
                                            | Posz 1 => (2, 1%R)
                                            | Posz
                                              (_.+2 as elpi_ctx_entry_15_) =>
                                                (elpi_ctx_entry_15_.+1, 1%R)
                                            | Negz _ => ((1 + y1)%R, 1%R)
                                            end
                                        | _ => ((1 * y2 + y1)%R, y2)
                                        end)
                                 end
                             end) elpi_ctx_entry_3_
                        with
                        | {| valq := y |} =>
                            fracq
                              (let (y1, y2) := y in
                               match y2 with
                               | Posz 1 =>
                                   match y1 with
                                   | Posz 0 => (1%R, 1%R)
                                   | Posz 1 => (2, 1%R)
                                   | Posz (_.+2 as elpi_ctx_entry_11_) =>
                                       (elpi_ctx_entry_11_.+1, 1%R)
                                   | Negz _ => ((1 + y1)%R, 1%R)
                                   end
                               | _ => ((1 * y2 + y1)%R, y2)
                               end)
                        end
                    end)%Q
               end)%Q + (- rat_of_Z 2)%Q)%Q +
             (-
              match k with
              | Posz elpi_ctx_entry_3_ => iterop elpi_ctx_entry_3_ addq 1 0
              | Negz elpi_ctx_entry_3_ =>
                  (-
                   match elpi_ctx_entry_3_ with
                   | 0 => 1%Q
                   | _.+1 =>
                       match
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 =>
                                match loop i with
                                | {| valq := y |} =>
                                    fracq
                                      (let (y1, y2) := y in
                                       match y2 with
                                       | Posz 1 =>
                                           match y1 with
                                           | Posz 0 => (1%R, 1%R)
                                           | Posz 1 => (2, 1%R)
                                           | Posz
                                             (_.+2 as elpi_ctx_entry_15_) =>
                                               (elpi_ctx_entry_15_.+1, 1%R)
                                           | Negz _ => ((1 + y1)%R, 1%R)
                                           end
                                       | _ => ((1 * y2 + y1)%R, y2)
                                       end)
                                end
                            end) elpi_ctx_entry_3_
                       with
                       | {| valq := y |} =>
                           fracq
                             (let (y1, y2) := y in
                              match y2 with
                              | Posz 1 =>
                                  match y1 with
                                  | Posz 0 => (1%R, 1%R)
                                  | Posz 1 => (2, 1%R)
                                  | Posz (_.+2 as elpi_ctx_entry_11_) =>
                                      (elpi_ctx_entry_11_.+1, 1%R)
                                  | Negz _ => ((1 + y1)%R, 1%R)
                                  end
                              | _ => ((1 * y2 + y1)%R, y2)
                              end)
                       end
                   end)%Q
              end)%Q)%Q * s (intZmod.addz n 1) k)%Q +
           ((match n with
             | Posz elpi_ctx_entry_3_ => iterop elpi_ctx_entry_3_ addq 1 0
             | Negz elpi_ctx_entry_3_ =>
                 (-
                  match elpi_ctx_entry_3_ with
                  | 0 => 1%Q
                  | _.+1 =>
                      match
                        (fix loop (m : nat) : rat :=
                           match m with
                           | 0 => 0
                           | 1 => 1
                           | (_.+1 as i).+1 =>
                               match loop i with
                               | {| valq := y |} =>
                                   fracq
                                     (let (y1, y2) := y in
                                      match y2 with
                                      | Posz 1 =>
                                          match y1 with
                                          | Posz 0 => (1%R, 1%R)
                                          | Posz 1 => (2, 1%R)
                                          | Posz (_.+2 as elpi_ctx_entry_15_) =>
                                              (elpi_ctx_entry_15_.+1, 1%R)
                                          | Negz _ => ((1 + y1)%R, 1%R)
                                          end
                                      | _ => ((1 * y2 + y1)%R, y2)
                                      end)
                               end
                           end) elpi_ctx_entry_3_
                      with
                      | {| valq := y |} =>
                          fracq
                            (let (y1, y2) := y in
                             match y2 with
                             | Posz 1 =>
                                 match y1 with
                                 | Posz 0 => (1%R, 1%R)
                                 | Posz 1 => (2, 1%R)
                                 | Posz (_.+2 as elpi_ctx_entry_11_) =>
                                     (elpi_ctx_entry_11_.+1, 1%R)
                                 | Negz _ => ((1 + y1)%R, 1%R)
                                 end
                             | _ => ((1 * y2 + y1)%R, y2)
                             end)
                      end
                  end)%Q
             end +
             (-
              match k with
              | Posz elpi_ctx_entry_3_ => iterop elpi_ctx_entry_3_ addq 1 0
              | Negz elpi_ctx_entry_3_ =>
                  (-
                   match elpi_ctx_entry_3_ with
                   | 0 => 1%Q
                   | _.+1 =>
                       match
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 =>
                                match loop i with
                                | {| valq := y |} =>
                                    fracq
                                      (let (y1, y2) := y in
                                       match y2 with
                                       | Posz 1 =>
                                           match y1 with
                                           | Posz 0 => (1%R, 1%R)
                                           | Posz 1 => (2, 1%R)
                                           | Posz
                                             (_.+2 as elpi_ctx_entry_15_) =>
                                               (elpi_ctx_entry_15_.+1, 1%R)
                                           | Negz _ => ((1 + y1)%R, 1%R)
                                           end
                                       | _ => ((1 * y2 + y1)%R, y2)
                                       end)
                                end
                            end) elpi_ctx_entry_3_
                       with
                       | {| valq := y |} =>
                           fracq
                             (let (y1, y2) := y in
                              match y2 with
                              | Posz 1 =>
                                  match y1 with
                                  | Posz 0 => (1%R, 1%R)
                                  | Posz 1 => (2, 1%R)
                                  | Posz (_.+2 as elpi_ctx_entry_11_) =>
                                      (elpi_ctx_entry_11_.+1, 1%R)
                                  | Negz _ => ((1 + y1)%R, 1%R)
                                  end
                              | _ => ((1 * y2 + y1)%R, y2)
                              end)
                       end
                   end)%Q
              end)%Q)%Q * s4)%Q)%Q)%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
s4 := s n k : rat
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: (match
            (((match n with
               | Posz elpi_ctx_entry_3_ => iterop elpi_ctx_entry_3_ addq 1 0
               | Negz elpi_ctx_entry_3_ =>
                   (-
                    match elpi_ctx_entry_3_ with
                    | 0 => 1%Q
                    | _.+1 =>
                        match
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 =>
                                 match loop i with
                                 | {| valq := y |} =>
                                     fracq
                                       (let (y1, y2) := y in
                                        match y2 with
                                        | Posz 1 =>
                                            match y1 with
                                            | Posz 0 => (1%R, 1%R)
                                            | Posz 1 => (2, 1%R)
                                            | Posz
                                              (_.+2 as elpi_ctx_entry_15_) =>
                                                (elpi_ctx_entry_15_.+1, 1%R)
                                            | Negz _ => ((1 + y1)%R, 1%R)
                                            end
                                        | _ => ((1 * y2 + y1)%R, y2)
                                        end)
                                 end
                             end) elpi_ctx_entry_3_
                        with
                        | {| valq := y |} =>
                            fracq
                              (let (y1, y2) := y in
                               match y2 with
                               | Posz 1 =>
                                   match y1 with
                                   | Posz 0 => (1%R, 1%R)
                                   | Posz 1 => (2, 1%R)
                                   | Posz (_.+2 as elpi_ctx_entry_11_) =>
                                       (elpi_ctx_entry_11_.+1, 1%R)
                                   | Negz _ => ((1 + y1)%R, 1%R)
                                   end
                               | _ => ((1 * y2 + y1)%R, y2)
                               end)
                        end
                    end)%Q
               end + rat_of_Z 2)%Q +
              match k with
              | Posz elpi_ctx_entry_3_ => iterop elpi_ctx_entry_3_ addq 1 0
              | Negz elpi_ctx_entry_3_ =>
                  (-
                   match elpi_ctx_entry_3_ with
                   | 0 => 1%Q
                   | _.+1 =>
                       match
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 =>
                                match loop i with
                                | {| valq := y |} =>
                                    fracq
                                      (let (y1, y2) := y in
                                       match y2 with
                                       | Posz 1 =>
                                           match y1 with
                                           | Posz 0 => (1%R, 1%R)
                                           | Posz 1 => (2, 1%R)
                                           | Posz
                                             (_.+2 as elpi_ctx_entry_15_) =>
                                               (elpi_ctx_entry_15_.+1, 1%R)
                                           | Negz _ => ((1 + y1)%R, 1%R)
                                           end
                                       | _ => ((1 * y2 + y1)%R, y2)
                                       end)
                                end
                            end) elpi_ctx_entry_3_
                       with
                       | {| valq := y |} =>
                           fracq
                             (let (y1, y2) := y in
                              match y2 with
                              | Posz 1 =>
                                  match y1 with
                                  | Posz 0 => (1%R, 1%R)
                                  | Posz 1 => (2, 1%R)
                                  | Posz (_.+2 as elpi_ctx_entry_11_) =>
                                      (elpi_ctx_entry_11_.+1, 1%R)
                                  | Negz _ => ((1 + y1)%R, 1%R)
                                  end
                              | _ => ((1 * y2 + y1)%R, y2)
                              end)
                       end
                   end)%Q
              end)%Q * s (intZmod.addz n 1) (intZmod.addz k 1))%Q +
            (((-
               match n with
               | Posz elpi_ctx_entry_3_ => iterop elpi_ctx_entry_3_ addq 1 0
               | Negz elpi_ctx_entry_3_ =>
                   (-
                    match elpi_ctx_entry_3_ with
                    | 0 => 1%Q
                    | _.+1 =>
                        match
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 =>
                                 match loop i with
                                 | {| valq := y |} =>
                                     fracq
                                       (let (y1, y2) := y in
                                        match y2 with
                                        | Posz 1 =>
                                            match y1 with
                                            | Posz 0 => (1%R, 1%R)
                                            | Posz 1 => (2, 1%R)
                                            | Posz
                                              (_.+2 as elpi_ctx_entry_15_) =>
                                                (elpi_ctx_entry_15_.+1, 1%R)
                                            | Negz _ => ((1 + y1)%R, 1%R)
                                            end
                                        | _ => ((1 * y2 + y1)%R, y2)
                                        end)
                                 end
                             end) elpi_ctx_entry_3_
                        with
                        | {| valq := y |} =>
                            fracq
                              (let (y1, y2) := y in
                               match y2 with
                               | Posz 1 =>
                                   match y1 with
                                   | Posz 0 => (1%R, 1%R)
                                   | Posz 1 => (2, 1%R)
                                   | Posz (_.+2 as elpi_ctx_entry_11_) =>
                                       (elpi_ctx_entry_11_.+1, 1%R)
                                   | Negz _ => ((1 + y1)%R, 1%R)
                                   end
                               | _ => ((1 * y2 + y1)%R, y2)
                               end)
                        end
                    end)%Q
               end)%Q +
              match k with
              | Posz elpi_ctx_entry_3_ => iterop elpi_ctx_entry_3_ addq 1 0
              | Negz elpi_ctx_entry_3_ =>
                  (-
                   match elpi_ctx_entry_3_ with
                   | 0 => 1%Q
                   | _.+1 =>
                       match
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 =>
                                match loop i with
                                | {| valq := y |} =>
                                    fracq
                                      (let (y1, y2) := y in
                                       match y2 with
                                       | Posz 1 =>
                                           match y1 with
                                           | Posz 0 => (1%R, 1%R)
                                           | Posz 1 => (2, 1%R)
                                           | Posz
                                             (_.+2 as elpi_ctx_entry_15_) =>
                                               (elpi_ctx_entry_15_.+1, 1%R)
                                           | Negz _ => ((1 + y1)%R, 1%R)
                                           end
                                       | _ => ((1 * y2 + y1)%R, y2)
                                       end)
                                end
                            end) elpi_ctx_entry_3_
                       with
                       | {| valq := y |} =>
                           fracq
                             (let (y1, y2) := y in
                              match y2 with
                              | Posz 1 =>
                                  match y1 with
                                  | Posz 0 => (1%R, 1%R)
                                  | Posz 1 => (2, 1%R)
                                  | Posz (_.+2 as elpi_ctx_entry_11_) =>
                                      (elpi_ctx_entry_11_.+1, 1%R)
                                  | Negz _ => ((1 + y1)%R, 1%R)
                                  end
                              | _ => ((1 * y2 + y1)%R, y2)
                              end)
                       end
                   end)%Q
              end)%Q * s n (intZmod.addz k 1))%Q
          with
          | {| valq := y |} =>
              fracq
                (let (y1, y2) := y in
                 match y2 with
                 | Posz 1 => (y1, 1%R)
                 | _ => ((0 * y2 + y1)%R, y2)
                 end)
          end +
          (((((-
               match n with
               | Posz elpi_ctx_entry_3_ => iterop elpi_ctx_entry_3_ addq 1 0
               | Negz elpi_ctx_entry_3_ =>
                   (-
                    match elpi_ctx_entry_3_ with
                    | 0 => 1%Q
                    | _.+1 =>
                        match
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 =>
                                 match loop i with
                                 | {| valq := y |} =>
                                     fracq
                                       (let (y1, y2) := y in
                                        match y2 with
                                        | Posz 1 =>
                                            match y1 with
                                            | Posz 0 => (1%R, 1%R)
                                            | Posz 1 => (2, 1%R)
                                            | Posz
                                              (_.+2 as elpi_ctx_entry_15_) =>
                                                (elpi_ctx_entry_15_.+1, 1%R)
                                            | Negz _ => ((1 + y1)%R, 1%R)
                                            end
                                        | _ => ((1 * y2 + y1)%R, y2)
                                        end)
                                 end
                             end) elpi_ctx_entry_3_
                        with
                        | {| valq := y |} =>
                            fracq
                              (let (y1, y2) := y in
                               match y2 with
                               | Posz 1 =>
                                   match y1 with
                                   | Posz 0 => (1%R, 1%R)
                                   | Posz 1 => (2, 1%R)
                                   | Posz (_.+2 as elpi_ctx_entry_11_) =>
                                       (elpi_ctx_entry_11_.+1, 1%R)
                                   | Negz _ => ((1 + y1)%R, 1%R)
                                   end
                               | _ => ((1 * y2 + y1)%R, y2)
                               end)
                        end
                    end)%Q
               end)%Q + (- rat_of_Z 2)%Q)%Q +
             (-
              match k with
              | Posz elpi_ctx_entry_3_ => iterop elpi_ctx_entry_3_ addq 1 0
              | Negz elpi_ctx_entry_3_ =>
                  (-
                   match elpi_ctx_entry_3_ with
                   | 0 => 1%Q
                   | _.+1 =>
                       match
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 =>
                                match loop i with
                                | {| valq := y |} =>
                                    fracq
                                      (let (y1, y2) := y in
                                       match y2 with
                                       | Posz 1 =>
                                           match y1 with
                                           | Posz 0 => (1%R, 1%R)
                                           | Posz 1 => (2, 1%R)
                                           | Posz
                                             (_.+2 as elpi_ctx_entry_15_) =>
                                               (elpi_ctx_entry_15_.+1, 1%R)
                                           | Negz _ => ((1 + y1)%R, 1%R)
                                           end
                                       | _ => ((1 * y2 + y1)%R, y2)
                                       end)
                                end
                            end) elpi_ctx_entry_3_
                       with
                       | {| valq := y |} =>
                           fracq
                             (let (y1, y2) := y in
                              match y2 with
                              | Posz 1 =>
                                  match y1 with
                                  | Posz 0 => (1%R, 1%R)
                                  | Posz 1 => (2, 1%R)
                                  | Posz (_.+2 as elpi_ctx_entry_11_) =>
                                      (elpi_ctx_entry_11_.+1, 1%R)
                                  | Negz _ => ((1 + y1)%R, 1%R)
                                  end
                              | _ => ((1 * y2 + y1)%R, y2)
                              end)
                       end
                   end)%Q
              end)%Q)%Q * s (intZmod.addz n 1) k)%Q +
           ((match n with
             | Posz elpi_ctx_entry_3_ => iterop elpi_ctx_entry_3_ addq 1 0
             | Negz elpi_ctx_entry_3_ =>
                 (-
                  match elpi_ctx_entry_3_ with
                  | 0 => 1%Q
                  | _.+1 =>
                      match
                        (fix loop (m : nat) : rat :=
                           match m with
                           | 0 => 0
                           | 1 => 1
                           | (_.+1 as i).+1 =>
                               match loop i with
                               | {| valq := y |} =>
                                   fracq
                                     (let (y1, y2) := y in
                                      match y2 with
                                      | Posz 1 =>
                                          match y1 with
                                          | Posz 0 => (1%R, 1%R)
                                          | Posz 1 => (2, 1%R)
                                          | Posz (_.+2 as elpi_ctx_entry_15_) =>
                                              (elpi_ctx_entry_15_.+1, 1%R)
                                          | Negz _ => ((1 + y1)%R, 1%R)
                                          end
                                      | _ => ((1 * y2 + y1)%R, y2)
                                      end)
                               end
                           end) elpi_ctx_entry_3_
                      with
                      | {| valq := y |} =>
                          fracq
                            (let (y1, y2) := y in
                             match y2 with
                             | Posz 1 =>
                                 match y1 with
                                 | Posz 0 => (1%R, 1%R)
                                 | Posz 1 => (2, 1%R)
                                 | Posz (_.+2 as elpi_ctx_entry_11_) =>
                                     (elpi_ctx_entry_11_.+1, 1%R)
                                 | Negz _ => ((1 + y1)%R, 1%R)
                                 end
                             | _ => ((1 * y2 + y1)%R, y2)
                             end)
                      end
                  end)%Q
             end +
             (-
              match k with
              | Posz elpi_ctx_entry_3_ => iterop elpi_ctx_entry_3_ addq 1 0
              | Negz elpi_ctx_entry_3_ =>
                  (-
                   match elpi_ctx_entry_3_ with
                   | 0 => 1%Q
                   | _.+1 =>
                       match
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 =>
                                match loop i with
                                | {| valq := y |} =>
                                    fracq
                                      (let (y1, y2) := y in
                                       match y2 with
                                       | Posz 1 =>
                                           match y1 with
                                           | Posz 0 => (1%R, 1%R)
                                           | Posz 1 => (2, 1%R)
                                           | Posz
                                             (_.+2 as elpi_ctx_entry_15_) =>
                                               (elpi_ctx_entry_15_.+1, 1%R)
                                           | Negz _ => ((1 + y1)%R, 1%R)
                                           end
                                       | _ => ((1 * y2 + y1)%R, y2)
                                       end)
                                end
                            end) elpi_ctx_entry_3_
                       with
                       | {| valq := y |} =>
                           fracq
                             (let (y1, y2) := y in
                              match y2 with
                              | Posz 1 =>
                                  match y1 with
                                  | Posz 0 => (1%R, 1%R)
                                  | Posz 1 => (2, 1%R)
                                  | Posz (_.+2 as elpi_ctx_entry_11_) =>
                                      (elpi_ctx_entry_11_.+1, 1%R)
                                  | Negz _ => ((1 + y1)%R, 1%R)
                                  end
                              | _ => ((1 * y2 + y1)%R, y2)
                              end)
                       end
                   end)%Q
              end)%Q)%Q * s4)%Q)%Q)%Q;
         (((((match n with
              | Posz elpi_ctx_entry_3_ => iterop elpi_ctx_entry_3_ addq 1 0
              | Negz elpi_ctx_entry_3_ =>
                  (-
                   match elpi_ctx_entry_3_ with
                   | 0 => 1%Q
                   | _.+1 =>
                       match
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 =>
                                match loop i with
                                | {| valq := y |} =>
                                    fracq
                                      (let (y1, y2) := y in
                                       match y2 with
                                       | Posz 1 =>
                                           match y1 with
                                           | Posz 0 => (1%R, 1%R)
                                           | Posz 1 => (2, 1%R)
                                           | Posz
                                             (_.+2 as elpi_ctx_entry_15_) =>
                                               (elpi_ctx_entry_15_.+1, 1%R)
                                           | Negz _ => ((1 + y1)%R, 1%R)
                                           end
                                       | _ => ((1 * y2 + y1)%R, y2)
                                       end)
                                end
                            end) elpi_ctx_entry_3_
                       with
                       | {| valq := y |} =>
                           fracq
                             (let (y1, y2) := y in
                              match y2 with
                              | Posz 1 =>
                                  match y1 with
                                  | Posz 0 => (1%R, 1%R)
                                  | Posz 1 => (2, 1%R)
                                  | Posz (_.+2 as elpi_ctx_entry_11_) =>
                                      (elpi_ctx_entry_11_.+1, 1%R)
                                  | Negz _ => ((1 + y1)%R, 1%R)
                                  end
                              | _ => ((1 * y2 + y1)%R, y2)
                              end)
                       end
                   end)%Q
              end +
              (-
               match k with
               | Posz elpi_ctx_entry_3_ => iterop elpi_ctx_entry_3_ addq 1 0
               | Negz elpi_ctx_entry_3_ =>
                   (-
                    match elpi_ctx_entry_3_ with
                    | 0 => 1%Q
                    | _.+1 =>
                        match
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 =>
                                 match loop i with
                                 | {| valq := y |} =>
                                     fracq
                                       (let (y1, y2) := y in
                                        match y2 with
                                        | Posz 1 =>
                                            match y1 with
                                            | Posz 0 => (1%R, 1%R)
                                            | Posz 1 => (2, 1%R)
                                            | Posz
                                              (_.+2 as elpi_ctx_entry_15_) =>
                                                (elpi_ctx_entry_15_.+1, 1%R)
                                            | Negz _ => ((1 + y1)%R, 1%R)
                                            end
                                        | _ => ((1 * y2 + y1)%R, y2)
                                        end)
                                 end
                             end) elpi_ctx_entry_3_
                        with
                        | {| valq := y |} =>
                            fracq
                              (let (y1, y2) := y in
                               match y2 with
                               | Posz 1 =>
                                   match y1 with
                                   | Posz 0 => (1%R, 1%R)
                                   | Posz 1 => (2, 1%R)
                                   | Posz (_.+2 as elpi_ctx_entry_11_) =>
                                       (elpi_ctx_entry_11_.+1, 1%R)
                                   | Negz _ => ((1 + y1)%R, 1%R)
                                   end
                               | _ => ((1 * y2 + y1)%R, y2)
                               end)
                        end
                    end)%Q
               end)%Q)%Q * s4)%Q +
            ((((-
                match n with
                | Posz elpi_ctx_entry_3_ => iterop elpi_ctx_entry_3_ addq 1 0
                | Negz elpi_ctx_entry_3_ =>
                    (-
                     match elpi_ctx_entry_3_ with
                     | 0 => 1%Q
                     | _.+1 =>
                         match
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 =>
                                  match loop i with
                                  | {| valq := y |} =>
                                      fracq
                                        (let (y1, y2) := y in
                                         match y2 with
                                         | Posz 1 =>
                                             match y1 with
                                             | Posz 0 => (1%R, 1%R)
                                             | Posz 1 => (2, 1%R)
                                             | Posz
                                               (_.+2 as elpi_ctx_entry_15_) =>
                                                 (elpi_ctx_entry_15_.+1, 1%R)
                                             | Negz _ => ((1 + y1)%R, 1%R)
                                             end
                                         | _ => ((1 * y2 + y1)%R, y2)
                                         end)
                                  end
                              end) elpi_ctx_entry_3_
                         with
                         | {| valq := y |} =>
                             fracq
                               (let (y1, y2) := y in
                                match y2 with
                                | Posz 1 =>
                                    match y1 with
                                    | Posz 0 => (1%R, 1%R)
                                    | Posz 1 => (2, 1%R)
                                    | Posz (_.+2 as elpi_ctx_entry_11_) =>
                                        (elpi_ctx_entry_11_.+1, 1%R)
                                    | Negz _ => ((1 + y1)%R, 1%R)
                                    end
                                | _ => ((1 * y2 + y1)%R, y2)
                                end)
                         end
                     end)%Q
                end)%Q + (- rat_of_Z 2)%Q)%Q +
              (-
               match k with
               | Posz elpi_ctx_entry_3_ => iterop elpi_ctx_entry_3_ addq 1 0
               | Negz elpi_ctx_entry_3_ =>
                   (-
                    match elpi_ctx_entry_3_ with
                    | 0 => 1%Q
                    | _.+1 =>
                        match
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 =>
                                 match loop i with
                                 | {| valq := y |} =>
                                     fracq
                                       (let (y1, y2) := y in
                                        match y2 with
                                        | Posz 1 =>
                                            match y1 with
                                            | Posz 0 => (1%R, 1%R)
                                            | Posz 1 => (2, 1%R)
                                            | Posz
                                              (_.+2 as elpi_ctx_entry_15_) =>
                                                (elpi_ctx_entry_15_.+1, 1%R)
                                            | Negz _ => ((1 + y1)%R, 1%R)
                                            end
                                        | _ => ((1 * y2 + y1)%R, y2)
                                        end)
                                 end
                             end) elpi_ctx_entry_3_
                        with
                        | {| valq := y |} =>
                            fracq
                              (let (y1, y2) := y in
                               match y2 with
                               | Posz 1 =>
                                   match y1 with
                                   | Posz 0 => (1%R, 1%R)
                                   | Posz 1 => (2, 1%R)
                                   | Posz (_.+2 as elpi_ctx_entry_11_) =>
                                       (elpi_ctx_entry_11_.+1, 1%R)
                                   | Negz _ => ((1 + y1)%R, 1%R)
                                   end
                               | _ => ((1 * y2 + y1)%R, y2)
                               end)
                        end
                    end)%Q
               end)%Q)%Q * s (intZmod.addz n 1) k)%Q)%Q +
           (((-
              match n with
              | Posz elpi_ctx_entry_3_ => iterop elpi_ctx_entry_3_ addq 1 0
              | Negz elpi_ctx_entry_3_ =>
                  (-
                   match elpi_ctx_entry_3_ with
                   | 0 => 1%Q
                   | _.+1 =>
                       match
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 =>
                                match loop i with
                                | {| valq := y |} =>
                                    fracq
                                      (let (y1, y2) := y in
                                       match y2 with
                                       | Posz 1 =>
                                           match y1 with
                                           | Posz 0 => (1%R, 1%R)
                                           | Posz 1 => (2, 1%R)
                                           | Posz
                                             (_.+2 as elpi_ctx_entry_15_) =>
                                               (elpi_ctx_entry_15_.+1, 1%R)
                                           | Negz _ => ((1 + y1)%R, 1%R)
                                           end
                                       | _ => ((1 * y2 + y1)%R, y2)
                                       end)
                                end
                            end) elpi_ctx_entry_3_
                       with
                       | {| valq := y |} =>
                           fracq
                             (let (y1, y2) := y in
                              match y2 with
                              | Posz 1 =>
                                  match y1 with
                                  | Posz 0 => (1%R, 1%R)
                                  | Posz 1 => (2, 1%R)
                                  | Posz (_.+2 as elpi_ctx_entry_11_) =>
                                      (elpi_ctx_entry_11_.+1, 1%R)
                                  | Negz _ => ((1 + y1)%R, 1%R)
                                  end
                              | _ => ((1 * y2 + y1)%R, y2)
                              end)
                       end
                   end)%Q
              end)%Q +
             match k with
             | Posz elpi_ctx_entry_3_ => iterop elpi_ctx_entry_3_ addq 1 0
             | Negz elpi_ctx_entry_3_ =>
                 (-
                  match elpi_ctx_entry_3_ with
                  | 0 => 1%Q
                  | _.+1 =>
                      match
                        (fix loop (m : nat) : rat :=
                           match m with
                           | 0 => 0
                           | 1 => 1
                           | (_.+1 as i).+1 =>
                               match loop i with
                               | {| valq := y |} =>
                                   fracq
                                     (let (y1, y2) := y in
                                      match y2 with
                                      | Posz 1 =>
                                          match y1 with
                                          | Posz 0 => (1%R, 1%R)
                                          | Posz 1 => (2, 1%R)
                                          | Posz (_.+2 as elpi_ctx_entry_15_) =>
                                              (elpi_ctx_entry_15_.+1, 1%R)
                                          | Negz _ => ((1 + y1)%R, 1%R)
                                          end
                                      | _ => ((1 * y2 + y1)%R, y2)
                                      end)
                               end
                           end) elpi_ctx_entry_3_
                      with
                      | {| valq := y |} =>
                          fracq
                            (let (y1, y2) := y in
                             match y2 with
                             | Posz 1 =>
                                 match y1 with
                                 | Posz 0 => (1%R, 1%R)
                                 | Posz 1 => (2, 1%R)
                                 | Posz (_.+2 as elpi_ctx_entry_11_) =>
                                     (elpi_ctx_entry_11_.+1, 1%R)
                                 | Negz _ => ((1 + y1)%R, 1%R)
                                 end
                             | _ => ((1 * y2 + y1)%R, y2)
                             end)
                      end
                  end)%Q
             end)%Q * s n (intZmod.addz k 1))%Q)%Q +
          (((match n with
             | Posz elpi_ctx_entry_3_ => iterop elpi_ctx_entry_3_ addq 1 0
             | Negz elpi_ctx_entry_3_ =>
                 (-
                  match elpi_ctx_entry_3_ with
                  | 0 => 1%Q
                  | _.+1 =>
                      match
                        (fix loop (m : nat) : rat :=
                           match m with
                           | 0 => 0
                           | 1 => 1
                           | (_.+1 as i).+1 =>
                               match loop i with
                               | {| valq := y |} =>
                                   fracq
                                     (let (y1, y2) := y in
                                      match y2 with
                                      | Posz 1 =>
                                          match y1 with
                                          | Posz 0 => (1%R, 1%R)
                                          | Posz 1 => (2, 1%R)
                                          | Posz (_.+2 as elpi_ctx_entry_15_) =>
                                              (elpi_ctx_entry_15_.+1, 1%R)
                                          | Negz _ => ((1 + y1)%R, 1%R)
                                          end
                                      | _ => ((1 * y2 + y1)%R, y2)
                                      end)
                               end
                           end) elpi_ctx_entry_3_
                      with
                      | {| valq := y |} =>
                          fracq
                            (let (y1, y2) := y in
                             match y2 with
                             | Posz 1 =>
                                 match y1 with
                                 | Posz 0 => (1%R, 1%R)
                                 | Posz 1 => (2, 1%R)
                                 | Posz (_.+2 as elpi_ctx_entry_11_) =>
                                     (elpi_ctx_entry_11_.+1, 1%R)
                                 | Negz _ => ((1 + y1)%R, 1%R)
                                 end
                             | _ => ((1 * y2 + y1)%R, y2)
                             end)
                      end
                  end)%Q
             end + rat_of_Z 2)%Q +
            match k with
            | Posz elpi_ctx_entry_3_ => iterop elpi_ctx_entry_3_ addq 1 0
            | Negz elpi_ctx_entry_3_ =>
                (-
                 match elpi_ctx_entry_3_ with
                 | 0 => 1%Q
                 | _.+1 =>
                     match
                       (fix loop (m : nat) : rat :=
                          match m with
                          | 0 => 0
                          | 1 => 1
                          | (_.+1 as i).+1 =>
                              match loop i with
                              | {| valq := y |} =>
                                  fracq
                                    (let (y1, y2) := y in
                                     match y2 with
                                     | Posz 1 =>
                                         match y1 with
                                         | Posz 0 => (1%R, 1%R)
                                         | Posz 1 => (2, 1%R)
                                         | Posz (_.+2 as elpi_ctx_entry_15_) =>
                                             (elpi_ctx_entry_15_.+1, 1%R)
                                         | Negz _ => ((1 + y1)%R, 1%R)
                                         end
                                     | _ => ((1 * y2 + y1)%R, y2)
                                     end)
                              end
                          end) elpi_ctx_entry_3_
                     with
                     | {| valq := y |} =>
                         fracq
                           (let (y1, y2) := y in
                            match y2 with
                            | Posz 1 =>
                                match y1 with
                                | Posz 0 => (1%R, 1%R)
                                | Posz 1 => (2, 1%R)
                                | Posz (_.+2 as elpi_ctx_entry_11_) =>
                                    (elpi_ctx_entry_11_.+1, 1%R)
                                | Negz _ => ((1 + y1)%R, 1%R)
                                end
                            | _ => ((1 * y2 + y1)%R, y2)
                            end)
                     end
                 end)%Q
            end)%Q * s (intZmod.addz n 1) (intZmod.addz k 1))%Q)%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
s4 := s n k : rat
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: (((((match n with
              | Posz elpi_ctx_entry_3_ => iterop elpi_ctx_entry_3_ addq 1 0
              | Negz elpi_ctx_entry_3_ =>
                  (-
                   match elpi_ctx_entry_3_ with
                   | 0 => 1%Q
                   | _.+1 =>
                       match
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 =>
                                match loop i with
                                | {| valq := y |} =>
                                    fracq
                                      (let (y1, y2) := y in
                                       match y2 with
                                       | Posz 1 =>
                                           match y1 with
                                           | Posz 0 => (1%R, 1%R)
                                           | Posz 1 => (2, 1%R)
                                           | Posz
                                             (_.+2 as elpi_ctx_entry_15_) =>
                                               (elpi_ctx_entry_15_.+1, 1%R)
                                           | Negz _ => ((1 + y1)%R, 1%R)
                                           end
                                       | _ => ((1 * y2 + y1)%R, y2)
                                       end)
                                end
                            end) elpi_ctx_entry_3_
                       with
                       | {| valq := y |} =>
                           fracq
                             (let (y1, y2) := y in
                              match y2 with
                              | Posz 1 =>
                                  match y1 with
                                  | Posz 0 => (1%R, 1%R)
                                  | Posz 1 => (2, 1%R)
                                  | Posz (_.+2 as elpi_ctx_entry_11_) =>
                                      (elpi_ctx_entry_11_.+1, 1%R)
                                  | Negz _ => ((1 + y1)%R, 1%R)
                                  end
                              | _ => ((1 * y2 + y1)%R, y2)
                              end)
                       end
                   end)%Q
              end +
              (-
               match k with
               | Posz elpi_ctx_entry_3_ => iterop elpi_ctx_entry_3_ addq 1 0
               | Negz elpi_ctx_entry_3_ =>
                   (-
                    match elpi_ctx_entry_3_ with
                    | 0 => 1%Q
                    | _.+1 =>
                        match
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 =>
                                 match loop i with
                                 | {| valq := y |} =>
                                     fracq
                                       (let (y1, y2) := y in
                                        match y2 with
                                        | Posz 1 =>
                                            match y1 with
                                            | Posz 0 => (1%R, 1%R)
                                            | Posz 1 => (2, 1%R)
                                            | Posz
                                              (_.+2 as elpi_ctx_entry_15_) =>
                                                (elpi_ctx_entry_15_.+1, 1%R)
                                            | Negz _ => ((1 + y1)%R, 1%R)
                                            end
                                        | _ => ((1 * y2 + y1)%R, y2)
                                        end)
                                 end
                             end) elpi_ctx_entry_3_
                        with
                        | {| valq := y |} =>
                            fracq
                              (let (y1, y2) := y in
                               match y2 with
                               | Posz 1 =>
                                   match y1 with
                                   | Posz 0 => (1%R, 1%R)
                                   | Posz 1 => (2, 1%R)
                                   | Posz (_.+2 as elpi_ctx_entry_11_) =>
                                       (elpi_ctx_entry_11_.+1, 1%R)
                                   | Negz _ => ((1 + y1)%R, 1%R)
                                   end
                               | _ => ((1 * y2 + y1)%R, y2)
                               end)
                        end
                    end)%Q
               end)%Q)%Q * s4)%Q +
            ((((-
                match n with
                | Posz elpi_ctx_entry_3_ => iterop elpi_ctx_entry_3_ addq 1 0
                | Negz elpi_ctx_entry_3_ =>
                    (-
                     match elpi_ctx_entry_3_ with
                     | 0 => 1%Q
                     | _.+1 =>
                         match
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 =>
                                  match loop i with
                                  | {| valq := y |} =>
                                      fracq
                                        (let (y1, y2) := y in
                                         match y2 with
                                         | Posz 1 =>
                                             match y1 with
                                             | Posz 0 => (1%R, 1%R)
                                             | Posz 1 => (2, 1%R)
                                             | Posz
                                               (_.+2 as elpi_ctx_entry_15_) =>
                                                 (elpi_ctx_entry_15_.+1, 1%R)
                                             | Negz _ => ((1 + y1)%R, 1%R)
                                             end
                                         | _ => ((1 * y2 + y1)%R, y2)
                                         end)
                                  end
                              end) elpi_ctx_entry_3_
                         with
                         | {| valq := y |} =>
                             fracq
                               (let (y1, y2) := y in
                                match y2 with
                                | Posz 1 =>
                                    match y1 with
                                    | Posz 0 => (1%R, 1%R)
                                    | Posz 1 => (2, 1%R)
                                    | Posz (_.+2 as elpi_ctx_entry_11_) =>
                                        (elpi_ctx_entry_11_.+1, 1%R)
                                    | Negz _ => ((1 + y1)%R, 1%R)
                                    end
                                | _ => ((1 * y2 + y1)%R, y2)
                                end)
                         end
                     end)%Q
                end)%Q + (- rat_of_Z 2)%Q)%Q +
              (-
               match k with
               | Posz elpi_ctx_entry_3_ => iterop elpi_ctx_entry_3_ addq 1 0
               | Negz elpi_ctx_entry_3_ =>
                   (-
                    match elpi_ctx_entry_3_ with
                    | 0 => 1%Q
                    | _.+1 =>
                        match
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 =>
                                 match loop i with
                                 | {| valq := y |} =>
                                     fracq
                                       (let (y1, y2) := y in
                                        match y2 with
                                        | Posz 1 =>
                                            match y1 with
                                            | Posz 0 => (1%R, 1%R)
                                            | Posz 1 => (2, 1%R)
                                            | Posz
                                              (_.+2 as elpi_ctx_entry_15_) =>
                                                (elpi_ctx_entry_15_.+1, 1%R)
                                            | Negz _ => ((1 + y1)%R, 1%R)
                                            end
                                        | _ => ((1 * y2 + y1)%R, y2)
                                        end)
                                 end
                             end) elpi_ctx_entry_3_
                        with
                        | {| valq := y |} =>
                            fracq
                              (let (y1, y2) := y in
                               match y2 with
                               | Posz 1 =>
                                   match y1 with
                                   | Posz 0 => (1%R, 1%R)
                                   | Posz 1 => (2, 1%R)
                                   | Posz (_.+2 as elpi_ctx_entry_11_) =>
                                       (elpi_ctx_entry_11_.+1, 1%R)
                                   | Negz _ => ((1 + y1)%R, 1%R)
                                   end
                               | _ => ((1 * y2 + y1)%R, y2)
                               end)
                        end
                    end)%Q
               end)%Q)%Q * s (intZmod.addz n 1) k)%Q)%Q +
           (((-
              match n with
              | Posz elpi_ctx_entry_3_ => iterop elpi_ctx_entry_3_ addq 1 0
              | Negz elpi_ctx_entry_3_ =>
                  (-
                   match elpi_ctx_entry_3_ with
                   | 0 => 1%Q
                   | _.+1 =>
                       match
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 =>
                                match loop i with
                                | {| valq := y |} =>
                                    fracq
                                      (let (y1, y2) := y in
                                       match y2 with
                                       | Posz 1 =>
                                           match y1 with
                                           | Posz 0 => (1%R, 1%R)
                                           | Posz 1 => (2, 1%R)
                                           | Posz
                                             (_.+2 as elpi_ctx_entry_15_) =>
                                               (elpi_ctx_entry_15_.+1, 1%R)
                                           | Negz _ => ((1 + y1)%R, 1%R)
                                           end
                                       | _ => ((1 * y2 + y1)%R, y2)
                                       end)
                                end
                            end) elpi_ctx_entry_3_
                       with
                       | {| valq := y |} =>
                           fracq
                             (let (y1, y2) := y in
                              match y2 with
                              | Posz 1 =>
                                  match y1 with
                                  | Posz 0 => (1%R, 1%R)
                                  | Posz 1 => (2, 1%R)
                                  | Posz (_.+2 as elpi_ctx_entry_11_) =>
                                      (elpi_ctx_entry_11_.+1, 1%R)
                                  | Negz _ => ((1 + y1)%R, 1%R)
                                  end
                              | _ => ((1 * y2 + y1)%R, y2)
                              end)
                       end
                   end)%Q
              end)%Q +
             match k with
             | Posz elpi_ctx_entry_3_ => iterop elpi_ctx_entry_3_ addq 1 0
             | Negz elpi_ctx_entry_3_ =>
                 (-
                  match elpi_ctx_entry_3_ with
                  | 0 => 1%Q
                  | _.+1 =>
                      match
                        (fix loop (m : nat) : rat :=
                           match m with
                           | 0 => 0
                           | 1 => 1
                           | (_.+1 as i).+1 =>
                               match loop i with
                               | {| valq := y |} =>
                                   fracq
                                     (let (y1, y2) := y in
                                      match y2 with
                                      | Posz 1 =>
                                          match y1 with
                                          | Posz 0 => (1%R, 1%R)
                                          | Posz 1 => (2, 1%R)
                                          | Posz (_.+2 as elpi_ctx_entry_15_) =>
                                              (elpi_ctx_entry_15_.+1, 1%R)
                                          | Negz _ => ((1 + y1)%R, 1%R)
                                          end
                                      | _ => ((1 * y2 + y1)%R, y2)
                                      end)
                               end
                           end) elpi_ctx_entry_3_
                      with
                      | {| valq := y |} =>
                          fracq
                            (let (y1, y2) := y in
                             match y2 with
                             | Posz 1 =>
                                 match y1 with
                                 | Posz 0 => (1%R, 1%R)
                                 | Posz 1 => (2, 1%R)
                                 | Posz (_.+2 as elpi_ctx_entry_11_) =>
                                     (elpi_ctx_entry_11_.+1, 1%R)
                                 | Negz _ => ((1 + y1)%R, 1%R)
                                 end
                             | _ => ((1 * y2 + y1)%R, y2)
                             end)
                      end
                  end)%Q
             end)%Q * s n (intZmod.addz k 1))%Q)%Q +
          (((match n with
             | Posz elpi_ctx_entry_3_ => iterop elpi_ctx_entry_3_ addq 1 0
             | Negz elpi_ctx_entry_3_ =>
                 (-
                  match elpi_ctx_entry_3_ with
                  | 0 => 1%Q
                  | _.+1 =>
                      match
                        (fix loop (m : nat) : rat :=
                           match m with
                           | 0 => 0
                           | 1 => 1
                           | (_.+1 as i).+1 =>
                               match loop i with
                               | {| valq := y |} =>
                                   fracq
                                     (let (y1, y2) := y in
                                      match y2 with
                                      | Posz 1 =>
                                          match y1 with
                                          | Posz 0 => (1%R, 1%R)
                                          | Posz 1 => (2, 1%R)
                                          | Posz (_.+2 as elpi_ctx_entry_15_) =>
                                              (elpi_ctx_entry_15_.+1, 1%R)
                                          | Negz _ => ((1 + y1)%R, 1%R)
                                          end
                                      | _ => ((1 * y2 + y1)%R, y2)
                                      end)
                               end
                           end) elpi_ctx_entry_3_
                      with
                      | {| valq := y |} =>
                          fracq
                            (let (y1, y2) := y in
                             match y2 with
                             | Posz 1 =>
                                 match y1 with
                                 | Posz 0 => (1%R, 1%R)
                                 | Posz 1 => (2, 1%R)
                                 | Posz (_.+2 as elpi_ctx_entry_11_) =>
                                     (elpi_ctx_entry_11_.+1, 1%R)
                                 | Negz _ => ((1 + y1)%R, 1%R)
                                 end
                             | _ => ((1 * y2 + y1)%R, y2)
                             end)
                      end
                  end)%Q
             end + rat_of_Z 2)%Q +
            match k with
            | Posz elpi_ctx_entry_3_ => iterop elpi_ctx_entry_3_ addq 1 0
            | Negz elpi_ctx_entry_3_ =>
                (-
                 match elpi_ctx_entry_3_ with
                 | 0 => 1%Q
                 | _.+1 =>
                     match
                       (fix loop (m : nat) : rat :=
                          match m with
                          | 0 => 0
                          | 1 => 1
                          | (_.+1 as i).+1 =>
                              match loop i with
                              | {| valq := y |} =>
                                  fracq
                                    (let (y1, y2) := y in
                                     match y2 with
                                     | Posz 1 =>
                                         match y1 with
                                         | Posz 0 => (1%R, 1%R)
                                         | Posz 1 => (2, 1%R)
                                         | Posz (_.+2 as elpi_ctx_entry_15_) =>
                                             (elpi_ctx_entry_15_.+1, 1%R)
                                         | Negz _ => ((1 + y1)%R, 1%R)
                                         end
                                     | _ => ((1 * y2 + y1)%R, y2)
                                     end)
                              end
                          end) elpi_ctx_entry_3_
                     with
                     | {| valq := y |} =>
                         fracq
                           (let (y1, y2) := y in
                            match y2 with
                            | Posz 1 =>
                                match y1 with
                                | Posz 0 => (1%R, 1%R)
                                | Posz 1 => (2, 1%R)
                                | Posz (_.+2 as elpi_ctx_entry_11_) =>
                                    (elpi_ctx_entry_11_.+1, 1%R)
                                | Negz _ => ((1 + y1)%R, 1%R)
                                end
                            | _ => ((1 * y2 + y1)%R, y2)
                            end)
                     end
                 end)%Q
            end)%Q * s (intZmod.addz n 1) (intZmod.addz k 1))%Q)%Q;
         (match
            (((match n with
               | Posz elpi_ctx_entry_3_ => iterop elpi_ctx_entry_3_ addq 1 0
               | Negz elpi_ctx_entry_3_ =>
                   (-
                    match elpi_ctx_entry_3_ with
                    | 0 => 1%Q
                    | _.+1 =>
                        match
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 =>
                                 match loop i with
                                 | {| valq := y |} =>
                                     fracq
                                       (let (y1, y2) := y in
                                        match y2 with
                                        | Posz 1 =>
                                            match y1 with
                                            | Posz 0 => (1%R, 1%R)
                                            | Posz 1 => (2, 1%R)
                                            | Posz
                                              (_.+2 as elpi_ctx_entry_15_) =>
                                                (elpi_ctx_entry_15_.+1, 1%R)
                                            | Negz _ => ((1 + y1)%R, 1%R)
                                            end
                                        | _ => ((1 * y2 + y1)%R, y2)
                                        end)
                                 end
                             end) elpi_ctx_entry_3_
                        with
                        | {| valq := y |} =>
                            fracq
                              (let (y1, y2) := y in
                               match y2 with
                               | Posz 1 =>
                                   match y1 with
                                   | Posz 0 => (1%R, 1%R)
                                   | Posz 1 => (2, 1%R)
                                   | Posz (_.+2 as elpi_ctx_entry_11_) =>
                                       (elpi_ctx_entry_11_.+1, 1%R)
                                   | Negz _ => ((1 + y1)%R, 1%R)
                                   end
                               | _ => ((1 * y2 + y1)%R, y2)
                               end)
                        end
                    end)%Q
               end + rat_of_Z 2)%Q +
              match k with
              | Posz elpi_ctx_entry_3_ => iterop elpi_ctx_entry_3_ addq 1 0
              | Negz elpi_ctx_entry_3_ =>
                  (-
                   match elpi_ctx_entry_3_ with
                   | 0 => 1%Q
                   | _.+1 =>
                       match
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 =>
                                match loop i with
                                | {| valq := y |} =>
                                    fracq
                                      (let (y1, y2) := y in
                                       match y2 with
                                       | Posz 1 =>
                                           match y1 with
                                           | Posz 0 => (1%R, 1%R)
                                           | Posz 1 => (2, 1%R)
                                           | Posz
                                             (_.+2 as elpi_ctx_entry_15_) =>
                                               (elpi_ctx_entry_15_.+1, 1%R)
                                           | Negz _ => ((1 + y1)%R, 1%R)
                                           end
                                       | _ => ((1 * y2 + y1)%R, y2)
                                       end)
                                end
                            end) elpi_ctx_entry_3_
                       with
                       | {| valq := y |} =>
                           fracq
                             (let (y1, y2) := y in
                              match y2 with
                              | Posz 1 =>
                                  match y1 with
                                  | Posz 0 => (1%R, 1%R)
                                  | Posz 1 => (2, 1%R)
                                  | Posz (_.+2 as elpi_ctx_entry_11_) =>
                                      (elpi_ctx_entry_11_.+1, 1%R)
                                  | Negz _ => ((1 + y1)%R, 1%R)
                                  end
                              | _ => ((1 * y2 + y1)%R, y2)
                              end)
                       end
                   end)%Q
              end)%Q * s (intZmod.addz n 1) (intZmod.addz k 1))%Q +
            (((-
               match n with
               | Posz elpi_ctx_entry_3_ => iterop elpi_ctx_entry_3_ addq 1 0
               | Negz elpi_ctx_entry_3_ =>
                   (-
                    match elpi_ctx_entry_3_ with
                    | 0 => 1%Q
                    | _.+1 =>
                        match
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 =>
                                 match loop i with
                                 | {| valq := y |} =>
                                     fracq
                                       (let (y1, y2) := y in
                                        match y2 with
                                        | Posz 1 =>
                                            match y1 with
                                            | Posz 0 => (1%R, 1%R)
                                            | Posz 1 => (2, 1%R)
                                            | Posz
                                              (_.+2 as elpi_ctx_entry_15_) =>
                                                (elpi_ctx_entry_15_.+1, 1%R)
                                            | Negz _ => ((1 + y1)%R, 1%R)
                                            end
                                        | _ => ((1 * y2 + y1)%R, y2)
                                        end)
                                 end
                             end) elpi_ctx_entry_3_
                        with
                        | {| valq := y |} =>
                            fracq
                              (let (y1, y2) := y in
                               match y2 with
                               | Posz 1 =>
                                   match y1 with
                                   | Posz 0 => (1%R, 1%R)
                                   | Posz 1 => (2, 1%R)
                                   | Posz (_.+2 as elpi_ctx_entry_11_) =>
                                       (elpi_ctx_entry_11_.+1, 1%R)
                                   | Negz _ => ((1 + y1)%R, 1%R)
                                   end
                               | _ => ((1 * y2 + y1)%R, y2)
                               end)
                        end
                    end)%Q
               end)%Q +
              match k with
              | Posz elpi_ctx_entry_3_ => iterop elpi_ctx_entry_3_ addq 1 0
              | Negz elpi_ctx_entry_3_ =>
                  (-
                   match elpi_ctx_entry_3_ with
                   | 0 => 1%Q
                   | _.+1 =>
                       match
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 =>
                                match loop i with
                                | {| valq := y |} =>
                                    fracq
                                      (let (y1, y2) := y in
                                       match y2 with
                                       | Posz 1 =>
                                           match y1 with
                                           | Posz 0 => (1%R, 1%R)
                                           | Posz 1 => (2, 1%R)
                                           | Posz
                                             (_.+2 as elpi_ctx_entry_15_) =>
                                               (elpi_ctx_entry_15_.+1, 1%R)
                                           | Negz _ => ((1 + y1)%R, 1%R)
                                           end
                                       | _ => ((1 * y2 + y1)%R, y2)
                                       end)
                                end
                            end) elpi_ctx_entry_3_
                       with
                       | {| valq := y |} =>
                           fracq
                             (let (y1, y2) := y in
                              match y2 with
                              | Posz 1 =>
                                  match y1 with
                                  | Posz 0 => (1%R, 1%R)
                                  | Posz 1 => (2, 1%R)
                                  | Posz (_.+2 as elpi_ctx_entry_11_) =>
                                      (elpi_ctx_entry_11_.+1, 1%R)
                                  | Negz _ => ((1 + y1)%R, 1%R)
                                  end
                              | _ => ((1 * y2 + y1)%R, y2)
                              end)
                       end
                   end)%Q
              end)%Q * s n (intZmod.addz k 1))%Q
          with
          | {| valq := y |} =>
              fracq
                (let (y1, y2) := y in
                 match y2 with
                 | Posz 1 => (y1, 1%R)
                 | _ => ((0 * y2 + y1)%R, y2)
                 end)
          end +
          (((((-
               match n with
               | Posz elpi_ctx_entry_3_ => iterop elpi_ctx_entry_3_ addq 1 0
               | Negz elpi_ctx_entry_3_ =>
                   (-
                    match elpi_ctx_entry_3_ with
                    | 0 => 1%Q
                    | _.+1 =>
                        match
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 =>
                                 match loop i with
                                 | {| valq := y |} =>
                                     fracq
                                       (let (y1, y2) := y in
                                        match y2 with
                                        | Posz 1 =>
                                            match y1 with
                                            | Posz 0 => (1%R, 1%R)
                                            | Posz 1 => (2, 1%R)
                                            | Posz
                                              (_.+2 as elpi_ctx_entry_15_) =>
                                                (elpi_ctx_entry_15_.+1, 1%R)
                                            | Negz _ => ((1 + y1)%R, 1%R)
                                            end
                                        | _ => ((1 * y2 + y1)%R, y2)
                                        end)
                                 end
                             end) elpi_ctx_entry_3_
                        with
                        | {| valq := y |} =>
                            fracq
                              (let (y1, y2) := y in
                               match y2 with
                               | Posz 1 =>
                                   match y1 with
                                   | Posz 0 => (1%R, 1%R)
                                   | Posz 1 => (2, 1%R)
                                   | Posz (_.+2 as elpi_ctx_entry_11_) =>
                                       (elpi_ctx_entry_11_.+1, 1%R)
                                   | Negz _ => ((1 + y1)%R, 1%R)
                                   end
                               | _ => ((1 * y2 + y1)%R, y2)
                               end)
                        end
                    end)%Q
               end)%Q + (- rat_of_Z 2)%Q)%Q +
             (-
              match k with
              | Posz elpi_ctx_entry_3_ => iterop elpi_ctx_entry_3_ addq 1 0
              | Negz elpi_ctx_entry_3_ =>
                  (-
                   match elpi_ctx_entry_3_ with
                   | 0 => 1%Q
                   | _.+1 =>
                       match
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 =>
                                match loop i with
                                | {| valq := y |} =>
                                    fracq
                                      (let (y1, y2) := y in
                                       match y2 with
                                       | Posz 1 =>
                                           match y1 with
                                           | Posz 0 => (1%R, 1%R)
                                           | Posz 1 => (2, 1%R)
                                           | Posz
                                             (_.+2 as elpi_ctx_entry_15_) =>
                                               (elpi_ctx_entry_15_.+1, 1%R)
                                           | Negz _ => ((1 + y1)%R, 1%R)
                                           end
                                       | _ => ((1 * y2 + y1)%R, y2)
                                       end)
                                end
                            end) elpi_ctx_entry_3_
                       with
                       | {| valq := y |} =>
                           fracq
                             (let (y1, y2) := y in
                              match y2 with
                              | Posz 1 =>
                                  match y1 with
                                  | Posz 0 => (1%R, 1%R)
                                  | Posz 1 => (2, 1%R)
                                  | Posz (_.+2 as elpi_ctx_entry_11_) =>
                                      (elpi_ctx_entry_11_.+1, 1%R)
                                  | Negz _ => ((1 + y1)%R, 1%R)
                                  end
                              | _ => ((1 * y2 + y1)%R, y2)
                              end)
                       end
                   end)%Q
              end)%Q)%Q * s (intZmod.addz n 1) k)%Q +
           ((match n with
             | Posz elpi_ctx_entry_3_ => iterop elpi_ctx_entry_3_ addq 1 0
             | Negz elpi_ctx_entry_3_ =>
                 (-
                  match elpi_ctx_entry_3_ with
                  | 0 => 1%Q
                  | _.+1 =>
                      match
                        (fix loop (m : nat) : rat :=
                           match m with
                           | 0 => 0
                           | 1 => 1
                           | (_.+1 as i).+1 =>
                               match loop i with
                               | {| valq := y |} =>
                                   fracq
                                     (let (y1, y2) := y in
                                      match y2 with
                                      | Posz 1 =>
                                          match y1 with
                                          | Posz 0 => (1%R, 1%R)
                                          | Posz 1 => (2, 1%R)
                                          | Posz (_.+2 as elpi_ctx_entry_15_) =>
                                              (elpi_ctx_entry_15_.+1, 1%R)
                                          | Negz _ => ((1 + y1)%R, 1%R)
                                          end
                                      | _ => ((1 * y2 + y1)%R, y2)
                                      end)
                               end
                           end) elpi_ctx_entry_3_
                      with
                      | {| valq := y |} =>
                          fracq
                            (let (y1, y2) := y in
                             match y2 with
                             | Posz 1 =>
                                 match y1 with
                                 | Posz 0 => (1%R, 1%R)
                                 | Posz 1 => (2, 1%R)
                                 | Posz (_.+2 as elpi_ctx_entry_11_) =>
                                     (elpi_ctx_entry_11_.+1, 1%R)
                                 | Negz _ => ((1 + y1)%R, 1%R)
                                 end
                             | _ => ((1 * y2 + y1)%R, y2)
                             end)
                      end
                  end)%Q
             end +
             (-
              match k with
              | Posz elpi_ctx_entry_3_ => iterop elpi_ctx_entry_3_ addq 1 0
              | Negz elpi_ctx_entry_3_ =>
                  (-
                   match elpi_ctx_entry_3_ with
                   | 0 => 1%Q
                   | _.+1 =>
                       match
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 =>
                                match loop i with
                                | {| valq := y |} =>
                                    fracq
                                      (let (y1, y2) := y in
                                       match y2 with
                                       | Posz 1 =>
                                           match y1 with
                                           | Posz 0 => (1%R, 1%R)
                                           | Posz 1 => (2, 1%R)
                                           | Posz
                                             (_.+2 as elpi_ctx_entry_15_) =>
                                               (elpi_ctx_entry_15_.+1, 1%R)
                                           | Negz _ => ((1 + y1)%R, 1%R)
                                           end
                                       | _ => ((1 * y2 + y1)%R, y2)
                                       end)
                                end
                            end) elpi_ctx_entry_3_
                       with
                       | {| valq := y |} =>
                           fracq
                             (let (y1, y2) := y in
                              match y2 with
                              | Posz 1 =>
                                  match y1 with
                                  | Posz 0 => (1%R, 1%R)
                                  | Posz 1 => (2, 1%R)
                                  | Posz (_.+2 as elpi_ctx_entry_11_) =>
                                      (elpi_ctx_entry_11_.+1, 1%R)
                                  | Negz _ => ((1 + y1)%R, 1%R)
                                  end
                              | _ => ((1 * y2 + y1)%R, y2)
                              end)
                       end
                   end)%Q
              end)%Q)%Q * s4)%Q)%Q)%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
s4 := s n k : rat
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: (match
            (((match n with
               | Posz elpi_ctx_entry_3_ => iterop elpi_ctx_entry_3_ addq 1 0
               | Negz elpi_ctx_entry_3_ =>
                   (-
                    match elpi_ctx_entry_3_ with
                    | 0 => 1%Q
                    | _.+1 =>
                        match
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 =>
                                 match loop i with
                                 | {| valq := y |} =>
                                     fracq
                                       (let (y1, y2) := y in
                                        match y2 with
                                        | Posz 1 =>
                                            match y1 with
                                            | Posz 0 => (1%R, 1%R)
                                            | Posz 1 => (2, 1%R)
                                            | Posz
                                              (_.+2 as elpi_ctx_entry_15_) =>
                                                (elpi_ctx_entry_15_.+1, 1%R)
                                            | Negz _ => ((1 + y1)%R, 1%R)
                                            end
                                        | _ => ((1 * y2 + y1)%R, y2)
                                        end)
                                 end
                             end) elpi_ctx_entry_3_
                        with
                        | {| valq := y |} =>
                            fracq
                              (let (y1, y2) := y in
                               match y2 with
                               | Posz 1 =>
                                   match y1 with
                                   | Posz 0 => (1%R, 1%R)
                                   | Posz 1 => (2, 1%R)
                                   | Posz (_.+2 as elpi_ctx_entry_11_) =>
                                       (elpi_ctx_entry_11_.+1, 1%R)
                                   | Negz _ => ((1 + y1)%R, 1%R)
                                   end
                               | _ => ((1 * y2 + y1)%R, y2)
                               end)
                        end
                    end)%Q
               end + rat_of_Z 2)%Q +
              match k with
              | Posz elpi_ctx_entry_3_ => iterop elpi_ctx_entry_3_ addq 1 0
              | Negz elpi_ctx_entry_3_ =>
                  (-
                   match elpi_ctx_entry_3_ with
                   | 0 => 1%Q
                   | _.+1 =>
                       match
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 =>
                                match loop i with
                                | {| valq := y |} =>
                                    fracq
                                      (let (y1, y2) := y in
                                       match y2 with
                                       | Posz 1 =>
                                           match y1 with
                                           | Posz 0 => (1%R, 1%R)
                                           | Posz 1 => (2, 1%R)
                                           | Posz
                                             (_.+2 as elpi_ctx_entry_15_) =>
                                               (elpi_ctx_entry_15_.+1, 1%R)
                                           | Negz _ => ((1 + y1)%R, 1%R)
                                           end
                                       | _ => ((1 * y2 + y1)%R, y2)
                                       end)
                                end
                            end) elpi_ctx_entry_3_
                       with
                       | {| valq := y |} =>
                           fracq
                             (let (y1, y2) := y in
                              match y2 with
                              | Posz 1 =>
                                  match y1 with
                                  | Posz 0 => (1%R, 1%R)
                                  | Posz 1 => (2, 1%R)
                                  | Posz (_.+2 as elpi_ctx_entry_11_) =>
                                      (elpi_ctx_entry_11_.+1, 1%R)
                                  | Negz _ => ((1 + y1)%R, 1%R)
                                  end
                              | _ => ((1 * y2 + y1)%R, y2)
                              end)
                       end
                   end)%Q
              end)%Q * s (intZmod.addz n 1) (intZmod.addz k 1))%Q +
            (((-
               match n with
               | Posz elpi_ctx_entry_3_ => iterop elpi_ctx_entry_3_ addq 1 0
               | Negz elpi_ctx_entry_3_ =>
                   (-
                    match elpi_ctx_entry_3_ with
                    | 0 => 1%Q
                    | _.+1 =>
                        match
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 =>
                                 match loop i with
                                 | {| valq := y |} =>
                                     fracq
                                       (let (y1, y2) := y in
                                        match y2 with
                                        | Posz 1 =>
                                            match y1 with
                                            | Posz 0 => (1%R, 1%R)
                                            | Posz 1 => (2, 1%R)
                                            | Posz
                                              (_.+2 as elpi_ctx_entry_15_) =>
                                                (elpi_ctx_entry_15_.+1, 1%R)
                                            | Negz _ => ((1 + y1)%R, 1%R)
                                            end
                                        | _ => ((1 * y2 + y1)%R, y2)
                                        end)
                                 end
                             end) elpi_ctx_entry_3_
                        with
                        | {| valq := y |} =>
                            fracq
                              (let (y1, y2) := y in
                               match y2 with
                               | Posz 1 =>
                                   match y1 with
                                   | Posz 0 => (1%R, 1%R)
                                   | Posz 1 => (2, 1%R)
                                   | Posz (_.+2 as elpi_ctx_entry_11_) =>
                                       (elpi_ctx_entry_11_.+1, 1%R)
                                   | Negz _ => ((1 + y1)%R, 1%R)
                                   end
                               | _ => ((1 * y2 + y1)%R, y2)
                               end)
                        end
                    end)%Q
               end)%Q +
              match k with
              | Posz elpi_ctx_entry_3_ => iterop elpi_ctx_entry_3_ addq 1 0
              | Negz elpi_ctx_entry_3_ =>
                  (-
                   match elpi_ctx_entry_3_ with
                   | 0 => 1%Q
                   | _.+1 =>
                       match
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 =>
                                match loop i with
                                | {| valq := y |} =>
                                    fracq
                                      (let (y1, y2) := y in
                                       match y2 with
                                       | Posz 1 =>
                                           match y1 with
                                           | Posz 0 => (1%R, 1%R)
                                           | Posz 1 => (2, 1%R)
                                           | Posz
                                             (_.+2 as elpi_ctx_entry_15_) =>
                                               (elpi_ctx_entry_15_.+1, 1%R)
                                           | Negz _ => ((1 + y1)%R, 1%R)
                                           end
                                       | _ => ((1 * y2 + y1)%R, y2)
                                       end)
                                end
                            end) elpi_ctx_entry_3_
                       with
                       | {| valq := y |} =>
                           fracq
                             (let (y1, y2) := y in
                              match y2 with
                              | Posz 1 =>
                                  match y1 with
                                  | Posz 0 => (1%R, 1%R)
                                  | Posz 1 => (2, 1%R)
                                  | Posz (_.+2 as elpi_ctx_entry_11_) =>
                                      (elpi_ctx_entry_11_.+1, 1%R)
                                  | Negz _ => ((1 + y1)%R, 1%R)
                                  end
                              | _ => ((1 * y2 + y1)%R, y2)
                              end)
                       end
                   end)%Q
              end)%Q * s n (intZmod.addz k 1))%Q
          with
          | {| valq := y |} =>
              fracq
                (let (y1, y2) := y in
                 match y2 with
                 | Posz 1 => (y1, 1%R)
                 | _ => ((0 * y2 + y1)%R, y2)
                 end)
          end +
          (((((-
               match n with
               | Posz elpi_ctx_entry_3_ => iterop elpi_ctx_entry_3_ addq 1 0
               | Negz elpi_ctx_entry_3_ =>
                   (-
                    match elpi_ctx_entry_3_ with
                    | 0 => 1%Q
                    | _.+1 =>
                        match
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 =>
                                 match loop i with
                                 | {| valq := y |} =>
                                     fracq
                                       (let (y1, y2) := y in
                                        match y2 with
                                        | Posz 1 =>
                                            match y1 with
                                            | Posz 0 => (1%R, 1%R)
                                            | Posz 1 => (2, 1%R)
                                            | Posz
                                              (_.+2 as elpi_ctx_entry_15_) =>
                                                (elpi_ctx_entry_15_.+1, 1%R)
                                            | Negz _ => ((1 + y1)%R, 1%R)
                                            end
                                        | _ => ((1 * y2 + y1)%R, y2)
                                        end)
                                 end
                             end) elpi_ctx_entry_3_
                        with
                        | {| valq := y |} =>
                            fracq
                              (let (y1, y2) := y in
                               match y2 with
                               | Posz 1 =>
                                   match y1 with
                                   | Posz 0 => (1%R, 1%R)
                                   | Posz 1 => (2, 1%R)
                                   | Posz (_.+2 as elpi_ctx_entry_11_) =>
                                       (elpi_ctx_entry_11_.+1, 1%R)
                                   | Negz _ => ((1 + y1)%R, 1%R)
                                   end
                               | _ => ((1 * y2 + y1)%R, y2)
                               end)
                        end
                    end)%Q
               end)%Q + (- rat_of_Z 2)%Q)%Q +
             (-
              match k with
              | Posz elpi_ctx_entry_3_ => iterop elpi_ctx_entry_3_ addq 1 0
              | Negz elpi_ctx_entry_3_ =>
                  (-
                   match elpi_ctx_entry_3_ with
                   | 0 => 1%Q
                   | _.+1 =>
                       match
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 =>
                                match loop i with
                                | {| valq := y |} =>
                                    fracq
                                      (let (y1, y2) := y in
                                       match y2 with
                                       | Posz 1 =>
                                           match y1 with
                                           | Posz 0 => (1%R, 1%R)
                                           | Posz 1 => (2, 1%R)
                                           | Posz
                                             (_.+2 as elpi_ctx_entry_15_) =>
                                               (elpi_ctx_entry_15_.+1, 1%R)
                                           | Negz _ => ((1 + y1)%R, 1%R)
                                           end
                                       | _ => ((1 * y2 + y1)%R, y2)
                                       end)
                                end
                            end) elpi_ctx_entry_3_
                       with
                       | {| valq := y |} =>
                           fracq
                             (let (y1, y2) := y in
                              match y2 with
                              | Posz 1 =>
                                  match y1 with
                                  | Posz 0 => (1%R, 1%R)
                                  | Posz 1 => (2, 1%R)
                                  | Posz (_.+2 as elpi_ctx_entry_11_) =>
                                      (elpi_ctx_entry_11_.+1, 1%R)
                                  | Negz _ => ((1 + y1)%R, 1%R)
                                  end
                              | _ => ((1 * y2 + y1)%R, y2)
                              end)
                       end
                   end)%Q
              end)%Q)%Q * s (intZmod.addz n 1) k)%Q +
           ((match n with
             | Posz elpi_ctx_entry_3_ => iterop elpi_ctx_entry_3_ addq 1 0
             | Negz elpi_ctx_entry_3_ =>
                 (-
                  match elpi_ctx_entry_3_ with
                  | 0 => 1%Q
                  | _.+1 =>
                      match
                        (fix loop (m : nat) : rat :=
                           match m with
                           | 0 => 0
                           | 1 => 1
                           | (_.+1 as i).+1 =>
                               match loop i with
                               | {| valq := y |} =>
                                   fracq
                                     (let (y1, y2) := y in
                                      match y2 with
                                      | Posz 1 =>
                                          match y1 with
                                          | Posz 0 => (1%R, 1%R)
                                          | Posz 1 => (2, 1%R)
                                          | Posz (_.+2 as elpi_ctx_entry_15_) =>
                                              (elpi_ctx_entry_15_.+1, 1%R)
                                          | Negz _ => ((1 + y1)%R, 1%R)
                                          end
                                      | _ => ((1 * y2 + y1)%R, y2)
                                      end)
                               end
                           end) elpi_ctx_entry_3_
                      with
                      | {| valq := y |} =>
                          fracq
                            (let (y1, y2) := y in
                             match y2 with
                             | Posz 1 =>
                                 match y1 with
                                 | Posz 0 => (1%R, 1%R)
                                 | Posz 1 => (2, 1%R)
                                 | Posz (_.+2 as elpi_ctx_entry_11_) =>
                                     (elpi_ctx_entry_11_.+1, 1%R)
                                 | Negz _ => ((1 + y1)%R, 1%R)
                                 end
                             | _ => ((1 * y2 + y1)%R, y2)
                             end)
                      end
                  end)%Q
             end +
             (-
              match k with
              | Posz elpi_ctx_entry_3_ => iterop elpi_ctx_entry_3_ addq 1 0
              | Negz elpi_ctx_entry_3_ =>
                  (-
                   match elpi_ctx_entry_3_ with
                   | 0 => 1%Q
                   | _.+1 =>
                       match
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 =>
                                match loop i with
                                | {| valq := y |} =>
                                    fracq
                                      (let (y1, y2) := y in
                                       match y2 with
                                       | Posz 1 =>
                                           match y1 with
                                           | Posz 0 => (1%R, 1%R)
                                           | Posz 1 => (2, 1%R)
                                           | Posz
                                             (_.+2 as elpi_ctx_entry_15_) =>
                                               (elpi_ctx_entry_15_.+1, 1%R)
                                           | Negz _ => ((1 + y1)%R, 1%R)
                                           end
                                       | _ => ((1 * y2 + y1)%R, y2)
                                       end)
                                end
                            end) elpi_ctx_entry_3_
                       with
                       | {| valq := y |} =>
                           fracq
                             (let (y1, y2) := y in
                              match y2 with
                              | Posz 1 =>
                                  match y1 with
                                  | Posz 0 => (1%R, 1%R)
                                  | Posz 1 => (2, 1%R)
                                  | Posz (_.+2 as elpi_ctx_entry_11_) =>
                                      (elpi_ctx_entry_11_.+1, 1%R)
                                  | Negz _ => ((1 + y1)%R, 1%R)
                                  end
                              | _ => ((1 * y2 + y1)%R, y2)
                              end)
                       end
                   end)%Q
              end)%Q)%Q * s4)%Q)%Q)%Q;
         (((((match n with
              | Posz elpi_ctx_entry_3_ => iterop elpi_ctx_entry_3_ addq 1 0
              | Negz elpi_ctx_entry_3_ =>
                  (-
                   match elpi_ctx_entry_3_ with
                   | 0 => 1%Q
                   | _.+1 =>
                       match
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 =>
                                match loop i with
                                | {| valq := y |} =>
                                    fracq
                                      (let (y1, y2) := y in
                                       match y2 with
                                       | Posz 1 =>
                                           match y1 with
                                           | Posz 0 => (1%R, 1%R)
                                           | Posz 1 => (2, 1%R)
                                           | Posz
                                             (_.+2 as elpi_ctx_entry_15_) =>
                                               (elpi_ctx_entry_15_.+1, 1%R)
                                           | Negz _ => ((1 + y1)%R, 1%R)
                                           end
                                       | _ => ((1 * y2 + y1)%R, y2)
                                       end)
                                end
                            end) elpi_ctx_entry_3_
                       with
                       | {| valq := y |} =>
                           fracq
                             (let (y1, y2) := y in
                              match y2 with
                              | Posz 1 =>
                                  match y1 with
                                  | Posz 0 => (1%R, 1%R)
                                  | Posz 1 => (2, 1%R)
                                  | Posz (_.+2 as elpi_ctx_entry_11_) =>
                                      (elpi_ctx_entry_11_.+1, 1%R)
                                  | Negz _ => ((1 + y1)%R, 1%R)
                                  end
                              | _ => ((1 * y2 + y1)%R, y2)
                              end)
                       end
                   end)%Q
              end +
              (-
               match k with
               | Posz elpi_ctx_entry_3_ => iterop elpi_ctx_entry_3_ addq 1 0
               | Negz elpi_ctx_entry_3_ =>
                   (-
                    match elpi_ctx_entry_3_ with
                    | 0 => 1%Q
                    | _.+1 =>
                        match
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 =>
                                 match loop i with
                                 | {| valq := y |} =>
                                     fracq
                                       (let (y1, y2) := y in
                                        match y2 with
                                        | Posz 1 =>
                                            match y1 with
                                            | Posz 0 => (1%R, 1%R)
                                            | Posz 1 => (2, 1%R)
                                            | Posz
                                              (_.+2 as elpi_ctx_entry_15_) =>
                                                (elpi_ctx_entry_15_.+1, 1%R)
                                            | Negz _ => ((1 + y1)%R, 1%R)
                                            end
                                        | _ => ((1 * y2 + y1)%R, y2)
                                        end)
                                 end
                             end) elpi_ctx_entry_3_
                        with
                        | {| valq := y |} =>
                            fracq
                              (let (y1, y2) := y in
                               match y2 with
                               | Posz 1 =>
                                   match y1 with
                                   | Posz 0 => (1%R, 1%R)
                                   | Posz 1 => (2, 1%R)
                                   | Posz (_.+2 as elpi_ctx_entry_11_) =>
                                       (elpi_ctx_entry_11_.+1, 1%R)
                                   | Negz _ => ((1 + y1)%R, 1%R)
                                   end
                               | _ => ((1 * y2 + y1)%R, y2)
                               end)
                        end
                    end)%Q
               end)%Q)%Q * s4)%Q +
            ((((-
                match n with
                | Posz elpi_ctx_entry_3_ => iterop elpi_ctx_entry_3_ addq 1 0
                | Negz elpi_ctx_entry_3_ =>
                    (-
                     match elpi_ctx_entry_3_ with
                     | 0 => 1%Q
                     | _.+1 =>
                         match
                           (fix loop (m : nat) : rat :=
                              match m with
                              | 0 => 0
                              | 1 => 1
                              | (_.+1 as i).+1 =>
                                  match loop i with
                                  | {| valq := y |} =>
                                      fracq
                                        (let (y1, y2) := y in
                                         match y2 with
                                         | Posz 1 =>
                                             match y1 with
                                             | Posz 0 => (1%R, 1%R)
                                             | Posz 1 => (2, 1%R)
                                             | Posz
                                               (_.+2 as elpi_ctx_entry_15_) =>
                                                 (elpi_ctx_entry_15_.+1, 1%R)
                                             | Negz _ => ((1 + y1)%R, 1%R)
                                             end
                                         | _ => ((1 * y2 + y1)%R, y2)
                                         end)
                                  end
                              end) elpi_ctx_entry_3_
                         with
                         | {| valq := y |} =>
                             fracq
                               (let (y1, y2) := y in
                                match y2 with
                                | Posz 1 =>
                                    match y1 with
                                    | Posz 0 => (1%R, 1%R)
                                    | Posz 1 => (2, 1%R)
                                    | Posz (_.+2 as elpi_ctx_entry_11_) =>
                                        (elpi_ctx_entry_11_.+1, 1%R)
                                    | Negz _ => ((1 + y1)%R, 1%R)
                                    end
                                | _ => ((1 * y2 + y1)%R, y2)
                                end)
                         end
                     end)%Q
                end)%Q + (- rat_of_Z 2)%Q)%Q +
              (-
               match k with
               | Posz elpi_ctx_entry_3_ => iterop elpi_ctx_entry_3_ addq 1 0
               | Negz elpi_ctx_entry_3_ =>
                   (-
                    match elpi_ctx_entry_3_ with
                    | 0 => 1%Q
                    | _.+1 =>
                        match
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 =>
                                 match loop i with
                                 | {| valq := y |} =>
                                     fracq
                                       (let (y1, y2) := y in
                                        match y2 with
                                        | Posz 1 =>
                                            match y1 with
                                            | Posz 0 => (1%R, 1%R)
                                            | Posz 1 => (2, 1%R)
                                            | Posz
                                              (_.+2 as elpi_ctx_entry_15_) =>
                                                (elpi_ctx_entry_15_.+1, 1%R)
                                            | Negz _ => ((1 + y1)%R, 1%R)
                                            end
                                        | _ => ((1 * y2 + y1)%R, y2)
                                        end)
                                 end
                             end) elpi_ctx_entry_3_
                        with
                        | {| valq := y |} =>
                            fracq
                              (let (y1, y2) := y in
                               match y2 with
                               | Posz 1 =>
                                   match y1 with
                                   | Posz 0 => (1%R, 1%R)
                                   | Posz 1 => (2, 1%R)
                                   | Posz (_.+2 as elpi_ctx_entry_11_) =>
                                       (elpi_ctx_entry_11_.+1, 1%R)
                                   | Negz _ => ((1 + y1)%R, 1%R)
                                   end
                               | _ => ((1 * y2 + y1)%R, y2)
                               end)
                        end
                    end)%Q
               end)%Q)%Q * s (intZmod.addz n 1) k)%Q)%Q +
           (((-
              match n with
              | Posz elpi_ctx_entry_3_ => iterop elpi_ctx_entry_3_ addq 1 0
              | Negz elpi_ctx_entry_3_ =>
                  (-
                   match elpi_ctx_entry_3_ with
                   | 0 => 1%Q
                   | _.+1 =>
                       match
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 =>
                                match loop i with
                                | {| valq := y |} =>
                                    fracq
                                      (let (y1, y2) := y in
                                       match y2 with
                                       | Posz 1 =>
                                           match y1 with
                                           | Posz 0 => (1%R, 1%R)
                                           | Posz 1 => (2, 1%R)
                                           | Posz
                                             (_.+2 as elpi_ctx_entry_15_) =>
                                               (elpi_ctx_entry_15_.+1, 1%R)
                                           | Negz _ => ((1 + y1)%R, 1%R)
                                           end
                                       | _ => ((1 * y2 + y1)%R, y2)
                                       end)
                                end
                            end) elpi_ctx_entry_3_
                       with
                       | {| valq := y |} =>
                           fracq
                             (let (y1, y2) := y in
                              match y2 with
                              | Posz 1 =>
                                  match y1 with
                                  | Posz 0 => (1%R, 1%R)
                                  | Posz 1 => (2, 1%R)
                                  | Posz (_.+2 as elpi_ctx_entry_11_) =>
                                      (elpi_ctx_entry_11_.+1, 1%R)
                                  | Negz _ => ((1 + y1)%R, 1%R)
                                  end
                              | _ => ((1 * y2 + y1)%R, y2)
                              end)
                       end
                   end)%Q
              end)%Q +
             match k with
             | Posz elpi_ctx_entry_3_ => iterop elpi_ctx_entry_3_ addq 1 0
             | Negz elpi_ctx_entry_3_ =>
                 (-
                  match elpi_ctx_entry_3_ with
                  | 0 => 1%Q
                  | _.+1 =>
                      match
                        (fix loop (m : nat) : rat :=
                           match m with
                           | 0 => 0
                           | 1 => 1
                           | (_.+1 as i).+1 =>
                               match loop i with
                               | {| valq := y |} =>
                                   fracq
                                     (let (y1, y2) := y in
                                      match y2 with
                                      | Posz 1 =>
                                          match y1 with
                                          | Posz 0 => (1%R, 1%R)
                                          | Posz 1 => (2, 1%R)
                                          | Posz (_.+2 as elpi_ctx_entry_15_) =>
                                              (elpi_ctx_entry_15_.+1, 1%R)
                                          | Negz _ => ((1 + y1)%R, 1%R)
                                          end
                                      | _ => ((1 * y2 + y1)%R, y2)
                                      end)
                               end
                           end) elpi_ctx_entry_3_
                      with
                      | {| valq := y |} =>
                          fracq
                            (let (y1, y2) := y in
                             match y2 with
                             | Posz 1 =>
                                 match y1 with
                                 | Posz 0 => (1%R, 1%R)
                                 | Posz 1 => (2, 1%R)
                                 | Posz (_.+2 as elpi_ctx_entry_11_) =>
                                     (elpi_ctx_entry_11_.+1, 1%R)
                                 | Negz _ => ((1 + y1)%R, 1%R)
                                 end
                             | _ => ((1 * y2 + y1)%R, y2)
                             end)
                      end
                  end)%Q
             end)%Q * s n (intZmod.addz k 1))%Q)%Q +
          (((match n with
             | Posz elpi_ctx_entry_3_ => iterop elpi_ctx_entry_3_ addq 1 0
             | Negz elpi_ctx_entry_3_ =>
                 (-
                  match elpi_ctx_entry_3_ with
                  | 0 => 1%Q
                  | _.+1 =>
                      match
                        (fix loop (m : nat) : rat :=
                           match m with
                           | 0 => 0
                           | 1 => 1
                           | (_.+1 as i).+1 =>
                               match loop i with
                               | {| valq := y |} =>
                                   fracq
                                     (let (y1, y2) := y in
                                      match y2 with
                                      | Posz 1 =>
                                          match y1 with
                                          | Posz 0 => (1%R, 1%R)
                                          | Posz 1 => (2, 1%R)
                                          | Posz (_.+2 as elpi_ctx_entry_15_) =>
                                              (elpi_ctx_entry_15_.+1, 1%R)
                                          | Negz _ => ((1 + y1)%R, 1%R)
                                          end
                                      | _ => ((1 * y2 + y1)%R, y2)
                                      end)
                               end
                           end) elpi_ctx_entry_3_
                      with
                      | {| valq := y |} =>
                          fracq
                            (let (y1, y2) := y in
                             match y2 with
                             | Posz 1 =>
                                 match y1 with
                                 | Posz 0 => (1%R, 1%R)
                                 | Posz 1 => (2, 1%R)
                                 | Posz (_.+2 as elpi_ctx_entry_11_) =>
                                     (elpi_ctx_entry_11_.+1, 1%R)
                                 | Negz _ => ((1 + y1)%R, 1%R)
                                 end
                             | _ => ((1 * y2 + y1)%R, y2)
                             end)
                      end
                  end)%Q
             end + rat_of_Z 2)%Q +
            match k with
            | Posz elpi_ctx_entry_3_ => iterop elpi_ctx_entry_3_ addq 1 0
            | Negz elpi_ctx_entry_3_ =>
                (-
                 match elpi_ctx_entry_3_ with
                 | 0 => 1%Q
                 | _.+1 =>
                     match
                       (fix loop (m : nat) : rat :=
                          match m with
                          | 0 => 0
                          | 1 => 1
                          | (_.+1 as i).+1 =>
                              match loop i with
                              | {| valq := y |} =>
                                  fracq
                                    (let (y1, y2) := y in
                                     match y2 with
                                     | Posz 1 =>
                                         match y1 with
                                         | Posz 0 => (1%R, 1%R)
                                         | Posz 1 => (2, 1%R)
                                         | Posz (_.+2 as elpi_ctx_entry_15_) =>
                                             (elpi_ctx_entry_15_.+1, 1%R)
                                         | Negz _ => ((1 + y1)%R, 1%R)
                                         end
                                     | _ => ((1 * y2 + y1)%R, y2)
                                     end)
                              end
                          end) elpi_ctx_entry_3_
                     with
                     | {| valq := y |} =>
                         fracq
                           (let (y1, y2) := y in
                            match y2 with
                            | Posz 1 =>
                                match y1 with
                                | Posz 0 => (1%R, 1%R)
                                | Posz 1 => (2, 1%R)
                                | Posz (_.+2 as elpi_ctx_entry_11_) =>
                                    (elpi_ctx_entry_11_.+1, 1%R)
                                | Negz _ => ((1 + y1)%R, 1%R)
                                end
                            | _ => ((1 * y2 + y1)%R, y2)
                            end)
                     end
                 end)%Q
            end)%Q * s (intZmod.addz n 1) (intZmod.addz k 1))%Q)%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
Unable to unify "true" with "false".
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: (((((match n with
              | Posz elpi_ctx_entry_2_ => iterop elpi_ctx_entry_2_ addq 1 0
              | Negz elpi_ctx_entry_2_ =>
                  (-
                   match elpi_ctx_entry_2_ with
                   | 0 => 1%Q
                   | _.+1 =>
                       (1%Q +
                        (fix loop (m : nat) : rat :=
                           match m with
                           | 0 => 0
                           | 1 => 1
                           | (_.+1 as i).+1 => 1%Q + loop i
                           end) elpi_ctx_entry_2_)%Q
                   end)%Q
              end +
              (-
               match k with
               | Posz elpi_ctx_entry_2_ => iterop elpi_ctx_entry_2_ addq 1 0
               | Negz elpi_ctx_entry_2_ =>
                   (-
                    match elpi_ctx_entry_2_ with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 => 1%Q + loop i
                            end) elpi_ctx_entry_2_)%Q
                    end)%Q
               end)%Q)%Q * s n k)%Q +
            ((((-
                match n with
                | Posz elpi_ctx_entry_2_ => iterop elpi_ctx_entry_2_ addq 1 0
                | Negz elpi_ctx_entry_2_ =>
                    (-
                     match elpi_ctx_entry_2_ with
                     | 0 => 1%Q
                     | _.+1 =>
                         (1%Q +
                          (fix loop (m : nat) : rat :=
                             match m with
                             | 0 => 0
                             | 1 => 1
                             | (_.+1 as i).+1 => 1%Q + loop i
                             end) elpi_ctx_entry_2_)%Q
                     end)%Q
                end)%Q + (- rat_of_Z 2)%Q)%Q +
              (-
               match k with
               | Posz elpi_ctx_entry_2_ => iterop elpi_ctx_entry_2_ addq 1 0
               | Negz elpi_ctx_entry_2_ =>
                   (-
                    match elpi_ctx_entry_2_ with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 => 1%Q + loop i
                            end) elpi_ctx_entry_2_)%Q
                    end)%Q
               end)%Q)%Q * s (intZmod.addz n 1) k)%Q)%Q +
           (((-
              match n with
              | Posz elpi_ctx_entry_2_ => iterop elpi_ctx_entry_2_ addq 1 0
              | Negz elpi_ctx_entry_2_ =>
                  (-
                   match elpi_ctx_entry_2_ with
                   | 0 => 1%Q
                   | _.+1 =>
                       (1%Q +
                        (fix loop (m : nat) : rat :=
                           match m with
                           | 0 => 0
                           | 1 => 1
                           | (_.+1 as i).+1 => 1%Q + loop i
                           end) elpi_ctx_entry_2_)%Q
                   end)%Q
              end)%Q +
             match k with
             | Posz elpi_ctx_entry_2_ => iterop elpi_ctx_entry_2_ addq 1 0
             | Negz elpi_ctx_entry_2_ =>
                 (-
                  match elpi_ctx_entry_2_ with
                  | 0 => 1%Q
                  | _.+1 =>
                      (1%Q +
                       (fix loop (m : nat) : rat :=
                          match m with
                          | 0 => 0
                          | 1 => 1
                          | (_.+1 as i).+1 => 1%Q + loop i
                          end) elpi_ctx_entry_2_)%Q
                  end)%Q
             end)%Q * s n (intZmod.addz k 1))%Q)%Q +
          (((match n with
             | Posz elpi_ctx_entry_2_ => iterop elpi_ctx_entry_2_ addq 1 0
             | Negz elpi_ctx_entry_2_ =>
                 (-
                  match elpi_ctx_entry_2_ with
                  | 0 => 1%Q
                  | _.+1 =>
                      (1%Q +
                       (fix loop (m : nat) : rat :=
                          match m with
                          | 0 => 0
                          | 1 => 1
                          | (_.+1 as i).+1 => 1%Q + loop i
                          end) elpi_ctx_entry_2_)%Q
                  end)%Q
             end + rat_of_Z 2)%Q +
            match k with
            | Posz elpi_ctx_entry_2_ => iterop elpi_ctx_entry_2_ addq 1 0
            | Negz elpi_ctx_entry_2_ =>
                (-
                 match elpi_ctx_entry_2_ with
                 | 0 => 1%Q
                 | _.+1 =>
                     (1%Q +
                      (fix loop (m : nat) : rat :=
                         match m with
                         | 0 => 0
                         | 1 => 1
                         | (_.+1 as i).+1 => 1%Q + loop i
                         end) elpi_ctx_entry_2_)%Q
                 end)%Q
            end)%Q * s (intZmod.addz n 1) (intZmod.addz k 1))%Q)%Q;
         ((0%Q +
           ((((match n with
               | Posz elpi_ctx_entry_2_ => iterop elpi_ctx_entry_2_ addq 1 0
               | Negz elpi_ctx_entry_2_ =>
                   (-
                    match elpi_ctx_entry_2_ with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 => 1%Q + loop i
                            end) elpi_ctx_entry_2_)%Q
                    end)%Q
               end + rat_of_Z 2)%Q +
              match k with
              | Posz elpi_ctx_entry_2_ => iterop elpi_ctx_entry_2_ addq 1 0
              | Negz elpi_ctx_entry_2_ =>
                  (-
                   match elpi_ctx_entry_2_ with
                   | 0 => 1%Q
                   | _.+1 =>
                       (1%Q +
                        (fix loop (m : nat) : rat :=
                           match m with
                           | 0 => 0
                           | 1 => 1
                           | (_.+1 as i).+1 => 1%Q + loop i
                           end) elpi_ctx_entry_2_)%Q
                   end)%Q
              end)%Q * s (intZmod.addz n 1) (intZmod.addz k 1))%Q +
            (((-
               match n with
               | Posz elpi_ctx_entry_2_ => iterop elpi_ctx_entry_2_ addq 1 0
               | Negz elpi_ctx_entry_2_ =>
                   (-
                    match elpi_ctx_entry_2_ with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 => 1%Q + loop i
                            end) elpi_ctx_entry_2_)%Q
                    end)%Q
               end)%Q +
              match k with
              | Posz elpi_ctx_entry_2_ => iterop elpi_ctx_entry_2_ addq 1 0
              | Negz elpi_ctx_entry_2_ =>
                  (-
                   match elpi_ctx_entry_2_ with
                   | 0 => 1%Q
                   | _.+1 =>
                       (1%Q +
                        (fix loop (m : nat) : rat :=
                           match m with
                           | 0 => 0
                           | 1 => 1
                           | (_.+1 as i).+1 => 1%Q + loop i
                           end) elpi_ctx_entry_2_)%Q
                   end)%Q
              end)%Q * s n (intZmod.addz k 1))%Q)%Q)%Q +
          (((((-
               match n with
               | Posz elpi_ctx_entry_2_ => iterop elpi_ctx_entry_2_ addq 1 0
               | Negz elpi_ctx_entry_2_ =>
                   (-
                    match elpi_ctx_entry_2_ with
                    | 0 => 1%Q
                    | _.+1 =>
                        (1%Q +
                         (fix loop (m : nat) : rat :=
                            match m with
                            | 0 => 0
                            | 1 => 1
                            | (_.+1 as i).+1 => 1%Q + loop i
                            end) elpi_ctx_entry_2_)%Q
                    end)%Q
               end)%Q + (- rat_of_Z 2)%Q)%Q +
             (-
              match k with
              | Posz elpi_ctx_entry_2_ => iterop elpi_ctx_entry_2_ addq 1 0
              | Negz elpi_ctx_entry_2_ =>
                  (-
                   match elpi_ctx_entry_2_ with
                   | 0 => 1%Q
                   | _.+1 =>
                       (1%Q +
                        (fix loop (m : nat) : rat :=
                           match m with
                           | 0 => 0
                           | 1 => 1
                           | (_.+1 as i).+1 => 1%Q + loop i
                           end) elpi_ctx_entry_2_)%Q
                   end)%Q
              end)%Q)%Q * s (intZmod.addz n 1) k)%Q +
           ((match n with
             | Posz elpi_ctx_entry_2_ => iterop elpi_ctx_entry_2_ addq 1 0
             | Negz elpi_ctx_entry_2_ =>
                 (-
                  match elpi_ctx_entry_2_ with
                  | 0 => 1%Q
                  | _.+1 =>
                      (1%Q +
                       (fix loop (m : nat) : rat :=
                          match m with
                          | 0 => 0
                          | 1 => 1
                          | (_.+1 as i).+1 => 1%Q + loop i
                          end) elpi_ctx_entry_2_)%Q
                  end)%Q
             end +
             (-
              match k with
              | Posz elpi_ctx_entry_2_ => iterop elpi_ctx_entry_2_ addq 1 0
              | Negz elpi_ctx_entry_2_ =>
                  (-
                   match elpi_ctx_entry_2_ with
                   | 0 => 1%Q
                   | _.+1 =>
                       (1%Q +
                        (fix loop (m : nat) : rat :=
                           match m with
                           | 0 => 0
                           | 1 => 1
                           | (_.+1 as i).+1 => 1%Q + loop i
                           end) elpi_ctx_entry_2_)%Q
                   end)%Q
              end)%Q)%Q * s n k)%Q)%Q)%Q]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
Unable to unify "true" with "false".
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
Unable to unify "true" with "false".
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
Unable to unify "true" with "false".
fun a : hT2 => [eta compare a]
     : hT2 -> hT2 -> comparison
T2lt : T2 -> T2 -> bool

T2lt is not universe polymorphic
Arguments T2lt a b
T2lt is transparent
Expands to: Constant gaia.schutte.ssete9.Gamma0.T2lt
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
Unable to unify "true" with "false".
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
_n__, _k__ : int
s1 := s (int.shift 2 _n__) _k__ : rat
s2 := s _n__ _k__ : rat
s3 := s (int.shift 1 _n__) _k__ : rat
s4 := s _n__ (int.shift 1 _k__) : rat
xn1 : precond.Sn2 _n__ _k__
Unable to unify "true" with "false".
Impossibility_free
     : forall (mu : T1) (m : Hydra -> T1) (Var : Hvariant T1_wf free m),
       BoundedVariant Var mu -> False
battle_length_std :
forall alpha : E0,
alpha <> E0zero ->
forall k : nat,
1 <= k -> battle_length standard k (iota (cnf alpha)) (L_ alpha (S k) - k)

battle_length_std is not universe polymorphic
Arguments battle_length_std alpha Halpha k%nat_scope Hk
battle_length_std is opaque
Expands to: Constant hydras.Hydra.Battle_length.battle_length_std
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
_n__, _k__ : int
s1 := s (int.shift 2 _n__) _k__ : rat
s2 := s _n__ _k__ : rat
a : ?Goal2 *m ?Goal4 = 0
b : precond.Sn2 _n__ _k__
Unable to unify "true" with "false".
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
_n__, _k__ : int
s1 := s (int.shift 2 _n__) _k__ : rat
s2 := s _n__ _k__ : rat
pG : ?Goal2 *m ?Goal4 = 0
H : precond.Sn2 _n__ _k__
Unable to unify "true" with "false".
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
_n__, _k__ : int
s1 := s (int.shift 2 _n__) _k__ : rat
s2 := s _n__ _k__ : rat
pG : ?Goal2 *m ?Goal4 = 0
IH : precond.Sn2 _n__ _k__
Unable to unify "true" with "false".
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
_n__, _k__ : int
s1 := s (int.shift 2 _n__) _k__ : rat
s2 := s _n__ _k__ : rat
pG : ?Goal2 *m ?Goal4 = 0
Hb : precond.Sn2 _n__ _k__
Unable to unify "true" with "false".
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
_n__, _k__ : int
s1 := s (int.shift 2 _n__) _k__ : rat
a : precond.Sn2 _n__ _k__
Unable to unify "true" with "false".
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n : nat
k : int
ltk0 : 0 <= k
ltkn : k < n
Sn2_lcomb_eq_0 : Sn2_lcomb s n k = 0
nzero := Sn2_lcomb_cf1 n k * d.P1_cf2_0 n k : rat_Ring
is_true_ : bool -> Prop
negb_ : bool -> bool
andb_ : bool -> bool -> bool
zero : rat_numFieldType
one : rat_numFieldType
add : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
mul : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
sub : rat_numFieldType -> rat_numFieldType -> rat_numFieldType
opp : rat_numFieldType -> rat_numFieldType
Feqb : rel rat_numFieldType
F_of_nat : nat -> rat_numFieldType
exp : rat_numFieldType -> nat -> rat_numFieldType
l : seq rat_numFieldType
is_trueE : is_true_ = is_true
negbE : negb_ = negb
andbE : andb_ = andb
zeroE : zero = 0
oneE : one = 1
addE : add = +%R
mulE : mul =  *%R
subE : sub = (fun x y : rat_numFieldType => x - y)
oppE : opp = -%R
FeqbE : Feqb = eq_op
F_of_natE : F_of_nat = GRing.natmul 1
expE : exp = GRing.exp (R:=rat_numFieldType)
lE : l =
     [:: Sn2_lcomb_cf1 n k; d.P1_cf2_0 n k;
         s (int.shift 1 n) (int.shift 1 k); SnSk_cf0_0 n k; 
        s n k; s (int.shift 1 n) k; SnSk_cf0_1 n k; 
        s n (int.shift 1 k); annotated_recs_d.P1_flat s n k;
         annotated_recs_d.P2_flat s n k; Sn2_lcomb_cf3 n k;
         annotated_recs_d.P3_flat s n k; annotated_recs_d.P4_flat s n k]
The term "conj (erefl false) ?y" has type "false = false /\ ?B"
while it is expected to have type "false = true /\ is_true_ true"
(cannot unify "false" and "true").
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
m, H : int
s4 := s m (int.shift 2 H) : rat
Hm : precond.Sk2 m H
s3 := s m H : rat
Unable to unify "true" with "false".
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, k : int
ltk0 : 0 <= k
ltkn : k + 1 < n
Unable to unify "true" with "false".
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
m, H : int
s4 := s m (int.shift 2 H) : rat
Hm : precond.Sk2 m H
s3 := s m H : rat
Unable to unify "true" with "false".
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
m, H : int
s4 := s m (int.shift 2 H) : rat
Hm : precond.Sk2 m H
s1 := s m H : rat
Unable to unify "true" with "false".
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, m : int
Hn : precond.Sk2 n m
s3 := s n (int.shift 2 m) : rat
s2 := s n m : rat
Unable to unify "true" with "false".
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, m : int
Hn : precond.Sk2 n m
s2 := s n (int.shift 2 m) : rat
s3 := s n m : rat
Unable to unify "true" with "false".
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, m : int
Hn : precond.Sk2 n m
s3 := s n m : rat
s2 := s n (int.shift 1 m) : rat
Unable to unify "true" with "false".
Debug:
In environment
d : int -> int -> int -> rat
d_ann : d.Ann d
d_Sn := d.Sn_ d_ann : d.Sn d
d_Sk := d.Sk_ d_ann : d.Sk d
d_Sm := d.Sm_ d_ann : d.Sm d
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
n, m : int
Hn : precond.Sk2 n m
s3 := s n m : rat
s2 := s n (int.shift 1 m) : rat
s4 := s n (int.shift 2 m) : rat
Unable to unify "true" with "false".
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
he, a : int
s1 := s he (int.shift 2 a) : rat
H : precond.Sk2 he a
Unable to unify "true" with "false".
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
he, H1 : int
l : precond.Sk2 he H1
s1 := s he (int.shift 2 H1) : rat
s2 := s he H1 : rat
Unable to unify "true" with "false".
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
he, H1 : int
l : precond.Sk2 he H1
s1 := s he (int.shift 2 H1) : rat
Unable to unify "true" with "false".
Debug:
In environment
d : int -> int -> int -> rat
s := fun n k : int => \sum_(1 <= m < k + 1 :> int) d n k m
 : int -> int -> rat
he, H1 : int
l : precond.Sk2 he H1
Unable to unify "true" with "false".
     = Lt
     : comparison
Closed under the global context
Closed under the global context
l_std_ok
     : forall alpha : E0,
       alpha <> E0zero ->
       forall k : nat,
       1 <= k -> battle_length standard k (iota (cnf alpha)) (l_std alpha k)
LNotPR
     : (forall alpha : E0, isPR 1 (l_std alpha)) -> False
m_ge_F_omega:
  forall k : nat,
  F_ E0omega (S k) <= (fun k0 : nat => L_ (E0phi0 E0omega) (S k0)) (S k)
     = Lt
     : comparison
AP_plus_closed
     : forall alpha beta gamma : Ord,
       In AP alpha -> beta < alpha -> gamma < alpha -> beta + gamma < alpha
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
Hydra_rect2
     : forall (P : Hydra -> Type) (P0 : Hydrae -> Type),
       (forall h : Hydrae, P0 h -> P (node h)) ->
       P0 hnil ->
       (forall h : Hydra, P h -> forall h0 : Hydrae, P0 h0 -> P0 (hcons h h0)) ->
       forall h : Hydra, P h
(* info auto: *)
idtac.
(* info auto: *)
idtac.
     = 9
     : nat
     = 4
     : nat
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
     = 16
     : nat
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
     = 28
     : nat
(* info auto: *)
idtac.
Impossibility_std
     : forall (mu : T1) (m : Hydra -> T1) (Var : Hvariant T1_wf standard m),
       BoundedVariant Var mu -> False
Hydra_ind
     : forall P : Hydra -> Prop,
       (forall h : Hydrae, P (node h)) -> forall h : Hydra, P h
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
L__equation_1 :
forall (alpha : E0) (i : nat),
L_ alpha i = L__unfold_clause_1 alpha (E0_eq_dec alpha E0zero) i

L__equation_1 is not universe polymorphic
Arguments L__equation_1 alpha i%nat_scope
L__equation_1 is transparent
Expands to: Constant hydras.Epsilon0.L_alpha.L__equation_1
     = Lt
     : comparison
     = true
     : bool
     = false
     : bool
     = (ω * 2 + 56)%pT1
     : ppT1
     = zero
     : T1
     = zero
     : T1
     = 1
     : ppT1
     = Remaining 1
     : answer
     = Remaining 3
     : answer
     = Ok
     : answer
     = Ok
     : answer
     = Ok
     : answer
     = Ok
     : answer
     = Ok
     : answer
     = Ok
     : answer
     = Ok
     : answer
     = Ok
     : answer
     = Remaining (ω + 1)%pT1
     : answer
     = Remaining ω
     : answer
     = Ok
     : answer
     = Remaining ω
     : answer
     = Ok
     : answer
     = Ok
     : answer
     = Ok
     : answer
     = Ok
     : answer
     = Ok
     : answer
     = Ok
     : answer
     = Ok
     : answer
     = Remaining (ω ^ 2 * 2 + ω * 220 + 798)%pT1
     : answer
     = Remaining (ω ^ 2 * 2 + ω * 220)%pT1
     : answer
     = Remaining (ω ^ 2 * 2 + ω * 219 + 1799)%pT1
     : answer
     = Remaining (ω ^ 2 * 2 + ω * 218 + 2198)%pT1
     : answer
     = Remaining (ω ^ ω * 2 + ω ^ 3 * 4 + ω ^ 2 * 4 + ω * 1148 + 4222)%pT1
     : answer
     = (ω + 1)%pT1
     : ppT1
     = 2
     : ppT1
     = Ok
     : answer
     = 0
     : ppT1
     = Ok
     : answer
     = 0
     : ppT1
     = Ok
     : answer
     = Too_far
     : answer
     = Ok
     : answer
     = Remaining 32
     : answer
     = (ω * 15)%pT1
     : ppT1
     = (ω * 14)%pT1
     : ppT1
     = (ω * 13)%pT1
     : ppT1
     = (ω * 12)%pT1
     : ppT1
     = (ω * 11)%pT1
     : ppT1
     = (ω * 10)%pT1
     : ppT1
     = (ω * 9)%pT1
     : ppT1
     = (ω * 8)%pT1
     : ppT1
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
     = one = one
     : Prop
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
     = ω ^ 3
     : ppT1
     = ω ^ ω ^ (ω + 1) * 42
     : ppT1
     = 1
     : ppT1
     = ω
     : ppT1
     = (ω ^ ω * 2 + 1)%pT1
     : ppT1
     = (ω ^ ω * 2 + ω)%pT1
     : ppT1
     = zero
     : T1
     = phi0 (FS 8)
     : T1
(* info auto: *)
idtac.
Canon_lt:
  forall (i : nat) [alpha : E0], alpha <> E0zero -> Canon alpha i o< alpha
Hprime.H'__obligations_obligation_1:
  forall alpha : E0,
  alpha <> E0zero -> forall i : nat, CanonS alpha i o< alpha
CanonS_lt:
  forall (i : nat) [alpha : E0], alpha <> E0zero -> CanonS alpha i o< alpha

type bool =
| True
| False

type nat =
| O
| S of nat

type 'a option =
| Some of 'a
| None

type ('a, 'b) sum =
| Inl of 'a
| Inr of 'b

type 'a sig0 = 'a
  (* singleton inductive, whose constructor was exist *)

type sumbool =
| Left
| Right

module Nat =
 struct
  (** val eq_dec : nat -> nat -> sumbool **)

  let rec eq_dec n m =
    match n with
    | O -> (match m with
            | O -> Left
            | S _ -> Right)
    | S n0 -> (match m with
               | O -> Right
               | S n1 -> eq_dec n0 n1)
 end

(** val sumbool_of_bool : bool -> sumbool **)

let sumbool_of_bool = function
| True -> Left
| False -> Right

type t1 =
| Zero
| Cons of t1 * nat * t1

(** val t1limit : t1 -> bool **)

let rec t1limit = function
| Zero -> False
| Cons (alpha0, _, beta) ->
  (match alpha0 with
   | Zero -> False
   | Cons (_, _, _) ->
     (match beta with
      | Zero -> True
      | Cons (_, _, _) -> t1limit beta))

(** val pred : t1 -> t1 option **)

let rec pred = function
| Zero -> None
| Cons (a, n, b) ->
  (match a with
   | Zero ->
     (match n with
      | O -> Some Zero
      | S n0 -> Some (Cons (Zero, n0, Zero)))
   | Cons (_, _, _) ->
     (match pred b with
      | Some c0 -> Some (Cons (a, n, c0))
      | None -> None))

(** val t1_eq_dec : t1 -> t1 -> sumbool **)

let rec t1_eq_dec t x =
  match t with
  | Zero -> (match x with
             | Zero -> Left
             | Cons (_, _, _) -> Right)
  | Cons (alpha, n, beta) ->
    (match x with
     | Zero -> Right
     | Cons (alpha0, n0, beta0) ->
       (match t1_eq_dec alpha alpha0 with
        | Left ->
          (match Nat.eq_dec n n0 with
           | Left -> t1_eq_dec beta beta0
           | Right -> Right)
        | Right -> Right))

(** val zero_limit_succ_dec : t1 -> (sumbool, t1) sum **)

let rec zero_limit_succ_dec = function
| Zero -> Inl Left
| Cons (alpha, n, beta) ->
  (match alpha with
   | Zero -> Inr (match n with
                  | O -> Zero
                  | S n0 -> Cons (Zero, n0, Zero))
   | Cons (alpha0, n0, beta0) ->
     let s = zero_limit_succ_dec beta in
     (match s with
      | Inl _ -> Inl Right
      | Inr b -> Inr (Cons ((Cons (alpha0, n0, beta0)), n, b))))

type e0 = t1
  (* singleton inductive, whose constructor was mkord *)

(** val cnf : e0 -> t1 **)

let cnf e1 =
  e1

(** val e0zero : e0 **)

let e0zero =
  Zero

(** val e0limit : e0 -> bool **)

let e0limit alpha =
  t1limit (cnf alpha)

(** val e0_eq_dec : e0 -> e0 -> sumbool **)

let e0_eq_dec =
  t1_eq_dec

(** val zero_Limit_Succ_dec : e0 -> (sumbool, e0) sum **)

let zero_Limit_Succ_dec alpha =
  let s = zero_limit_succ_dec alpha in
  (match s with
   | Inl a -> Inl a
   | Inr b -> Inr b)

(** val e0pred : e0 -> e0 **)

let e0pred alpha =
  match zero_Limit_Succ_dec alpha with
  | Inl _ -> alpha
  | Inr s -> s

(** val canon : t1 -> nat -> t1 **)

let rec canon alpha i =
  match alpha with
  | Zero -> Zero
  | Cons (alpha0, n, beta) ->
    (match alpha0 with
     | Zero ->
       (match n with
        | O ->
          (match beta with
           | Zero -> Zero
           | Cons (_, _, _) -> Cons (alpha0, n, (canon beta i)))
        | S n0 ->
          (match beta with
           | Zero -> Cons (Zero, n0, Zero)
           | Cons (_, _, _) -> Cons (alpha0, n, (canon beta i))))
     | Cons (_, _, _) ->
       (match n with
        | O ->
          (match beta with
           | Zero ->
             (match pred alpha0 with
              | Some gamma' ->
                (match i with
                 | O -> Zero
                 | S j -> Cons (gamma', j, Zero))
              | None -> Cons ((canon alpha0 i), O, Zero))
           | Cons (_, _, _) -> Cons (alpha0, n, (canon beta i)))
        | S n0 ->
          (match beta with
           | Zero ->
             (match pred alpha0 with
              | Some gamma' ->
                (match i with
                 | O -> Cons (alpha0, n0, Zero)
                 | S j -> Cons (alpha0, n0, (Cons (gamma', j, Zero))))
              | None -> Cons (alpha0, n0, (Cons ((canon alpha0 i), O, Zero))))
           | Cons (_, _, _) -> Cons (alpha0, n, (canon beta i)))))

(** val canon0 : e0 -> nat -> e0 **)

let canon0 alpha i =
  canon (cnf alpha) i

(** val l_ : e0 -> nat -> nat **)

let l_ a b =
  let rec fix_F x =
    let alpha = let pr1,_ = x in pr1 in
    let i = let _,pr2 = x in pr2 in
    (match e0_eq_dec alpha e0zero with
     | Left -> i
     | Right ->
       (match sumbool_of_bool (e0limit alpha) with
        | Left -> let y = (canon0 alpha i),(S i) in fix_F y
        | Right -> let y = (e0pred alpha),(S i) in fix_F y))
  in fix_F (a,b)

(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
polynomial not in the ideal
polynomial not in the ideal
polynomial not in the ideal
polynomial not in the ideal
polynomial not in the ideal
polynomial not in the ideal
polynomial not in the ideal
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
polynomial not in the ideal
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
F_alpha_not_PR
     : forall alpha : E0, E0omega o<= alpha -> isPR 1 (F_ alpha) -> False
F_alpha_PR_inv
     : forall alpha : E0, isPR 1 (F_ alpha) -> alpha o< E0omega
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
simple apply lt_2 (in T2).
 simple apply lt_alpha_cons (in T2).
 simple apply lt_alpha_cons (in T2).
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
E0omega + E0omega
     : E0
(* info auto: *)
idtac.
Finished transaction in 63.487 secs (34.243u,0.371s) (successful)
Finished transaction in 0. secs (0.u,0.s) (successful)
Finished transaction in 2.356 secs (2.353u,0.002s) (successful)
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
simple apply lt_2 (in T2).
 simple apply lt_1 (in T2).
 simple apply lt_2 (in T2).
  simple apply lt_1 (in T2).
  simple apply lt_1 (in T2).
(* info auto: *)
idtac.
(* info auto: *)
idtac.
[DEBUG] {|
  case_ind := nat;
  case_val := 3;
  case_return := Dyn (fun _ : nat => bool);
  case_branches := [m: Dyn true
                     | Dyn (fun _ : nat => false)]
|}
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
simple apply lt_2 (in T2).
 simple apply lt_6 (in T2).
  unfold Peano.lt (in core).
   simple apply le_n (in core).
 simple apply lt_1 (in T2).
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
(* info auto: *)
idtac.
     = 1535
     : nat
(* info auto: *)
idtac.
If ffalse or nil then ;; else If ttrue then ;; else ;; end end
     : st
Cr_pos_iff alpha_pos
     : forall x : Ord,
       Cr alpha x <->
       (forall beta : Ord, beta < alpha -> In (A_ beta) x /\ phi beta x = x)
(* info auto: *)
simple apply @eq_refl (in core).
     = 48
     : nat
T1mul_a0E: forall c : T1, c * zero = zero
T1mul1n: forall x : T1, one * x = x
T1muln0: forall x : T1, x * zero = zero
mul_fin_omega: forall n : nat, \F n.+1 * T1omega = T1omega
mul_int_limit: forall (n : nat) [y : T1], T1limit y -> \F n.+1 * y = y
exp_FO:
  forall (z : T1) (n : nat) [v : T1_eqType],
  v != zero -> exp_F z n * exp_O z v = exp_O z v
mult_a_0: forall a : hT1, (a * T1.zero)%t1 = T1.zero
mult_1_a: forall [a : hT1], nf a -> (\F 1 * a)%t1 = a
mult_fin_omega: forall n : nat, (FS n * T1.T1omega)%t1 = T1.T1omega
L7:
  forall (n : nat) [c : hT1] (p : nat),
  c <> T1.zero -> (FS n * T1.cons c p T1.zero)%t1 = T1.cons c p T1.zero
Ex3: (\F 5 * T1.T1omega)%t1 = T1.T1omega
     = Eq
     : comparison
     = Eq
     : comparison
Constant gaia.schutte.ssete9.CantorOrdinal.T1omega
Notation hydras.Epsilon0.T1.T1omega
  (shorter name to refer to it in current context is T1.T1omega)
clear  H0  :  (False -> 0 = S n)
clear  H0  :  (False -> 0 = S n)
clear  H0  :  (False -> list_count p l = S n)
clear  IHl  :  (False -> List.forallb p l = true)
specialized IHl using (eq_refl (n, a0) )
Cr_pos_iff alpha_pos
     : forall x : Ord,
       Cr alpha x <->
       (forall beta : Ord, beta < alpha -> In (A_ beta) x /\ phi beta x = x)
     = Lt
     : comparison
     = true
     : bool
     = false
     : bool
Canon_lt:
  forall (i : nat) [alpha : E0], alpha <> E0zero -> Canon alpha i o< alpha
Hprime.H'__obligations_obligation_1:
  forall alpha : E0,
  alpha <> E0zero -> forall i : nat, CanonS alpha i o< alpha
CanonS_lt:
  forall (i : nat) [alpha : E0], alpha <> E0zero -> CanonS alpha i o< alpha
(* info auto: *)
idtac.
     = one = one
     : Prop
     = 1535
     : nat
(* info auto: *)
idtac.
If ffalse or nil then ;; else If ttrue then ;; else ;; end end
     : st
     = 2559
     : nat
(* info auto: *)
idtac.
